# JUnit5有什么新功能

Those who can imagine anything, can create the impossible.
*- Alan Turing*

JUnit是JVM最重要的测试框架，也是软件工程中最有影响力的框架之一。JUnit 5是下一代JUnit，其首个**通用**（**GA**）版本（5.0.0）于2017年9月10日发布。正如我们将要发现的，JUnit5设想了一场关于JUnit4的小革命，提供了一个全新的架构、编程和扩展模型。本章包括以下内容：

*   **JUnit 5之路**：在第一部分中，我们将发现创建JUnit新主要版本的动机（即JUnit 4的局限性）、指导JUnit 5开发的设计原则，以及JUnit 5开源社区的细节。
*   **JUnit 5架构**：JUnit 5是一个模块化框架，由平台、Jupiter和Vintage三个主要组件组成。
*   **在JUnit 5中运行测试**：我们将发现如何使用流行的构建工具（如Maven或Gradle）以及IDE（如IntelliJ或Eclipse）运行JUnit 5测试。
*   **JUnit 5的扩展模型**：该扩展模型允许第三方库和框架通过自己的添加来扩展JUnit 5编程模型。

# 通往JUnit 5的道路

自2006年第一次发布JUnit4以来，软件测试已经发生了很大的变化。从那时起，不仅Java和JVM有所发展，而且我们的测试需求也已经成熟。我们不再只编写单元测试了。相反，除了验证单个代码外，软件工程师和测试人员还需要其他类型的测试，例如集成和端到端测试。

此外，我们对测试框架的期望也在增长。现在，我们需要这些框架的高级功能，例如可扩展性或模块化。在本节中，我们将发现JUnit4的主要局限性、JUnit5的远景以及支持其开发的社区。

# JUnit 5动机

根据一些研究，JUnit4是Java项目最常用的库。例如，*GitHub*上的前100个Java库是OverOps（[@overopshq](https://twitter.com/overopshq)一家专注于大规模Java和Scala代码库的软件分析公司发布的一份著名报告。

在2017年版中，该报告分析了GitHub上1000个Java项目（按stars）使用的独特Java库的导入语句。从结果来看，JUnit4无疑是Java库之王：包`org.junit`和`org.junit.runner`的导入分别出现在第一和第二位置：

![](img/00018.jpeg)

GitHub上排名前20的Java库

尽管如此，JUnit4是十多年前创建的一个框架，并且存在一些重要的限制，需要对框架进行全面的重新设计。

# 模块化

首先，JUnit4不是模块化的。如下图所示，JUnit4的体系结构是完全单片的。JUnit4的所有功能都由`junit.jar`依赖项提供。因此，不同的测试机制，如测试发现和执行，在JUnit4中紧密耦合。

![](img/00019.jpeg)

JUnit4体系结构

JUnit 5核心团队成员之一Johannes Link在2015年8月13日接受Jax杂志采访时总结了这个问题（在JUnit 5成立期间）：

JUnit作为平台的成功阻止了JUnit作为测试工具的开发。我们想要解决的基本问题是通过分离一个足够强大和稳定的API来执行测试用例。

# 少年4级运动员

JUnit4的runner API也具有重要的威慑作用。如[第1章](1.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb)*软件质量和Java测试回顾*所述，在JUnit4中，runner是一个Java类，用于管理测试的生命周期。JUnit4中的runner API非常强大，但是它有一个重要的缺点：runner是不可组合的，也就是说，我们一次只能使用一个runner。

例如，参数化测试不能与Spring测试支持相结合，因为两个测试都将使用自己的runner实现。用Java思考（参见下面给出的代码片段），每个测试用例都使用自己独特的`@RunWith`注释。第一个使用`Parameterized`跑步者：

```java
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

@RunWith(Parameterized.class)
public class MyParameterizedTest {

   @Test
   public void myFirstTest() {
      // my test code
   }

}
```

虽然第二个示例使用的是`SpringJUnit4ClassRunner`runner，但由于JUnit4的限制（runner是不可组合的），它不会与前一个示例结合使用：

```java
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
public class MySpringTest {

   @Test
   public void yetAnotherTest() {
      // my test code
   }

}
```

# JUnit4规则

由于JUnit 4运行程序在同一测试类中的唯一性受到严格限制，JUnit 4.7版引入了方法级规则的概念，这些规则是测试类中带有`@Rule`的注释字段。这些规则允许通过在测试执行之前和之后执行一些代码来添加或重新定义测试行为。JUnit4.9还引入了类级规则的概念，这些规则是在类内的所有测试之前和之后执行的。这些规则通过使用`@ClassRule`注释静态字段来标识，如下例所示：

```java
import org.junit.ClassRule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

public class MyRuleTest {

   @ClassRule
   public static TemporaryFolder temporaryFolder = new TemporaryFolder();

   @Test
   public void anotherTest() {
      // my test code
   }

}
```

虽然规则更简单，而且大部分是可组合的，但它们还有其他缺点。在复杂测试中使用JUnit4规则的主要不便之处在于，我们无法在方法级和类级使用单个规则实体。最终，这会对定制生命周期管理（前/后行为）施加限制。

# JUnit 5《盗梦空间》

尽管JUnit4是全世界数百万Java开发人员的默认测试框架，但是没有一个活跃的JUnit维护人员是由他们的雇主付钱来做这项工作的。因此，为了克服JUnit 4的缺点，Johannes Link和Marc Philipp于2015年7月启动了JUnit Lambda众筹活动（[http://junit.org/junit4/junit-lambda-campaign.html 国际众筹网站Indiegogo上的](http://junit.org/junit4/junit-lambda-campaign.html)：

![](img/00020.jpeg)

JUnit Lambda众筹活动

JUnit Lambda是该项目的名称，它是当前JUnit 5框架的种子。在项目名称中包含lambda一词强化了从项目一开始就使用Java8的想法。引用JUnit Lambda项目站点：

目标是为JVM上的开发人员端测试创建最新的基础。这包括关注Java8及以上版本，以及支持多种不同风格的测试。

JUnit Lambda众筹活动于2015年7月至10月进行。这是一个成功，从全球474家个人和公司筹集了53937欧元。从这一点上，JUnit5启动团队成立了，加入了Eclipse、Gradle、IntelliJ或Spring的人员。

JUnit Lambda项目成为JUnit 5，指导开发过程的设计原则如下：

*   模块化：正如前面介绍的，JUnit4不是模块化的，这会导致一些问题。从一开始，JUnit5体系结构就完全模块化，允许开发人员使用他们需要的框架的特定部分。
*   功能强大的扩展模型，重点关注可组合性：可扩展性是现代测试框架所必须的。因此，JUnit5应该提供与第三方框架（例如Spring或Mockito）的无缝集成。
*   API分离：将测试发现和执行与测试定义分离。
*   与旧版本的兼容性：支持在新的JUnit5平台上执行旧的Java3和Java4。
*   用于编写测试的现代编程模型（Java8）：如今，越来越多的开发人员使用Java8的新特性编写代码，例如lambda表达式。JUnit4是在Java5上构建的，但是JUnit5是使用Java8从头创建的。

# JUnit 5社区

JUnit5的源代码托管在GitHub上（[https://github.com/junit-team/junit5](https://github.com/junit-team/junit5) 。JUnit5框架的所有模块都已根据开放源码许可证EPLV1.0的条款发布。此规则有一个例外，因为名为`junit-platform-surefire-provider`（稍后描述）的模块已使用Apache License v2.0发布。

JUnit开发路线图（[https://github.com/junit-team/junit5/wiki/Roadmap](https://github.com/junit-team/junit5/wiki/Roadmap) 以及不同版本和里程碑的定义和状态（[https://github.com/junit-team/junit5/milestones/](https://github.com/junit-team/junit5/milestones/) ）在GitHub上公开。下表总结了该路线图：

| 阶段 | 日期 | 释放 |
| 0众筹 | 2015年7月至2015年10月 | - |
| 1.开球 | 2015年10月20日至22日 | - |
| 2.第一个原型 | 2015年10月23日至2015年11月底 | - |
| 3.阿尔法版本 | 2016年2月1日 | 5.0阿尔法 |
| 4第一个里程碑 | 2016年7月9日 | 5.0 M1：稳定的、记录在案的面向IDE的API（启动器API和引擎SPI），动态测试 |
| 5.其他里程碑 | 2016年7月23日（5.0平方米）2016年11月30日（5.0 M3）2017年4月1日（5.0 M4）2017年7月5日（5.0 M5）2017年7月16日（5.0 M6） | 5.0 M2：错误修复和小改进版本5.0 M3:JUnit 4互操作性，附加发现选择器5.0 M4：测试模板、重复测试和参数化测试5.0 M5：动态容器和轻微API更改5.0 M6:Java 9兼容性、场景测试、JUnit Jupiter的附加扩展API |
| 6**发布候选**（**RC**） | 2017年7月30日2017年7月30日2017年8月23日 | 5.0 RC1：最终缺陷修复和文档改进5.0 RC2:*junit jupiter发动机*的固定梯度消耗5.0 RC3：配置参数和错误修复 |
| 7.**一般可用性**（**GA**） | 2017年9月10日 | 5.0 GA：首次稳定发布 |

JUnit5贡献者不仅仅是开发人员。贡献者也是测试人员、维护人员和沟通者。在撰写本文时，GitHub上排名前5的贡献者是：

*   Sam Brannen（[@Sam_Brannen](https://twitter.com/sam_brannen)）：核心Spring框架和JUnit 5提交人。Swiftmind的企业Java顾问。春天&少年教练。会议发言人。
*   Marc Philipp（[@MarchPhilipp](https://twitter.com/marcphilipp)）：LogMeIn的高级软件工程师，积极参与JUnit或Usus等开源项目。会议发言人。
*   johanneslink（[@johanneslink](https://twitter.com/johanneslink)）：程序员和软件治疗师。JUnit5的支持者。
*   Matthias Merdes：德国海德堡美孚股份有限公司的首席开发商。

![](img/00021.jpeg)

GitHub上排名前5的JUnit贡献者

以下列表提供了联机JUnit 5资源的集合：

*   官方网站（[http://junit.org/junit5/](https://twitter.com/hashtag/JUnit5) ）。
*   源代码（[https://github.com/junit-team/junit5/](https://github.com/junit-team/junit5/) ）。
*   JUnit5开发者指南（[http://junit.org/junit5/docs/current/user-guide/](http://junit.org/junit5/docs/current/user-guide/) ）。参考文件。
*   JUnit团队推特（[https://twitter.com/junitteam](https://twitter.com/junitteam) 。通常，关于JUnit 5的推文都带有`#JUnit5`（[的标签https://twitter.com/hashtag/JUnit5](https://twitter.com/hashtag/JUnit5) ）。
*   问题（[https://github.com/junit-team/junit5/issues](https://github.com/junit-team/junit5/issues) ）。关于GitHub上附加功能的问题或建议。
*   关于堆栈溢出的问题（[https://stackoverflow.com/questions/tagged/junit5](https://stackoverflow.com/questions/tagged/junit5) 。Stack Overflow是一个流行的计算机编程问答网站。标签`junit5`应用于询问有关JUnit 5的问题。
*   JUnit5 JavaDoc（[http://junit.org/junit5/docs/current/api/](http://junit.org/junit5/docs/current/api/) ）。
*   JUnit 5吉特（[https://gitter.im/junit-team/junit5](https://gitter.im/junit-team/junit5) ），一个即时消息和聊天室系统，用于直接与JUnit 5团队成员和其他从业者进行讨论。
*   JVM开放测试联盟（[https://github.com/ota4j-team/opentest4j](https://github.com/ota4j-team/opentest4j) 。它是由JUnit5团队发起的一项计划，其目标是为测试JVM上的库（JUnit、TestNG、Spock等）和第三方断言库（Hamcrest、AssertJ等）提供一个最小的公共基础。其思想是使用一组通用的异常，IDE和构建工具可以在所有测试场景中以一致的方式支持这些异常（到目前为止，还没有在JVM上进行测试的标准，唯一通用的构建块是Java异常`java.lang.AssertionError`。

# JUnit5体系结构

JUnit5框架被设计为供不同的编程客户端使用。第一组客户机是Java测试。这些测试可以基于JUnit4（使用测试遗留编程模型的测试）、JUnit5（使用全新编程模型的测试），甚至其他类型的Java测试（第三方测试）。第二组客户机是构建工具（如Maven或Gradle）和IDE（如IntelliJ或Eclipse）。

为了以松散耦合的方式实现所有这些部分的集成，JUnit5被设计为模块化的。如下图所示，JUnit 5框架由三个主要组件组成，称为平台、Jupiter*、*和Vintage：

![](img/00022.jpeg)

JUnit5体系结构：高级组件

JUnit 5体系结构的高级组件列举如下：

*   第一个高级组件称为*木星*。它提供了JUnit5框架的全新编程和扩展模型。
*   在JUnit5的核心中，我们找到了JUnit*平台*。该组件旨在成为JVM中执行的任何测试框架的基础。换句话说，它提供了运行Jupiter测试、遗留JUnit4以及第三方测试（例如，Spock、FitNesse等）的机制。
*   JUnit5体系结构的最后一个高级组件称为*Vintage*。此组件允许在JUnit平台上开箱即用地运行遗留JUnit测试。

让我们仔细看看每个组件的细节，找出它们的内部模块：

![](img/00023.jpeg)

JUnit5体系结构：模块

如上图所示，有三种类型的模块：

*   **测试API**：这些是面向用户（即软件工程师和测试人员）的模块。这些模块为特定的测试引擎提供编程模型（例如，`junit-jupiter-api`用于JUnit 5测试，`junit`用于JUnit 4测试）。
*   **测试引擎**：这些模块允许在JUnit平台内执行一种测试（Jupiter测试、遗留JUnit 4或其他Java测试）。它们是通过扩展通用的*平台引擎*（`junit-platform-engine`）创建的。
*   **测试启动器**：*这些模块为外部构建工具和IDE提供JUnit平台内部的测试发现能力。此API由Maven、Gradle、IntelliJ等工具使用`junit-platform-launcher`模块使用。*

 *作为这种模块化体系结构的结果，JUnit框架公开了一组接口：

*   编写测试的**API**（**应用程序编程接口**）和*Jupiter API*。该API的详细描述就是我们所知的Jupiter编程模型，在本书的[第3章](#)、*JUnit 5标准测试*和[第4章](4.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb)、*使用高级JUnit功能简化测试*中有详细描述。
*   用于发现和执行测试的**SPI**（**服务提供商接口**），*引擎SPI*。此SPI通常由测试引擎扩展，测试引擎最终提供编写测试的编程模型。
*   一个用于测试发现和执行的API，*启动器API*。此API通常由编程客户端（即IDE和构建工具）使用。

API和SPI都是软件工程师为特定目的使用的一组资产（通常是类和接口）。区别在于API被*调用*，而SPI被*扩展*。

# 测试引擎SPI

测试引擎SPI允许在JVM上创建测试执行器。在JUnit 5框架中，有两种现成的测试引擎实现：

*   `junit-vintage-engine`：这允许在JUnit平台上运行JUnit3和JUnit4测试。
*   `junit-jupiter-engine`：这允许在JUnit平台上运行JUnit5测试。

此外，第三方测试库（例如，Spock、TestNG等）可以通过提供自定义测试引擎插入JUnit平台。为此，这些框架应该通过扩展JUnit5接口`org.junit.platform.engine.TestEngine`来创建自己的测试引擎。为了扩展此接口，必须覆盖三个强制方法：

*   `getId`：测试引擎的唯一标识符。
*   `discover`：查找和过滤测试的逻辑。
*   `execute`：运行先前找到的测试的逻辑。

以下示例提供了自定义测试引擎的框架：

```java
package io.github.bonigarcia;

import org.junit.platform.engine.EngineDiscoveryRequest;
import org.junit.platform.engine.ExecutionRequest;
import org.junit.platform.engine.TestDescriptor;
import org.junit.platform.engine.TestEngine;
import org.junit.platform.engine.UniqueId;
import org.junit.platform.engine.support.descriptor.EngineDescriptor;

public class MyCustomEngine implements TestEngine {

    public static final String *ENGINE_ID* = "my-custom-engine";

    @Override
    public String getId() {
        return *ENGINE_ID*;
    }

    @Override
    public TestDescriptor discover(EngineDiscoveryRequest discoveryRequest,
            UniqueId uniqueId) {
        // Discover test(s) and return a TestDescriptor object
        TestDescriptor testDescriptor = new EngineDescriptor(uniqueId,
                "My test");
        return testDescriptor;
    }

    @Override
    public void execute(ExecutionRequest request) {
        // Use ExecutionRequest to execute TestDescriptor
        TestDescriptor rootTestDescriptor =             
                request.getRootTestDescriptor();
        request.getEngineExecutionListener()
                .executionStarted(rootTestDescriptor);
    }

}
```

社区在JUnit 5团队的GitHub站点的wiki中维护现有测试引擎（例如，Specsy、Spek和其他）的列表：[https://github.com/junit-team/junit5/wiki/Third-party-Extensions](https://github.com/junit-team/junit5/wiki/Third-party-Extensions) 。

# 测试启动器API

JUnit5的目标之一是使JUnit与其编程客户机（构建工具和IDE）之间的接口更加强大和稳定。为此，已经实现了测试启动器API。IDE和构建工具使用此API来发现、过滤和执行测试。

仔细查看这个API的细节，我们发现了类`LauncherDiscoveryRequest`，它公开了一个fluent API来选择测试的位置（例如类、方法或包）。例如，可以使用匹配模式筛选这组测试：

```java
import static org.junit.platform.engine.discovery.ClassNameFilter.includeClassNamePatterns;
import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
import static org.junit.platform.engine.discovery.DiscoverySelectors.selectPackage;

import org.junit.platform.launcher.Launcher;
import org.junit.platform.launcher.LauncherDiscoveryRequest;
import org.junit.platform.launcher.TestPlan;
import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
import org.junit.platform.launcher.core.LauncherFactory;

// Discover and filter tests
LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
     .*request*()
     .*selectors*(*selectPackage*("io.github.bonigarcia"),     
      selectClass(MyTest.class))
     .*filters*(i*ncludeClassNamePatterns*(".*Test")).build();
Launcher launcher = LauncherFactory.create();
TestPlan plan = launcher.discover(request);
```

之后，可以使用类`TestExecutionListener`执行生成的测试套件。此类还可用于获取反馈和接收事件：

```java
import org.junit.platform.launcher.TestExecutionListener;
import org.junit.platform.launcher.listeners.SummaryGeneratingListener;

// Executing tests
TestExecutionListener listener = new SummaryGeneratingListener();
launcher.registerTestExecutionListeners(listener);
launcher.execute(request);
```

# 在JUnit5中运行测试

在编写本文时，Jupiter测试可以通过几种方式执行：

*   **使用构建工具**：Maven（在模块`junit-plaform-surefire-provider`中实现）或Gradle（在模块`junit-platform-gradle-plugin`中实现）。
*   **使用控制台启动器**：允许从控制台启动JUnit平台的命令行Java应用程序。
*   **使用IDE**：IntelliJ（自2016.2版起）和Eclipse（自4.7版起，氧气）。

正如我们将要发现的，由于JUnit5的模块化架构，我们需要在项目中包括三个依赖项：一个用于测试API（实现测试），另一个用于测试引擎（运行测试），以及最后一个测试启动器（发现测试）。

# Jupiter与Maven测试

为了在Maven项目中运行Jupiter测试，我们需要正确配置`pom.xml`文件。首先，我们需要包含`junit-jupiter-api`模块作为依赖项。这是编写我们的测试所必需的，并且通常具有测试范围：

```java
<dependencies>
   <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <version>${junit.jupiter.version}</version>
      <scope>test</scope>
   </dependency>
</dependencies>
```

通常，建议使用最新版本的依赖项。为了检查该版本是什么，我们可以在Maven Central（[上进行检查http://search.maven.org/](http://search.maven.org/) ）

然后，必须声明`maven-surefire-plugin`。在内部，该插件需要两个依赖项：测试启动器（`junit-platform-surefire-provider`和测试引擎（`junit-jupiter-engine`）：

```java
<build>
   <plugins>
      <plugin>
         <artifactId>maven-surefire-plugin</artifactId>
         <version>${maven-surefire-plugin.version}</version>
         <dependencies>
             <dependency>
                <groupId>org.junit.platform</groupId>
                <artifactId>junit-platform-surefire-provider</artifactId>
                <version>${junit.platform.version}</version>
            </dependency>
            <dependency>
               <groupId>org.junit.jupiter</groupId>
               <artifactId>junit-jupiter-engine</artifactId>
               <version>${junit.jupiter.version}</version>
            </dependency>
         </dependencies>
      </plugin>
   </plugins>
 </build>
```

本书的所有源代码都可以在GitHub存储库的[上公开获取https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5) 。

最后但并非最不重要的一点是，我们需要创建一个Jupiter测试用例。到目前为止，我们还没有学会如何实现Jupiter测试（这部分在[第3章](3.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)JUnit 5标准测试中介绍）。然而，我们在这里执行的测试是演示JUnit5框架执行的最简单的测试。Jupiter测试在其最小表达式中只是一个Java类，其中一个（或多个）方法用`@Test`（包`org.junit.jupiter.api`）注释。以下代码段提供了一个示例：

```java
package io.github.bonigarcia;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

class MyFirstJUnit5Test {

   @Test
   void myFirstTest() {
       String message = "1+1 should be equal to 2";
       System.*out*.println(message);
       *assertEquals*(2, 1 + 1, message);
   }

}
```

JUnit在运行时需要Java8（或更高版本）。但是，我们仍然可以测试使用以前版本的Java编译的代码。

如下图所示，可以使用命令`mvn test`执行此测试：

![](img/00024.gif)

使用Maven运行Jupiter测试

# 朱庇特与格拉德尔测试

现在，我们将学习相同的示例，但这次是用Gradle执行的。因此，我们需要配置`build.gradle`文件。在此文件中，我们需要定义：

*   Jupiter API的依赖项（`junit-jupiter-api`。
*   测试引擎的依赖关系（`junit-jupiter-engine`。
*   测试启动器的插件（`junit-platform-gradle-plugin`。

`build.gradle`的完整来源如下：

```java
buildscript {
   repositories {
      mavenCentral()
   }
   dependencies {
      classpath("org.junit.platform:junit-platform-gradle-plugin:${junitPlatformVersion}")
   }
}
repositories {
   mavenCentral()
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'org.junit.platform.gradle.plugin'

compileTestJava {
   sourceCompatibility = 1.8
   targetCompatibility = 1.8
   options.compilerArgs += '-parameters'
}

dependencies {
   testCompile("org.junit.jupiter:junit-jupiter-api:${junitJupiterVersion}")
   testRuntime("org.junit.jupiter:junit-jupiter-engine:${junitJupiterVersion}")
}
```

我们使用命令`gradle test`从命令行与Gradle一起运行Jupiter测试：

![](img/00025.gif)

使用Gradle运行Jupiter测试

# Maven遗留测试

下面是我们希望在JUnit平台内运行遗留测试（本例中为JUnit 4）的映像：

```java
package io.github.bonigarcia;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class LegacyJUnit4Test {

   @Test
   public void myFirstTest() {
      String message = "1+1 should be equal to 2";
      System.*out*.println(message);
      *assertEquals*(message, 2, 1 + 1);
   }

}
```

为此，在Maven中，我们首先需要在我们的`pom.xml`中包含旧的JUnit4依赖项，如下所示：

```java
<dependencies>
   <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
   </dependency>
</dependencies>
```

然后，我们需要使用插件的以下依赖项包括`maven-surefire-plugin`：测试引擎（`junit-vintage-engine`）和测试启动器（`junit-platform-surefire-provider`）：

```java
<build>
   <plugins>
      <plugin>
         <artifactId>maven-surefire-plugin</artifactId>
         <version>${maven-surefire-plugin.version}</version>
         <dependencies>
            <dependency>
               <groupId>org.junit.platform</groupId>
               <artifactId>junit-platform-surefire-provider</artifactId>
               <version>${junit.platform.version}</version>
            </dependency>
            <dependency>
                <groupId>org.junit.vintage</groupId>
                <artifactId>junit-vintage-engine</artifactId>
                <version>${junit.vintage.version}</version>
            </dependency>
         </dependencies>
      </plugin>
   </plugins>
</build>
```

命令行的执行也将使用命令`mvn test`：

![](img/00026.gif)

使用Maven运行遗留测试

# 具有Gradle的遗留测试

如果我们想执行前面的示例（`io.github.bonigarcia.LegacyJUnit4Test`中所示的相同测试，但这次使用Gradle，我们需要在`build.gradle`文件中包括以下内容：

*   JUnit4.12的依赖关系。
*   测试引擎的依赖关系（`junit-vintage-engine`。
*   测试启动器的插件（`junit-platform-gradle-plugin`。

因此，`build.gradle`的完整来源如下：

```java
buildscript {
   repositories {
      mavenCentral()
   }
   dependencies {
      classpath("org.junit.platform:junit-platform-gradle-plugin:${junitPlatformVersion}")
   }
}

repositories {
   mavenCentral()
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'org.junit.platform.gradle.plugin'

compileTestJava {
   sourceCompatibility = 1.8
   targetCompatibility = 1.8
   options.compilerArgs += '-parameters'
}

dependencies {
   testCompile("junit:junit:${junitLegacy}")
   testRuntime("org.junit.vintage:junit-vintage-engine:${junitVintageVersion}")
}
```

从命令行执行如下：

![](img/00027.gif)

使用Gradle运行遗留测试

# 控制台

`ConsoleLauncher`是一个命令行Java应用程序，允许从控制台启动JUnit平台。例如，它可以用于从命令行运行Vintage和Jupiter测试。

包含所有依赖项的可执行JAR发布在中央Maven存储库中的`junit-platform-console-standalone`工件下。独立控制台启动器可以按如下方式执行：

```java
java -jar junit-platform-console-standalone-version.jar <Options>
```

示例GitHub存储库[*junit5控制台启动器*](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-console-launcher)包含一个使用控制台启动器的简单示例。如下图所示，在Eclipse中创建了一个运行配置条目，运行主类`org.junit.platform.console.ConsoleLauncher`。然后，使用选项`--select-class`和限定类名（在本例中为`io.github.bonigarcia.EmptyTest`）将测试类名作为参数传递。之后，我们可以运行应用程序，在Eclipse的集成控制台中获得测试结果：

![](img/00028.jpeg)

Eclipse中ConsoleLancher的示例

# JUnit4中的Jupiter测试

JUnit5被设计为向前和向后兼容。一方面，Vintage组件支持在JUnit3和JUnit4上运行遗留代码。另一方面，JUnit 5提供了一个JUnit 4运行程序，它允许在IDE中运行JUnit 5，并构建支持JUnit 4的系统，但还不能直接支持新的JUnit平台5。

让我们看一个例子。假设我们想要在一个不支持JUnit5的IDE中运行Jupiter测试，例如旧版本的Eclipse。在这种情况下，我们需要用`@RunWith(JUnitPlatform.class)`注释我们的Jupiter测试。`JUnitPlatform`runner是一个基于JUnit 4的runner，它支持在JUnit 4环境中运行其编程模型在JUnit平台上受支持的任何测试。因此，我们的测试结果如下：

```java
package io.github.bonigarcia;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
import org.junit.platform.runner.JUnitPlatform;
import org.junit.runner.RunWith;

@RunWith(JUnitPlatform.class)
public class JUnit5CompatibleTest {

   @Test 
   void myTest() {
      String message = "1+1 should be equal to 2";
      System.*out*.println(message);
 *assertEquals*(2, 1 + 1, message);
   }

}
```

如果此测试包含在Maven项目中，我们的`pom.xml`应该包含以下依赖项：

```java
<dependencies>
   <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <version>${junit.jupiter.version}</version>
      <scope>test</scope>
    </dependency>
    <dependency>
       <groupId>org.junit.jupiter</groupId>
       <artifactId>junit-jupiter-engine</artifactId>
       <version>${junit.jupiter.version}</version>
       <scope>test</scope>
     </dependency>
     <dependency>
        <groupId>org.junit.platform</groupId>
        <artifactId>junit-platform-runner</artifactId>
        <version>${junit.platform.version}</version>
        <scope>test</scope>
     </dependency>
 </dependencies>
```

另一方面，对于Gradle项目，我们的`build.gradle`如下：

```java
buildscript {
   repositories {
      mavenCentral()
   }
   dependencies {
      classpath("org.junit.platform:junit-platform-gradle-plugin:${junitPlatformVersion}")
   }
}

repositories {
   mavenCentral()
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'org.junit.platform.gradle.plugin'

compileTestJava {
   sourceCompatibility = 1.8
   targetCompatibility = 1.8
   options.compilerArgs += '-parameters'
}

dependencies {
   testCompile("org.junit.jupiter:junit-jupiter-api:${junitJupiterVersion}")
   testRuntime("org.junit.jupiter:junit-jupiter-engine:${junitJupiterVersion}")
   testCompile("org.junit.platform:junit-platform-runner:${junitPlatformVersion}")
}
```

# IntelliJ

IntelliJ 2016.2+是第一个支持本地执行Jupiter测试的IDE。如以下屏幕截图所示，可以使用IDE的集成功能执行任何Jupiter测试：

![](img/00029.jpeg)

在IntelliJ 2016.2中运行Jupiter测试+

# 日食

Eclipse4.7（*Oxygen*）对JUnit5有beta版支持。由于这一点，Eclipse提供了直接在Eclipse中运行Jupiter测试的能力，如以下屏幕截图所示：

![](img/00030.jpeg)

在Eclipse4.7中运行Jupiter测试+

此外，Eclipse 4.7（*Oxygen*）提供了一个向导，以简单的方式创建Jupiter测试，如下图所示：

![](img/00031.jpeg)

创建Jupiter测试的Eclipse向导

# JUnit5的扩展模型

如前所述，Jupiter是JUnit 5新编程模型的名称，详细描述见[第3章](3.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)、*JUnit 5标准测试*和[第4章](4.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb)、*使用高级JUnit特性简化测试*以及扩展模型。扩展模型允许通过自定义添加扩展Jupiter编程模型。由于这一点，第三方框架（如Spring或Mockito等）可以无缝地实现与JUnit5的互操作性。这些框架提供的扩展将在[第5章](5.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb)*JUnit 5与外部框架的集成*中研究。在本节中，我们将分析扩展模型的一般性能，以及JUnit5中提供的现成扩展。

与JUnit4中以前的扩展点（即测试运行程序和规则）不同，JUnit5扩展模型由一个单一的、连贯的概念组成：**扩展API**。此API允许任何第三方（工具供应商、开发人员等）扩展JUnit5的核心功能。关于Jupiter中的扩展，我们需要了解的第一件事是，每个新扩展都实现一个名为`Extension`的接口。该接口是一个*标记*接口，即没有字段或方法的Java接口：

```java
package org.junit.jupiter.api.extension;

import static org.apiguardian.api.API.Status.STABLE;

import org.apiguardian.api.API;

/**
 * Marker interface for all extensions.
 *
 * @since 5.0
 */
@API(status = STABLE, since = "5.0")
public interface Extension {
}
```

为了简化Jupiter扩展的创建，JUnit5提供了一组扩展点，允许在测试生命周期的不同部分执行自定义代码。下表总结了Jupiter中的扩展点，其详细信息将在下一节中介绍：

| **扩展点** | **由想要……**的扩展实现 |
| `TestInstancePostProcessor` | 在测试实例化之后提供其他行为 |
| `BeforeAllCallback` | 在测试容器中调用所有测试之前提供其他行为 |
| `BeforeEachCallback` | 在调用每个测试之前，为测试提供其他行为 |
| `BeforeTestExecutionCallback` | 在执行每个测试之前，为测试提供额外的行为 |
| `TestExecutionExceptionHandler` | 处理测试执行期间引发的异常 |
| `AfterAllCallback` | 在调用所有测试后，为测试容器提供其他行为 |
| `AfterEachCallback` | 在调用每个测试后，为测试提供其他行为 |
| `AfterTestExecutionCallback` | 在执行每个测试后立即向测试提供附加行为 |
| `ExecutionCondition` | 在运行时条件化测试执行 |
| `ParameterResolver` | 在运行时解析参数 |

一旦我们创建了一个扩展，为了使用它，我们需要使用注释`ExtendWith`。此批注可用于注册一个或多个扩展名。它可以在接口、类、方法、字段甚至其他注释中声明：

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

public class MyTest {

   @ExtendWith(MyExtension.class)
   @Test
   public void test() {
     // My test logic
   }

}
```

# 测试生命周期

有一组扩展点旨在控制测试的生命周期。首先，在测试实例化之后，`TestInstancePostProcessor`可以用来执行一些逻辑。之后，有不同的扩展控制预测试阶段：

*   `BeforeAllCallback`定义了所有测试之前执行的逻辑。
*   `BeforeEachCallback`定义了测试方法之前执行的逻辑。
*   `BeforeTestExecutionCallback`定义了测试方法之前立即执行的逻辑。

类似地，也有控制测试后阶段的扩展：

*   `AfterAllCallback`定义了所有测试后执行的逻辑。
*   `AfterEachCallback`定义了测试方法后执行的逻辑。
*   `AfterTestExecutionCallback`定义了测试方法之后立即执行的逻辑。

在`Before*`和`After*`回调之间，有一个扩展提供了收集异常的方法：`TestExecutionExceptionHandler`。

所有这些回调及其在测试生命周期中的顺序如下图所示：

![](img/00032.jpeg)

扩展回调的生命周期

让我们看一个例子。我们创建了一个名为`IgnoreIOExceptionExtension`的扩展，它实现了`TestExecutionExceptionHandler`。在本例中，扩展检查异常是否为`IOException`。如果是，则丢弃异常：

```java
package io.github.bonigarcia;

import java.io.IOException;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.TestExecutionExceptionHandler;

public class IgnoreIOExceptionExtension
   implements TestExecutionExceptionHandler {

   @Override
   public void handleTestExecutionException(ExtensionContext context,
          Throwable throwable) throws Throwable {
      if (throwable instanceof IOException) {
         return;
      }
      throw throwable;
   }

}
```

考虑下面的测试类，它包含两个测试（AutoT0}）。第一个注释为`@ExtendWith`和我们的自定义扩展名（`IgnoreIOExceptionExtension`：

```java
package io.github.bonigarcia;

import java.io.IOException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

public class ExceptionTest {

   @ExtendWith(IgnoreIOExceptionExtension.class)
   @Test
   public void firstTest() throws IOException {
      throw new IOException("IO Exception");
   }

   @Test
   public void secondTest() throws IOException {
      throw new IOException("My IO Exception");
   }

}
```

当执行这个测试类时，第一个测试成功，因为`IOException`已经由我们的扩展内部处理。另一方面，第二个将失败，因为没有处理该异常。

在下一个屏幕截图中可以看到该测试类在控制台中的执行。注意，我们使用Maven命令`mvn test -Dtest=ExceptionTest`选择要执行的测试：

![](img/00033.gif)

忽略异常示例的输出

# 条件扩展点

为了创建根据给定条件激活或停用测试的扩展，JUnit5提供了一个被调用的条件扩展点`ExecutionCondition`。以下代码段显示了此扩展点的声明：

```java
package org.junit.jupiter.api.extension;

import static org.apiguardian.api.API.Status.STABLE;

import org.apiguardian.api.API;

@FunctionalInterface
@API(status = STABLE, since = "5.0")
public interface ExecutionCondition extends Extension {
   ConditionEvaluationResult evaluateExecutionCondition         
     ExtensionContext context);

}
```

该扩展可用于停用容器中的所有测试（可能是类）或单个测试（可能是测试方法）。[第3章](3.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)*JUnit 5标准测试*中的*条件测试执行*部分提供了此扩展的示例。

# 依赖注入

`ParameterResolver`扩展在方法级别提供依赖注入。在这个例子中，我们可以看到一个参数是如何通过一个名为`MyParameterResolver`的`ParameterResolver`自定义实现注入测试方法的。在代码之后，我们可以看到此解析器将简单地使用值`my parameter`注入硬编码字符串参数：

```java
package io.github.bonigarcia;

import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.ParameterContext;
import org.junit.jupiter.api.extension.ParameterResolutionException;
import org.junit.jupiter.api.extension.ParameterResolver;

public class MyParameterResolver implements ParameterResolver {

    @Override
    public boolean supportsParameter(ParameterContext parameterContext,
            ExtensionContext extensionContext)
            throws ParameterResolutionException {
        return true;
    }

    @Override
    public Object resolveParameter(ParameterContext parameterContext,
            ExtensionContext extensionContext)
            throws ParameterResolutionException {
        return "my parameter";
    }

}
```

然后，可以在测试中使用此参数解析器，并使用注释`@ExtendWith`声明其正常：

```java
package io.github.bonigarcia;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

public class DependencyInjectionTest {

   @ExtendWith(MyParameterResolver.class)
   @Test
   public void test(Object parameter) {
      System.*out*.println("My parameter " + parameter);
   }
}
```

最后，如果我们执行这个测试（例如使用Maven和命令行），我们可以看到注入的参数是如何记录在标准输出中的：

![](img/00034.gif)

依赖项注入扩展示例的输出

# 第三方扩展

在现实世界中，扩展通常实现前面解释的几个扩展点。例如，`SpringExtension`（详见[第5章](5.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb)、*JUnit 5与外部框架的集成*）实现了`BeforeAllCallback`、`TestInstancePostProcessor`、`ParameterResolver`等扩展点。以下片段提供了`SpringExtension`的结构：

```java
package org.springframework.test.context.junit.jupiter;

import org.junit.jupiter.api.extension.*;

public class SpringExtension implements BeforeAllCallback,     
   AfterAllCallback,
   TestInstancePostProcessor, BeforeEachCallback, AfterEachCallback,
   BeforeTestExecutionCallback, AfterTestExecutionCallback,
   ParameterResolver {

   @Override
   public void afterTestExecution(TestExtensionContext context) 
    throws Exception {
      // implementation
   }

   // Rest of methods
}
```

社区在JUnit 5团队的GitHub站点的wiki中维护现有JUnit 5扩展（例如Spring、Selenium、Docker和其他）的列表：[https://github.com/junit-team/junit5/wiki/Third-party-Extensions](https://github.com/junit-team/junit5/wiki/Third-party-Extensions) 。其中一些在[第5章](5.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb)、*JUnit 5与外部框架的集成*中也有详细介绍。

# 总结

本章概述JUnit5测试框架。由于JUnit4的局限性（单片架构、组合测试运行程序的不可能性以及测试规则的局限性），需要一个新的主要框架版本。为了实施，JUnit Lambda项目于2015年启动了众筹活动。因此，JUnit5开发团队诞生了，框架的GA版本于2017年9月10日发布。

JUnit5被设计成现代的（也就是说，从一开始就使用Java8和Java9兼容）和模块化的。JUnit5中的三个主要组件是：Jupiter（新的扩展模型编程）、Platform（JVM中执行的任何测试框架的基础）和Vintage（与遗留JUnit3和4测试的集成）。在撰写本文时，JUnit5测试可以使用构建工具（Maven或Gradle）和IDE（Intellij2016.2+或Eclipse4.7+）执行。

JUnit5的扩展模型允许任何第三方扩展JUnit5的核心功能。为了创建JUnit 5扩展，我们需要实现一个或多个JUnit扩展点（例如`BeforeAllCallback`、`ParameterResolver`或`ExecutionCondition`等），然后使用注释`@ExtendWith`在我们的测试中注册扩展。

在接下来的[第3章](3.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)*JUnit 5标准测试*中，我们将学习Jupiter编程模型的基础知识。换句话说，我们将学习如何创建标准JUnit5测试。*