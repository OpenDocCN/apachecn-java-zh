# 扩展我们的电子商务应用程序

在上一章中，我们开始开发一个电子商务应用程序，并创建了根据产品 ID 以及一些参数查找产品的功能。在本章中，我们将扩展功能，以便我们也可以订购所选的产品。在此过程中，我们将学习新技术，重点关注 Java 中的函数式编程和其他一些语言功能，如运行时的反射和注释处理，以及脚本接口。

正如我们在前几章中所做的那样，我们将逐步开发该应用程序。随着我们发现新学到的技术，我们将重构代码，加入新的工具和方法，以生成更可读、更有效的代码。我们还将模仿现实项目的开发，从这个意义上说，一开始，我们将有简单的需求，然后，随着我们想象中的业务发展和销售越来越多的产品，将设置新的需求。我们将成为想象中的百万富翁。

我们将使用上一章的代码库，但我们将在一个新项目中进一步开发它。我们将使用 Spring、Gradle、Tomcat 和 soapUI，在上一章中我们了解了它们之后，这些都不是新的。在本章中，您将学习以下主题：

*   Annotation processing
*   Using reflection
*   Functional programming in Java using:

# 我的商业订单

订购过程比仅仅查找产品要复杂一点。订单表单本身列出了产品和金额，并标识了该订单的客户。标识符提供产品。我们所要做的就是检查产品是否在我们的商店中可用，然后我们可以将它们交付给给定的客户。这是最简单的方法；然而，对于某些产品，有更多的限制。例如，当有人订购台灯时，我们会单独提供电源线。原因是电源线是特定于国家/地区的。我们向英国和德国提供不同的电源线。一种可能的方法是确定客户的国家。但这种方法没有考虑到我们的客户是经销商。所有客户都可能位于英国，同时他们可能希望将带有电源线的灯具运送到德国。为了避免这种情况和含糊不清，我们的客户最好在同一订单中将台灯和电源线作为单独的项目订购。在某些情况下，我们提供的台灯没有电源线，但这是一个特殊情况。我们需要一些逻辑来确定这些特殊情况。因此，我们必须实现逻辑，以查看是否有台灯的电源线，如果没有自动处理订单，则拒绝。这并不意味着我们不会交付产品。我们将只把订单放入队列中，一些操作员将不得不查看它。

这种方法的问题在于，台灯只是一种需要配置支持的产品。我们拥有的产品越多，他们可能拥有的特殊性就越多，检查订单一致性的代码也变得越来越复杂，直到达到无法管理的复杂程度。当一个类或方法变得过于复杂时，程序员会对其进行重构，将该方法或类拆分为更小的部分。我们也必须对产品进行同样的检查。我们不应该试图创建一个庞大的类来检查产品和所有可能的订单星座，而是应该有许多较小的检查，以便每个检查只检查一个小集合。

在某些情况下，检查一致性更简单。检查灯是否有电源线对于任何新手程序员来说都很复杂。我们在代码中使用此示例是因为我们希望关注代码的实际结构，而不是检查本身的复杂性质。然而，在现实生活中，检查可能相当复杂。想象一下一家卖电脑的商店。它将一个配置放在一起：电源、图形卡、主板、适当的 CPU 和内存。有很多选择，其中一些可能无法协同工作。在现实生活中，我们需要检查主板是否与所选内存兼容，是否有顺序中的尽可能多的存储组，它们是否正确配对（一些内存只能成对安装），是否有图形卡的兼容插槽，而且电源有足够的瓦特，可以可靠地运行整个配置。这非常复杂，最好不要与检查灯是否有电源线的代码混淆。

# 建立项目

由于我们仍然使用 Spring 引导，构建文件不需要任何修改；我们将使用它，因为我们将使用与上一章相同的文件。然而，包结构有点不同。这一次，我们做的事情比获取请求和响应后端服务提供给我们的任何内容都要复杂。现在，我们必须实现复杂的业务逻辑，正如我们将看到的，它需要很多类。当我们在一个特定的包中有 10 个以上的类时，是时候考虑将它们放在不同的包中了。相互关联且具有类似功能的类应放在一个包中。通过这种方式，我们将获得以下产品的包装：

*   控制器（虽然在本例中我们只有一个，但通常有更多）
*   数据存储 bean 的功能仅限于存储数据，例如字段、setter 和 getter
*   在订购台灯时帮助我们检查电源线的检查器
*   为控制器执行不同服务的服务
*   我们的程序的主程序包包含`Application`类、`SpringConfiguration`和一些接口

# 订单控制器和 DTO

当服务器收到订购一系列产品的请求时，它会发出 HTTPS`POST`请求。请求的主体用 JSON 编码。到目前为止，我们拥有处理`GET`参数的控制器，但当我们可以依赖 Spring 的数据编组时，处理`POST`请求并不难。控制器代码本身很简单：

```
package packt.java9.by.example.mybusiness.bulkorder.controllers; 

import ... 

@RestController 
public class OrderController { 
    private Logger log = 
                LoggerFactory.getLogger(OrderController.class); 
    private final Checker checker; 

    public OrderController(@Autowired Checker checker) { 
        this.checker = checker; 
    } 

    @RequestMapping("/order") 
    public Confirmation getProductInformation(@RequestBody Order order) { 
        if (checker.isConsistent(order)) { 
            return Confirmation.accepted(order); 
        } else { 
            return Confirmation.refused(order); 
        } 
    } 
}

```

我们在此控制器中只处理一个请求：`order`。这被映射到 URL`/order`。订单将从 JSON 自动转换为请求正文中的订单对象。这就是`@RequestBody`注释要求 Spring 为我们做的事情。控制器的功能只是检查订单的一致性。如果订单一致，则我们接受订单；否则，我们拒绝。现实生活中的示例还将检查订单是否不仅一致，而且是否来自有资格购买这些产品的客户，并且根据生产商的承诺和交付周期，产品是否在仓库中可用，或者至少可以交付。

为了检查订单的一致性，我们需要一些能帮我们完成这项工作的东西。正如我们所知，我们必须模块化代码，而不是在一个类中实现太多的东西，我们需要一个 checker 对象。这是根据`@Autowired`对类和控制器构造函数的注释自动提供的。

`Order`类是一个简单的 bean，只列出以下项：

```
package packt.java9.by.example.mybusiness.bulkorder.dtos; 
import ...; 
public class Order { 
    private String orderId; 
    private List<OrderItem> items; 
    private String customerId; 

... setters and getters ... 
}

```

包的名称为`dtos`，代表**数据传输对象**（**DTO**的复数形式。DTO 是用于在不同组件（通常通过网络）之间传输数据的对象。由于另一方可以用任何语言实现，封送可以是 JSON、XML 或其他格式，这些格式只能传递数据。这些类没有真正的方法。DTO 通常只有字段、setter 和 getter。

以下是包含订单中一项的类：

```
package packt.java9.by.example.mybusiness.bulkorder.dtos; 

public class OrderItem { 
    private double amount; 
    private String unit; 
    private String productId; 

... setters and getters ... 
}

```

订单确认也在这个包中，虽然这也是一个真正的 DTO，但它有一些简单的辅助方法：

```
package packt.java9.by.example.mybusiness.bulkorder.dtos; 

public class Confirmation { 
    private final Order order; 
    private final boolean accepted; 

    private Confirmation(Order order, boolean accepted) { 
        this.order = order; 
        this.accepted = accepted; 
    } 

    public static Confirmation accepted(Order order) { 
        return new Confirmation(order, true); 
    } 

    public static Confirmation refused(Order order) { 
        return new Confirmation(order, false); 
    } 

    public Order getOrder() { 
        return order; 
    } 

    public boolean isAccepted() { 
        return accepted; 
    } 
}

```

我们为该类提供了两个工厂方法。这有点违反了纯粹主义者所憎恨的单一责任原则。大多数情况下，当代码变得更复杂时，这些捷径会起到反作用，代码必须进行重构才能变得更干净。最纯粹的解决方案是创建一个单独的工厂类。使用此类或分离类中的工厂方法可以使控制器的代码更具可读性。

我们的主要任务是一致性检查。到目前为止，代码几乎微不足道。

# 一致性检查器

我们有一个一致性检查器类，它的一个实例被注入控制器。此类用于检查一致性，但实际上它本身并不执行检查。它只控制我们提供的不同的 checker，并逐个调用它们来完成真正的工作。

我们要求一致性检查器（如在订购台灯时检查订单是否包含电源线的一致性检查器）实现`ConsistencyChecker`接口：

```
package packt.java9.by.example.mybusiness.bulkorder; 

import ... 
public interface ConsistencyChecker { 
    boolean isInconsistent(Order order); 
}

```

如果顺序不一致，方法`isInconsistent`应该返回`true`。如果不知道订单是否不一致，则返回`false`，但从实际检查人检查订单的角度来看，不存在不一致。有几个`ConsistencyChecker`类，我们必须一个接一个地调用，直到其中一个返回`true`为止，否则我们就没有这些类了。如果没有人返回`true`，那么我们可以安全地假设，至少从自动检查的角度来看，订单是一致的。

我们在开发之初就知道，我们确实会有很多一致性检查，而且并非所有的一致性检查都与所有订单相关。我们希望避免为每个订单调用每个检查器。为此，我们实现了一些过滤。我们让产品指定他们需要的检查类型。这是一条产品信息，如尺寸或说明。为了适应这种情况，我们需要扩展`ProductInformation`类。

我们将创建每个`ConsistencyChecker`接口，将类实现为 Springbean（用`@Component`注释进行注释），同时，我们将用注释对它们进行注释，该注释指定它们实现的检查类型。同时，`ProductInformation`被扩展，包含一组`Annotation`类对象，用于指定要调用的检查程序。我们可以简单地列出 checker 类而不是注释，但这给了我们一些额外的自由来配置产品和注释之间的映射。注释指定产品的类型，并对检查器类进行注释。桌边灯为`PoweredDevice`型，棋盘格类`NeedPowercord`为`@PoweredDevice`注释。如果有任何其他类型的产品也需要电源线，那么该类型的注释应该添加到`NeedPowercord`类中，我们的代码就可以工作了。由于我们开始深入研究注释和注释处理，我们必须首先了解注释的真正含义。自[第 3 章](03.html)起，我们就已经使用了注释*优化排序，使代码专业化*，但我们所知道的只是如何使用注释，如果不了解我们所做的事情，这通常是危险的。

# 注释

注释前面带有`@`字符，可以附加到包、类、接口、字段、方法、方法参数、泛型类型声明和使用，最后附加到注释。注释几乎可以在任何地方使用，它们用于描述一些程序元信息。例如，`@RestController`注释不会直接改变`OrderController`类的行为。类的行为由内部的 Java 代码描述。注释帮助 Spring 理解类是什么以及如何使用它。当 Spring 扫描所有包和类以发现不同的 Springbean 时，它会看到类上的注释并将其考虑在内。Spring 可能不理解类上的其他注释。它们可能被其他一些框架或程序代码使用。Spring 将它们视为任何行为良好的框架。例如，正如我们稍后将看到的，我们的代码库中有一个`NeedPowercord`类，它是一个 Springbean，因此用`@Component`注释进行注释。同时，也用`@PoweredDevice`注释进行注释。Spring 不知道什么是电动设备。这是我们定义和使用的东西。Spring 忽略了这一点。

包、类、接口、字段等可以附加许多注释。这些注释应该简单地写在它们所附加的语法单位声明的前面。

对于包，注释必须写在`package-info.java`文件中包名的前面。该文件可以放置在包的目录中，可以用于编辑包的*JavaDoc*，还可以向包添加注释。此文件不能包含任何 Java 类，因为名称`package-info`不是有效标识符。

我们不能在任何东西前面写任何东西作为注释。应该声明注释。它们位于 Java 特殊接口的运行时中。例如，声明`@PoweredDevice`注释的 Java 文件如下所示：

```
package packt.java9.by.example.mybusiness.bulkorder.checkers; 

import java.lang.annotation.Retention; 
import java.lang.annotation.RetentionPolicy; 

@Retention(RetentionPolicy.RUNTIME) 
public @interface PoweredDevice { 
}

```

`interface`关键字前面的`@`字符表示这是一种特殊的注释类型。有一些特殊的规则；例如，注释接口不应扩展任何其他接口，即使是注释接口也不应扩展。另一方面，编译器会自动生成注释接口，以便扩展 JDK 接口`java.lang.annotation.Annotation`。

注释位于源代码中，因此，它们在编译过程中可用。它们也可以由编译器保留并放入生成的类文件中，当类加载器加载类文件时，它们也可能在运行时可用。默认行为是编译器将注释与注释元素一起存储在类文件中，但类加载器不使其在运行时可用。

为了在编译过程中处理注释，必须使用注释处理器扩展 Java 编译器。这是一个相当高级的主题，在使用 Java 时，您只能遇到几个示例。注释处理器是一个 Java 类，它实现了一个特殊的接口，当编译器处理处理器声明感兴趣的源文件中的注释时，编译器会调用它。

# 注释保留

Spring 和其他框架通常在运行时处理注释。必须指示编译器和类加载器在运行时保持注释可用。为此，必须使用`@Retention`注释对注释接口本身进行注释。此注释有一个`RetentionPolicy`类型的参数，它是一个`enum`。我们将很快讨论如何定义注释参数。

有趣的是，注释接口上的`@Retention`注释必须在类文件中可用；否则，类装入器将不知道如何处理注释。在编译过程之后，我们如何表示编译器将保留注释？我们对注释接口声明进行注释。因此，`@Retention`的声明由自身进行注释，并声明在运行时可用。

注释声明可以使用`@Retention(RetentionPolicy.SOURCE)`、`@Retention(RetentionPolicy.CLASS)`或`@Retention(RetentionPolicy.RUNTIME)`进行注释。

# 注释目标

最后一种保留类型将是最常用的保留类型。还可以在注释声明上使用其他注释。`@Target`注释可用于限制注释在特定位置的使用。此注释的参数是单个`java.lang.annotation.ElementType`值或这些值的数组。有充分的理由限制注释的使用。当我们将注释放置在错误的位置时，获得编译时错误比在运行时查找框架忽略注释的原因要好得多。

# 注释参数

正如我们所看到的，注释可以有参数。为了在注释的`@interface`声明中声明这些参数，我们使用方法。这些方法具有名称和返回值，但不应具有参数。您可以尝试声明一些参数，但 Java 编译器将非常严格，不会编译您的代码。

这些值可以在使用注释的地方定义，使用方法的名称和`=`字符，为它们分配一些与方法类型兼容的值。例如，假设我们将注释`PoweredDevice`的声明修改为：

```
public @interface ParameteredPoweredDevice { 
    String myParameter(); 
}

```

在这种情况下，在使用注释时，我们应该为参数指定一些值，例如：

```
@Component 
@ParameteredPoweredDevice(myParameter = "1966") 
public class NeedPowercord implements ConsistencyChecker { 
...

```

如果参数的名称是一个值，并且在注释的使用位置没有定义其他参数，则可能会跳过名称“值”。例如，当我们只有一个参数时，按如下方式修改代码是一种方便的速记方式：

```
public @interface ParameteredPoweredDevice{ 
    String value(); 
} 
... 
@Component 
@ParameteredPoweredDevice("1966") 
public class NeedPowercord implements ConsistencyChecker { 
...

```

我们还可以在方法声明之后使用`default`关键字定义可选参数。在这种情况下，我们必须为参数定义一个默认值。进一步修改示例注释，我们仍然可以（但不需要）指定值。在后一种情况下，它将是一个空字符串：

```
public @interface ParameteredPoweredDevice { 
    String value() default ""; 
}

```

由于我们指定的值应该是常量，并且在编译时是可计算的，所以复杂类型的使用并不多。注释参数通常是字符串、整数，有时是双精度或其他基本类型。语言规范给出的确切类型列表如下：

*   原语（`double`、`int`等）
*   一串
*   班
*   枚举
*   另一个注释
*   上述任何类型的数组

我们已经看到了`String`的例子，而且`enum`：`Retention`和`Target`都有`enum`参数。我们要关注的有趣部分是前面列表的最后两项。

当参数的值为数组时，可以将该值指定为介于`{`和`}`字符之间的逗号分隔值。例如：

```
String[] value();

```

这可以添加到`@interface`注释中，我们可以这样写：

```
@ParameteredPoweredDevice({"1966","1967","1991"})

```

但是，如果我们只想传递一个值作为参数值，我们仍然可以使用以下格式：

```
@ParameteredPoweredDevice("1966")

```

在这种情况下，该属性的值将是长度为`1`的数组。当注释的值是注释类型的数组时，事情会变得更加复杂。我们创建一个`@interface`注释（注意名称中的复数）：

```
@Retention(RetentionPolicy.RUNTIME) 
public @interface PoweredDevices { 
ParameteredPoweredDevice[] value() default {}; 
}

```

此注释的使用可如下所示：

```
@PoweredDevices( 
        {@ParameteredPoweredDevice("1956"), @ParameteredPoweredDevice({"1968", "2018"})} 
)

```

请注意，这与具有三个参数的`ParameteredPoweredDevice`注释不同。这是一个具有两个参数的注释。每个参数都是一个注释。第一个有一个字符串参数，第二个有两个。

正如您所看到的，注释可能相当复杂，一些框架（或者更确切地说是创建它们的程序员）使用它们疯狂运行。在开始编写框架之前，先研究一下是否已经有了可以使用的框架。此外，检查是否有其他方法来解决您的问题。99%的注释处理代码可以避免并简化。我们为相同功能编写的代码越少，我们就越快乐。我们程序员是懒惰的类型，这是必须的。

最后一个示例中，注释的参数是注释数组，这对于理解如何创建可重复的注释非常重要。

# 可重复注释

用`@Repeatable`注释该注释的声明，表示该注释可以在一个地方应用多次。此批注的参数是一个批注类型，该类型应具有类型为的参数，该参数是此批注的数组。不要试图去理解！我将举一个例子。我已经有了，事实上：我们有`@PoweredDevices`。它有一个参数，它是一个`@ParameteredPoweredDevice`数组。现在我们把这个 T3 的注释注释如下：

```
... 
@Repeatable(PoweredDevices.class) 
public @interface ParameteredPoweredDevice { 
...

```

然后，我们可以简化`@ParameteredPoweredDevice`的使用。我们可以多次重复注释，Java 运行时将自动将其包含在包装类中，在本例中，包装类是`@PoweredDevices`。在这种情况下，以下两项将等效：

```
... 
@ParameteredPoweredDevice("1956") 
@ParameteredPoweredDevice({"1968", "2018"}) 
public class NeedPowercord implements ConsistencyChecker { 
... 

@PoweredDevices( 
        {@ParameteredPoweredDevice("1956"), @ParameteredPoweredDevice({"1968", "2018"})} 
) 
public class NeedPowercord implements ConsistencyChecker { 
...

```

这种复杂方法的原因也是 Java 严格遵循的向后兼容性的一个例子。注释是在 Java1.5 中引入的，可重复的注释只有在版本 1.8 之后才可用。我们将很快讨论用于在运行时处理注释的反射 API。`java.lang.reflect.AnnotatedElement`接口中的这个 API 有一个`getAnnotation(annotationClass)`方法，它返回一个注释。如果一个注释可以在类、方法等上多次出现，则无法调用此方法来获取具有所有不同参数的所有不同实例。通过引入封装多个注释的包含类型，确保了向后兼容性。

# 注释继承

注释，就像方法或字段一样，可以在类层次结构之间继承。如果注释声明标记有`@Inherited`，则使用此注释扩展另一个类的类可以继承它。如果子类具有注释，则可以重写注释。因为 Java 中没有多重继承，所以不能继承接口上的注释。即使继承了注释，检索特定元素注释的应用程序代码也可以区分继承的注释和在实体本身上声明的注释。有方法获取注释，也有单独的方法获取声明的注释，这些注释是在实际元素上声明的，而不是继承的。

# @文档注释

`@Documented`注释表示注释是实体合同的一部分，因此必须进入文档。这是一个注释，*JavaDoc*生成器在为引用`@Documented`注释的元素创建文档时查看的注释。

# JDK 注释

除了用于定义注释的注释外，JDK 中还定义了其他注释。我们已经看到了其中的一些。最常用的是`@Override`注释。当编译器看到此注释时，它会检查该方法是否确实覆盖了某些继承的方法。否则将导致错误，使我们免于痛苦的运行时调试。

`@Deprecated`注释在方法、类或其他元素的文档中表示不使用该元素。它仍然存在于代码中，因为一些用户可能仍然使用它，但是对于依赖于包含元素的库的新开发，新开发的代码不应该使用它。注释有两个参数。其中一个参数是`since`，它可以有一个字符串值，并且可以提供关于该方法或类被弃用的时间或时间的版本信息。另一个参数是`forRemoval`，如果该元素不会出现在库的未来版本中，则该参数应为`true`。有些方法可能会被弃用，因为有更好的替代方法，但开发人员不打算从库中删除该方法。在这种情况下，`forRemoval`可以设置为`false`。

`@SuppressWarning`注释也是一个常用的注释，尽管它的用法值得怀疑。它可用于抑制编译器的某些警告。如果可能的话，建议编写代码，这些代码可以在没有任何警告的情况下编译。

`@FunctionalInterface`注释声明一个接口只打算有一个方法。这样的接口可以实现为 lambda 表达式。您将在本章后面了解 lambda 表达式。当此注释应用于接口且接口中声明了多个方法时，编译器将发出编译错误信号。这将防止任何开发人员在早期向接口添加另一种方法，该接口将与函数式编程和 lambda 表达式一起使用。

# 使用反射

现在您已经学习了如何声明注释以及如何将注释附加到类和方法，我们可以返回到`ProductInformation`类。回想一下，我们想在这个类中指定产品的类型，并且每个产品类型都由一个`@interface`注释表示。我们已经在前面几页中列出了它，我们将在`@PoweredDevice`示例中实现它。我们将开发代码，假设以后会有许多这样的注释、产品类型和一致性检查，它们都用`@Component`和我们的一个或多个注释进行注释。

# 获取注释

我们将使用以下字段扩展`ProductInformation`类：

```
private List<Class<? extends Annotation>> check;

```

因为这是一个 DTO，Spring 需要 setter 和 getter，所以我们还将向其添加一个新的 getter 和 setter。该字段将包含每个类实现一个注释的类的列表，以及内置的 JDK 接口`Annotation`，因为 Java 编译器是通过这种方式生成它们的。在这一点上，这可能是一个有点模糊，但我保证，黎明将打破，将有光明，因为我们继续。

要获得产品信息，我们必须通过 ID 进行查找。这是我们在上一章中开发的接口和服务，但这次我们有了另一个新领域。事实上，这是一个显著的差异，尽管`ProductLookup`接口根本没有改变。在最后一章中，我们开发了两个版本。其中一个版本正在从属性文件读取数据，另一个版本正在连接到 REST 服务。

属性文件是一种丑陋而陈旧的技术，但如果你想通过 Java 面试或从事 21 世纪初开发的企业应用程序，那么属性文件是必须的。我必须把它写在最后一章里。把它写进书中是我自己的冲动。同时，在为本章编写代码时，我没有勇气继续使用它。我还想向您展示，相同的内容可以用 JSON 格式管理。

现在，我们将扩展`ResourceBasedProductLookup`的实现，从 JSON 格式的资源文件中读取产品信息。类中的大部分代码保持不变；因此，我们在此仅列出差异：

```
package packt.java9.by.example.mybusiness.bulkorder.services; 

import ... 

@Service 
public class ResourceBasedProductLookup implements ProductLookup { 
    private static final Logger log = LoggerFactory.getLogger(ResourceBasedProductLookup.class); 

    private ProductInformation fromJSON(InputStream jsonStream) 
                                              throws IOException { 
        ObjectMapper mapper = new ObjectMapper(); 
        return mapper.readValue(jsonStream, 
                                   ProductInformation.class); 
    } 

... 
    private void loadProducts() { 
        if (productsAreNotLoaded) { 
            try { 
                Resource[] resources =  
                     new PathMatchingResourcePatternResolver(). 
                        getResources("classpath:products/*.json"); 
                for (Resource resource : resources) { 
                    loadResource(resource); 
                } 
                productsAreNotLoaded = false; 
            } catch (IOException ex) { 
                log.error("Test resources can not be read", ex); 
            } 
        } 
    } 

    private void loadResource(Resource resource) 
                                       throws IOException { 
        final int dotPos = 
                      resource.getFilename().lastIndexOf('.'); 
        final String id = 
                      resource.getFilename().substring(0, dotPos); 
        final ProductInformation pi = 
                      fromJSON(resource.getInputStream()); 
        pi.setId(id); 
        products.put(id, pi); 
    } 
...

```

在`project resources/products`目录中，我们有一些 JSON 文件。其中一个包含台灯产品信息：

```
{ 
  "id" : "124", 
  "title": "Desk Lamp", 
  "check": [ 
    "packt.java9.by.example.mybusiness.bulkorder.checkers.PoweredDevice" 
  ], 
  "description": "this is a lamp that stands on my desk", 
  "weight": "600", 
  "size": [ "300", "20", "2" ] 
}

```

产品类型在 JSON 数组中指定。在本例中，此数组只有一个元素，该元素是表示产品类型的注释接口的完全限定名。当 JSON 封送器将 JSON 转换为 Java 对象时，它会识别出需要此信息的字段是一个`List`，因此它会将数组转换为一个列表，以及从`String`到代表注释接口的`Class`对象的元素。

现在我们已经从 JSON 格式的资源中加载了资源，并且我们看到了使用 Spring 读取 JSON 数据是多么容易，我们可以回到顺序一致性检查。`Checker`类实现了收集可插入检查器并调用它们的逻辑。它还实现了基于注释的筛选，以避免调用实际订单中实际产品不需要的检查器：

```
package packt.java9.by.example.mybusiness.bulkorder.services; 

import ... 

@Component() 
@RequestScope 
public class Checker { 
    private static final Logger log = 
                        LoggerFactory.getLogger(Checker.class); 

    private final Collection<ConsistencyChecker> checkers; 
    private final ProductInformationCollector piCollector; 
    private final ProductsCheckerCollector pcCollector; 

    public Checker( 
              @Autowired Collection<ConsistencyChecker> checkers, 
              @Autowired ProductInformationCollector piCollector, 
              @Autowired ProductsCheckerCollector pcCollector) { 
        this.checkers = checkers; 
        this.piCollector = piCollector; 
        this.pcCollector = pcCollector; 
    } 

    public boolean isConsistent(Order order) { 
        Map<OrderItem, ProductInformation> map = 
                piCollector.collectProductInformation(order); 
        if (map == null) { 
            return false; 
        } 
        Set<Class<? extends Annotation>> annotations =  
                pcCollector.getProductAnnotations(order); 
        for (ConsistencyChecker checker :  
                checkers) { 
            for (Annotation annotation :  
                    checker.getClass().getAnnotations()) { 
                if (annotations.contains( 
                                 annotation.annotationType())) { 
                    if (checker.isInconsistent(order)) { 
                        return false; 
                    } 
                    break; 
                } 
            } 
        } 
        return true; 
    } 
}

```

有趣的是，弹簧自动接线非常聪明。我们有一个`Collection<ConsistencyChecker>`类型的字段。通常，如果只有一个类与要连接的资源具有相同的类型，则自动连接可以工作。在我们的例子中，因为这是一个集合，所以我们没有任何这样的候选者，但是我们有许多`ConsistencyChecker`类。我们所有的 checker 都实现了这个接口，Spring 识别它，实例化它们，神奇地创建它们的集合，并将集合注入这个字段。

通常，一个好的框架在逻辑上工作。我不知道 Spring 的这个特性，但我认为这是合乎逻辑的，而且神奇的是，它起了作用。如果事情符合逻辑且正常工作，则无需阅读和记住文档。然而，小心谨慎并不有害。在我体验到这个功能是以这种方式工作的之后，我在文档中查阅了它，发现这确实是 Spring 的一个有保证的特性，而不是只是碰巧可以工作，但在未来的版本中可能会在没有通知的情况下更改。仅使用有保证的功能非常重要，但在我们的行业中被忽略了很多次。

调用`isConsistent`方法时，首先将产品信息收集到`HashMap`中，为每个`OrderItem`分配一个`ProductInformation`实例。这是在一个单独的类中完成的。在此之后，`ProductsCheckerCollector`收集一个或多个产品项所需的`ConsistencyChecker`实例。当我们拥有这个集合时，我们只需要调用那些用这个集合中的一个注释进行注释的 checker。我们在一个循环中这样做。

在这段代码中，我们使用反射。我们循环检查每个检查器的注释。为了获得注释集合，我们调用`checker.getClass().getAnnotations()`。此调用返回一个对象集合。每个对象都是某个 JDK 运行时生成的类的实例，该类实现了我们在其自己的源文件中声明为注释的接口。但是，无法保证动态创建的类只实现我们的`@interface`而不实现其他一些接口。因此，为了获得实际的注释类，我们必须调用`annotationType`方法。

`ProductCheckerCollector`和`ProductInformationCollector`类非常简单，我们将在稍后学习 streams 时讨论它们。当我们使用循环实现它们时，它们将成为一个很好的例子，之后，使用流实现它们。

有了它们，我们最终可以创建实际的 checker 类。以下是帮助我们了解我们的灯具订购的电源线：

```
package packt.java9.by.example.mybusiness.bulkorder.checkers; 

import ... 
@Component 
@PoweredDevice 
public class NeedPowercord implements ConsistencyChecker { 
    private static final Logger log = 
               LoggerFactory.getLogger(NeedPowercord.class); 

    @Override 
    public boolean isInconsistent(Order order) { 
        log.info("checking order {}", order); 
        CheckHelper helper = new CheckHelper(order); 
        return !helper.containsOneOf("126", "127", "128"); 
    } 
}

```

helper 类包含许多检查器需要的简单方法，例如：

```
public boolean containsOneOf(String... ids) { 
    for (final OrderItem item : order.getItems()) { 
        for (final String id : ids) { 
            if (item.getProductId().equals(id)) { 
                return true; 
            } 
        } 
    } 
    return false; 
}

```

# 调用方法

在本例中，我们仅使用一个反射调用来获取附加到类的注释。反思可以做更多的事情。处理注释是这些调用最重要的用途，因为注释没有自己的功能，在运行时不能以任何其他方式处理。然而，反射并没有停止告诉我们一个类或任何其他可注释元素有什么注释。反射可以用来获取一个类的方法列表、作为字符串的方法名称、类的实现接口、它扩展的父类、字段、字段类型等等。反射通常提供方法和类，以编程方式遍历实际代码结构，直至方法级别。

本演练不仅允许读取类型和代码结构，还允许在编译时设置字段值和调用方法，而不必知道方法的名称。我们甚至可以设置`private`字段，外部世界通常无法访问这些字段。还需要注意的是，通过反射访问方法和字段通常比通过编译代码慢，因为它总是涉及按代码中元素的名称进行查找。

经验法则是，如果您看到必须使用反射来创建代码，那么您可能正在创建一个框架（或者写一本关于 Java 的书来详细介绍反射）。听起来熟悉吗？

Spring 还使用反射来发现类、方法和字段，并注入对象。它使用 URL 类加载器列出类路径上的所有 JAR 文件和目录，加载它们并检查类。

举一个人为的例子，为了演示，让我们假设`ConsistencyChecker`实现是由许多外部软件供应商编写的，而最初设计程序结构的架构师只是忘记了在接口中包含`isConsistent`方法。（同时，为了保护我们的心理健康，我们还可以想象此人不再在公司工作了。）因此，不同的供应商提供了“实现”该接口的 Java 类，但我们无法调用该方法，这不仅是因为我们没有一个具有此方法的公共父接口，还因为供应商恰好为其方法使用了不同的名称。

在这种情况下我们能做什么？从业务角度来看，要求所有供应商重写他们的检查表是不可能的，因为他们知道我们有麻烦，这会给任务贴上沉重的价格标签。我们的管理者希望避免这一成本，我们开发人员也希望证明我们能够改变现状，创造奇迹。（稍后，我将对此发表评论。）

我们可以有一个类，它知道每个检查器以及如何以多种不同的方式调用它们。这将要求我们在系统中引入新检查器时维护上述类，我们希望避免这种情况。我们正在使用的整个插件架构最初就是为了这个目的而发明的。

如果我们知道一个对象只有一个声明的方法，并且该方法接受一个命令作为参数，那么我们如何对该对象调用一个方法呢？这就是反射进入画面的地方。我们没有调用`checker.isInconsistent(order)`，而是实现了一个小的`private`方法`isInconsistent`，它通过反射调用该方法，无论其名称如何：

```
private boolean isInconsistent(ConsistencyChecker checker, Order order) { 
    Method[] methods = checker.getClass().getDeclaredMethods(); 
    if (methods.length != 1) { 
        log.error( 
                "The checker {} has zero or more than one methods", 
                checker.getClass()); 
        return false; 
    } 
    final Method method = methods[0]; 
    final boolean inconsistent; 
    try { 
        inconsistent = (boolean) method.invoke(checker, order); 
    } catch (InvocationTargetException | 
            IllegalAccessException | 
            ClassCastException e) { 
        log.error("Calling the method {} on class {} threw exception", 
                method, checker.getClass()); 
        log.error("The exception is ", e); 
        return false; 
    } 
    return inconsistent; 
}

```

我们可以通过调用`getClass`方法得到对象的类，对于表示类本身的对象，我们可以调用`getDeclaredMethods`。幸运的是，checker 类没有被许多方法弄乱，因此我们检查 checker 类中是否只声明了一个方法。请注意，反射库中还有一个`getMethods`方法，但它总是返回多个方法。它返回声明的方法和继承的方法。因为每个类都继承自`java.lang.Object`，所以至少会有`Object`类的方法。

之后，我们尝试使用表示反射类中的方法的`Method`对象调用该类。请注意，这个`Method`对象并没有直接连接到实例。我们从类中检索该方法，因此，当我们调用它时，应该将它应该处理的对象作为第一个参数传递。这样，`x.y(z)`就变成了`method.invoke(x,z)`。invoke 的最后一个参数是作为`Object`数组传递的可变数量的参数。在大多数情况下，当我们调用一个方法时，我们知道代码中的参数，即使我们不知道方法的名称并且必须使用反射。如果连参数都不知道，但作为计算的一个问题是可用的，那么我们必须将它们作为一个`Object`数组传递。

通过反射调用方法是一种危险的调用。如果我们尝试以正常方式调用方法，即`private`，那么编译器将发出错误信号。如果参数或类型的数量不合适，编译器将再次给我们一个错误。如果返回值不是`boolean`，或者根本没有返回值，那么我们再次得到一个编译器错误。在反射的情况下，编译器是无知的。它不知道在代码执行时我们将调用什么方法。另一方面，`invoke`方法在被调用时可以并将注意到所有这些失败。如果出现上述任何问题，那么我们将得到异常。如果`invoke`方法本身发现它无法执行我们对它的要求，那么它将抛出`InvocationTargetException`或`IllegalAccessException`。如果无法将实际返回值转换为`boolean`，则我们将得到`ClassCastException`。

关于做魔术，这是一种自然的冲动，我们想做一些不同寻常的事情，一些杰出的事情。当我们在做一些实验，做一些爱好工作时，这是可以的。另一方面，当我们从事专业工作时，这是非常不好的。普通程序员不理解您的优秀解决方案，他们会在企业环境中维护代码。他们将把你精心梳理的代码变成草堆，同时修复一些 bug 或实现一些小的新特性。即使你是编程界的莫扎特，他们充其量也只是无名歌手。企业环境中的优秀代码可以是安魂曲，包含了这个比喻的所有含义。

最后但并非最不重要的是，可悲的现实是，我们通常不是编程的莫扎特。

请注意，如果原始值的返回值是基元，那么它将通过反射转换为对象，然后我们将其转换回基元值。如果该方法没有返回值，换句话说，如果它是`void`，那么反射将返回一个`java.lang.Void`对象。`Void`对象只是一个占位符。我们不能将其转换为任何基本值或任何其他类型的对象。它是必需的，因为 Java 是严格的，`invoke`必须返回一个`Object`，所以运行时需要它可以返回的东西。我们所能做的就是检查返回值类是否真的是`Void`。

让我们继续讲故事情节和解决方案。我们提交了代码，它在生产中运行了一段时间，直到软件供应商的新更新打破它。我们在测试环境中调试代码，发现该类现在包含多个方法。我们的文档清楚地表明，他们应该只有一个`public`方法，并且他们提供了一个代码，该代码具有……嗯……我们意识到其他方法是`private`。他们是对的；根据合同，他们可以有`private`方法，所以我们必须修改代码。我们替换查找唯一方法的行：

```
Method[] methods = checker.getClass().getDeclaredMethods(); 
if (methods.length != 1) { 
... 
} 
final Method method = methods[0];

```

新守则如下：

```
final Method method = getSingleDeclaredPublicMethod(checker); 
if (method == null) { 
    log.error( 
            "The checker {} has zero or more than one methods", 
            checker.getClass()); 
    return false; 

}

```

我们编写的新方法用于查找唯一的`public`方法，如下所示：

```
private Method getSingleDeclaredPublicMethod( 
                           ConsistencyChecker checker) { 
    final Method[] methods = 
        checker.getClass().getDeclaredMethods(); 
    Method singleMethod = null; 
    for (Method method : methods) { 
        if (Modifier.isPublic(method.getModifiers())) { 
            if (singleMethod != null) { 
                return null; 
            } 
            singleMethod = method; 
        } 
    } 
    return singleMethod; 
}

```

为了检查方法是否为`public`，我们使用`Modifier`类中的`static`方法。有一些方法可以检查所有可能的修改器。`getModifiers`方法返回的值是`int`位字段。不同的位具有不同的修饰符，并且存在定义这些修饰符的常量。这种简化会导致不一致性，您可以检查方法是接口还是易失性，也就是说，实际上是无意义的。事实上，永远不会设置只能用于其他类型反射对象的位。

有一个例外，就是`volatile`。该位被重新用于信号桥接方法。桥接方法是由编译器自动创建的，可能会有我们在本书中没有讨论的深层次和复杂的问题。重复使用同一位不会造成混淆，因为字段可以是`volatile`，但作为字段，它不能是桥接方法。显然，字段是字段而不是方法。同样，方法不能是`volatile`字段。一般规则是：不要在反射对象上使用没有意义的方法；或者，你知道你在做什么。

让故事情节更加复杂的是，新版检查器意外地将检查方法作为一个包`private`实现。程序员只是忘记了使用`public`关键字。为了简单起见，让我们假设类再次只声明一个方法，但它不是公共的。我们如何使用反射来解决这个问题？

显然，最简单的解决方案是要求供应商解决问题：这是他们的错。然而，在某些情况下，我们必须针对某些问题创建一个解决方案。还有另一种解决方案：在同一个包中创建一个带有`public`方法的类，从另一个类调用包`private`方法，从而中继另一个类。事实上，这个解决方案，作为这样一个 bug 的解决方案，似乎更符合逻辑，更清晰，但这次，我们希望使用反射。

为了避免`java.lang.IllegalAccessException`，我们必须将`method`对象设置为可访问。为此，我们必须在调用前插入以下行：

```
method.setAccessible(true);

```

请注意，这不会将方法更改为`public`。它只会通过我们设置为可访问的`method`对象的实例来访问调用的方法。

我见过通过调用`isAccessible`方法检查方法是否可访问并保存此信息的代码；如果方法不可访问，它将该方法设置为可访问，并在调用后恢复原始可访问性。这完全没有用。一旦`method`变量超出范围，并且没有对我们设置可访问性标志的对象的引用，设置的效果就会消失。此外，设置`public`或其他可调用方法的可访问性也不会受到惩罚。

# 设置字段

我们还可以在`Field`对象上调用`setAccessible`，然后我们甚至可以使用反射设置私有字段的值。没有更多的虚假故事，为了示例，让我们制作一个名为`SettableChecker`的`ConsistencyChecker`：

```
@Component 
@PoweredDevice 
public class SettableChecker implements ConsistencyChecker { 
    private static final Logger log = LoggerFactory.getLogger(SettableChecker.class); 

    private boolean setValue = false; 

    public boolean isInconsistent(Order order) { 
        return setValue; 
    } 
}

```

此检查器将返回`false`，除非我们使用反射将字段设置为`true`。我们确实是这样设定的。我们在`Checker`类中创建一个方法，并从每个检查器的检查过程中调用它：

```
private void setValueInChecker(ConsistencyChecker checker) { 
    Field[] fields = checker.getClass().getDeclaredFields(); 
    for( final Field field : fields ){ 
        if( field.getName().equals("setValue") && 
            field.getType().equals(boolean.class)){ 
            field.setAccessible(true); 
            try { 
                log.info("Setting field to true"); 
                field.set(checker,true); 
            } catch (IllegalAccessException e) { 
                log.error("SNAFU",e); 
            } 
        } 
    } 
}

```

该方法遍历所有声明的字段，如果名称为`setValue`，类型为`boolean`，则将其设置为`true`。这将实质上导致包含通电设备的所有订单被拒绝。

请注意，尽管`boolean`是一个内置的语言原语，它无论如何都不是一个类，但它仍然有一个类，以便反射可以将字段的类型与`boolean`人工拥有的类进行比较。现在，`boolean.class`是语言中的一个类文本，对于每个原语，可以使用一个类似的常量。编译器将其识别为类文本，并在字节码中创建适当的伪类引用，以便也可以通过这种方式检查原语，如`setValueInChecker`方法的示例代码所示。

我们检查了该字段是否具有适当的类型，并在该字段上调用了`setAccessible`方法。尽管编译器不知道我们确实尽了一切努力来避免`IllegalAccessException`，但它仍然相信，调用`field`上的`set`会抛出这样一个异常，正如它所声明的那样。然而，我们知道这不应该发生。（著名的程序员遗言？）为了处理这种情况，我们用一个`try`块围绕方法调用，并在`catch`分支中记录异常。

# Java 中的函数式编程

由于我们在本章的示例中创建了大量代码，我们将研究 Java 的函数式编程特性，这将帮助我们从代码中删除许多行。我们拥有的代码越少，维护应用程序就越容易；因此，程序员喜欢函数式编程。但这并不是函数式编程如此流行的唯一原因。它也是一种很好的方法，可以用比传统循环更可读、更不容易出错的方式来描述某些算法。

函数式编程不是什么新鲜事。数学背景是在 20 世纪 30 年代发展起来的。LISP 是最早（如果不是最早）的函数式编程语言之一。它是在 20 世纪 50 年代开发的，现在仍在使用，以至于有一个版本的语言在 JVM 上实现（Clojure）。

简言之，函数式编程意味着我们用函数来表达程序结构。从这个意义上说，我们应该把函数看作是数学中的函数，而不是像 C 这样的编程语言中使用的术语。在 Java 中，我们有方法，当我们遵循函数编程范式时，我们创建并使用行为类似于数学函数的方法。如果一个方法无论调用多少次都给出相同的结果，那么它就是函数式的，就像*sin（0）*总是零一样。函数式编程避免改变对象的状态，因为状态没有改变，所以结果总是一样的。这也简化了调试。

如果函数曾经为给定的参数返回了某个值，它将始终返回相同的值。我们还可以将代码作为计算声明来读取，而不是作为一个接一个执行的命令来读取。如果执行顺序不重要，那么代码的可读性也会增加。

Java 通过 lambda 表达式和流帮助实现函数式编程风格。请注意，这些流不是 I/O 流，实际上与这些流没有任何关系。

我们将首先简要介绍 lambda 表达式以及流是什么，然后，我们将转换程序的一些部分以使用这些编程结构。我们还将看到这些代码的可读性有多高。

可读性是一个有争议的话题。代码可能对一个开发人员可读，而对另一个开发人员可读性较差。这在很大程度上取决于他们习惯了什么。我经历过很多次开发人员因为流而分心。当开发人员第一次遇到流时，思考它们的方式和它们的外观都很奇怪。但这与开始学习使用自行车是一样的。当你还在学习它的用法时，你摔倒的比翻滚的多，它肯定比走路慢。另一方面，一旦你学会了骑自行车。。。

# 兰姆达

在编写异常抛出测试时，我们已经在[第 3 章](03.html)中使用了 lambda 表达式，*优化了排序代码专业人员*。在该代码中，我们将比较器设置为在每次调用时抛出`RuntimeException`的特殊值：

```

        throw new RuntimeException(); 
    });

```

参数类型为`Comparator`；因此，我们必须在那里设置一个实现`java.util.Comparator`接口的类的实例。该接口只定义了一个实现必须定义的方法：`compare.`因此，我们可以将其定义为 lambda 表达式。如果没有 lambda，如果我们需要一个实例，我们必须输入很多。我们必须创建一个类，命名它，在其中声明`compare`方法，并编写方法体，如下面的代码段所示：

```
public class ExceptionThrowingComparator implements Comparator { 
  public int compare(T o1, T o2){ 
    throw new RuntimeException(); 
  } 
}

```

在使用位置，我们应该实例化该类并将其作为参数传递：

```
sort.setComparator(new ExceptionThrowingComparator());

```

如果我们将类定义为匿名类，则可以节省一些字符，但开销仍然存在。我们真正需要的是我们必须定义的单一方法的主体。这就是 lambda 出现的地方。

我们可以在任何需要一个只定义一个方法的类实例的地方使用 lambda 表达式。从`Object`定义和继承的方法不计算在内，我们也不关心接口中定义为`default`方法的方法。他们在那里。Lambda 定义了一个尚未定义的。换句话说，lambda 清楚地描述了这个值是一个作为参数传递的功能，而匿名类的开销要小得多。

lambda 表达式的简单形式如下所示：

```
parameters -> body

```

参数可以用括号括起来，也可以不带括号。正文同样可以包含在`{`和`}`字符之间，也可以是一个简单的表达式。通过这种方式，lambda 表达式可以将开销降至最低，只在真正需要的地方使用括号。

lambda 表达式的另一个非常有用的特性是，我们不需要指定参数的类型，以防从我们使用表达式的上下文中显而易见。因此，前面的代码段甚至可以更短，如下所示：

```
sort.setComparator((a, b) -> { 
    throw new RuntimeException(); 
});

```

参数`a`和`b`将具有所需的类型。为了更简单，我们还可以省略参数周围的`(`和`)`字符，以防只有一个。

如果有多个参数，则括号不是可选的。这是为了避免在某些情况下出现歧义。例如，方法调用`f(x,y->x+y)`可能是一个具有两个参数的方法：`x`和一个具有一个参数`y`的 lambda 表达式。同时，它也可以是具有 lambda 表达式的方法调用，该表达式有两个参数，`x`和`y`。

当我们想将函数作为参数传递时，Lambda 表达式非常方便。方法声明处参数类型的声明应该是函数接口类型。可以选择使用`@FunctionalInterface`对这些接口进行注释。Java 运行时在`java.util.function`包中定义了许多这样的接口。我们将在下一节中讨论其中一些，以及它们在流中的使用。对于其余部分，标准 Java 文档可从 Oracle 获得。

# 溪流

流在 Java8 中也是新的，就像 lambda 表达式一样。他们在一起工作得非常紧密，所以他们同时出现并不令人惊讶。Lambda 表达式和流支持函数式编程风格。

首先要澄清的是，流与输入和输出流没有任何关系，除了名称。它们是完全不同的东西。流更像是集合，有一些显著的差异。（如果没有区别，它们只是集合。）流本质上是可以顺序或并行运行的操作管道。他们从收集或其他来源获取数据，包括动态制造的数据。

流支持对多个数据执行相同的计算。此结构称为**单指令多数据**（**单指令多数据**。不要害怕这个表达。这是一件非常简单的事情。在这本书中，我们已经做了很多次了。循环也是一种 SIMD 结构。当我们循环检查 checker 类以查看这些类是否与顺序相反时，我们对每个 checker 执行相同的指令。多个 checker 是多个数据。

循环的一个问题是，我们定义了不需要的执行顺序。对于跳棋，我们并不真正关心跳棋的执行顺序。我们关心的是，所有人都同意订单。在编程循环时，我们仍然指定一些顺序。这来自循环的本质，我们无法改变这一点。这就是他们的工作方式。然而，如果我们能以某种方式说*“为每个检查者做这个和那个”*，那就太好了。这是一个流进入画面的点。

另一点是，使用循环的代码更具强制性，而不是描述性。当我们阅读循环构造的程序时，我们将重点放在各个步骤上。我们首先看到循环中的命令的作用。这些命令作用于数据的各个元素，而不是整个集合或数组。

后来，在我们的大脑中把各个步骤放在一起，我们意识到大画面是什么，循环是为了什么。在流的情况下，操作的描述更高一级。一旦我们学习了流方法，就更容易阅读了。流方法处理整个流，而不是单个元素，因此更具描述性。

`java.lang.Stream`是一个接口。具有实现此接口的类型的对象表示许多对象，并提供可用于对这些对象执行指令的方法。当我们在其中一个对象上启动操作时，这些对象可能不可用，也可能不可用，或者只在需要时创建。这取决于`Stream`接口的实际实现。例如，假设我们使用以下代码生成一个包含`int`值的流：

```
IntStream.iterate( 0, (s) -> s+1 )

```

在前面的代码段中，无法生成所有元素，因为流包含无限多的元素。此示例将返回数字 0、1、2 等，直到进一步的流操作（此处未列出）终止计算。

当我们编程`Stream`时，我们通常从`Collection`创建一个流—不总是，但会多次创建。在 Java8 中扩展了`Collection`接口，以提供`stream`和`parallelStream`方法。它们都返回表示集合元素的流对象。当`stream`以自然顺序返回集合中的元素时，`parallelStream`创建了一个可以并行处理的流。在这种情况下，如果我们在流上使用的某些方法是以这种方式实现的，那么代码可以使用计算机中可用的多个处理器。

一旦我们有了一个流，我们就可以使用`Stream`接口定义的方法。首先是`forEach`。此方法有一个参数，通常作为 lambda 表达式提供，并将为流的每个元素执行 lambda 表达式。

在`Checker`类中，我们有`isConsistent`方法。在这个方法中，有一个循环遍历 checker 类的注释。如果要记录循环中注释实现的接口，可以添加以下内容：

```
for (ConsistencyChecker checker :checkers) { 
  for (Annotation annotation : 
checker.getClass().getAnnotations()) { 
Arrays.stream(annotation.getClass().getInterfaces()) 
.forEach( 
t ->log.info("annotation implemented interfaces {}",t) 
); 
...

```

在本例中，我们使用`Arrays`类中的工厂方法从数组创建流。数组包含反射方法`getInterfaces`返回的接口。lambda 表达式只有一个参数；因此，我们不需要在其周围使用括号。表达式的主体是一个不返回值的方法调用；因此，我们也省略了`{`和`}`字符。

为什么这么麻烦？好处是什么？为什么我们不能编写一个简单的循环来记录数组的元素？
增加了可读性和可维护性。当我们创建一个程序时，我们必须关注*程序应该做什么*而不是*程序应该如何做。在理想情况下，规范只是可执行的。当编程工作被人工智能所取代时，我们可能会在未来实现这一目标。（虽然不是程序员）我们还没有到那里。我们必须告诉计算机如何做我们想做的事情。我们过去必须在 PDP-11 的控制台上输入二进制代码，以便将机器代码部署到内存中执行。后来，我们有了汇编程序；后来，我们有了 FORTRAN 和其他高级编程语言，它们取代了 40 年前的大部分编程工作。所有这些编程方面的发展都将方向从*如何*转向*什么*。今天，我们使用 Java9 编程，这条路还有很长的路要走。
我们越能表达要做什么而不是如何做，我们的节目就会越短，越容易理解。它将包含精华，而不是机器所需的人工垃圾，以满足我们的需要。
当我在我必须维护的代码中看到一个循环时，我假设循环的执行顺序有一定的重要性。可能根本不重要。几秒钟后可能很明显。可能需要几分钟或更长时间才能意识到订购并不重要。这段时间是浪费的，可以通过更好地表达*要做什么*部分而不是*如何做*的编程结构来节省时间。*

# 功能接口

该方法的参数应为`java.util.function.Consumer`。这是一个需要定义`accept`方法的接口，此方法为`void`。实现此接口的 lambda 表达式或类将*使用*方法的参数，并且不会产生任何结果。

该包中还定义了几个其他接口，每个接口都用作函数接口，用于描述一些方法参数，这些参数可以在实际参数中作为 lambda 表达式给出。

例如，`Consumer`的对立面是`Supplier`。此接口有一个名为`get`的方法，该方法不需要任何参数，但提供一些`Object`作为返回值。

如果有参数和返回值，则调用接口`Function`。如果返回的值必须与参数的类型相同，那么`UnaryOperator`接口就是我们的朋友。类似地，还有一个`BinaryOperator`接口，它返回一个与参数类型相同的对象。正如我们从`Function`到`UnaryOperator`一样，我们可以看到在另一个方向上，如果参数和返回值不共享类型，也会有`BiFunction`。

这些接口不是相互独立定义的。如果一个方法需要`Function`并且我们必须通过`UnaryOperator`，那么这应该不是问题。`UnaryOperator`只是具有相同类型参数的`Function`。一个可以使用`Function`的方法，它接受一个对象并返回一个对象，如果它们具有相同的类型，应该不会有问题。这些可以不同，但不一定不同。
为了实现这一点，`UnaryOperator`接口扩展了`Function`，因此可以代替`Function`使用。

到目前为止，我们在这个类中遇到的接口是使用泛型定义的。因为泛型类型不能是基元，所以对基元值进行操作的接口应该单独定义。例如，`Predicate`是定义`booleantest(T t)`的接口。它是一个返回`boolean`值的函数，在流方法中被多次使用。

还有一些接口，如`BooleanSupplier`、`DoubleConsumer`、`DoubleToIntFunction`等，可以与原语`boolean`、`double`和`int`一起使用。不同参数类型和返回值的可能组合的数量是无限的。。。几乎

**Fun fact**: To be very precise, it is not infinite. A method can have at most 254 arguments. This limit is specified in the JVM and not in the Java language specification. Of course, one is useless without the other. There are 8 primitive types (plus `Object`, plus the possibility that there are less than 254 arguments), which means that the total number of possible functional interfaces is 10<sup class="calibre31">254</sup>, give or take, a few magnitudes. Practically, infinite!

我们不应该期望在这个包的 JDK 中定义所有可能的接口。这些只是最有用的接口。例如，没有使用`short`或`char`的接口。如果我们需要类似的东西，那么我们可以在代码中定义`interface`。或者只是仔细想想，看看如何使用一个已经定义好的。（在我的职业航母中，我从未使用过`short`型航母。它从未被需要过。）

这些功能接口是如何在流中使用的？`Stream`接口定义了一些函数接口类型作为参数的方法。例如，`allMatch`方法有一个`Predicate`参数并返回一个`Boolean`值，如果流中的所有元素都匹配`Predicate`，则返回`true`。换句话说，此方法返回`true`当且仅当作为参数提供的`Predicate`为流的每个元素返回`true`时。

在下面的代码中，我们将重写我们在示例代码中使用循环来使用流实现的一些方法，通过这些示例，我们将讨论流提供的最重要的方法。我们保存了两个类，和`ProductInformationCollector`来演示流的使用情况。我们可以从这些开始。`ProductsCheckerCollector`遍历`Order`中包含的所有产品，并收集产品中列出的注释。每个产品可能包含零个、一个或多个注释。这些可以在列表中找到。同一注释可以多次引用。为了避免重复，我们使用`HashSet`，即使产品中有多个实例，它也只包含元素的一个实例：

```
public class ProductsCheckerCollector { 

    private final ProductInformationCollector pic; 
    public ProductsCheckerCollector(@Autowired 
      ProductInformationCollector pic) { this.pic = pic; } 

    public Set<Class<? extends Annotation>> 
                       getProductAnnotations(Order order) { 
        Map<OrderItem, ProductInformation> piMap = 
                          pic.collectProductInformation(order); 
        final Set<Class<? extends Annotation>> 
                            annotations = new HashSet<>(); 
        for (OrderItem item : order.getItems()) { 
            final ProductInformation pi = piMap.get(item); 
            if (pi != null && pi.getCheck() != null) { 
                for (Class<? extends Annotation> check : 
                                              pi.getCheck()) { 
                    annotations.addAll(pi.getCheck()); 
                } 
        } 
        return annotations; 
    } 
}

```

现在，让我们看看当我们使用 streams 对该方法重新编码时该方法的外观：

```
public Set<Class<? extends Annotation>> 
                getProductAnnotations(Order order) { 
    Map<OrderItem, ProductInformation> piMap = 
                      pic.collectProductInformation(order); 

    return order.getItems().stream() 
            .map(piMap::get) 
            .filter(Objects::nonNull) 
            .peek(pi -> { 
                if (pi.getCheck() == null) { 
                    log.info("Product {} has no annotation", 
                                                  pi.getId()); 
                } 
            }) 
            .filter(pi -> pi.getCheck() != null) 
            .peek(pi -> log.info("Product {} is annotated with class {}", pi.getId(), pi.getCheck())) 
            .flatMap(pi -> pi.getCheck().stream()) 
            .collect(Collectors.toSet()); 
}

```

该方法的主要工作是生成一个单一但庞大的流表达式。我们将在接下来的几页中介绍表达式的元素。`order.getItems`返回的`List`被转换为调用`stream`方法：

```
returnorder.getItems().stream()

```

正如我们已经简要提到的，`stream`方法是`Collection`接口的一部分。任何实现`Collection`接口的类都将具有此方法，即使是在 Java8 中引入 streams 之前实现的类。这是因为`stream`方法在接口中作为`default`方法实现。这样，如果我们碰巧实现了一个实现这个接口的类，即使我们不需要流，我们也可以免费获得它。

Java8 中引入了`default`方法来支持接口的向后兼容性。JDK 的一些接口将被修改以支持 lambda 和函数式编程。一个例子是`stream`方法。使用 Java8 之前的特性集，实现一些修改过的接口的类应该已经修改过了。他们将被要求实施新方法。这样的变化是不向后兼容的，Java 作为一种语言和 JDK 非常关注向后兼容。因此，引入了`default`方法。这些方法允许开发人员扩展接口，并且仍然保持接口向后兼容，为新方法提供了默认实现。
与此相反，Java 8 JDK 全新的功能接口也有`default`方法，尽管 JDK 中没有以前的版本，它们也没有什么可兼容的。在 Java9 中，接口也被扩展，现在它们不仅可以包含`default`和`static`方法，还可以包含`private`方法。这样，接口就相当于抽象类，尽管接口中除了常量`static`字段之外没有字段。这种接口功能的开放性是一个备受批评的特性，它只是提出了允许多类继承的其他语言所面临的编程风格和结构问题。Java 在 Java8 和 Java9 之前一直在避免这种情况。
这有什么好处？注意接口中的`default`方法和`private`方法。如果有的话，明智地使用它们。

这个流的元素是`OrderItem`对象。我们每个`OrderItem`都需要`ProductInformation`。

# 方法引用

幸运的是我们有`Map`，它将订单项目与产品信息配对，因此我们可以在`Map`上调用`get`：

```
.map(piMap::get)

```

`map`方法与 Java 中的其他方法同名，不应混淆。当`Map`类是数据结构时，`Stream`接口中的`map`方法执行流元素的映射。该方法的参数是一个`Function`（回想一下，这是我们最近讨论的一个功能接口）。此函数将作为原始流（`Stream<T>`的元素可用的值`T`转换为值`R`，并且`map`方法的返回值为`Stream<R>`。`map`方法使用给定的`Function<T,R>`将`Stream<T>`转换为`Stream<R>`，为原始流的每个元素调用它，并从转换后的元素创建一个新流。

我们可以说，`Map`接口以静态方式将键映射到数据结构中的值，`Stream`方法`map`动态地将一种类型的值映射到另一种（或相同）类型的值。

我们已经看到，我们可以以 lambda 表达式的形式提供函数接口的实例。此参数不是 lambda 表达式。这是一个方法参考。它说`map`方法应该调用`Map piMap`上的`get`方法，使用实际的流元素作为参数。我们很幸运`get`也需要一个论点，不是吗？我们也可以这样写：

```
.map( orderItem ->piMap.get(orderItem))

```

然而，这与`piMap::get`完全相同。

通过这种方式，我们可以引用在特定实例上工作的实例方法。在我们的示例中，实例是由`piMap`变量引用的实例。也可以参考`static`方法。在这种情况下，类的名称应该写在`::`字符前面。当我们使用`Objects`类中的`static`方法`nonNull`时，我们很快就会看到一个例子（请注意，类名是复数的，它在`java.util`包中，而不是`java.lang`）。

也可以引用实例方法，而无需给出调用实例方法的引用。这可以在函数接口方法具有额外的第一个参数（将用作实例）的地方使用。我们已经在[第 3 章](03.html)*优化排序代码专业*中使用过，当我们通过`String::compareTo`时，当预期参数为`Comparator`时。`compareTo`方法需要一个参数，`Comparator`接口中的`compare`方法需要两个参数。在这种情况下，第一个参数将用作必须调用`compare`的实例，第二个参数将传递给`compare`。在本例中，`String::compareTo`与编写 lambda 表达式`(String a, String b) -> a.compareTo(b)`相同。

最后但并非最不重要的一点是，我们可以使用构造函数的方法引用。当我们需要`Supplier`的`Object`时，我们可以写`Object::new`。

下一步是从流中过滤出`null`元素。请注意，此时，流具有`ProductInformation`元素：

```
.filter(Objects::nonNull)

```

`filter`方法使用`Predicate`并创建一个只包含与谓词匹配的元素的流。在本例中，我们使用了对`static`方法的引用。`filter`方法不会改变流的类型。它只过滤掉元素。

我们采用的下一种方法有点反功能。纯函数流方法不会改变任何对象的状态。它们创建返回的新对象，但除此之外，没有任何副作用。`peek`本身没有什么不同，因为它只返回与应用它的元素相同的元素流。然而，这一*无操作*特性诱使新手程序员做一些非功能性的事情，并编写带有副作用的代码。毕竟，如果调用它没有副作用，为什么要使用它呢？

```
.peek(pi -> { 
    if (pi.getCheck() == null) { 
        log.info("Product {} has no annotation", pi.getId()); 
    } 
})

```

虽然`peek`方法本身没有任何副作用，但 lambda 表达式的执行可能会产生副作用。然而，对于任何其他方法，这也是正确的。事实上，在这种情况下，做一些不充分的事情更具诱惑力。不要。我们是有纪律的成年人。正如该方法的名称所示，我们可以窥视流，但我们不应该做任何其他事情。由于编程是一项特殊的活动，在这种情况下，偷看就足够了。这就是我们在代码中实际做的：我们记录一些东西。

在此之后，我们去掉了没有`ProductInformation`的元素；我们还希望删除已定义的元素，但没有定义检查器：

```
.filter(pi ->pi.getCheck() != null)

```

在这种情况下，我们不能使用方法引用。相反，我们使用 lambda 表达式。作为替代方案，我们可以在`ProductInformation`中创建`boolean hasCheck`方法，如果`private`字段检查不是`null`，则返回`true`。这将改为：

```
.filter(ProductInformation::hasCheck)

```

虽然该类没有实现任何函数接口，并且有许多方法，而不仅仅是这个方法，但这是完全有效的，并且可以工作。但是，方法引用是显式的，并指定要调用的方法。

在第二个过滤器之后，我们再次记录元素：

```
.peek(pi -> log.info( 
     "Product {} is annotated with class {}", pi.getId(), 
                                            pi.getCheck()))

```

下一种方法是`flatMap`，这是一种特殊且不容易理解的方法。至少对我来说，当我学习函数式编程时，理解`map`和`filter`有点困难：

```
.flatMap(pi ->pi.getCheck().stream())

```

该方法期望 lambda、方法引用或作为参数传递给它的任何内容为调用该方法的原始流的每个元素创建一个全新的对象流。然而，结果不是流的流（这也是可能的），而是返回的流被连接成一个巨大的流。

如果我们应用它的流是一个整数流，例如 1、2、3，…，并且每个数字的函数*n*返回一个由三个元素组成的流*n*、*n+1*和*n+2*，则生成的流`flatMap`生成一个包含 1、2、3、2、3、4、4、4、5、5、，6，等等。

最后，我们拥有的流应该被收集到一个`Set`。这是通过调用`collector`方法完成的：

```
.collect(Collectors.toSet());

```

`collector`方法的参数是（又是一个名称过度使用）`Collector`。它可以用于将流的元素收集到某个集合中。注意，`Collector`不是功能接口。您不能仅使用 lambda 或简单的方法收集某些内容。为了收集元素，我们肯定需要一些地方来收集元素，因为不断更新的元素来自流。`Collector`接口并不简单。幸运的是，`java.util.streams.Collectors`类（再次注意复数形式）有许多`static`方法创建并返回`Object`，这些方法创建并返回`Collector`对象。

其中一个是`toSet`，它返回一个`Collector`，帮助将流中的元素收集到`Set`中。当所有元素都存在时，`collect`方法将返回`Set`。还有其他方法可以帮助收集流元素，方法是将元素相加，计算平均值，或将其转换为`List`、`Collection`或`Map`。将元素收集到`Map`是一件特殊的事情，因为`Map`的每个元素实际上都是一个键值对。当我们看`ProductInformationCollector`时，我们将看到这个例子。

`collectProductInformation`方法，我们将从`Checker`类和`ProductsCheckerCollector`类中使用该方法：

```
private Map<OrderItem, ProductInformation> map = null; 

public Map<OrderItem, ProductInformation>  
                  collectProductInformation(Order order) { 
    if (map == null) { 
        map = new HashMap<>(); 
        for (OrderItem item : order.getItems()) { 
            final ProductInformation pi = 
                     lookup.byId(item.getProductId()); 
            if (!pi.isValid()) { 
                map = null; 
                return null; 
            } 
            map.put(item, pi); 
        } 
    } 
    return map; 
}

```

简单的技巧是将收集到的值存储在`Map`中，如果该值不是`null`，则只返回已经计算的值，如果在处理同一 HTTP 请求时多次调用此方法，可能会节省大量服务调用。

有两种方法可以对这种结构进行编码。一个是检查`Map`的非空性，如果`Map`已经存在，则返回。此模式被广泛使用，并有一个名称。如果，则称为防护*。在这种情况下，方法中有多个 return 语句，这可能被视为一个弱点或反模式。另一方面，该方法的列表较浅。这是一个味觉的问题，如果你发现自己处于一个关于另一个解决方案的辩论中，那就帮自己一个忙，让你的同伴在这个话题上胜出，为你更重要的问题节省你的精力，例如，你应该使用流还是简单的旧循环。*

现在，让我们看看如何将此解决方案转换为功能样式：

```
public Map<OrderItem, ProductInformation> collectProductInformation(Order order) { 
    if (map == null) { 
        map = 
        order.getItems() 
                .stream() 
                .map(item -> tuple(item, item.getProductId())) 
                .map(t -> tuple(t.r, lookup.byId((String) t.s))) 
                .filter(t -> ((ProductInformation)t.s).isValid()) 
                .collect( 
                    Collectors.toMap( t -> (OrderItem)t.r, 
                                      t -> (ProductInformation)t.s 
                                    ) 
                ); 
        if (map.keySet().size() != order.getItems().size()) { 
            log.error("Some of the products in the order do not have product information, {} != {} ",map.keySet().size(),order.getItems().size()); 
            map = null; 
        } 
    } 
    return map; 
}

```

我们使用一个 helper 类`Tuple`，它只不过是两个名为`r`和`s`的`Object`实例。稍后我们将列出这个类的代码。这很简单。

在 streams 表达式中，我们首先从集合中创建流，然后将`OrderItem`元素映射到`OrderItem`和`productId`元组的流。然后我们将这些元组映射到现在包含`OrderItem`和`ProductInformation`的元组。这两个映射可以在一个映射调用中完成，这将只在一个映射调用中执行这两个步骤。我决定创建这两个代码，以便在每行中都有更简单的步骤，但徒劳地希望生成的代码更容易理解。

过滤步骤也不是什么新鲜事。它只是过滤掉无效的产品信息元素。实际上应该没有。如果订单包含不存在产品的订单 ID，则会发生这种情况。在下一个语句中，当我们查看收集的产品信息元素的数量以确定所有项目都具有适当的信息时，会检查这一点。

有趣的代码是我们如何将流的元素收集到一个`Map`中。为此，我们再次使用`collect`方法和`Collectors`类。这一次，`toMap`方法创建`Collector`。这需要两个`Function`结果表达式。第一个应将流的元素转换为键，第二个应生成要在`Map`中使用的值。因为键和值的实际类型是根据传递的 lambda 表达式的结果计算的，所以我们必须显式地将元组的字段转换为所需的类型。

最后，简单的`Tuple`类如下：

```
public class Tuple<R, S> { 
    final public R r; 
    final public S s; 

    private Tuple(R r, S s) { 
        this.r = r; 
        this.s = s; 
    } 

    public static <R, S> Tuple tuple(R r, S s) { 
        return new Tuple<>(r, s); 
    } 
}

```

我们的代码中仍然有一些类值得转换为函数式。这些是`Checker`和`CheckerHelper`类。

在`Checker`类中，我们可以重写`isConsistent`方法：

```
public boolean isConsistent(Order order) { 
    Map<OrderItem, ProductInformation> map = 
                  piCollector.collectProductInformation(order); 
    if (map == null) { return false; } 
    final Set<Class<? extends Annotation>> annotations = 
                       pcCollector.getProductAnnotations(order); 
    return !checkers.stream().anyMatch( 
                 checker -> Arrays.stream( 
                              checker.getClass().getAnnotations() 
                            ).filter( 
                              annotation -> 
                                annotations.contains( 
                                      annotation.annotationType()) 
                            ).anyMatch( 
                              x ->  
                                checker.isInconsistent(order) 
                            )); 
}

```

因为您已经学习了大多数重要的流方法，所以这里几乎没有什么新问题。我们可以提到`anyMatch`方法，如果至少有一个元素，则返回`true`，这样传递给`anyMatch`的`Predicate`参数就是`true`。它可能还需要一些空间，以便我们可以在另一条溪流中使用一条溪流。当一个流表达式过于复杂，需要使用局部变量将其拆分为更小的部分时，这很可能就是一个例子。

最后，在我们离开函数式风格之前，我们重写了`CheckHelper`类中的`containsOneOf`方法。这不包含新元素，将帮助您检查您对`map`、`filter`、`flatMap`和`Collector`的了解。请注意，正如我们所讨论的，如果`order`至少包含一个作为字符串给出的订单 ID，则此方法返回`true`：

```
public boolean containsOneOf(String... ids) { 
    return order.getItems().stream() 
            .map(OrderItem::getProductId) 
            .flatMap(itemId -> Arrays.stream(ids) 
                    .map(id -> tuple(itemId, id))) 
            .filter(t -> Objects.equals(t.s, t.r)) 
            .collect(Collectors.counting()) > 0; 
}

```

我们创建`OrderItem`对象流，然后将其映射到流中包含的产品 ID 流。然后，我们为每个 ID 创建另一个流，其中包含 ID 的元素和一个字符串 ID 作为参数。然后，我们将这些子流展平为一个流。此流将包含`order.getItems().size()`次`ids.length`元素：所有可能的对。我们将过滤掉那些包含相同 ID 的对两次，最后，我们将计算流中的元素数。

# 用 Java9 编写脚本

我们已经准备好了本章的示例程序。有一个问题，尽管它不专业。当我们有一个新产品需要一个新的检查器时，我们必须创建一个新的代码版本。

专业环境中的程序有版本。当修改代码、修复 bug 或实现新功能时，在应用程序投入生产之前，组织需要执行许多步骤。这些步骤构成了发布过程。有些环境具有轻量级的发布过程；另一些则需要严格而昂贵的检查。然而，这并不是因为组织中人员的品味。当一个不工作的生产代码的成本很低，并且不管程序中是否有中断或错误运行，那么发布过程可以很简单。这样，发布速度更快，成本更低。例如，用户可以使用一些聊天程序来取乐。在这种情况下，发布新的花哨特性可能比确保无 bug 工作更重要。在调色板的另一端，如果您创建控制原子能发电厂的代码，那么失败的成本可能相当高。对所有特性进行认真的测试和仔细的检查，即使是在最小的更改之后，也会有回报。

在我们的示例中，简单的检查可能是一个不太可能导致严重错误的区域。这不是不可能的，但是代码很简单……是的，我知道这样一个参数有点可疑，但是让我们假设这些小例程可以通过更少的测试以比代码的其他部分更简单的方式进行更改。那么，如何分离这些小脚本的代码，以便它们不需要技术版本、应用程序的新版本，甚至不需要重新启动应用程序？我们有一个新产品，需要一个新的检查，我们希望有一些方法将此检查注入到应用程序环境中，而不会造成任何服务中断。

我们选择的解决方案是脚本。Java 程序可以执行用*JavaScript*、*Groovy*、*Jython*（即语言*Python*的*JVM*版本）和许多其他语言编写的脚本。除了*JavaScript*之外，这些语言的语言解释器都不是 JDK 的一部分，但它们都提供了一个标准接口，这个接口在 JDK 中定义。结果是，我们可以在代码中实现脚本执行，提供脚本的开发人员可以自由选择任何可用的语言；我们不需要关心执行一个*JavaScript*代码。我们将使用与执行*Groovy*或*Jython*相同的 API。我们唯一应该知道的是脚本是用什么语言编写的。这通常很简单：我们可以从文件扩展名猜测，如果猜测不够，我们可以要求脚本开发人员将*JavaScript*放入扩展名为`.js`的文件中，*Jython*放入扩展名为`.jy`或`.py`的文件中，*Groovy*放入扩展名为`.groovy`的文件中，等等同样重要的是要注意，如果我们希望程序执行这些语言中的一种，我们应该确保解释器位于类路径上。在*JavaScript*的情况下，给出了该值；因此，作为本章的演示，我们将使用*JavaScript*编写脚本。不会有很多；这是一本 Java 书，而不是一本*JavaScript*书。

当我们希望通过编程方式配置或扩展应用程序时，脚本通常是一个不错的选择。这就是我们现在的情况。

我们要做的第一件事是扩展生产信息。如果存在检查产品订单一致性的脚本，我们需要一个字段，在该字段中可以指定脚本的名称：

```
    private String checkScript; 
    public String getCheckScript() { 
        return checkScript; 
    } 
    public void setCheckScript(String checkScript) { 
        this.checkScript = checkScript; 
    }

```

我们不希望为每个产品指定多个脚本；因此，我们不需要脚本名称列表。我们只有一个由名称指定的脚本。

老实说，checker 类和注释的数据结构太复杂了，允许每个产品和每个 checker 类都有多个注释。然而，我们无法避免的是，要有一个足够复杂的结构来展示流表达式的功能和能力。现在我们已经讨论了这个主题，我们可以继续使用更简单的数据结构，重点是脚本执行。

我们还必须修改`Checker`类，以便不仅使用 checker 类，还使用脚本。我们不能抛弃 checker 类，因为当我们意识到我们更需要脚本时，我们已经有了很多 checker 类，我们没有资金将它们重写为脚本。是的，我们在一本书中，而不是在现实生活中，但在一个企业中，情况就是这样。这就是为什么在为公司设计解决方案时要非常小心。结构和解决方案将在那里存在很长一段时间，仅仅因为它在技术上不是最好的，就不容易抛出一段代码。如果它能够工作并且已经存在，那么企业将极不愿意在代码维护和重构上花钱。

小结：我们修改了`Checker`类。我们需要一个可以执行脚本的新类；因此，修改了构造函数：

```
private final CheckerScriptExecutor executor; 

    public Checker( 
        @Autowired Collection<ConsistencyChecker> checkers, 
        @Autowired ProductInformationCollector piCollector, 
        @Autowired ProductsCheckerCollector pcCollector, 
        @Autowired CheckerScriptExecutor executor ) { 
        this.checkers = checkers; 
        this.piCollector = piCollector; 
        this.pcCollector = pcCollector; 
        this.executor = executor; 
    }

```

我们也必须在`isConsistent`方法`:`中使用此`executor`

```
public boolean isConsistent(Order order) { 
        final Map<OrderItem, ProductInformation> map = 
                piCollector.collectProductInformation(order); 
        if (map == null) { 
            return false; 
        } 
        final Set<Class<? extends Annotation>> annotations = 
                pcCollector.getProductAnnotations(order); 
        Predicate<Annotation> annotationIsNeeded = annotation -> 
                annotations.contains(annotation.annotationType()); 
        Predicate<ConsistencyChecker> productIsConsistent = 
                checker -> 
                Arrays.stream(checker.getClass().getAnnotations()) 
                        .parallel().unordered() 
                        .filter(annotationIsNeeded) 
                        .anyMatch( 
                             x -> checker.isInconsistent(order)); 
        final boolean checkersSayConsistent = !checkers.stream(). 
                anyMatch(productIsConsistent); 
        final boolean scriptsSayConsistent = 
                !map.values(). 
                        parallelStream(). 
                        map(ProductInformation::getCheckScript). 
                        filter(Objects::nonNull). 
                        anyMatch(s -> 
                           executor.notConsistent(s,order)); 
        return checkersSayConsistent && scriptsSayConsistent; 
    }

```

注意，在这段代码中，我们使用并行流，因为，为什么不呢？只要有可能，我们就可以使用并行流，即使是无序的，来告诉底层系统，也告诉维护代码的程序员顺序并不重要。

我们还通过一些注释修改了一个产品 JSON 文件，以引用脚本而不是 checker 类：

```
{ 
  "id" : "124", 
  "title": "Desk Lamp", 
  "checkScript" : "powered_device", 
  "description": "this is a lamp that stands on my desk", 
  "weight": "600", 
  "size": [ "300", "20", "2" ] 
}

```

甚至 JSON 也更简单。注意，当我们决定使用 JavaScript 时，在命名脚本时不需要指定文件扩展名。

当我们允许产品检查器脚本维护者使用不同的脚本语言时，我们可能会考虑以后的进一步发展。在这种情况下，我们可能仍然要求他们指定扩展，如果没有扩展，我们的程序会将其添加为`.js`。在我们当前的解决方案中，我们不检查这一点，但我们可能会花几秒钟来考虑它，以确保解决方案可以进一步开发。重要的是，我们不要为了进一步的开发而开发额外的代码。开发人员不是算命师，无法可靠地预测未来需要什么。这是商界人士的任务。

我们把脚本放到我们项目的`scripts`目录下的`resource`目录中。文件名必须为`powered_device.js`，因为这是我们在 JSON 文件中指定的名称：

```
function isInconsistent(order){ 
    isConsistent = false 
    items = order.getItems() 
    for( i in items ){ 
    item = items[i] 
    print( item ) 
        if( item.getProductId() == "126" || 
            item.getProductId() == "127" || 
            item.getProductId() == "128"  ){ 
            isConsistent = true 
            } 
    } 
    return ! isConsistent 
}

```

这是一个非常简单的 JavaScript 程序。作为旁注，在 JavaScript 中迭代列表或数组时，循环变量将迭代集合或数组的索引。因为我很少用 JavaScript 编程，所以我陷入了这个陷阱，花了半个多小时来调试我犯的错误。

我们已经准备好了调用脚本所需的一切。我们仍然需要调用它。为此，我们使用 JDK 脚本 API。首先，我们需要一个`ScriptEngineManager`。此管理器用于访问 JavaScript 引擎。尽管 JavaScript 解释器自 Java7 以来一直是 JDK 的一部分，但它仍然以抽象的方式进行管理。它是 Java 程序可以用来执行脚本的许多可能的解释器之一。它正好在 JDK 中，所以我们不需要将解释器 JAR 添加到类路径中。`ScriptEngineManager`发现类路径上的所有解释器并注册它们。

它使用服务提供者规范（长期以来一直是 JDK 的一部分）来实现这一点，通过 Java9，它还获得了模块处理方面的额外支持。这要求脚本解释器实现`ScriptEngineFactory`接口，并在`META-INF/services/javax.script.ScriptEngineFactory`文件中列出执行该接口的类。`ScriptEngineManager`从属于类路径的所有 JAR 文件中读取这些文件作为资源，通过这些文件，它知道哪些类实现了脚本解释器。`ScriptEngineFactory`接口要求口译员提供`getNames`、`getExtensions`、`getMimeTypes`等方式。经理调用这些方法来收集有关口译员的信息。当我们询问 JavaScript 解释器时，经理将返回工厂创建的一个解释器，其中一个名称是`JavaScript`。

通过名称、文件扩展名或 mime 类型访问解释器只是`ScriptEngineManager`的功能之一。另一个是管理`Bindings`。

当我们在 Java 代码中执行脚本时，我们不会这样做，因为我们想提高多巴胺水平。在脚本的情况下，它不会发生。我们想要一些结果。我们希望传递参数，在脚本执行之后，我们希望从脚本中返回值，以便在 Java 代码中使用。这可以通过两种方式实现。一种是将参数传递给脚本中实现的方法或函数，并从脚本中获取返回值。这通常是可行的，但有些脚本语言甚至可能没有函数或方法的概念。在这种情况下，这是不可能的。可以将一些环境传递给脚本，并在脚本执行后从环境中读取值。此环境由`Bindings`表示。

`Bindings`是具有`String`键和`Object`值的映射。

在大多数脚本语言中，例如在 JavaScript 中，`Bindings`与我们执行的脚本中的全局变量相连接。换句话说，如果我们在调用脚本之前在 Java 程序中执行以下命令，那么 JavaScript 全局变量`globalVariable`将引用`myObject`对象：

```
myBindings.put("globalVariable",myObject)

```

我们可以创建`Bindings`并将其传递给`ScriptEngineManager`，但我们也可以使用它自动创建的那个，我们可以直接在 engine 对象上调用`put`方法。

当我们执行脚本时，有两个`Bindings`。一个设置在`ScriptEngineManager`级别。这称为全局绑定。还有一个是由`ScriptEngine`自己管理的。这是当地的`Bindings`。从脚本的角度来看，没有区别。从嵌入的角度来看，有一些不同。如果我们使用相同的`ScriptEngineManager`创建多个`ScriptEngine`实例，那么全局绑定将由它们共享。如果其中一个得到一个值，那么它们都看到相同的值；如果一个设置了一个值，所有其他人稍后都会看到该更改的值。本地绑定特定于它所管理的引擎。由于本书中我们只介绍 Java 脚本 API，因此我们不会详细介绍，也不会使用`Bindings`。我们擅长调用 JavaScript 函数并从中获得结果。

实现脚本调用的类是`CheckerScriptExecutor`：

```
package packt.java9.by.example.mybusiness.bulkorder.services; 

import ... 

@Component 
public class CheckerScriptExecutor { 
    private static final Logger log = ... 

    private final ScriptEngineManager manager = 
                             new ScriptEngineManager(); 

    public boolean notConsistent(String script, Order order) { 

        try { 
            final Reader scriptReader = getScriptReader(script); 
            final Object result =  
                         evalScript(script, order, scriptReader); 
            assertResultIsBoolean(script, result); 
            log.info("Script {} was executed and returned {}", 
                                                 script, result); 
            return (boolean) result; 

        } catch (Exception wasAlreadyHandled) { 
            return true; 
        } 
    }

```

唯一的`public`方法`notConsistent`获取要执行的脚本的名称以及`order`。后者必须传递给脚本。首先得到`Reader`，可以读取脚本文本，对脚本文本进行求值，如果结果为`boolean`或者至少可以转换为`boolean`，则返回结果。如果我们在这个类中实现的从这里调用的任何方法是错误的，它将抛出一个异常，但只有在适当地记录它之后。在这种情况下，安全的方法是拒绝命令。

事实上，这是企业应该做出的决定。如果存在无法执行的检查脚本，则显然是错误的情况。在这种情况下，接受订单并随后手动处理问题会产生一定的成本。由于某些内部错误而拒绝订单或确认也不是订单处理的好方法。我们必须检查哪种方法对公司造成的损害最小。这当然不是程序员的职责。在我们的情况下，我们处于一个轻松的局面。

我们假设业务代表说，在这种情况下，订单应该被拒绝。在现实生活中，类似的决策多次被业务代表拒绝，他们说这不应该发生，it 部门必须确保程序和整个操作完全没有 bug。这种反应是有心理原因的，但这确实使我们远离 Java 编程。

引擎可以执行通过`Reader`或作为`String`传递的脚本。因为现在我们在资源文件中有了脚本代码，所以让引擎读取资源似乎是一个更好的主意，而不是将其读取到一个`String`：

```

        private Reader getScriptReader(String script) 
                                throws IOException { 
        final Reader scriptReader; 
        try { 
            final InputStream scriptIS = new ClassPathResource( 
                    "scripts/" + script + ".js").getInputStream(); 
            scriptReader = new InputStreamReader(scriptIS); 
        } catch (IOException ioe) { 
            log.error("The script {} is not readable", script); 
            log.error("Script opening exception", ioe); 
            throw ioe; 
        } 
        return scriptReader; 
    }

```

为了从资源文件中读取脚本，我们使用 Spring`ClassPathResource`类。脚本的名称前面有`scripts`目录，后面有`.js`扩展名。其余部分相当标准，我们在本书中没有看到任何内容。下一个评估脚本的方法更有趣：

```
        private Object evalScript(String script, 
                              Order order, 
                              Reader scriptReader)  
            throws ScriptException, NoSuchMethodException { 
        final Object result; 
        final ScriptEngine engine = 
                          manager.getEngineByName("JavaScript"); 
        try { 
            engine.eval(scriptReader); 
            Invocable inv = (Invocable) engine; 
            result = inv.invokeFunction("isInconsistent", order); 
        } catch (ScriptException | NoSuchMethodException se) { 
            log.error("The script {} thruw up", script); 
            log.error("Script executing exception", se); 
            throw se; 
        } 
        return result; 
    }

```

要在脚本中执行该方法，首先，我们需要一个能够处理**JavaScript**的脚本引擎。我们从经理那里得到了引擎的名字。如果不是**JavaScript**，我们应该检查返回的`engine`不是`null`。在**JavaScript**的情况下，解释器是**JDK**的一部分，检查**JDK**是否符合标准是偏执的。

如果我们想要扩展这个类来处理**JavaScript**以及其他类型的脚本，那么必须进行此检查，并且脚本引擎可能应该通过文件扩展名从管理器请求，而我们在`private`方法中无法访问此文件扩展名。但这是未来的发展，而不是在本书中。

当我们拥有引擎时，我们必须评估脚本。这将在脚本中定义函数，以便我们以后可以调用它。要调用它，我们需要一些`Invocable`对象。在**JavaScript**的情况下，引擎还实现了`Invocable`接口。并非所有脚本引擎都实现此接口。有些脚本没有函数或方法，并且没有可调用的内容。同样，这是稍后要做的事情，当我们不仅要允许**JavaScript**脚本，还要允许其他类型的脚本时。

要调用该函数，我们将其名称传递给`invokeFunction`方法，并传递要传递的参数。在本例中，这是`order`。在**JavaScript**的案例中，两种语言之间的集成已经相当成熟。在我们的示例中，我们可以访问作为参数传递的 Java 对象的字段和方法，并且返回的 JavaScript`true`或`false`值也会神奇地转换为`Boolean`。但在某些情况下，访问并不是那么简单：

```

private void assertResultIsBoolean(String script, 
                                       Object result) { 
        if (!(result instanceof Boolean)) { 
            log.error("The script {} returned non boolean", 
                                                    script); 
            if (result == null) { 
                log.error("returned value is null"); 
            } else { 
                log.error("returned type is {}", 
                                 result.getClass()); 
            } 
            throw new IllegalArgumentException(); 
        } 
    } 
}

```

类的最后一个方法检查返回值是否可转换为`boolean`，返回值可以是任何值，因为这是一个脚本引擎。

需要注意的是，某些功能是在脚本中实现的，这一事实并不保证应用程序能够无缝工作。可能存在多个问题，脚本可能会影响整个应用程序的内部工作。一些脚本引擎提供了特殊的方法来保护应用程序不受坏脚本的影响，而另一些则没有。我们不向脚本传递命令，但不能保证脚本不能访问其他对象。使用反射、`static`方法和其他技术，可以访问 Java 程序中的任何内容。当我们的代码库中只有一个脚本发生变化时，我们的测试周期可能会容易一些，但这并不意味着我们应该盲目地信任任何脚本。

在我们的示例中，让产品的生产者将脚本上传到我们的系统可能是一个非常糟糕的主意。他们可能会提供检查脚本，但在部署到系统中之前，必须从安全角度对这些脚本进行审查。如果这是正确的，那么脚本是 Java 生态系统的一个极其强大的扩展，为我们的程序提供了极大的灵活性。

# 总结

在本章中，我们开发了企业应用程序的订购系统。随着代码的开发，我们遇到了许多新事物。您了解了注释以及如何通过反射处理注释。虽然没有很强的相关性，但是您已经学习了如何使用 lambda 表达式和流来表达一些比传统循环更简单的编程结构。在本章的最后一部分，我们使用脚本扩展了应用程序，从 Java 调用 JavaScript 函数，也从 JavaScript 调用 Java 方法。

In fact, with all this knowledge, we matured to a Java level that is needed for enterprise programming. The rest of the topics the book covers are for the aces. But you want to be one, don't you? This is why I wrote the rest of the chapters. Read on!