# 第一个真正的 Java 程序-排序名称

在上一章中，我们熟悉了 Java，特别是使用 REPL 工具和交互式地执行一些简单代码。这是一个良好的开端，但我们需要更多。在本章中，我们将开发一个简单的排序程序。以这段代码为例，我们将了解 Java 项目中经常使用的不同构建工具，并了解 Java 语言的基本特性。本章将涵盖以下主题：

*   排序问题
*   项目结构和构建工具
*   Make、Ant、Maven 和 Gradle 构建工具
*   与代码示例相关的 Java 语言功能

# 开始排序

排序问题是工程师处理的最古老的编程任务之一。我们有一组记录，我们知道我们希望在以后的某个时候找到一个特定的记录，我们希望尽快找到那个记录。为了找到它，我们按照特定的顺序对记录进行排序，这有助于我们快速找到所需的记录。

例如，我们在一些卡片上有学生的名字和分数。当学生们来到办公室询问成绩时，我们一张接一张地查看所有卡片，以找到询问学生的姓名。然而，如果我们按照学生姓名的字母顺序对卡片进行排序会更好。当学生进行询问时，我们可以更快地搜索姓名上的标记。

我们可以看看中间的牌；如果它显示了学生的名字，那么我们很高兴找到了名字和标记。如果卡片按字母顺序排在学生姓名之前，那么我们将在下半场继续搜索；否则，我们将检查上半场。

按照这种方法，我们可以通过几个步骤找到学生的名字。步数不能超过牌包数的一半。如果我们有两张牌，那么最多是两步。如果是四个步骤，那么我们最多需要三个步骤。如果有八张卡片，那么我们可能需要四个步骤，但不需要更多。如果有 1000 张卡片，那么我们最多需要 11 个步骤，而原始的、未排序的卡片集最坏需要 1000 个步骤。也就是说，它大约将搜索速度提高了 100 倍，因此对卡片进行排序是值得的，除非排序本身花费太多时间。在我们刚才描述的已排序集合中查找元素的算法称为**二进制搜索**（[https://en.wikipedia.org/wiki/Binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm) ）。

在许多情况下，对数据集进行排序是值得的，有许多可以做到这一点。有更简单和更复杂的算法，在许多情况下，更复杂的算法运行得更快。

由于我们关注的是 Java 编程部分，而不是算法锻造，因此在本章中，我们将开发一个 Java 代码来实现一个简单而不是那么快的算法。

# 气泡排序

我们将在本章中实现的算法是众所周知的**气泡排序**。方法非常简单。从卡片的开头开始，比较第一张和第二张卡片。如果第一张卡片的字典顺序晚于第二张，则交换两张卡片。然后对现在位于第二位的卡重复此操作，然后是第三位，依此类推。威尔逊说，有一张卡片在词典上是最新的。当我们拿到这张卡片并开始与下一张比较时，我们总是会交换它们；这样，Wilson 的卡将移动到排序后最后一个必须放置的位置。我们所要做的就是从一开始就重复这个过程，偶尔再交换一次牌，但这一次只到最后一个元素。这一次，第二个最新的元素将到位，比如说，威尔金森将在威尔逊之前。如果我们有*n*张卡，并且我们重复这个*n-1*次，所有卡都会到达它们的位置。

在以下部分中，我们将创建一个实现该算法的 Java 项目。

# 开始使用项目结构和构建工具

当一个项目比单个类更复杂时，通常是这样，那么定义一个项目结构是明智的。我们必须决定源文件的存储位置、资源文件（那些包含程序的一些资源，但不是 Java 源代码的文件）的位置、编译器应该在哪里编写`.class`文件，等等。通常，结构主要是目录设置和执行构建的工具的配置。

使用发出`javac`命令的命令行不可能完成复杂程序的编译。如果我们有 100 个 Java 源文件，编译将需要发出许多`javac`命令。可以使用通配符（如`javac *.java`）来缩短它，或者我们可以编写一个简单的 bash 脚本或一个 BAT 命令文件来实现这一点。首先，它将只有 100 行，每行将一个源 Java 文件编译成类文件。然后，我们将认识到编译自上次编译以来未更改的文件只需花费时间、CPU 和电源，因此我们可以添加一些 bash 编程来检查源文件和生成文件上的时间戳。然后，我们可能会意识到。。。无论什么最后，我们将得到一个基本上是构建工具的工具。构建工具是现成的；重新发明轮子是不值得的。

我们将使用一个现成的构建工具，而不是创建一个。在[可以找到其中的一些 https://en.wikipedia.org/wiki/List_of_build_automation_software](https://en.wikipedia.org/wiki/List_of_build_automation_software) 。在本章中，我们将使用一个名为 Maven 的；但是，在开始讨论这个工具的细节之前，我们将先看看作为 Java 专业人员在企业项目中可能遇到的一些其他工具。

在以下部分中，我们将讨论四种构建工具：

*   制作
*   蚂蚁
*   专家
*   格拉德尔

我们将只简单地提到 Make，因为它现在不在 Java 环境中使用。然而，Make 是第一个构建工具，现代 Java 构建工具所基于的许多想法来自于*古老的*`make`。作为一名专业的 Java 开发人员，您还应该熟悉 Make，这样，如果您碰巧在项目中看到出于某种目的使用它，您就不会感到害怕，并且可以知道它是什么以及在哪里可以找到它的详细文档。

Ant 是许多年前广泛用于 Java 的第一个构建工具，现在仍在许多项目中使用。

Maven 比 Ant 更新，它使用不同的方法。我们将详细研究它。Maven 也是 Apache 软件基金会的 java 项目的官方构建工具。在本章中，我们还将使用 Maven 作为构建工具。

Gradle 甚至比 Maven 更新，最近它开始赶上 Maven。我们将在后面的章节中更详细地使用此工具。

# 制作

`make`程序最初创建于 1976 年 4 月，因此这不是一个新工具。它包含在 Unix 系统中，因此此工具在 Linux、Mac OS X 或任何其他基于 Unix 的系统上无需额外安装即可使用。此外，该工具在 Windows 上有许多端口，Visual Studio 编译器工具集中包含了一些版本。

Make 与 Java 无关。它是在主要编程语言是 C 时创建的，但它与 C 或任何其他语言无关。`make`是一种依赖描述语言，语法非常简单。
与任何其他构建工具一样，`make`由项目描述文件控制。对于 make，此文件包含一个规则集。描述文件通常命名为`Makefile`，但如果描述文件的名称不同，可以将其指定为`make`命令的命令行选项。

`Makefile`中的规则相互遵循，由一行或多行组成。第一行从第一个位置开始（行首没有制表符或空格），下面的行从制表符开始。因此，`Makefile`可能类似于以下代码：

```
run : hello.jar 
    java -cp hello.jar HelloWorld 

hello.jar : HelloWorld.class 
    jar -cf hello.jar HelloWorld.class 

HelloWorld.class : HelloWorld.java 
    javac HelloWorld.java

```

该文件定义了三个所谓的目标：`run`、`hello.jar`和`HelloWorld.class`。要创建`HelloWorld.class`，请在命令提示下键入以下行：

```
    make HelloWorld.class

```

Make 将查看规则并确定它取决于`HelloWorld.java`。如果`HelloWorld.class`文件不存在，或者`HelloWorld.java`比 Java 类文件更新，`make`将执行下一行写入的命令，并编译 Java 源文件。如果类文件是在上次修改`HelloWorld.java`之后创建的，则`make`知道不需要运行该命令。

在创建`HelloWorld.class`的情况下，`make`程序的任务很简单。源文件已经存在。如果您发出`make hello.jar`命令，程序会更复杂。`make`命令看到，为了创建`hello.jar`，它需要`HelloWorld.class`，它本身也是另一条规则的目标。因此，可能需要创建它。

首先，它以与以前相同的方式启动问题。如果`HelloWorld.class`在那里，并且比`hello.jar`更老，则无事可做。如果该命令不存在，或者比`hello.jar`新，则需要执行`jar -cf hello.jar HelloWorld.class`命令，尽管不一定在它意识到必须执行该命令时执行。`make`程序记住，当创建`HelloWorld.class`所需的所有命令都已成功执行时，该命令必须在将来某个时候执行。因此，它继续以与我前面描述的完全相同的方式创建类文件。

通常，规则可以具有以下格式：

```
target : dependencies 
    command

```

`make`命令可以使用`make target`命令创建任何目标，首先计算要执行的命令，然后逐个执行。这些命令是在不同进程中执行的 shell 命令，在 Windows 下可能会出现问题，这可能导致`Makefile`文件的操作系统依赖。

注意，`run`目标不是`make`创建的实际文件。目标可以是文件名，也可以只是目标的名称。在后一种情况下，ORT T2 将永远不会认为目标是容易获得的。

由于我们没有将`make`用于 Java 项目，因此没有理由深入了解更多细节。此外，我还通过使规则的描述比它应该的更简单来作弊。`make`工具有许多本书没有介绍的强大功能。还有几个实现彼此略有不同。你很可能会遇到由 GNU 制作的自由软件基金会所做的那件事。当然，就任何 Unix 命令行工具而言，`man`都是您的朋友。`man make`命令将在屏幕上显示工具的文档。

关于`make`你应该记住的要点如下：

*   它以声明的方式定义各个工件（目标）的依赖关系
*   它定义了以命令式方式创建缺少的工件的操作

这种结构是几十年前发明的，在大多数构建工具中一直存在到现在，正如您将在接下来的几章中看到的那样。

# 蚂蚁

`ant`构建工具是专门为 2000 年左右的 Java 项目构建的。Java 要想成为一种“一次编写、随时随地运行”的语言，需要一种工具，这种工具也可以在不同的环境中使用。虽然`make`可以在 Unix 机器上使用，也可以在 Windows 上使用，`Makefiles`并不总是兼容的。使用制表符时出现了一个小问题，一些编辑器将其替换为空格，导致`Makefile`无法使用，但这不是主要原因。`make`引发 Ant 开发的主要问题是命令是 shell 命令。即使`make`程序的实现在不同的操作系统上是兼容的，但所使用的命令很多时候是不兼容的，这是 make 本身无法改变的。因为`make`发出外部命令来构建目标，开发人员可以自由使用开发机器上为他们提供的任何外部工具。使用相同操作系统的另一台机器可能没有`make`调用的相同工具集。这破坏了`make`已建项目的可移植性。

同时，Ant 遵循`make`的主要原则。有些目标可能相互依赖，有些命令需要以适当的顺序执行，以便按照依赖顺序一个接一个地创建目标。依赖项和命令的描述是 XML（解决了选项卡问题），命令是用 Java 实现的（解决了系统依赖项，嗯……或多或少）。

由于 Ant 既不是操作系统的一部分，也不是 JDK 的一部分，如果您想使用它，就必须单独下载和安装它。

# 安装蚂蚁

蚂蚁可从其官方网站（[下载 http://ant.apache.org](http://ant.apache.org) 。您可以下载源代码或预编译版本。最简单的方法是以`tar.gz`格式下载二进制文件。

无论何时从 Internet 下载软件，强烈建议您检查下载文件的完整性。HTTP 协议不包含错误检查，并且可能发生网络错误仍然隐藏或恶意内部代理修改下载的文件的情况。下载站点通常为可下载文件提供校验和。它们通常是 MD5、SHA1、SHA512 或其他一些校验和。

当我以`tar.gz`格式下载 Apache Ant 1.9.7 版本时，我还打开了导致 MD5 校验和的页面。校验和值为`bc1d9e5fe73eee5c50b26ed411fb0119`。

![](../images/00027.jpeg)

可以使用以下命令行检查下载的文件：
`$ md5 apache-ant-1.9.7-bin.tar.gz`
`MD5 (apache-ant-1.9.7-bin.tar.gz) = bc1d9e5fe73eee5c50b26ed411fb0119`
计算出的 MD5 校验和与网站上的相同，表示文件完整性没有受到损害。
在 Windows 操作系统上，不包括计算 MD5 摘要的工具。微软提供了一个名为**文件完整性校验和校验工具**的工具，可通过[页面获取 https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility](https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility) 。如果您使用 Linux，则可能未安装`md5`或`md5sum`实用程序。在这种情况下，您可以使用命令`apt-get`或 Linux 发行版支持的任何安装工具来安装它。

下载文件后，可以使用以下命令将其分解到子目录：

```
    tar xfz apache-ant-1.9.7-bin.tar.gz

```

创建的子目录是 Ant 的可用二进制发行版。通常，我会将其移动到`~/bin`下，使其仅在 OS X 上对我的用户可用。之后，您应该将环境变量设置为`ANT_HOME`以指向此目录，并将安装的`bin`目录添加到`PATH`中。为此，您应该编辑`~/.bashrc`文件并添加以下行：

```
export ANT_HOME=~/bin/apache-ant-1.9.7/ 
export PATH=${ANT_HOME}bin:$PATH

```

然后，重新启动终端应用程序，或者只需键入`. ~/.bashrc`并通过键入以下命令测试 Ant 的安装：

```
    $ ant
Buildfile: build.xml does not exist!
Build failed

```

如果安装正确，您应该会看到前面的错误消息。

# 使用蚂蚁

当您看到 Ant 将要构建的项目时，您将看到一个`build.xml`文件。这是项目构建文件，Ant 在检查安装是否正确时丢失了该文件。它可以有任何其他名称，您可以将文件名指定为 Ant 的命令行选项，但这是默认的文件名，因为`Makefile`代表`make`。`build.xml`样本如下所示：

```
<project name="HelloWorld" default="jar" basedir="."> 
<description> 
    This is a sample HelloWorld project build file. 
</description> 
    <property name="buildDir" value="build"/> 
    <property name="srcDir" value="src"/> 
    <property name="classesDir" value="${buildDir}/classes"/> 
    <property name="jarDir" value="${buildDir}/jar"/> 

    <target name="dirs"> 
        <mkdir dir="${classesDir}"/> 
        <mkdir dir="${jarDir}"/> 
    </target> 

    <target name="compile" depends="dirs"> 
        <javac srcdir="${srcDir}" destdir="${classesDir}"/> 
    </target> 

    <target name="jar" depends="dirs,compile"> 
        <jar destfile="${jarDir}/HelloWorld.jar" basedir="${classesDir}"/> 
    </target> 
</project>

```

顶级 XML 标记为`project`。每个生成文件描述一个项目，因此命名为。标签有三个可能的属性，如下所示：

*   `name`：这定义了项目的名称，一些 IDE 使用它在识别项目的左面板中显示
*   `default`：当命令行上没有定义目标时，此选项命名要使用的目标
*   `basedir`：定义用于生成文件中任何其他目录名计算的初始目录

生成文件可以包含项目的说明以及属性标记中的属性。这些属性可以用作任务属性中介于`${`和`}`字符之间的变量，并在构建过程中发挥重要作用。

目标在目标 XML 标记中定义。每个标记都应该有一个唯一标识构建文件中目标的名称，并且可能有一个`depends`标记，指定此目标所依赖的一个或多个其他目标。如果有多个目标，则目标在属性中以逗号分隔。属于目标的任务按照目标依赖链要求的相同顺序执行，执行方式与我们在`make`案例中看到的非常相似。

当使用命令行选项`-projecthelp`时，您还可以向 Ant 打印的目标添加`description`属性。这有助于构建文件的用户了解存在哪些目标，哪些目标做什么。构建文件往往会随着许多目标而变大，当您有十个或更多目标时，很难记住每个目标。

带有`HelloWorld.java`的示例项目现在安排在以下目录中：

*   项目`root`文件夹中的`build.xml`
*   项目`src`文件夹中的`HelloWorld.java`
*   `build/`文件夹不存在；它将在构建过程中创建
*   `build/classes`和`build/jar`也不存在，将在构建过程中创建

当您第一次启动`HelloWorld`项目的构建时，您将看到以下输出：

```
$ ant  
Buildfile: /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build.xml 

dirs: 
    [mkdir] Created dir: /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build/classes 
    [mkdir] Created dir: /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build/jar 

compile: 
... 
    [javac] Compiling 1 source file to /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build/classes 

jar: 
      [jar] Building jar: /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build/jar/HelloWorld.jar 

BUILD SUCCESSFUL 
Total time: 0 seconds

```

从实际输出中删除一些不重要的行。

Ant 意识到，首先它必须创建目录，然后它必须编译源代码，最后它可以将`.class`文件打包成`.jar`文件。现在，您需要记住执行`HelloWorld`应用程序的命令。它已经在第一章中列出了。注意，这次 JAR 文件名为`HelloWorld.jar`，它不在当前目录中。您还可以尝试阅读 Ant 的在线文档，并创建一个执行编译和打包程序的目标`run`。

Ant 有一个名为`java`的内置任务，它执行 Java 类的方式与您在终端中键入`java`命令的方式几乎相同。

# 专家

由于 Ant 是为了克服`make`的不足而创建的，Maven 也是为了克服 Ant 的不足而创建的。您可能还记得 make 不能保证构建的可移植性，因为`make`执行的命令是任意的 shell 命令，可能是系统特定的。只要 Java 在不同平台上以相同的方式运行，Ant 构建（如果所有任务都在类路径上可用）是可移植的。

蚂蚁的问题有点不同。当您下载一个项目的源代码并想要构建时，该命令是什么？您应该让 Ant 列出所有目标，并选择最合适的目标。任务的名称取决于编制`build.xml`文件的工程师。有一些惯例，但它们不是严格的规则。

在哪里可以找到 Java 源文件？它们是否在`src`目录中？如果项目是 polyglot，还会有一些 Groovy 或其他编程语言文件吗？那要看情况。同样，一些团体或公司文化可能会提出一些惯例，但没有通用的最佳行业实践。

使用 Ant 启动新项目时，必须为编译、测试执行和打包创建目标。这是你已经为其他项目做过的事情。在完成第二个或第三个项目后，您只需将以前的`build.xml`复制并粘贴到新项目中即可。这是个问题吗？是的。这是复制/粘贴编程，即使它只是*一些构建文件。*

开发人员意识到，利用 Ant 的项目的一项重要工作是致力于项目构建工具配置，包括重复性任务。当新加入者加入团队时，他们首先必须了解构建是如何配置的。如果启动了新项目，则必须创建生成配置。如果这是一项重复性的任务，那么最好让计算机来完成。这通常就是编程的全部内容，不是吗？

Maven 处理构建问题的方式有点不同。我们想要构建 Java 项目。有时候，一些*Groovy*或者*Jython*之类的东西，但是它们也是*JVM*语言；因此，说我们想要构建 Java 项目并不是一个很大的限制。Java 项目包含 Java 文件，有时还包含一些其他编程语言的源文件、资源文件，通常就是它。*Ant*可以做任何事情，但我们不想只使用构建工具做任何事情。我们想要建立项目。

好的，在我们限制自己并接受我们不需要任何可以用于任何事情的构建工具之后，我们可以继续。我们可以要求源文件位于`src`目录下。有些文件是操作代码所需的，有些文件包含一些测试代码和数据。因此，我们将有两个目录，`src/test`和`src/main`。Java 文件在`src/main/java`和`src/test/java`中。资源文件在`src/main/resources`和`src/test/resources`下。

如果你想把你的源文件放在别的地方，那就不要。我是认真的。这是可能的，但我甚至不会告诉你怎么做。没有人做这件事。我甚至不知道为什么 Maven 会让它成为可能。每当您看到一个使用 Maven 作为构建工具的项目时，源代码都是这样组织的。不需要理解项目的构建工程师所设想的目录结构。它总是一样的。

目标和任务如何？对于所有基于 Maven 的项目，它们也是相同的。除了编译、测试、打包或部署 Java 项目之外，您还想对它做什么？Maven 为我们定义了这些项目生命周期。当您想使用 Maven 作为构建工具来编译项目时，必须键入`$ mvn compile`来编译项目。你甚至可以在理解项目实际是什么之前就这样做。

由于我们有相同的目录结构和相同的目标，导致这些目标的实际任务也都是相同的。当我们创建一个 Maven 项目时，我们不必描述构建过程必须做什么以及它必须如何做。我们必须描述项目，并且只描述项目特定的部分。

Maven 项目的构建配置在 XML 文件中给出。该文件的名称通常为`pom.xml`，应该在项目的`root`目录中，该目录应该是启动 Maven 时的当前工作目录。**POM**一词代表**项目对象模型**，对项目进行分层描述。源目录、打包和其他内容在所谓的超级 POM 中定义。该 POM 是 Maven 项目的一部分。POM 定义的任何内容都会覆盖超级 POM 中定义的默认值。当有一个包含多个模块的项目时，POM 被安排成一个层次结构，并且它们继承了从父级到模块的配置值。由于我们将使用 Maven 开发我们的排序代码，我们将在后面看到更多细节。

# 安装 Maven

Maven 既不是操作系统的一部分，也不是 JDK 的一部分。它必须以与 Ant 非常相似的方式下载和安装。您可以从 Maven 的官方网站（[下载 https://maven.apache.org/ 下载部分下的](https://maven.apache.org/)。目前，最新的稳定版本是 3.3.9。下载时，实际版本可能会有所不同；相反，请使用最新的稳定版本。您可以下载源代码或预编译版本。最简单的方法是下载`tar.gz`格式的二进制文件。

我不能不提请您注意使用校验和检查下载完整性的重要性。我在关于 Ant 安装的章节中详细介绍了实现方法。

下载文件后，可以使用以下命令将其分解到子目录：

```
tar xfz apache-maven-3.3.9-bin.tar.gz

```

创建的子目录是 Maven 的可用二进制发行版。通常，我会将其移动到`~/bin`下，使其仅在 OS X 上对我的用户可用。之后，您应该将安装的`bin`目录添加到`PATH`中。为此，您应该编辑`~/.bashrc`文件并添加以下行：

```
export M2_HOME=~/bin/apache-maven-3.3.9/ 
export PATH=${M2_HOME}bin:$PATH

```

然后，重新启动终端应用程序，或者只需键入`. ~/.bashrc`并测试 Maven typing 的安装，如下所示：

```
    $ mvn -v
Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T17:41:47+01:00)
Maven home: /Users/verhasp/bin/apache-maven-3.3.9
Java version: 9-ea, vendor: Oracle Corporation
Java home: /Library/Java/JavaVirtualMachines/jdk-9.jdk/Contents/Home
Default locale: en_US, platform encoding: UTF-8
OS name: "mac os x", version: "10.11.6", arch: "x86_64", family: "mac"

```

您应该会在屏幕上看到类似的消息，显示已安装的 Maven 版本和其他信息。

# 使用 Maven

与 Ant 不同，Maven 帮助您创建新项目的框架。为此，必须键入以下命令：

```
    $ 

```

Maven 将首先从网络下载实际可用的项目类型，并提示您选择要使用的项目类型。当 Maven 还是个新手时，这种方法似乎是个好主意。当我第一次启动 Maven 时，列出的项目数量大约在 10 到 20 个之间。今天，当我写这本书的时候，它列出了 1635 个不同的原型。这个数字似乎更像是一个历史日期（法国科学院的章程），而不是不同原型的可用大小列表。但是，不要惊慌失措。Maven 在询问您的选择时提供了一个默认值，这对我们所追求的`HelloWorld`是有好处的。

```
    Choose a number: 817: 

```

安装时的实际数量可能不同。无论是什么，接受建议并按*进入*。之后，Maven 将询问您项目的版本：

```
    Choose version: 
1: 1.0-alpha-1
2: 1.0-alpha-2
3: 1.0-alpha-3
4: 1.0-alpha-4
5: 1.0
6: 1.1
Choose a number: 6: 5

```

选择列为编号`5`的`1.0`版本。Maven 要求的下一件事是项目的组 ID 和工件 ID。我们将在后面讨论的依赖关系管理使用这些。我根据书籍和出版商选择了一个组 ID。项目的是`SortTutorial`，因为我们将在本项目中开始我们的章节示例。

```
Define value for property 'groupId': : packt.java9.by.example
Define value for property 'artifactId': : SortTutorial

```

下一个问题是项目的当前版本。我们已经选择了`1.0`和 Maven 提供`1.0-SNAPSHOT`。在这里，我选择了`1.0.0-SNAPSHOT`，因为我更喜欢语义版本控制。

```
Define value for property 'version':  1.0-SNAPSHOT: : 1.0.0-SNAPSHOT

```

语义版本控制，在[上定义 http://semver.org/](http://semver.org/) 是一个版本控制方案，建议*大调*、*小调*和*补丁*版本号使用三位版本号*M.M.p.*。这对图书馆非常有用。如果自上一版本以来只有一个 bug 修复，您将增加最后一个版本号。当新版本还包含新功能，但库与以前的版本兼容时，您将增加次要编号；换句话说，任何使用旧版本的程序仍然可以使用新版本。当新版本与前一版本有显著差异时，主要版本号将增加。
对于应用程序，没有使用应用 API 的代码；因此，次要版本号并不那么重要。不过，这并没有什么坏处，而且它通常被证明对于在应用程序中显示较小的更改是有用的。我们将在最后一章讨论如何对软件进行版本设置。

Maven 将带有`-SNAPSHOT`后缀的版本作为非发布版本处理。在我们开发代码时，我们将有许多代码的*版本*，所有版本都具有相同的快照版本号。另一方面，非快照版本号只能用于单个版本。

```
Define value for property 'package':  packt.java9.by.example: :

```

程序框架生成的最后一个问题是 Java 包的名称。默认值是我们为`groupId`给定的值，我们将使用该值。使用其他东西是一个罕见的例外。

当我们指定了所需的所有参数后，最后的请求是确认设置：

```
Confirm properties configuration: 
groupId: packt.java9.by.example 
artifactId: SortTutorial 
version: 1.0.0-SNAPSHOT 
package: packt.java9.by.example 
 Y: : Y

```

进入`Y`后，Maven 将生成项目所需的文件，并显示此报告：

```
[INFO] ----------------------------------------------------------- 
[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:1.0 
[INFO] ----------------------------------------------------------- 
[INFO] Parameter: basedir, Value: .../mavenHelloWorld 
[INFO] Parameter: package, Value: packt.java9.by.example 
[INFO] Parameter: groupId, Value: packt.java9.by.example 
[INFO] Parameter: artifactId, Value: SortTutorial 
[INFO] Parameter: packageName, Value: packt.java9.by.example 
[INFO] Parameter: version, Value: 1.0.0-SNAPSHOT 
[INFO] *** End of debug info from resources from generated POM *** 
[INFO] project created from Old (1.x) Archetype in dir: .../mavenHelloWorld/SortTutorial 
[INFO] ----------------------------------------------------------- 
[INFO] BUILD SUCCESS 
[INFO] ----------------------------------------------------------- 
[INFO] Total time: 01:27 min 
[INFO] Finished at: 2016-07-24T14:22:36+02:00 
[INFO] Final Memory: 11M/153M 
[INFO] -----------------------------------------------------------

```

您可以查看以下生成的目录结构：

![](../images/00028.jpeg)

您还可以看到，它生成了以下三个文件：

*   包含**项目对象模型**的`SortTutorial/pom.xml`
*   包含`HelloWorld`示例应用程序的`SortTutorial/``src/main/java/packt/java9/by/example/App.java`
*   `SortTutorial/src/test/java/packt/java9/by/example/AppTest.java`包含使用`junit4`库的单元测试框架

我们将在下一章讨论单元测试。现在，我们将重点关注排序应用程序。由于 Maven 非常友好，为应用程序生成了一个示例类，我们可以编译并运行它，而无需实际编码，只是为了看看如何使用 Maven 构建项目。将默认目录更改为`SortTutorial`发出`cd SortTutorial`并发出以下命令：

```
    $ mvn package

```

我们将获得以下输出：

![](../images/00029.jpeg)

Maven 自动启动、编译和打包项目。如果没有，请阅读下一个信息框。

当您第一次启动 Maven 时，它会从中央存储库下载很多依赖项。这些下载需要时间，并且会在屏幕上报告，因此实际输出可能与您在前面代码中看到的不同。
Maven 使用 Java 版本 1.5 的默认设置编译代码。这意味着生成的类文件与 Java 1.5 版兼容，而且编译器只接受 Java 1.5 中已有的语言结构。如果我们想使用更新的语言功能，并且在本书中我们使用了很多，`pom.xml`文件应该被编辑成包含以下行：

`<build>`

`<plugins>`

`<plugin>`

`<groupId>org.apache.maven.plugins</groupId>`

`<source>1.9</source>`

`</configuration>`

`</plugin>`

`</plugins>`

`</build>`

当对 Maven 使用 Java9 的默认设置时，它会变得更加复杂，因为 Java9 不会生成类格式，也不会限制 Java1.6 之前的源代码兼容性。在我写这些行的时候，最新的 Maven 版本是 3.3.9。当我尝试在没有修改的情况下编译前面的代码时，Java 编译器停止并显示以下错误：
`[ERROR] Source option 1.5 is no longer supported. Use 1.6 or later.`
**`[ERROR] Target option 1.5 is no longer supported. Use 1.6 or later.`** 
以后，Maven 版本可能会有不同的行为。

现在，您可以使用以下命令启动代码：

```
    $ java -cp target/SortTutorial-1.0.0-SNAPSHOT.jar packt.java9.by.example.App

```

您可以在下图中看到示例运行的结果：

![](../images/00030.jpeg)

# 格拉德尔

Ant 和 Maven 是两个世界，使用其中一个可能会导致互联网论坛上的激烈辩论。Ant 为开发人员提供了创建适合他们口味的构建过程的自由。Maven 限制团队使用更标准的构建过程。一些特殊的过程与任何标准构建都不匹配，但在某些环境中有时需要，很难使用 Maven 实现。在 Ant 中，您可以使用内置任务编写几乎所有的脚本，几乎与编写 bash 的方式相同。利用 Maven 并不是那么简单，它通常需要编写一个插件。尽管编写插件不是火箭科学，但开发人员通常喜欢用一种更简单的方式：编写脚本。我们有两种方法，两种心态和风格，没有一种工具可以满足所有需求。毫不奇怪，随着 Java 技术的发展，一种新的构建工具正在出现。

Gradle 试图利用这两个世界中最好的，利用 Maven 和 Ant 最初开发时所没有的技术。

Gradle 有内置的目标和生命周期，但同时，您也可以编写自己的目标。您可以像使用 Maven 一样配置项目，而无需编写任务脚本，但同时，您也可以像在 Ant 中一样编写自己的目标脚本。更重要的是，Gradle 集成了 Ant，所以为 Ant 实现的任何任务也可用于 Gradle。

Maven 和 Ant 使用 XML 文件来描述构建。今天，XML 已经是过去的技术了。我们仍然在使用它，开发人员应该能够熟练地处理、读取和编写 XML 文件，但*现代*工具不使用 XML 进行配置。新的、奇特的格式（如 JSON）更受欢迎。格雷德尔也不例外。Gradle 的配置文件使用基于 Groovy 的**领域专用语言**（**DSL**。这种语言对程序员来说更具可读性，并为程序构建过程提供了更多的自由。这也是格雷德尔的危险所在。

将功能强大的 JVM 语言 Groovy 交给开发人员来创建构建工具，让他们可以自由地创建复杂的构建过程，这在一开始似乎是个好主意，但后来可能会证明过于复杂和困难，因此维护成本高昂。这正是 Maven 最初实现的原因。

在进入另一个领域之前，我必须停下来，因为这是激烈和毫无意义的辩论的基础。Gradle 是一个非常强大的构建工具。你应该小心使用它，就像你会使用武器一样——不要射你的腿。

# 安装梯度

要安装 Gradle，您必须从[下载已编译的二进制文件 https://gradle.org/gradle-download/](https://gradle.org/gradle-download/) 网站。

再次强调使用校验和检查下载完整性的重要性。在关于 Ant 安装的部分中，我给出了详细的方法。
遗憾的是，Gradle 网站没有提供可下载文件的校验和值。

Gradle 以 ZIP 格式下载。要解压缩文件，必须使用 unzip 命令：

```
    $ unzip gradle-3.3-bin.zip

```

创建的子目录是 Gradle 的可用二进制发行版。通常，我会将其移动到`~/bin`下，使其仅在 OS X 上对我的用户可用。之后，您应该将安装的`bin`目录添加到`PATH`中。为此，您应该编辑`~/.bashrc`文件并添加以下行：

```
export GRADLE_HOME=~/bin/gradle-3.3/ 
export PATH=${GRADLE_HOME}bin:$PATH

```

然后，重新启动终端应用程序，或者只需键入`. ~/.bashrc`并测试 Gradle 的安装，键入以下内容：

```
    $ gradle -version

```

我们得到以下输出，如本屏幕截图所示：

![](../images/00031.jpeg)

# 使用 Maven 设置项目

为了启动项目，我们将使用目录结构和`pom.xml`，它是在我们使用以下命令行启动时由 Maven 自己创建的：

```
    $ mvn archetype:generate

```

它创建了目录、`pom.xml`文件和`App.java`文件。现在，我们将通过创建新文件来扩展此项目。我们将首先在`packt.java9.by.example.stringsort`包中对排序算法进行编码：

![](../images/00032.jpeg)

当我们在 IDE 中创建新包时，编辑器会自动在已经存在的`src/main/java/packt/java9/by/example`目录下创建`stringsort`子目录：

![](../images/00033.jpeg)

使用 IDE 创建新的`Sort`类也会自动在该目录中创建一个名为`Sort.java`的新文件，并填充类的骨架：

```
package packt.java9.by.example.stringsort; 

public class Sort { 
}

```

我们现在将有包含以下代码的`App.java`：

```
package packt.java9.by.example; 

public class App  
{ 
    public static void main( String[] args ) 
    { 
        System.out.println( "Hello World!" ); 
    } 
}

```

Maven 将其创建为起始版本。我们将编辑此文件以提供排序算法可以排序的示例列表。我建议您使用 IDE 来编辑文件，并编译和运行代码。IDE 提供了一个快捷菜单来启动代码，这比在终端中键入命令要简单一些。通常，建议您熟悉 IDE 功能，以节省时间，避免重复性任务，例如键入终端命令。专业开发人员几乎完全使用命令行来测试命令行功能，并尽可能使用 IDE。

![](../images/00034.jpeg)

# 分类编码

Maven 和 IDE 为排序程序创建了文件。它们构成了我们代码的骨架，现在是时候在它们身上长一些肌肉让它移动了。我们花了相当长的时间通过访问不同的构建工具来设置项目，只是为了学习如何编译代码。我希望这不会让你分心，但无论如何，我们应该看到一些真正的代码。

首先，我们将为排序代码创建代码，然后是调用排序的代码。调用排序的代码是一种测试代码。为了简单起见，我们现在将简单地使用`public static void main`方法来启动代码。我们将在后面的章节中使用测试框架。

目前，排序代码如下所示：

```
package packt.java9.by.example.stringsort; 

public class Sort { 

    public void sort(String[] names) { 
        int n = names.length; 
        while (n > 1) { 
            for (int j = 0; j < n - 1; j++) { 
                if (names[j].compareTo(names[j + 1]) > 0) { 
                    final String tmp = names[j + 1]; 
                    names[j + 1] = names[j]; 
                    names[j] = tmp; 
                } 
            } 
            n--; 
        } 
    } 
}

```

这是进行排序的类。这个类中只有一个方法进行排序。该方法的参数是一个包含字符串的数组，该方法对该数组进行排序。该方法没有返回值。这在使用伪类型`void`的声明中表示。方法使用其参数执行某些任务，并且可能返回一个值。方法的参数是按值传递的，这意味着方法无法修改作为参数传递的变量。但是，它可以修改参数包含的对象。在本例中，数组被修改，我们将对其进行排序。另一方面，`actualNames`变量将指向同一数组，`sort`方法无法使该变量指向其他数组。

这个类中没有`main`方法，这意味着它不能单独从命令行启动。这个类只能从其他类中使用，因为每个 Java 程序都应该有一个类，该类具有我们单独创建的`public static void main`方法。

我也可以将`main`方法放入类中，使其可执行，但这不是一个好的做法。真正的程序由许多类组成，一个类不应该做很多事情。相反，情况恰恰相反。s*单责任原则*说一个类应该负责一件事；因此，`class sort`进行排序。执行应用程序是一项不同的任务，因此它必须在不同的类中实现。

通常，我们不实现包含`main`方法的类。通常，一个框架提供了它。例如，编写在 servlet 容器中运行的*servlet*需要包含一个实现`javax.servlet.Servlet`接口的类。在这种情况下，程序似乎没有`main`方法。servlet 容器的实际实现确实如此。Java 命令行启动容器，容器在需要时加载 servlet。

在下面的示例代码中，我们实现了包含`main`方法的`App`类：

```
package packt.java9.by.example; 

import packt.java9.by.example.stringsort.Sort; 

public class App { 
    public static void main(String[] args) { 
        String[] actualNames = new String[]{ 
                "Johnson", "Wilson", 
                "Wilkinson", "Abraham", "Dagobert" 
        }; 
        final Sort sorter = new Sort(); 
        sorter.sort(actualNames); 
        for (final String name : actualNames) { 
            System.out.println(name); 
        } 
    } 
}

```

此代码包含初始化为包含常量值的字符串数组，创建`Sort`类的新实例，调用`sort`方法，然后将代码打印到标准输出。

在实际程序中，我们几乎从未在程序代码中有这样的常量；我们将它们放入资源文件中，并有一些代码来读取实际值。这将代码与数据分离并简化维护，消除了仅更改数据时意外修改代码结构的风险。类似地，我们几乎不会使用`System.out`将任何内容写入标准输出。通常，我们将使用从不同来源获得的日志记录可能性。有不同的库提供日志记录功能，JDK 本身也提供日志记录。

至于现在，我们将关注简单的解决方案，这样就不会因为过多的不同库和工具而分散您对 Java 的注意力。在下一节中，我们将研究用于编码算法的 Java 语言结构。首先，我们将对它们进行总体研究，然后再进行更详细的研究。这些语言特性并不是相互独立的：一个是建立在另一个之上的，因此，首先将对其进行一般性的解释，我们将在小节中详细介绍。

# 理解算法和语言结构

该算法在本章的开头进行了解释。实现在`sort`方法内的`Sort`类中，只有几行：

```
        int n = names.length; 
        while (n > 1) { 
            for (int j = 0; j < n - 1; j++) { 
                if (names[j].compareTo(names[j + 1]) > 0) { 
                    final String tmp = names[j + 1]; 
                    names[j + 1] = names[j]; 
                    names[j] = tmp; 
                } 
            } 
            n--; 
        }

```

`n`变量保存排序开始时数组的长度。Java 中的数组总是有一个给出长度的属性，称为`length`。当我们开始排序时，我们将从数组的开始一直到最后，正如您可能记得的那样，最后一个元素*Wilson*将在第一次迭代中向上移动到最后一个位置。随后的迭代将更短，因此变量`n`将减少。

# 阻碍

Java 中的代码是在代码块中创建的。任何介于`{`和`}`字符之间的字符都是块。在前面的示例中，方法的代码是一个块。它包含命令，其中一些命令，比如`while`循环，也包含一个块。在该块中，有两个命令。其中一个是一个`for`回路，同样带有一个块。虽然我们可以使用单个表达式来形成循环体，但我们通常使用块。我们将在几页中详细讨论循环。

正如我们在前面的示例中所看到的，循环可以嵌套，因此，`{`和`}`字符形成成对。一个块可以位于另一个块内，但两个块不能重叠。当代码包含一个`}`字符时，它将关闭上次打开的块。

# 变量

在 Java 中，就像在几乎所有编程语言中一样，我们使用变量。Java 中的变量是类型化的。这意味着变量可以保存单一类型的值。变量不可能在程序中的某个点保存`int`类型，随后保存`String`类型。声明变量时，其类型写在变量名前面。

变量也具有可见性范围。方法中的局部变量只能在定义它们的块内使用。变量可以在方法内部使用，也可以属于类或对象。为了区分两者，我们通常将这些变量称为*字段*。

# 类型

每个变量都有一种类型。在 Java 中，有两大类类型：基元类型和引用类型。基本体类型是预定义的，不能定义或创建新的基本体类型。有八种原始类型：`byte`、`short`、`int`、`long`、`float`、`double`、`boolean`和`char`。

前四种类型`byte`、`short`、`int`和`long`是有符号数字整数类型，能够存储 8、16、32 和 64 位的正数和负数。

`float`和`double`类型以在 32 位和 64 位上存储浮点数。

`boolean`类型是一个原语类型，只能是`true`或`false`。

`char`类型是存储单个 16 位 Unicode 字符的字符数据类型。

对于每个基元类型，都有一个类可以存储相同类型的值。当必须将基元类型转换为匹配的类类型时，它会自动完成。它被称为自动装箱。这些类型为`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Boolean`和`Character`。以以下变量声明为例：

```
Integer a = 113;

```

这将值`113`（一个`int`数字）转换为`Integer`对象。

这些类型是运行时的一部分，也是语言的一部分。虽然它没有原始的对应物，但我们已经使用了一个非常重要且无处不在的类：`String`。字符串包含字符。

基本类型和对象之间的主要区别在于基本类型不能用于调用方法，但它们消耗的内存较少。对于阵列，内存消耗及其对速度的影响之间的差异非常重要。

# 阵列

根据其声明，变量可以是基元类型，也可以包含对对象的引用。一种特殊的对象类型是数组。当一个变量持有对数组的引用时，可以使用`[`和`]`字符以及由 0 组成的整数值或小于数组长度一的正值对其进行索引，以访问数组的某个元素。当数组中的元素也是数组时，Java 也支持多维数组。在 Java 中，数组从零开始索引。在运行时检查索引不足或索引过度，结果是异常。

异常是一种特殊情况，它会中断正常的执行流并停止代码的执行或跳转到最近的封闭`catch`语句。我们将在下一章讨论异常以及如何处理它们。

当代码具有基元类型的数组时，该数组包含许多内存插槽，每个插槽都保存该类型的值。当数组具有引用类型时，换句话说，当它是对象数组时，则数组元素是对对象的引用，每个对象都包含该类型。例如，在`int`的情况下，数组的每个元素都是 32 位的，即 4 个字节。如果数组是一种`Integer`类型，那么元素是对对象、指针的引用，也就是说，使用 64 位 JVM 时通常是 64 位的，32 位 JVM 时通常是 32 位的。除此之外，内存中还有一个包含 4 字节值的`Integer`对象，还有一个可能多达 24 字节的对象头。

标准中未定义管理每个对象所需的额外信息的实际大小。在 JVM 的不同实现上可能会有所不同。实际编码，甚至环境中的代码优化，不应该取决于实际大小。但是，开发人员应该知道，这种开销是存在的，并且每个对象的开销大约在 20 字节左右。对象在内存消耗方面是昂贵的。

内存消耗是一个问题，但还有其他问题。当程序处理大量数据且工作需要阵列的连续元素时，CPU 会将一块内存加载到处理器缓存中。这意味着 CPU 可以访问连续更快的阵列元素。如果数组是基元类型，则速度较快。如果数组是某种类类型，那么 CPU 必须访问内存才能获得实际值，这可能要慢 50 倍。

# 表达

Java 中的表达式与其他编程语言中的表达式非常相似。可以使用与 C 或 C++等语言相似的运算符。详情如下:

*   一元前缀和后缀增量运算符（ `--`和`++`在变量前后）
*   一元符号（`+`和`-`运算符
*   逻辑（`!`和位（`~`求反
*   乘法（`*`）、除法（`/`）和模（`%`）
*   加法和减法（`+`和-再次，但这次作为二进制运算符）
*   移位运算符按位移动值，有左移位（`<<`）和右移位（`>>`）以及无符号右移位（`>>>`）
*   比较运算符为导致`boolean`值的`<`、`>`、`<=`、`>=`、`==`、`!=`和`instanceof`
*   有按位 or（`|`）和（`&`）、异或（`^`）运算符，以及类似的逻辑 or（`||`）和（`&&`运算符

计算逻辑运算符时，将对其进行快捷方式计算。这意味着只有当无法从左操作数的结果中识别结果时，才会计算右操作数。

三元运算符也类似于 C 上的运算符，根据某些条件从表达式中选择：`condition ? expression 1 : expression 2`。通常，三元运算符没有问题，但有时必须小心，因为如果两个表达式的类型不相同，则有一个复杂的规则控制类型转换。最好让这两个表达式的类型相同。

最后，还有一个赋值运算符（`=`），它将表达式的值赋值给变量。对于每个二元运算符，都有一个赋值版本，该版本将`=`与二元运算符相结合，以执行涉及右操作数的操作，并将结果赋值给左操作数，左操作数必须是变量。它们是`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`^=`、`|=`、`<<=`、`>>=`和`>>>=`。

运算符具有优先级，通常可以用括号覆盖。

表达式的一个重要部分是调用方法。静态方法可以通过类的名称和方法的名称来调用。例如，要计算 1.22 的正弦，我们可以写下以下行：

```
double z = Math.sin(1.22);

```

这里，`Math`是包`java.lang`中的类。调用方法`sin`时不使用`Math`的任何实例。这个方法是`static`，除了类`Math`中提供的实现之外，我们不可能需要任何其他的实现。

可以使用实例和方法名调用非静态方法，方法名之间用点分隔。例如，以以下代码行为例：

```
System.out.println("Hello World");

```

前面的代码使用类`PrintStream`的实例，该实例可通过类`System`中的静态字段随时获取。这个变量被称为`out`，当我们编写代码时，我们必须将其引用为`System.out`。方法`println`在类`PrintStream`中定义，我们在变量`out`引用的对象上调用它。该示例还显示，静态字段也可以通过类的名称和由点分隔的字段来引用。类似地，当我们需要引用非静态字段时，我们可以通过类的实例来实现。

在调用或继承静态方法的同一类中定义的静态方法可以在不使用类名的情况下调用。调用在同一类中定义的或被继承的非静态方法可以在没有实例的情况下调用。在本例中，实例是执行所在的当前对象。此对象也可通过获取。类似地，当我们使用代码所在的同一类的字段时，我们只需使用名称。对于静态字段，默认情况下我们所在的类。对于非静态字段，实例是由`this`关键字引用的对象。

您还可以使用`import``static`语言特性将静态方法导入到代码中，在这种情况下，您可以调用该方法，而不需要类的名称。

方法调用的参数使用逗号分隔。方法和方法参数传递是一个重要的主题，我们将在单独的小节中详细介绍。

# 循环

`while`循环中的`for`循环将遍历从第一个（在 Java 中用零索引）到最后一个（用`n-1`索引）的所有元素。通常，`for`循环与 C 中的语法相同：

```
for( initial expression ; condition ; increment expression ) 
  block

```

首先，对初始表达式求值。它可能包含变量声明，如我们的示例所示。上例中的变量`j`仅在循环块内部可见。在此之后，对条件进行求值，并在每次执行块之后，执行增量表达式。只要条件为真，循环就会重复。如果在执行初始表达式之后条件为 false，则循环根本不会执行。该块是由分号分隔的命令列表，包含在`{`和`}`字符之间。

封闭式块 Java 代替了`{`和`}`，它允许您在`for`循环的开头使用单个命令。对于`while`循环和`if...else`构造也是如此。实践表明，这不是一个专业人士应该使用的东西。专业代码总是使用大括号，即使只有一个命令块在适当的位置。这可以防止`else`问题，通常会使代码更具可读性。这类似于许多类似 C 的语言。它们中的大多数允许在这些地方使用单个命令，而专业程序员为了可读性的目的避免在这些语言中使用单个命令。
具有讽刺意味的是，在这些地方，唯一严格要求使用`{`和`}`大括号的语言是 Perl，这是一种因代码不可读而臭名昭著的语言。

`for (int j = 0; j < n - 1; j++) {`样本中的循环从零开始到`n-2`。书写`j < n-1`与本例中的`j <= n-2`相同。我们将限制`j`在数组部分结束之前停止在循环中，因为我们通过比较`j`和`j+1`索引的元素并有条件地交换它们，从而超出索引`j`。如果我们进一步访问一个元素，我们将尝试访问数组中不存在的元素，这将导致运行时异常。尝试将循环条件修改为`j < n`或`j <= n-1`，您将得到以下错误消息：

![](../images/00035.jpeg)

Java 的一个重要特性是运行时检查内存访问，并在数组索引错误的情况下抛出异常。在过去的好日子里，当我们用 C 编写代码时，经常会遇到无法解释的错误，这些错误会在很久以后停止编写代码，并且与真正的错误所在的代码位置完全不同。C 中的数组索引悄悄损坏了内存。一旦你犯了错误，Java 就会阻止你。它遵循您也应该在代码中使用的*快速失败*方法。如果出现问题，程序应该失败。任何代码都不应该试图接受或克服由编码错误引起的错误。在编码错误造成更大的损害之前，应将其修复。

Java 中还有另外两个循环构造：`while`循环和`do`循环。该示例包含一个`while`循环：只要阵列中至少有两个元素可能需要交换，就运行外部循环：

```
while (n > 1) {

```

`while`循环的一般语法和语义非常简单，如下所示：

```
while ( condition ) block

```

只要条件为真，就重复执行块。如果在循环的最开始处该条件不是真的，则根本不执行该块。`do`循环也类似，但在每次执行块后检查*条件：*

```
do block while( condition );

```

出于某种原因，程序员很少使用`do`循环。

# 有条件执行

排序的核心是循环内的条件和值交换。

```
                if (names[j].compareTo(names[j + 1]) > 0) { 
                    final String tmp = names[j + 1]; 
                    names[j + 1] = names[j]; 
                    names[j] = tmp; 
                }

```

Java 中只有一个条件命令，`if`命令。其格式如下：

```
if( condition ) block else block

```

代码结构的含义非常简单。如果条件为真，则执行第一个块，否则执行第二个块。`else`关键字以及第二个块是可选的。如果在条件为 false 的情况下不需要执行任何操作，那么就不需要 else 分支，就像示例中所示。如果用`j`索引的数组元素在排序顺序上晚于元素`j+1,`，那么我们交换它们，但如果它们已经按顺序排列，则与它们无关。

为了交换这两个数组元素，我们将使用一个名为`tmp`的临时变量。此变量的类型为`String`，此变量声明为`final`。`final`关键字有不同的含义，这取决于它在 Java 中的使用位置。这可能会让初学者感到困惑，除非你像现在一样被警告过。`final`类或方法与`final`字段完全不同，后者又不同于`final`局部变量。

# 最终变量

在我们的例子中，`tmp`是一个`final`局部变量。该变量的作用域仅限于`if`语句后面的块，在该块中，该变量只获取一次值。该块在代码执行期间执行多次，每次变量进入作用域时，它都会得到一个值。但是，无法在块中更改此值。这可能有点混乱。您可以将其视为每次执行块时都有一个新的`tmp`。该变量被声明，并且具有未定义的值，并且只能获取一次值。

最终的局部变量不需要获得声明它们的值。您可以稍后为`final`变量赋值。重要的是，不应该有一个代码执行为之前已经赋值的`final`变量赋值。如果存在重新分配`final`变量的可能性，编译器将对其进行检查，并且不编译代码。

将变量声明为 final 通常是为了简化代码的可读性。当您在声明为`final`的代码中看到一个变量时，您可以假设该变量的值不会改变，并且该变量的含义在方法中使用的任何地方都是相同的。当您试图修改一些`final`变量时，它还将帮助您避免一些错误，IDE 将立即对此进行投诉。在这种情况下，很可能是一个很早就被发现的编程错误。

原则上，可以编写一个所有变量均为`final`的程序。通常，将所有可声明为`final`的`final`变量声明为`final`是一种良好的做法，如果某些变量可能未声明为`final`，则尝试找到某种方式对该方法进行稍微不同的编码。

如果需要引入一个新变量来实现这一点，可能意味着使用一个变量来存储两个不同的东西。这些东西属于同一类型，在不同的时间存储在同一个变量中，但从逻辑上讲，它们仍然是不同的东西。不要试图优化变量的使用。永远不要使用变量，因为您的代码中已经有可用类型的变量。如果它在逻辑上是一个不同的东西，那么声明一个新变量。
编码时，始终希望源代码清晰易读。特别是在 Java 中，即时编译器将为您优化所有这些。

虽然我们不明确地倾向于在方法的参数列表上使用`final`关键字，但如果参数声明为`final`，则确保方法编译并工作是一种良好的做法。包括我在内的一些专家认为，默认情况下，该语言中的方法参数应该是最终的。这在任何版本的 Java 中都不会发生，只要 Java 遵循向后兼容性原则。

# 班级

现在，我们已经了解了实际的代码行，并且已经了解了算法是如何工作的，接下来让我们看看将其组合在一起的更全局的代码结构：包含方法的类和包。

Java 程序中的每个文件都定义了一个类。Java 程序中的任何代码都在类中。没有什么比 C、Python、Go 或其他语言中的全局变量或全局函数更好的了。Java 是完全面向对象的。

一个文件中可以有多个类，但通常一个文件就是一个类。稍后，我们将看到，当一个类位于另一个类中时，会有内部类，但现在，我们将把一个类放入一个文件中。

Java 语言中有一些我们不使用的特性。创建语言时，这些功能似乎是个好主意。CPU、内存和其他资源，包括平庸的开发人员，也比今天更加有限。由于这些环境限制，一些功能可能更有意义。有时候，我会提到这些。对于类，您可以将多个类放入一个文件中，只要只有一个是`public`。这是不好的做法，我们永远不会这样做。
Java 永远不会淘汰这些功能。Java 的一个理念是与所有以前的版本保持兼容。这种理念适用于已经编写的大量遗留代码。使用旧版本编写和测试的 Java 代码将在更新的环境中工作。同时，这些特性将初学者引诱到错误的风格。出于这个原因，有时我甚至不会提及这些特性。例如，在这里，我可以说：*一个文件中有一个类。*这不是绝对正确的。同时，详细解释一个我建议不要使用的特性或多或少是毫无意义的。稍后，我可能会跳过它们并“撒谎”。这些功能并不太多。

类是使用`class`关键字定义的，每个类都必须有一个名称。该名称在包中应该是唯一的（请参阅下一节），并且必须与文件名相同。一个类可以实现一个接口或扩展另一个类，我们将在后面看到一个示例。一个类也可以是`abstract`、`final`和`public`。这些都是用适当的关键字定义的，您将在示例中看到。

我们的课程有两个班。他们都是`public`。`public`类可以从任何地方访问。非`public`的类仅在包内可见。内部类和嵌套类也可以`private`仅在文件级定义的顶级类中可见。

包含由 Java 环境调用的`main`方法的类应该是`public`。这是因为它们是由 JVM 调用的。

该类从包声明之后的文件开头开始，`{`和`}`字符之间的所有内容都属于该类。方法、字段、内部或嵌套类等都是类的一部分。通常，花括号表示 Java 中的某些块。这是 C 语言发明的，许多语言都遵循这种符号。类声明是一些块，方法是使用一些块定义的，循环和条件命令使用块。

当我们使用类时，我们必须创建类的实例。这些实例是对象。换句话说，对象是通过实例化类来创建的。为此，Java 中使用了`new`关键字。当线路`final Sort sorter = new Sort()`发生故障时；在`App`类中执行，它创建一个实例化`Sort`类的新对象。我们还会说我们创建了一个新的`Sort`对象，或者该对象的类型是`Sort`。创建新对象时，将调用该对象的构造函数。有点草率，我可以说，构造函数是类中一个特殊的*方法*，它与类本身具有相同的名称，并且没有返回值。这是因为它*返回*已创建的对象。确切地说，构造函数不是方法。它们是初始值设定项，不返回新对象。他们正在处理*尚未准备就绪的*对象。当执行对象的构造函数未完全初始化时，某些最终字段可能未初始化，如果构造函数引发异常，则整个初始化仍可能失败。在我们的示例中，代码中没有任何构造函数。在这种情况下，Java 创建一个默认构造函数，该构造函数不接受任何参数，也不修改已分配但未初始化的对象。如果 Java 代码定义了初始值设定项，那么 Java 编译器不会创建默认值设定项。

一个类可以有许多构造函数，每个构造函数都有不同的参数列表。

除了构造函数之外，Java 类还可以包含初始值设定项块。它们是类级别上的块，与构造函数和方法的级别相同。这些块中的代码被编译到构造函数中，并在构造函数执行时执行。

也可以在静态初始值设定项块中初始化静态字段。这些是类中顶层的块，前面有`static`关键字。当类被加载时，它们只执行一次。

我们将示例中的类命名为`App`和`Sort`。在 Java 中，这是一种约定，用于命名 CamelCase 中的几乎所有内容。

CamelCase 是指单词之间没有空格。第一个单词可以以小写或大写开头，为了表示第二个和后续单词的开头，它们可以以大写开头。`ForExampleThisIsALongCamelCase`姓名。

类名以大写字母开头。这不是语言形式上的要求，但这是每个程序员都应该遵循的惯例。这些编码约定帮助您创建其他程序员更容易理解的代码，并使维护更容易。静态代码分析器工具，如 Checkstyle（[http://checkstyle.sourceforge.net/](http://checkstyle.sourceforge.net/) ），同时检查程序员是否遵守约定。

# 内部类、嵌套类、本地类和匿名类

在上一节中，我已经提到了内部类和嵌套类。现在我们更详细地看一下它们。

此时，内部类和嵌套类的细节可能很难理解。如果你不完全理解这一部分，不要感到羞愧。如果太难，请跳到下一节，阅读有关软件包的内容，稍后返回此处。嵌套类、内部类和本地类很少使用，尽管它们在 Java 中有自己的角色和用途。匿名类在 GUI 编程中非常流行，Swing 用户界面允许开发人员创建 JavaGUI 应用程序。有了 Java8 和 lambda 特性，匿名类现在就不再那么重要了，而随着 JavaScript 和浏览器技术的出现，JavaGUI 变得不那么流行了。

当一个类自己在一个文件中定义时，它被称为顶级类。显然，位于另一个类中的类不是顶级类。如果它们是在与字段（不是某个方法或其他块的局部变量）相同级别的类中定义的，则它们是内部类或嵌套类。它们之间有两个区别。一个是嵌套类在其定义中将`static`关键字放在`class`关键字之前，而内部类则没有。

另一个区别是嵌套类的实例可以在没有周围类的实例的情况下存在。内部类实例总是引用周围类的实例。

因为没有周围类的实例，内部类实例就无法存在，所以只能通过提供外部类的实例来创建它们的实例。如果周围的类实例是实际的`this`变量，我们看不出有什么区别，但是如果我们想从周围的类外部创建一个内部类的实例，那么我们必须在`new`关键字前面提供一个实例变量，用点分隔，就像 new 是一个方法一样。例如，我们可以有一个名为`TopLevel`的类，它有一个名为`InnerClass`的类，如下面的代码片段所示：

```
public class TopLevel { 

    class InnerClass { } 
}

```

然后我们可以从外部创建一个只包含一个`TopLevel`对象的`InnerClass`实例，如下面的代码片段所示：

```
TopLevel tl = new TopLevel(); 
InnerClass ic = tl.new InnerClass();

```

由于内部类具有对封闭类实例的隐式引用，因此内部类中的代码可以访问封闭类的字段和方法。

嵌套类没有对封闭类的任何实例的隐式引用，它们可以使用`new`关键字实例化，而不引用任何其他类的任何实例。因此，它们不能访问封闭类的字段，除非它们是静态字段。

局部类是在方法、构造函数或初始值设定项块中定义的类。我们将很快讨论初始化程序块和构造函数。本地类可以在定义它们的块内使用。

匿名类在单个命令中定义和实例化。它们是嵌套类、内部类或本地类的缩写形式，以及类的实例化。匿名类始终实现接口或扩展命名类。new 关键字后面是接口或类的名称，括号之间是构造函数的参数列表。定义匿名类主体的块位于构造函数调用之后。在扩展接口的情况下，构造函数只能是没有参数的构造函数。没有名称的匿名类不能有自己的构造函数。在现代 Java 中，我们通常使用 lambda 而不是匿名类。

最后但并非最不重要的是，实际上，至少我应该提到嵌套类和内部类也可以嵌套在更深的结构中。内部类不能包含嵌套类，但嵌套类可以包含内部类。为什么？我从未见过任何人能可靠地告诉我真正的原因。没有建筑方面的原因。可能是这样的。Java 不允许这样做。然而，这并不是很有趣。如果您碰巧编写了具有多个类嵌套级别的代码，那么请停止这样做。很可能你做错了什么。

# 包装

类被组织成包，文件中的第一行代码应该指定类所在的包。

```
package packt.java9.by.example.stringsort;

```

如果未指定包，则该类将位于*默认*包中。除非在最简单的情况下，您想尝试一些代码，否则不应使用此选项。对于 Java9，您可以使用`jshell`来实现这一目的，因此，与以前版本的 Java 不同，现在建议变得非常简单—不要将任何类放入默认包中。

包的名称是分层的。名字的各个部分用点隔开。使用包名称有助于避免名称冲突。类的名称通常保持简短，将它们放入包中有助于程序的组织。类的全名包括该类所在的包的名称。通常，我们会将这些类放入一个以某种方式相关的包中，并向程序的类似方面添加一些内容。例如，MVC 模式程序中的控制器保存在单个包中。包还可以帮助您避免类的名称冲突。但是，这只会将问题从类名冲突推到包名冲突。我们必须确保包的名称是唯一的，并且当我们的代码与任何其他库一起使用时不会导致任何问题。开发应用程序时，我们无法知道在以后的版本中将使用哪些其他库。为了应对意外情况，惯例是根据一些互联网域名来命名包。当开发公司拥有域名`acmecompany.com`时，他们的软件通常在`com.acmecompany...`包下。这不是严格的语言要求。从右到左写入域名并将其用作包名只是一种惯例，但这在实践中被证明是相当好的。有时候，就像我在这本书中所做的那样，人们可以偏离这种做法，这样你就可以看到这条规则不是刻在石头上的。

当橡皮碰到路面时，代码被编译成字节码，包成为类的名称。因此，`Sort`类的全名为`packt.java9.by.example.stringsort.Sort`。当您使用另一个包中的类时，可以使用此全名或将该类导入到您的类中。同样，这是在语言层面上。当 Java 变成字节码时，使用完全限定名或导入没有任何区别。

# 方法

我们已经讨论了方法，但没有详细讨论，在继续之前，我们还应该讨论一些方面。

示例类中有两个方法。一个类中可以有许多方法。方法名也是按约定大小写的，名称以小写字母开头，而不是类。方法可以返回一个值。如果一个方法返回一个值，该方法必须声明它返回的值的类型，在这种情况下，任何代码的执行都必须以一个`return`语句结束。`return`语句在关键字后面有一个表达式，该表达式在方法执行时计算，并由方法返回。一个方法只返回一次是一种很好的做法，但在一些简单的情况下，打破这种编码惯例是可以原谅的。编译器检查可能的方法执行路径，如果某些路径不返回值，则为编译时错误。

当一个方法没有返回任何值时，它必须声明为`void`。这是一种特殊类型，表示没有值。属于`void`的方法，例如`public static void main`方法，可能只是错过了返回语句而只是结束。如果有一个`return`语句，则在`return`关键字之后没有任何表达式定义返回值。同样，这是一种编码约定，在方法不返回任何值的情况下不使用`return`语句，但在某些编码模式中，可能不遵循此约定。

方法可以是`private`、`protected`、`public`和`static`，我们将在后面讨论它们的含义。

我们已经看到程序启动时调用的`main`方法是`static`方法。这样的方法属于类，可以在没有类的任何实例的情况下调用。静态方法是用`static`修饰符声明的，它们不能访问任何非静态的字段或方法。

在我们的示例中，`sort`方法不是静态的，但由于它不访问任何字段，也不调用任何非静态方法（事实上，它根本不调用任何方法），所以它也可以是`static`。如果我们将方法的声明更改为`public static void sort(String[] names) {`（注意`static`一词），程序仍然工作，但 IDE 在编辑时会给出警告，例如：

```
    Static member 'packt.java9.by.example.stringsort.Sort.sort(java.lang.String[])' accessed via instance reference

```

这是因为您可以通过`Sort.sort(actualNames);`类的名称直接访问方法，而无需`sorter`变量。在 Java 中，通过实例变量调用静态方法是可能的（同样，在 Java 的起源中，这似乎是一个好主意，但可能不是），但它可能会误导代码读者，使他们认为该方法是一个实例方法。

制作`sort`方法`static`，`main`方法可以如下：

```
public static void main(String[] args) { 
    String[] actualNames = new String[]{ 
            "Johnson", "Wilson", 
            "Wilkinson", "Abraham", "Dagobert" 
    }; 
    Sort.sort(actualNames); 
    for (final String name : actualNames) { 
        System.out.println(name); 
    } 
}

```

它似乎更简单（事实上是这样），如果方法不使用任何字段，您可能会认为没有理由使方法成为非静态的。在 Java 的前十年中，静态方法被大量使用。甚至还有一个术语，实用程序类，它意味着只有静态方法的类，不应该被实例化。随着**控制反转**容器的出现，我们倾向于使用较少的静态方法。当使用静态方法时，使用**依赖项注入**更难，创建测试也更难。我们将在接下来的几章中讨论这些高级主题。现在，您会被告知什么是静态方法以及它们可以被使用；然而，通常情况下，除非有非常特殊的需求，否则我们会避免它们。

稍后，我们将了解类在层次结构中是如何实现的，以及类如何实现接口和扩展其他类。当我们研究这些特性时，我们将看到一些所谓的抽象类可能包含抽象方法。这些方法都有`abstract`修饰符，它们不仅定义了名称，还指定了参数类型（和名称）和返回类型。扩展抽象类的具体（非抽象）类应该定义它们。

abstract method 的反面是使用`final`修饰符声明的最终方法。无法在子类中重写`final`方法。

# 接口

方法也在接口中声明。接口中声明的方法不定义该方法的实际行为；它们不包含代码。他们只有方法的头脑；换句话说，它们隐含着抽象性。虽然没有人这样做，但在定义方法时，您甚至可以在接口中使用`abstract`关键字。

接口看起来与类非常相似，但我们使用的不是`class`关键字，而是`interface`关键字。由于接口主要用于定义方法，如果不使用修饰符，则方法为`public`。

接口也可以定义字段，但由于接口不能有实例（只有实现类才能有实例），所以这些字段都是`static`，也必须是`final`。这是接口中字段的默认值，因此如果在接口中定义字段，则不需要编写这些字段。

通常的做法是在某些接口中只定义常量，然后在类中使用这些常量。要做到这一点，最简单的方法是实现接口。因为这些接口没有定义任何方法，所以实现只不过是将 implements 关键字和接口名称写入类声明的头中。这是一种不好的做法，因为这样接口就成为类的公共声明的一部分，尽管类内部需要这些常量。如果您需要定义的常量不是某个类的本地常量，而是在许多类中使用的常量，那么请在类中定义它们并使用`import static`导入字段，或者只使用类和字段的名称。

接口也可以有嵌套类，但不能有内部类。这样做的明显原因是内部类实例引用了封闭类的实例。在接口的情况下，没有实例，因此内部类不能引用封闭接口的实例，因为封闭接口的实例并不存在。令人高兴的是，我们不需要在嵌套类的情况下使用`static`关键字，因为这是默认值，就像在字段的情况下一样。

随着 Java8 的出现，您还可以在接口中使用`default`方法，为实现接口的类提供方法的默认实现。自 Java9 以来，接口中还可以有`static`和`private`方法。

方法由其名称和参数列表标识。您可以重用方法的名称，并具有不同的参数类型；Java 将根据实际参数的类型确定使用哪种方法。这称为**方法重载**。通常，很容易判断调用哪个方法，但当存在相互扩展的类型时，情况会变得更加复杂。该标准为编译器遵循的方法的实际选择定义了非常精确的规则，因此没有歧义。然而，阅读代码的程序员可能会误解重载方法，或者至少很难确定实际调用了哪个方法。当您想要扩展类时，方法重载也可能会阻碍向后兼容性。一般的建议是在创建重载方法之前要三思。它们是有利可图的，但有时可能很昂贵。

# 论点传递

在 Java 中，参数是按值传递的。当该方法修改参数变量时，只修改原始值的副本。在方法调用期间复制任何基元值。当对象作为参数传递时，则传递对该对象的引用的副本。

这样，就可以为该方法修改对象。对于具有其原始对应项的类，以及对于`String`和其他一些类类型，对象根本不提供修改状态的方法或字段。这对于语言的完整性很重要，并且在对象和原语值自动转换时不会遇到麻烦。

在其他情况下，当对象可修改时，该方法可以有效地处理传递给它的对象。这也是我们示例中的`sort`方法在数组上的工作方式。同一个数组本身也是一个对象，将被修改。

此参数传递比其他语言中的要简单得多。其他语言允许开发人员混合使用*传递引用*和*传递值*参数传递。在 Java 中，当使用变量本身作为表达式将参数传递给方法时，可以确保变量本身从未被修改。但是，如果对象是可变的，则可以修改它所引用的对象。

一个对象是可变的，如果它可以被修改，直接或通过一些方法调用改变它的一些字段的值。当一个类被设计成在对象创建之后没有正常的方式来修改对象的状态时，对象是不可变的。类`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Boolean`、`Character`以及`String`都是在 JDK 中设计的，因此对象是不可变的。
使用反射可以克服某些类的不变性实现的限制，但这样做是黑客行为，而不是专业编码。这样做的目的只有一个，那就是更好地了解和理解一些 Java 类的内部工作，而不是别的。

# 领域

字段是类级别上的变量。它们表示对象的状态。它们是变量，具有定义的类型和可能的初始值。字段可以是`static`、`final`、`transient`、`volatile`，访问权限可以修改为`public`、`protected`、`private`关键字。

静态字段属于该类。这意味着类的所有实例都共享其中一个。普通、非静态字段属于对象。如果您有一个名为`f`的字段，那么该类的每个实例都有自己的`f`。如果将`f`声明为`static`，则实例将共享非常相同的`f`字段。

`final`字段初始化后不能修改。初始化可以在声明它们的行、初始化程序块或构造函数代码中完成。严格的要求是，必须在构造函数返回之前进行初始化。这样一来，`final`关键字的含义就与类或方法的含义大不相同了。`final`类不能被扩展，而`final`方法不能在扩展类中被重写，我们将在下一章中看到。`final`字段要么未初始化，要么在实例创建过程中获取值。编译器还检查代码是否在对象实例创建期间或类加载期间初始化了所有的`final`字段（如果`final`字段为`static`，并且代码没有访问/读取任何尚未初始化的`final`字段。

通常的误解是，`final`字段必须在声明时初始化。它可以在初始化器代码或构造函数中完成。限制是，如果有更多的构造函数，无论调用哪个构造函数，`final`字段都必须精确初始化一次。

`transient`字段不是对象序列化状态的一部分。序列化是将对象的实际值转换为物理字节的行为。从字节创建对象时，反序列化正好相反。在某些框架中，它用于保存状态。进行序列化的代码`java.lang.io.ObjectOutputStream`仅适用于实现`Serializable`接口的类，并且仅使用非`transient`对象中的字段。非常明显，`transient`字段也不会从表示对象序列化形式的字节中恢复，因为它们的值不存在。

序列化通常用于分布式程序中。servlet 的会话对象就是一个很好的例子。当 servlet 容器在集群节点上运行时，存储在会话对象中的一些对象字段可能会在 HTTP 点击之间神奇地消失。这是因为序列化保存并重新加载会话以在节点之间移动会话。在这种情况下，如果开发人员不知道会话中存储的大型对象的副作用，序列化也可能是一个性能问题。

`volatile`关键字是告诉编译器该字段可能被不同线程使用的关键字。当任何代码访问`volatile`字段时，JIT 编译器会生成代码，确保所访问字段的值是最新的。当某个字段不是易失性字段时，编译器生成的代码可能会将该字段的值存储在处理器缓存或注册表中，以便在看到后续代码片段很快需要该值时更快地进行访问。对于`volatile`字段，无法进行此优化。此外，请注意，将值保存到内存并始终从内存加载可能比从注册表或缓存访问值慢 50 倍或更多。

# 修饰语

方法、构造函数、字段、接口和类可以具有访问修饰符。一般规则是，如果没有修饰符，那么方法、构造函数等的范围就是包。同一包中的任何代码都可以访问它。

当使用`private`修饰符时，范围仅限于所谓的编译单元。这意味着一个文件中的类。一个文件中的内容可以查看并使用任何声明为`private`的内容。通过这种方式，内部类和嵌套类可以访问彼此的`private`变量，这可能不是一种好的编程风格，但 Java 允许这样做。

`private`的对立面是`public`。它将可见性扩展到整个 Java 程序，或者至少扩展到整个模块（如果项目是 Java9 模块）。

中间有一条路：`protected`。具有此修饰符的任何内容都可以在包内访问，也可以在扩展受保护方法、字段等所在的类（无论包如何）的类中访问。

# 对象初始值设定项和构造函数

实例化对象时，将调用相应的构造函数。构造函数声明类似于具有以下偏差的方法：构造函数没有返回值。这是因为当调用`new`命令操作符时，构造函数在未完全就绪的实例上工作，并且不返回任何内容。构造函数与类同名，不能相互区分。如果需要多个构造函数，则必须重载它们。因此，构造函数可以互相调用，就像它们是具有不同参数的`void`方法一样。然而，当一个构造函数调用另一个构造函数时有一个限制，它必须是构造函数中的第一条指令。使用`this()`语法和适当的参数列表（可能为空）从另一个构造函数调用构造函数。

对象实例的初始化也会执行初始化程序块。这些块在方法和构造函数之外的`{`和`}`字符中包含可执行代码。它们按照它们在代码中出现的顺序在构造函数之前执行，如果它们的声明包含值初始化，则还会初始化字段。

如果在初始值设定项块前面看到`static`关键字，则该块属于该类，并在该类与静态字段初始值设定项一起加载时执行。

# 编译和运行程序

最后，我们将从命令行编译并执行我们的程序。这件事没有什么新鲜事；我们将仅使用以下两个命令应用本章所学内容：

```
    $ mvn package

```

这将编译程序，将结果打包到 JAR 文件中，最后执行以下命令：

```
    $ java -cp target/SortTutorial-1.0.0-SNAPSHOT.jar packt.java9.by.example.App

```

这将在命令行上打印以下结果：

**![](../images/00036.jpeg)**

# 总结

在本章中，我们开发了一个非常基本的排序算法。它被有意地简化了，以便我们可以重申基本的和最重要的 Java 语言元素、类、包、变量、方法等等。我们还研究了构建工具，因此在接下来的章节中，当项目将包含两个以上的文件时，我们不会空手而归。在接下来的章节中，我们将使用 Maven 和 Gradle。

在下一章中，我们将使排序程序更加复杂，实现更有效的算法，并使我们的代码更加灵活，使我们有机会学习更高级的 Java 语言特性。