# 使我们的游戏专业化-作为网络应用程序进行

在本章中，我们将编写一个 web 应用程序。我们将在我们已经取得的成就的基础上，创建一个网络版的智囊团游戏。这一次，它不仅会单独运行，猜测并回答位置和匹配颜色的数量，还会与用户进行通信，询问猜测的答案。这将是一场真正的比赛。Web 编程对于 Java 程序员来说非常重要。大多数程序都是 web 应用程序。Internet 上可用的通用客户端是 web 浏览器。瘦客户端、基于 web 浏览器的体系结构也被企业广泛接受。当体系结构除了 web 客户端之外还有其他东西时，只有一些例外情况。如果你想成为一名专业的 Java 开发人员，你必须熟悉 web 编程。而且它也很有趣！

在开发过程中，我们将访问许多技术主题。首先，我们将讨论网络和 web 架构。这是整个建筑物的混凝土底座。它不太性感，就像你建造大楼时一样。你花了很多钱和精力挖壕沟，然后你埋了混凝土，最后在这个阶段结束时，你似乎拥有了以前的东西：平坦的地面。除了有基地。如果没有这个基础，房子要么在建造后不久倒塌，要么在建造过程中倒塌。网络对于网络编程同样重要。有很多主题似乎与编程无关。尽管如此，它还是构建的基础，当您编写 web 应用程序时，您也会发现其中有趣的部分。

我们还将讨论一些 HTML、CSS 和 JavaScript，但不会太多。我们无法避免它们，因为它们对 web 编程也很重要，但它们也是您可以从其他地方学习的主题。如果您不是这些领域的专家，那么企业项目团队中通常还有其他专家可以扩展您的知识。除此之外，JavaScript 是一个如此复杂和庞大的主题，值得一本书从它开始。对 Java 和 JavaScript 都有深刻理解的专家寥寥无几。我了解该语言的一般结构及其运行环境，但我无法跟上这些天每周发布的新框架，我的注意力集中在其他领域。

您将学习如何创建在应用服务器中运行的 Java 应用程序，这次是在 Jetty 中，我们将了解什么是 servlet。我们将创建一个 web*hello world*应用程序以快速启动，然后我们将创建 Mastermind 的 servlet 版本。请注意，如果没有实现代码以处理参数、身份验证和许多其他非特定于应用程序的事情的框架的帮助，我们几乎不会直接编程 servlet。在本章中，我们仍将坚持使用裸 servlet，因为如果不首先理解 servlet 是什么，就不可能有效地使用 Spring 等框架。春天将在下一章到来。

我们将提到**Java 服务器页面**（**JSP**），只是因为您可能会遇到一些使用该技术开发的遗留应用程序，但现代 web 应用程序不使用 JSP。不过，JSP 是 servlet 标准的一部分，可以使用。还有其他一些技术是在最近的过去开发的，但现在似乎不能证明未来。它们仍然可用，但只出现在遗留应用程序中，因此在新项目中选择它们是相当值得怀疑的。我们将在单独一节中讨论这些技术。

在本章结束时，您将了解基本的 web 技术是如何工作的，主要的架构元素是什么，并且您将能够创建简单的 web 应用程序。这还不足以成为一名专业的 Java web 开发人员，但将为下一章打下良好的基础，在下一章中，我们将了解当今企业中用于实际应用程序开发的专业框架。

# 网络与网络

程序在计算机上运行，计算机连接到 Internet。这一网络是在过去 60 年中发展起来的，首先是为了提供能够抵御火箭攻击的军事数据通信，然后它被扩展为一个学术网络，后来它变成了一个任何人都可以使用的商业网络，几乎遍布全球。

该网络的设计和研究始于 50 年代加加林飞越地球的飞行。将加加林送上太空并在地球上空飞行证明了俄罗斯可以在地球上任何地方发射火箭，可能带有原子炸药。这意味着任何需要中央控制的数据网络都无法抵御此类攻击。将具有中心位置的网络作为单一故障点是不可行的。因此，研究人员开始创建一个网络，即使网络的任何部分被破坏，该网络仍能继续工作。

# 知识产权

网络在连接到它的任何两台计算机之间传送数据包。网络上使用的协议是 IP，它只是 Internet 协议的缩写。使用 IP，一台计算机可以向另一台计算机发送数据包。包包含一个标题和数据内容。标头包含发件人和目标计算机的 Internet 地址、其他标志以及有关包的信息。由于机器之间没有直接连接，路由器转发数据包。这就像邮局之间互相发送邮件，直到它落入你认识的邮递员手中，邮递员可以直接将邮件送到你的邮箱。为此，路由器使用报头中的信息。路由器如何交互的算法和组织是复杂的，我们作为 Java 专业人员不需要知道。

如果您曾经需要编程以便直接发送 IP 数据包，您应该查看`java.net.DatagramPacket`，其余部分在 JDK、操作系统和网卡固件中实现。你可以创建一个数据包；发送并改变网卡上的调制电压或向光纤发射光子并不是你头疼的事。然而，您将知道是否真的需要直接编程数据报。

IP 有两个版本。仍在使用的旧版本是 IPv4。与旧版本共存的新版本是 IPv6 或 IPng（*ng*代表*新一代*。Java 开发人员可能关心的主要区别是版本 4 使用 32 位地址，而版本 6 使用 128 位地址。当您看到版本 4 地址时，您将看到类似于`192.168.1.110`的内容，其中包含由点分隔的十进制格式的四个字节。IPv6 地址表示为`2001:db8:0:0:0:0:2:1`，八个 16 位数字以十六进制表示，用冒号分隔。

网络比发送数据包要复杂一些。如果发送数据包就像发送一页纸的信件，那么网页下载就像讨论纸质邮件中的合同。在合同签署之前，在最初的纸质邮件中应该有一个关于发送什么、回复什么等的协议。在互联网上，该协议称为**传输控制协议**（**TCP**。虽然不太可能（但也有可能）遇到 IP 路由问题，但作为 Java 开发人员，您肯定会遇到 TCP 编程问题。因此，我们将很快介绍 TCP 是如何工作的。请注意，这是非常简短的。真正地在阅读下一节时，您不会成为 TCP 专家，但您将了解影响 web 编程的最重要问题。

# TCP/IP

TCP 协议在操作系统中实现，并提供比 IP 更高级别的接口。编程 TCP 时，不处理数据报。相反，您有一个字节流通道，您可以将要传送到另一台计算机的字节放入其中，并且您可以从该通道中读取由另一台计算机发送的字节，其顺序与发送的顺序完全相同。这是两台计算机之间的连接，更重要的是，两个程序之间的连接。

还有一些其他协议是通过 IP 实现的，它们不是面向连接的。其中一个是**用户数据报协议**（**UDP**），用于不需要连接、数据可能丢失时的服务，数据及时到达目的地比丢失一些数据包（视频流、电话）更重要。当数据量较小且未交付时，可再次请求；丢失它的成本很低（DNS 请求，请参阅下一节）。

当一个数据包在网络上丢失时，或当它被发送两次时，或当它比后面的数据包更早交付时，它由操作系统实现的 TCP 软件层处理。这一层也通称为**TCP 堆栈**。

由于 TCP 是一个已连接的协议，因此需要一些东西来告诉 TCP 堆栈数据报到达时属于哪个流。流由两个端口标识。端口是 16 位整数。一个标识启动连接的程序，称为源端口。另一个用于标识目标程序：目标端口。这些都包含在每个交付的 TCP 数据包中。当机器运行**Secure Shell**（**SSH**服务器）和 web 服务器时，它们使用不同的端口，通常是端口 22 和 80。当 TCP 头中包含目标端口号 22 的包出现时，TCP 堆栈知道包中的数据属于 SSH 服务器处理的流。同样，如果目标端口为 80，则数据将发送到 web 服务器。

当我们为服务器编程时，通常必须定义端口号；否则，客户端将无法找到服务器程序。Web 服务器通常侦听端口 80，客户端尝试连接到该端口。客户端端口通常不重要且未指定；它由 TCP 堆栈自动分配。

从客户端代码连接到服务器很容易：只需要几行代码。有时，它只是一行代码。然而，在幕后，TCP 堆栈做了很多工作，我们应该注意建立 TCP 连接需要时间。

要建立连接，TCP 堆栈必须向目标发送一个数据报，以知道它存在。如果没有服务器侦听端口，则通过网络发送数据不会产生任何结果，只会浪费网络带宽。因此，客户机首先发送一个名为 SYN 的空数据包。当另一方收到它时，它会发回一个类似的包，称为 SYN-ACK。最后，客户端发送一个名为 ACK 的包。如果数据包通过大西洋，每个数据包大约 45 毫秒，相当于 4500 万秒的官僚时间。这差不多是一年半了。我们需要其中三个来建立连接，还有更多。

当 TCP 连接启动时，客户端不会在没有控制的情况下开始发送数据。它发送一些数据包，然后等待服务器确认收到它们。发送服务器不准备接受且不得不丢弃的数据不仅毫无用处，而且会浪费网络。TCP 旨在优化网络使用。因此，客户端发送一些数据，然后等待确认。TCP 堆栈自动管理这一点。如果确认到达，它将发送更多的数据包，如果 TCP 堆栈中实现的精心设计的优化算法认为发送更多数据是好的，那么它将发送比第一步多一点的数据。如果有否定的确认告诉客户机服务器无法接受某些数据，必须将其丢弃，那么客户机将减少它在未确认的情况下发送的数据包数量。但首先，它开始缓慢而谨慎。这就是所谓的 TCP 慢启动，我们必须意识到这一点。虽然它是一个低层网络特性，但它的后果是我们必须在 java 代码中考虑的：我们需要使用数据库连接池，而不是每次需要某些数据时创建数据库的新连接；我们尝试使用诸如*keep alive*、*SPDY*协议或*http/2.0*（也替换 SPDY）等技术尽可能少地连接到 web 服务器。

首先，TCP 是面向连接的，您可以建立到服务器的连接，发送和接收字节，最后关闭连接。当您遇到网络性能问题时，您必须查看我列出的问题。

# 域名服务器

TCP 协议使用机器的 IP 地址创建通道。在浏览器中键入 URL 时，它通常不包含 IP 号码。它包含机器名。使用名为**域名系统**（**DNS**的分布式数据库将名称转换为 IP 号码。该数据库是分布式的，当程序需要将名称转换为地址时，它会将 DNS 请求发送到它知道的 DNS 服务器之一。这些服务器相互查询或告诉客户端询问谁，直到客户端知道分配给该名称的 IP 地址。服务器和客户机还缓存最近请求的名称，因此应答很快。另一方面，当服务器的 IP 地址更改此名称时，并非所有客户端都会立即看到全球范围内的地址分配。DNS 查找可以很容易地编程，JDK 中有支持这一点的类和方法，但通常我们不需要关心这一点；当我们编程时，它是在 web 编程中自动完成的。

# HTTP 协议

**超文本传输协议**（**HTTP**建立在 TCP 之上。在浏览器中键入 URL 时，浏览器会打开到服务器的 TCP 通道（当然，在 DNS 查找之后），并向 web 服务器发送 HTTP 请求。服务器在接收到请求后，生成响应并将其发送给客户端。在此之后，TCP 通道可能会关闭或保持活动状态，以获得进一步的 HTTP 请求-响应对。

请求和响应都包含头和可选（可能为零长度）正文。标题为文本格式，并用空行与正文分隔。

更准确地说，头部和正文由四个字节分隔：`0x0D`、`0x0A`、`0x0D`和`0x0A`，这是两个`CR`、`LF`行分隔符。HTTP 协议使用回车符和换行符来终止报头中的行，因此，空行是紧跟在后面的两个`CRLF`。

标题的开头是一个状态行加上标题字段。以下是一个示例 HTTP 请求：

```
GET /html/rfc7230 HTTP/1.1 
Host: tools.ietf.org 
Connection: keep-alive 
Pragma: no-cache 
Cache-Control: no-cache 
Upgrade-Insecure-Requests: 1 
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36 
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 
DNT: 1 
Referer: https://en.wikipedia.org/ 
Accept-Encoding: gzip, deflate, sdch, br 
Accept-Language: en,hu;q=0.8,en-US;q=0.6,de;q=0.4,en-GB;q=0.2

```

答复如下：

```
HTTP/1.1 200 OK 
Date: Tue, 04 Oct 2016 13:06:51 GMT 
Server: Apache/2.2.22 (Debian) 
Content-Location: rfc7230.html 
Vary: negotiate,Accept-Encoding 
TCN: choice 
Last-Modified: Sun, 02 Oct 2016 07:11:54 GMT 
ETag: "225d69b-418c0-53ddc8ad0a7b4;53e09bba89b1f" 
Accept-Ranges: bytes 
Cache-Control: max-age=604800 
Expires: Tue, 11 Oct 2016 13:06:51 GMT 
Content-Encoding: gzip 
Strict-Transport-Security: max-age=3600 
X-Frame-Options: SAMEORIGIN 
X-Xss-Protection: 1; mode=block 
X-Content-Type-Options: nosniff 
Keep-Alive: timeout=5, max=100 
Connection: Keep-Alive 
Transfer-Encoding: chunked 
Content-Type: text/html; charset=UTF-8 

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html  xml:lang="en" lang="en"> 
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/"> 
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
    <meta name="robots" content="index,follow" />

```

请求不包含正文。状态行如下所示：

```
GET /html/rfc7230 HTTP/1.1

```

它包含所谓的请求方法、请求的对象以及请求使用的协议版本。标头请求的其余部分包含格式为`label : value`的标头字段。一些行在打印版本中被包装，但标题行中没有换行。

响应指定它使用的协议（通常与请求相同）、状态代码和状态的消息格式：

```
HTTP/1.1 200 OK

```

之后，响应字段的语法与请求中的相同。一个重要的标题是内容类型：

```
Content-Type: text/html; charset=UTF-8

```

它指定响应正文（在打印输出中被截断）是 HTML 文本。

实际请求已发送到 URL[https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230) ，定义 HTTP 1.1 版本的标准。您可以自己轻松查看通信，启动浏览器并打开开发人员工具。如今，每个浏览器都内置了这样的工具。您可以使用它在网络应用程序级别上调试程序行为，查看字节级别上的实际 HTTP 请求和响应。以下屏幕截图显示了开发人员工具如何显示此通信：

![](../images/00045.jpeg)

# HTTP 方法

作为请求状态行中第一个单词的方法告诉服务器如何处理请求。本标准定义了不同的方法，如`GET`、`HEAD`、`POST`、`PUT`、`DELETE`等。

当客户端想要获取资源的内容时，它使用`GET`方法。在`GET`请求的情况下，请求主体为空。这是我们下载网页时浏览器使用的方法。很多时候，当一些用 JavaScript 实现并在浏览器中运行的程序从 web 应用程序请求一些信息时，它也会使用这种方法，但它不想向服务器发送太多信息。

当客户端使用`POST`时，目的通常是向服务器发送一些数据。服务器会回复，而且很多时候，回复中也有一个主体，但是请求/回复通信的主要目的是从客户端向服务器发送一些信息。在某种意义上，这与`GET`方法相反。

`GET`和`POST`方法是最常用的方法。虽然使用`GET`检索数据和`POST`向服务器发送数据有一个通用的指导原则，但这只是一个建议，这两种情况之间没有明确的区分。很多时候，`GET`用于向服务器发送一些数据。毕竟，它是一个带有状态行和头字段的 HTTP 请求，尽管请求中没有正文，但遵循状态行中方法的对象（URL 的一部分）仍然能够传递参数。很多时候，测试响应`GET`请求的服务也很容易，因为您只需要一个浏览器，输入带有参数的 URL，并在浏览器开发工具中查看响应。如果您看到一个应用程序使用`GET`请求执行修改 web 服务器状态的操作，您不应该感到惊讶。然而，不感到惊讶并不意味着赞同。您应该知道，在大多数情况下，这些都不是好的做法。当我们使用`GET`请求发送敏感信息时，URL 中的参数可用于浏览器地址行中的客户端。当我们使用`POST`发送时，客户机仍然可以访问参数（毕竟，客户机发送的信息是由客户机生成的，因此不可能不可用），但对于一个不了解安全的简单用户来说，复制粘贴信息并发送给恶意的第三方并不是那么容易。使用 AutoT99 和 ORT T10T 之间的决策应始终考虑实用性和安全性问题。

`HEAD`方法与`GET`请求相同，但响应不包含正文。当客户端对实际响应不感兴趣时，使用此选项。客户机可能已经拥有该对象，并希望查看该对象是否已更改。`Last-Modified`标头将包含上次更改资源的时间，客户端可以决定是否有较新的资源或需要在新请求中请求资源。

当客户端希望在服务器上存储某些内容时使用`PUT`方法，当客户端希望擦除某些资源时使用`DELETE`方法。这些方法仅由通常用 JavaScript 编写的应用程序使用，而不是由浏览器直接使用。

标准中定义了其他方法，但这些方法是最重要和最常用的方法。

# 状态代码

响应以状态代码开始。还定义了这些代码，并且响应中可用的代码数量有限。最重要的是`200`，表示一切正常；响应包含请求所需的内容。代码始终在`100`到`599`的范围内，包含三位数字，并按第一位数字分组。

*   `1xx`：这些代码是信息代码。它们很少使用，但在某些情况下可能非常重要。例如，`100`表示继续。当服务器收到一个`POST`请求时，它可以发送此代码，并且服务器希望向客户端发送发送请求主体的信号，因为它可以处理请求主体。如果在服务器和客户机上正确实现，使用此代码以及等待此代码的客户机可以节省大量带宽。
*   `2xx`：这些代码意味着成功。请求得到正确响应，或请求的服务已完成。标准中定义了`200`、`201`、`202`等代码，并对何时使用其中一种进行了说明。
*   `3xx`：这些代码表示重定向。当服务器无法直接为请求提供服务，但知道可以提供服务的 URL 时，会发送其中一个代码。实际代码可以区分永久重定向（当知道未来的所有请求都应该发送到新 URL 时）和临时重定向（当以后的任何请求都应该发送到这里并可能被服务或重定向时），但决定权在服务器端。
*   `4xx`：这些是错误代码。最著名的代码是`404`，意思是找不到，即服务器无法响应请求，因为找不到资源。`401`表示服务请求的资源可能可用，但需要身份验证。`403`是表示请求有效但仍被服务器拒绝的代码。
*   `5xx`：这些代码是服务器错误代码。当响应包含其中一个错误代码时，这意味着服务器上存在一些错误。此错误可能是暂时的，例如，当服务器处理太多请求，并且无法使用计算密集型响应响应（这通常由错误代码`503`表示）响应新请求时，或者当未实现该功能时（代码`501`）。一般错误代码`500`被解释为内部错误，这意味着没有任何关于服务器出现问题的信息，但运行不正常，因此没有有意义的响应。

# HTTP/2.0

自上一次发布 HTTP 近 20 年后，新版本的 HTTP 于 2015 年发布。该协议的新版本比以前的版本有一些增强。其中一些增强还将影响服务器应用程序的开发方式。

第一个也是最重要的增强是，新协议将使在单个 TCP 连接中并行发送多个资源成为可能。keep alive 标志可用于避免重新创建 TCP 通道，但在缓慢创建响应时，它没有帮助。在新协议中，即使在一个请求得到完全服务之前，其他资源也可以在同一 TCP 通道中交付。这需要在协议中进行复杂的包处理，但这对服务器应用程序程序员和浏览器程序员都是隐藏的。应用服务器、servlet 容器和浏览器透明地实现了这一点。

HTTP/2.0 将始终加密，因此无法在浏览器 URL 中将`http`用作协议。它将永远是`https`。

需要在 servlet 编程中进行更改以利用新版本协议的优势的特性是服务器推送。servlet 规范的 4.0 版本包括对 HTTP/2.0 的支持，该版本仍处于起草阶段。

服务器推送是对将来将出现的请求的 HTTP 响应。服务器如何回答甚至未发出的请求？好的，服务器预期。例如，应用程序发送一个 HTML 页面，该页面引用了许多小图片和图标。客户端下载 HTML 页面，构建 DOM 结构，对其进行分析，实现所需图片，并发送图片请求。应用程序程序员知道那里有什么图片，甚至在浏览器请求图片之前，就可以对服务器进行编码以发送图片。每个这样的响应都包含此响应所针对的 URL。当浏览器需要资源时，它会意识到资源已经存在，并且不会发出新的请求。在`HttpServlet`中，程序应通过请求的新`getPushBuilder`方法访问`PushBuilder`，并使用该方法将资源下推到客户端。

# 曲奇饼

Cookie 由浏览器维护，并使用`Cookie`标头字段在 HTTP 请求标头中发送。每个 cookie 都有一个名称、值、域、路径、过期时间和一些其他参数。当将请求发送到与域（未过期 cookie 的路径）匹配的 URL 时，客户端将 cookie 发送到服务器。Cookie 通常通过浏览器或本地数据库存储在客户端的小文件中。实际实现是浏览器的业务，我们不必担心。客户端不执行的只是文本信息。只有当某些规则（主要是域和路径）匹配时，才会将其发送回服务器。Cookie 由服务器创建，并使用`Set-Cookie`头字段以 HTTP 响应的形式发送给客户端。因此，本质上，服务器告诉客户机，嘿，这是 cookie，下次你来找我时，给我看这段信息，这样我就知道是你。

Cookies 通常是用来记住客户的。广告商和在线商店需要记住他们正在与谁交谈，他们大量使用它。但这不是唯一的用途。现在，任何维护用户会话的应用程序都使用 cookie 来链接来自同一用户的 HTTP 请求。当您登录到应用程序时，用于标识您自己的用户名和密码只发送到服务器一次，在后续请求中，仅向用于标识已登录用户的服务器发送一个特殊 cookie。cookie 的使用强调了为什么使用不易猜测的 cookie 值很重要。如果用于识别用户的 cookie 很容易猜测，那么攻击者可以创建一个 cookie，并模仿其他用户将其发送到服务器。为此，Cookie 值通常是长的随机字符串。

Cookie 并不总是发送回它们发源的服务器。设置 cookie 后，服务器将指定 URL 的域，cookie 应发送回该域。当提供需要身份验证的服务的服务器与提供需要身份验证的服务的服务器不同时，将使用此选项进行用户身份验证。

应用程序有时将值编码到 cookie 中。这并不一定是坏的，尽管在大多数实际情况下确实如此。当将某物编码成 Cookie 时，我们应该始终考虑 cookie 通过网络传播的事实，并且随着越来越多的数据被编码在网络中，它可能会变得巨大，并且会在网络上造成不必要的负担。通常，最好只发送一些唯一的、没有意义的随机键，并将值存储在一些数据库中，无论是磁盘还是内存中。

# 客户机-服务器和 web 体系结构

到目前为止，我们开发的应用程序运行在单个 JVM 上。我们已经有了一些并发编程的经验，这将是现在方便的东西。当我们编写 web 应用程序时，一部分代码将在服务器上运行，一部分应用程序逻辑将在浏览器中执行。服务器部分将用 Java 编写，浏览器部分将用 HTML、CSS 和 JavaScript 实现。由于这是一本 Java 书籍，我们将主要关注服务器部分，但我们仍然应该知道，许多功能可以并且应该实现为在浏览器中运行。这两个程序通过 IP 网络（即 Internet）或企业内部应用程序（即公司网络）相互通信。

如今，浏览器能够运行非常强大的应用程序，所有应用程序都是用 JavaScript 实现的。几年前，这些应用程序需要客户端应用程序在 Delphi、C++或 java 中实现，使用客户端操作系统的窗口功能。

最初，客户机-服务器体系结构意味着应用程序的功能是在客户机上实现的，程序只使用来自服务器的通用服务。服务器提供了数据库访问和文件存储，但仅此而已。后来，三层体系结构将业务功能放在使用其他服务器进行数据库和其他通用服务的服务器上，客户机应用程序实现了用户界面和有限的业务功能。

当 web 技术开始渗透到企业计算时，web 浏览器开始在许多用例中取代客户端应用程序。以前，浏览器无法运行复杂的 JavaScript 应用程序。应用程序在 web 服务器上执行，客户端显示服务器创建的 HTML 作为应用程序逻辑的一部分。每次在用户界面上更改某些内容时，浏览器都会启动与服务器的通信，并在 HTTP 请求-响应对中替换浏览器内容。web 应用程序本质上是一系列表单填充和表单数据发送到服务器，服务器用 HTML 格式的页面响应，可能包含新表单。

JavaScript 解释器得到了开发，并且变得越来越有效和标准化。如今，现代 web 应用程序包含 HTML（这是客户端代码的一部分，不是由服务器动态生成）、CSS 和 JavaScript。当代码从 web 服务器下载时，JavaScript 开始执行并与服务器通信。它仍然是 HTTP 请求和响应，但响应不包含 HTML 代码。它包含纯数据，通常为 JSON 格式。这些数据由 JavaScript 代码使用，如果需要，一些数据显示在 web 浏览器显示器上，也由 JavaScript 控制。这在功能上相当于三层体系结构，但有一些细微但非常重要的区别。

第一个区别是该代码未安装在客户端上。客户端从 web 服务器下载应用程序，唯一安装的是现代浏览器。这消除了许多企业维护负担和成本。

第二个区别是，客户机无法或受限于访问客户机的资源。厚客户端应用程序可以将任何内容保存在本地文件中或访问本地数据库。出于安全原因，与在浏览器上运行的程序相比，这是非常有限的。同时，这是一个方便的限制，因为客户端不是也不应该是体系结构中受信任的一部分。客户端计算机中的磁盘很硬，备份成本很高。它可能会被笔记本偷走，而且加密成本很高。有一些工具可以保护客户机存储，但大多数情况下，仅在服务器上存储数据是一种更可行的解决方案。

信任客户端应用程序也是常见的程序设计错误。客户端实际控制客户端计算机，尽管这在技术上非常困难，但客户端仍然可以克服客户端设备和客户端代码的安全限制。如果只有客户端应用程序检查某些功能或数据的有效性，则不使用服务器的物理控件提供的物理安全性。每当数据从客户端发送到服务器时，无论客户端应用程序是什么，都必须检查数据的有效性。实际上，由于客户机应用程序是可以更改的，所以我们不知道客户机应用程序到底是什么。

在这一章中，事实上，在整本书中，我们主要关注 Java 技术；因此，示例应用程序几乎不包含任何客户端技术。我忍不住创建了一些 CSS。另一方面，我绝对避免使用 JavaScript。因此，我必须再次强调，这个例子是为了演示服务器端的编程，并且仍然提供一些真正有效的东西。现代应用程序将使用 REST 和 JSON 通信，而不会在服务器端动态创建 HTML。最初，我想创建一个 JavaScript 客户机和 REST 服务器应用程序，但是重点从服务器端 Java 编程转移了太多，所以我放弃了这个想法。另一方面，您可以将应用程序扩展为这样的应用程序。

# 编写 servlet

servlet 是在实现 servlet 容器环境的 web 服务器中执行的 Java 类。第一批 web 服务器只能向浏览器提供静态 HTML 文件。对于每个 URL，web 服务器上都有一个 HTML 页面，服务器根据浏览器发送的请求传递此文件的内容。很快，就需要扩展 web 服务器，以便能够启动一些程序，在处理请求时动态计算响应的内容。

第一个这样做的标准定义了 CGI。它启动了一个新流程来响应请求。新流程在其标准输入上获得请求，标准输出被发送回客户机。这种方法浪费了大量资源。正如您在上一章中了解到的，启动一个新流程的成本太高，无法响应 HTTP 请求。甚至开始一个新的线程似乎都是不必要的，但有了它，我们就领先了一点。

下一种方法是 FastCGI，持续执行外部流程并重用它，然后是其他不同的方法。之后的方法

FastCGIall 使用进程内扩展。在这些情况下，计算响应的代码在与 web 服务器相同的进程中运行。这些标准或扩展接口是针对 Microsoft IIS 服务器的 ISAPI、针对 Netscape 服务器的 NSASPI 和 Apache 模块接口。其中每一项都可以创建一个**动态加载库**（**DLL**（在 Unix 系统上的 Windows 或其他文件上），以便在运行期间由 web 服务器加载

startupand 映射这些库中实现的代码要处理的某些请求。

例如，当有人编程 PHP 时，Apache 模块扩展就是 PHP 解释器，它读取 PHP 代码并对其执行操作。当有人为 MicrosoftIIS 编程 ASP 页面时，会执行实现 ASP 页面解释器的 ISAPI 扩展（好吧，这有点草率，说起来过于简单，但可以作为一个例子）。

对于 Java 来说，接口定义是从 3.1 版开始在 JSR340 中定义的 servlet。

JSR 代表 Java 规范请求。这些是修改 Java 语言、库接口和其他组件的请求。这些请求经过一个评估过程，当它们被接受时，它们就成为一个标准。该流程由 Java 社区流程（JCP）定义。JCP 也有文档记录，并且有不同的版本。当前版本为 2.10，可在[找到 https://jcp.org/en/procedures/overview](https://jcp.org/en/procedures/overview) 。JSR340 标准见[https://jcp.org/en/jsr/detail?id=340](https://jcp.org/en/jsr/detail?id=340) 。

servlet 程序实现 servlet 接口。通常通过扩展`Servlet`接口的抽象实现`HttpServlet`来实现。这个抽象类实现了`doGet`、`doPost`、`doPut`、`doDelete`、`doHead`、`doOption`、`doTrace`等方法，这些方法可以被扩展它的实际类自由重写。若 servlet 类并没有覆盖其中一个方法，则发送相应的 HTTP 方法`GET`、`POST`等，将返回`405``Not Allowed`状态代码。

# 你好，世界 servlet

在进入技术细节之前，让我们创建一个极其简单的*hello world*servlet。为此，我们使用构建文件`build.gradle`和文件`src/main/java/packt/java9/by/example/mastermind/servlet/HelloWorld.java`中的 servlet 类设置了一个 Gradle 项目，最后但并非最不重要的是，我们必须创建文件`src/main/webapp/WEB-INF/web.xml`。`gradle.build`文件将显示以下内容：

```
apply plugin: 'java' 
 apply plugin: 'jetty' 

 repositories { 
     jcenter() 
 } 

 dependencies { 
     providedCompile "javax.servlet:javax.servlet-api:3.1.0" 
 } 

 jettyRun { 
     contextPath '/hello' 
 }

```

Gradle 构建文件使用两个插件，`java`和`jetty`。我们已经在上一章中使用了`java`插件。`jetty`插件添加了`jettyRun`等任务，用于加载 Jetty servlet 容器并启动应用程序。`jetty`插件也是`war`插件的扩展，该插件将 web 应用程序编译成**web 存档**（**WAR**`)`打包格式。

战争包装格式实际上与 JAR 相同；它是一个 zip 文件，包含一个`lib`目录，其中包含 web 应用程序所依赖的所有 JAR 文件。应用程序的类位于目录`WEB-INF/classes`中，并且有一个`WEB-INF/web.xml`文件描述 servlet URL 映射，我们将很快详细探讨这个文件。

因为我们想要开发一个非常简单的 servlet，所以我们将 servlet API 作为依赖项添加到项目中。但是，这不是编译依赖项。当 servlet 在容器中运行时，API 可用。不过，它必须在编译器编译我们的代码时可用；因此，指定为`providedCompile`的工件提供了*伪*实现。因为是这样指定的，所以构建过程不会将库打包到生成的 WAR 文件中。生成的文件将不包含任何特定于 Jetty 或任何其他 servlet 容器的内容。

servlet 容器将提供 servlet 库的实际实现。当应用程序在 Jetty 中部署和启动时，servlet 库的 Jetty 特定实现将在类路径上可用。当应用程序部署到 Tomcat 时，特定于 Tomcat 的实现将可用。

我们在项目中创建一个类，如下所示：

```
package packt.java9.by.example.mastermind.servlet; 

 import javax.servlet.ServletException; 
 import javax.servlet.http.HttpServlet; 
 import javax.servlet.http.HttpServletRequest; 
 import javax.servlet.http.HttpServletResponse; 
 import java.io.IOException; 
 import java.io.PrintWriter; 

 public class HelloWorld extends HttpServlet { 

     private String message; 

     @Override 
     public void init() throws ServletException { 
         message = "Hello, World"; 
     } 

     @Override 
     public void doGet(HttpServletRequest request, 
                       HttpServletResponse response) 
             throws ServletException, IOException { 
         response.setContentType("text/html"); 
         PrintWriter out = response.getWriter(); 
         out.println("<h1>" + message + "</h1>"); 
     } 

     @Override 
     public void destroy() { 
     } 
 }

```

当 servlet 启动时，`init`方法被调用。当它停止服务时，调用`destroy`方法。这些方法可以被重写，并提供比构造函数和其他终结可能性更细粒度的控制。servlet 对象可以多次投入使用，调用`destroy`后，servlet 容器可以再次调用`init`；因此，该周期与对象的生命周期没有严格的联系。通常，我们在这些方法中做的事情并不多，但有时，您可能需要在其中编写一些代码。

另外，请注意，一个 servlet 对象可以用于服务多个请求，即使是在同一时间；因此，其中的 servlet 类和方法应该是线程安全的。该规范要求 servlet 容器仅使用一个 servlet 实例，以防容器在非分布式环境中运行。如果容器在同一台机器上的多个进程中运行，每个进程执行一个 JVM，或者甚至在不同的机器上运行，那么可以有许多 servlet 实例来处理请求。通常，servlet 类的设计应确保它们不会假定只有一个线程在执行它们，但同时，它们也不应假定不同请求的实例相同。我们就是不知道。

这在实践中意味着什么？您不应该使用特定于某个请求的实例字段。在该示例中，初始化为保存消息的字段为每个请求保存相同的值；本质上，变量几乎是一个最终常数。它仅用于演示`init`方法的一些功能。

当 servlet 容器通过`GET`方法获得 HTTP 请求时，调用`doGet`方法。该方法有两个参数。第一个代表请求，第二个代表响应。`request`可用于收集请求中的所有信息。在前面的示例中，没有类似的情况。我们不使用任何输入。如果一个请求到达我们的 servlet，那么不管发生什么，我们都会回答`Hello, World`字符串。稍后，我们将看到从请求读取参数时的示例。`response`给出了可用于处理输出的方法。在本例中，我们获取`PrintWriter`，用于向 HTTP 响应主体发送字符。这是显示在浏览器中的内容。我们发送的 mime 类型是`text/html`，这是通过调用`setContentType`方法设置的。这将进入 HTTP 头字段`Content-Type`。这些类的标准和 JavaDoc 文档定义了所有可以使用的方法，以及如何使用这些方法。

最后，我们有一个`web.xml`文件，它声明了在我们的代码中实现的 servlet。正如文件名所示，这是一个 XML 文件。它声明性地定义了归档中包含的所有 servlet 以及其他参数。在这个示例中，没有定义参数，只有 servlet 和到 URL 的映射。因为在本例中只有一个 servlet，即 WAR 文件，所以它被映射到根上下文。到达 servlet 容器和此存档的所有和每个`GET`请求都将由此 servlet 提供服务：

```
<?xml version="1.0" encoding="UTF-8"?> 
<web-app version="2.5" 

         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"> 

    <servlet> 
        <display-name>HelloWorldServlet</display-name> 
        <servlet-name>HelloWorldServlet</servlet-name> 
        <servlet-class>packt.java9.by.example.mastermind.servlet.HelloWorld</servlet-class> 
    </servlet> 

    <servlet-mapping> 
        <servlet-name>HelloWorldServlet</servlet-name> 
        <url-pattern>/</url-pattern> 
    </servlet-mapping> 

</web-app>

```

# Java 服务器页面

我向您保证，我不会让您对 Java 服务器页面感到厌烦，因为这是一种过去的技术。尽管它已经成为过去，但它仍然不是历史，因为运行的许多程序仍然使用 JSP 并包含 JSP 代码。

JSP 页面是包含 HTML 和 Java 混合代码的网页。当 JSP 页面提供 HTTP 请求时，servlet 容器读取 JSP 页面，执行 Java 部分，将 HTML 部分保持原样，并以这种方式将两者混合在一起，创建一个发送到浏览器的 HTML 页面。

```
<%@ page language="java" 
         contentType="text/html; charset=UTF-8" 
         pageEncoding="UTF-8"%> 
<html> 
<body> 
<% for( int i = 0 ; i < 5 ; i ++ ){ %> 
  hallo<br/> 
<% } %> 
</body> 
</html>

```

前面的页面将创建一个 HTML 页面，其中包含五次文本`hallo`，每一次在一个新行中，由标记`br`分隔。在幕后，servlet 容器将 JSP 页面转换为 Javaservlet，然后使用 Java 编译器编译 servlet，然后运行 servlet。每次源 JSP 文件中有一些更改时，它都会这样做；因此，使用 JSP 以增量方式编写一些简单代码非常容易。从前面的 JSP 文件生成的代码有 138 行（在 Tomcat 8.5.5 版本上），这里列出的代码很长，很无聊，但是有助于理解 Java 文件生成工作原理的代码只有几行。

如果希望查看生成的 servlet 类的所有行，可以将应用程序部署到 Tomcat 服务器中，并查看目录`work/Catalina/localhost/hello/org/apache/jsp/`。在开发人员中，这是一个鲜为人知的事实，即此代码实际上已保存到磁盘并可用。有时，当您需要调试某些 JSP 页面时，它会有所帮助。

下面是前面代码生成的几行有趣的代码：

```
      out.write("\n"); 
      out.write("<html>\n"); 
      out.write("<body>\n"); 
 for( int i = 0 ; i < 5 ; i ++ ){  
      out.write("\n"); 
      out.write("  hallo<br/>\n"); 
 }  
      out.write("\n"); 
      out.write("</body>\n"); 
      out.write("</html>\n");

```

JSP 编译器将 JSP 代码的内部向外移动，外部向内移动。在 JSP 代码中，Java 被 HTML 包围，在生成的 servlet Java 源代码中，HTML 被 Java 包围。这就像当你想修补衣服：第一件事是把衣服翻过来。

不仅可以将 Java 代码混合到 JSP 页面中的 HTML 中，还可以混合到所谓的标记中。标记被收集到标记库中，用 Java 实现，并打包到 JAR 文件中，它们应该在要使用的类路径上可用。使用某个库中的标记的 JSP 页面应声明其用途：

```
<%@ taglib prefix="c" 
           uri="http://java.sun.com/jsp/jstl/core" %>

```

这些标记看起来像 HTML 标记，但它们由 JSP 编译器处理，并由`taglib`库中实现的代码执行。JSP 还可以引用 JSP 范围内可用的 Java 对象的值。要在 HTML 页面中实现这一点，可以使用 JSP 表达式语言。

JSP 最初是为了简化 web 应用程序的开发而创建的。其主要优势在于开发的快速启动。在开发过程中，配置、设置等都不会花费很长时间，而且当 JSP 页面发生任何更改时，也不需要再次编译整个应用程序：servlet 容器生成 Java 代码，将其编译为类文件，将代码加载到内存中，然后执行。JSP 是 Microsoft ASP 页面的竞争对手，后者将 HTML 与 VisualBasic 代码混合在一起。

当应用程序开始变大时，使用 JSP 技术会带来更多的问题。混合了业务逻辑和应用程序视图的代码，以及它在浏览器中的呈现方式，变得杂乱无章。开发 JSP 需要前端技术知识。Java 开发人员应该了解一些前端技术，但很少是设计专家和 CSS 专家。现代代码还包含 JavaScript，多次嵌入在 HTML 页面中。毕竟，JSP 的最大优势在于它包含在服务器和客户端代码上运行的代码。开发人员多次遵循这一范式，因此看到一些遗留代码包含 Java、HTML、CSS 和 JavaScript，它们都混合在一个 JSP 文件中，不要感到惊讶。由于 Java 和 JavaScript 有时在语法上是相似的，所以看不出在服务器上执行的是什么，在客户端执行的是什么。我甚至看到过从 JSP 文件中的 Java 代码创建 JavaScript 代码的代码。这是一个完全不同的责任和混乱的组合，几乎不可能维持。这导致了到今天为止 JSP 的全面弃用。

对 JSP 的反对不是官方的。这是我的专家意见。您可能会遇到一些仍然热爱 JSP 的经验丰富的开发人员，并且您可能会发现自己正在从事需要使用 JSP 开发程序的项目。这样做并不可耻。有些人为了钱做得更糟。

为了改善这种混乱局面，越来越多的技术主张将服务器代码和客户端功能分离。这些技术包括 Wicket、Vaadin、JSF 和不同的 Java 模板引擎，如 Freemarker、ApacheVelocity 和 Thymeleaf。当您从 Java 生成文本输出时，即使代码根本与 web 无关，这些后一种技术也会很有趣。

这些技术有规律地帮助控制了中大型 web 项目的开发和维护成本，但架构的基本问题仍然存在：没有明确的关注点分离。

今天，现代应用程序在单独的项目中实现 web 应用程序的代码：一个用于客户端，使用 HTML、CSS 和 JavaScript，另一个用于用 Java（或其他方式，但我们在这里重点讨论 Java）实现服务器功能。两者之间的通信是 REST 协议，我们将在后面的章节中介绍。

# HTML、CSS 和 JavaScript

HTML、CSS 和 JavaScript 是客户端技术。这些对于 web 应用程序非常重要，专业 Java 开发人员应该对它们有一些了解。没有人期望您同时成为 Java 和 web 客户机技术方面的专家，尽管这并非不可能。一定的理解是可取的。

HTML 是结构化文本的文本表示。与任何文本文件一样，文本以字符形式给出。标记表示结构。开始标记以一个`<`字符开始，然后是标记的名称，然后可选地是`name="value"`属性，最后是一个结束`>`字符。结束标记以`</`开头，然后是标记的名称，然后是`>`。标记包含在层次结构中；因此，您不应该比稍后打开的标记更早地关闭标记。首先，必须关闭上次打开的标记，然后关闭下一个标记，依此类推。这样，HTML 中的任何实际标记都有一个级别，并且开始标记和结束标记之间的所有标记都在该标记的*下方。一些不能包含其他标记或文本的标记没有结束标记，它们自己独立。考虑以下样本：*

```
<html> 
  <head> 
    <title>this is the title</title> 
  </head> 
</html>

```

标签`head`在`html`下，`title`在`head`下。可以将其结构化为树，如下所示：

```
html 
+ head 
  + title 
    + "this is the title"

```

浏览器以树状结构存储 HTML 文本，此树是网页文档的对象模型，因此名称为**文档对象模型**（**DOM**树。

最初的 HTML 概念混合了格式和结构，即使在当前版本的 HTML5 中，我们仍然有诸如`b`、`i`、`tt`等标签，它们建议浏览器分别以粗体、斜体和电传显示开始标签和结束标签之间的文本。

正如代表超文本标记语言的名称 HTML 所暗示的那样，文本可以以超链接的形式包含对其他网页的引用。这些链接被分配给使用`a`标签（代表锚定）的文本或可能由不同字段组成的表单，当按下表单的提交按钮时，字段的内容以`POST`请求发送给服务器。发送表单时，字段的内容以所谓的`application/x-www-form-urlencoded`形式编码。

HTML 结构总是试图促进结构和格式的分离。为此，将格式移动到样式。**层叠样式表**（**CSS**中定义的样式）为格式设置提供了比 HTML 更大的灵活性；CSS 的格式对于格式化更有效。创建 CSS 的目的是使设计与文本结构分离。如果我必须从这三个选项中选择一个，我会选择 CSS 作为对 Java 服务器端 web 开发人员最不重要的选项，同时也是对用户最重要的选项（看起来应该不错）。

JavaScript 是客户端技术的第三大支柱。JavaScript 是一种由浏览器执行的功能齐全的解释性编程语言。它可以访问 DOM 树，并读取和修改它。修改 DOM 树时，浏览器会自动显示修改后的页面。可以计划和注册 JavaScript 函数，以便在发生某些事件时调用。例如，您可以注册一个函数，以便在文档完全加载、用户按下按钮、单击链接或将鼠标悬停在某个部分上时调用。虽然 JavaScript 最初只用于在浏览器上创建有趣的动画，但今天，使用浏览器的功能对功能齐全的客户端进行编程是可能的，并且是一种惯例。有很多用 JavaScript 编写的强大程序，甚至像 PC 仿真器这样耗电的应用程序。

在本书中，我们将重点介绍 Java，并尽可能多地使用客户端技术来演示技术。但是，作为一名 Java web 开发人员专业人员，您还必须学习这些技术，至少在某种程度上，要理解客户机可以做什么，并能够与负责前端技术的专业人员合作。

# 策划者 servlet

通过网络玩智囊团游戏与过去有点不同。到目前为止，我们还没有任何用户交互，我们的类也因此而设计。例如，我们可以向表中添加一个新的猜测，以及程序计算的部分匹配和完全匹配。现在我们必须分开创建一个新的猜测，将其添加到游戏中，并设置完全匹配和部分匹配。这一次，我们必须首先显示表，用户必须计算并提供匹配数。

我们必须修改一些类才能做到这一点。我们需要在`Game.java`中增加一个新的方法：

```
public Row addGuess(Guess guess, int full, int partial) { 
    assertNotFinished(); 
    final Row row = new Row(guess, full, partial); 
    table.addRow(row); 
    if (itWasAWinningGuess(full)) { 
        finished = true; 
    } 
    return row; 
}

```

到目前为止，我们只有一种方法是添加一个新的猜测，由于程序知道这个秘密，它立即计算出`full`和`partial`的值。该方法的名称可以是`addNewGuess`，重载了原始方法，但这次，该方法不仅用于添加新猜测，还用于添加旧猜测以重建表。

当程序启动时，没有猜测。程序创建了一个，第一个。之后，当用户告知程序完全匹配和部分匹配时，程序需要包含`Guess`对象的`Game`结构和`Table`和`Row`对象以及`full`和`partial`匹配值。这些已经可以使用了，但是当新的 HTTP 出现时，我们必须从某个地方把它拉出来。编写 servlet 时，我们必须将游戏状态存储在某个地方，并在新的 HTTP 请求到达服务器时将其恢复。

# 存储状态

存储状态可以在两个地方完成。我们将在代码中首先做的一个地方是客户机。当程序创建一个新的猜测时，它会将其添加到表中，并发送一个 HTML 页面，该页面不仅包含新的猜测，还包含所有以前的猜测以及用户为每一行提供的`full`和`partial`匹配值。要将数据发送到服务器，值存储在表单的字段中。提交表单时，浏览器收集字段中的信息，根据字段内容创建编码字符串，并将内容放入`POST`请求的正文中。

存储实际状态的另一种可能性是在服务器中。服务器可以存储游戏的状态，并在创建新猜测时重建结构。这种情况下的问题是知道使用哪种游戏。服务器可以而且应该存储多个游戏，每个用户一个，用户可以同时使用该应用程序。它不一定意味着与我们在上一章中所研究的相同的意义上的强并发。

即使在多个线程中不同时为用户提供服务，也可能有处于活动状态的游戏。想象一下`cnn.com`告诉你，你现在无法阅读新闻，因为有人正在阅读。可以有多个用户在玩多个游戏，在服务 HTTP 请求时，我们应该知道我们在服务哪个用户。

servlet 维护可用于此目的的会话，我们将在下一节中看到。

# HTTP 会话

当客户端从同一浏览器向同一 servlet 发送请求时，该系列请求属于一个会话。为了知道这些请求属于同一个会话，servlet 容器会自动向客户端发送一个名为`JSESSIONID`的 cookie，这个 cookie 有一个长的、随机的、难以猜测的值（当我在 Jetty 中运行应用程序时为`tkojxpz9qk9xo7124pvanc1z`。servlet 维护一个包含`HttpSession`实例的会话存储。在`JSESSIONID`cookie 的值中移动的键字符串标识实例。当 HTTP 请求到达 servlet 时，容器将会话从存储区附加到请求对象。如果密钥没有会话，则创建一个会话，代码可以通过调用`request.getSession()`方法访问会话对象。

`HttpSession`对象可以存储属性。程序可以调用`setAttribute(String,Object)`、`getAttribute(String)`和`removeAttribute(String)`方法来存储、检索或删除属性对象。每个属性都分配给一个`String`，可以是任何`Object`。

虽然会话属性存储本质上看起来像一个`Map<String,?>`对象一样简单，但事实并非如此。当 servlet 容器在集群或其他分布式环境中运行时，存储在会话中的值可以从一个节点移动到另一个节点。为此，将值序列化；因此，会话中存储的值应该是`Serializable`。不这样做是一个非常常见的新手错误。在开发过程中，在简单的开发 Tomcat 或 Jetty 容器中执行代码实际上从未将会话序列化到磁盘，也从未从序列化表单加载它。这意味着通过调用`getAttribute`可以使用`setAttribute`设置的值。当应用程序第一次安装在集群环境中时，我们就遇到了麻烦。一旦 HTTP 请求到达不同的节点，`getAttribute`可能返回`null`。方法`setAttribute`在一个节点上被调用，在处理下一个请求`getAttribute`的过程中，另一个节点上的`getAttribute`无法从节点之间共享的磁盘反序列化属性值。不幸的是，这通常是生产环境。

作为一名开发人员，您还应该意识到，序列化和反序列化对象是一项耗费数个 CPU 周期的繁重操作。如果应用程序的结构仅使用服务于大多数 HTTP 请求的客户机状态的一部分，那么从序列化表单在内存中创建整个状态，然后再次序列化它，这是对 CPU 的浪费。在这种情况下，最好只在会话中存储一个键，并使用一些数据库（SQL 或 NoSQL）或其他服务来存储键引用的实际数据。企业应用程序几乎完全使用这种结构。

# 在客户端上存储状态

首先，我们将开发在客户机上存储状态的代码。发送用户输入和新的完全和部分匹配数所需的表单还包含用户当时给出的所有猜测和答案的所有先前颜色。为此，我们创建了一个新的助手类来格式化 HTML 代码。这是在现代企业环境中使用模板、JSP 文件完成的，或者完全避免在企业环境中使用纯 REST 和单页应用程序。然而，在这里，我们将使用旧技术来演示在现代发动机罩下旋转的齿轮：

```
package packt.java9.by.example.mastermind.servlet; 

import packt.java9.by.example.mastermind.Color; 
import packt.java9.by.example.mastermind.Table; 

import javax.inject.Inject; 
import javax.inject.Named; 

public class HtmlTools { 
    @Inject 
    Table table; 

    @Inject 
    @Named("nrColumns") 
    private int NR_COLUMNS; 

    public String tag(String tagName, String... attributes) { 
        StringBuilder sb = new StringBuilder(); 
        sb.append("<").append((tagName)); 
        for (int i = 0; i < attributes.length; i += 2) { 
            sb.append(" "). 
                    append(attributes[i]). 
                    append("=\""). 
                    append(attributes[i + 1]). 
                    append("\""); 
        } 
        sb.append(">"); 
        return sb.toString(); 
    } 

    public String inputBox(String name, String value) { 
        return tag("input", "type", "text", "name", name, "value", value, "size", "1"); 
    } 

    public String colorToHtml(Color color, int row, int column) { 
        return tag("input", "type", "hidden", "name", paramNameGuess(row, column), 
                "value", color.toString()) + 
                tag("div", "class", "color" + color) + 
                tag("/div") + 
                tag("div", "class", "spacer") + 
                tag("/div"); 
    } 

    public String paramNameFull(int row) { 
        return "full" + row; 
    } 

    public String paramNamePartial(int row) { 
        return "partial" + row; 
    } 

    public String paramNameGuess(int row, int column) { 
        return "guess" + row + column; 
    } 

    public String tableToHtml() { 
        StringBuilder sb = new StringBuilder(); 
        sb.append("<html><head>"); 
        sb.append("<link rel=\"stylesheet\" type=\"text/css\" href=\"colors.css\">"); 
        sb.append("<title>Mastermind guessing</title>"); 
        sb.append("<body>"); 
        sb.append(tag("form", "method", "POST", "action", "master")); 

        for (int row = 0; row < table.nrOfRows(); row++) { 
            for (int column = 0; column < NR_COLUMNS; column++) { 
                sb.append(colorToHtml(table.getColor(row, column), row, column)); 
            } 

            sb.append(inputBox(paramNameFull(row), "" + table.getFull(row))); 
            sb.append(inputBox(paramNamePartial(row), "" + table.getPartial(row))); 
            sb.append("<p>"); 
        } 
        return sb.toString(); 
    } 
}

```

除了`@Inject`注释，其余代码都简单明了。我们稍后会关注`@Inject`，但很快会。我们必须关注的是代码生成的 HTML 结构。生成的页面将如下所示：

```
<html> 
    <head> 
        <link rel="stylesheet" type="text/css" href="colors.css"> 
        <title>Mastermind guessing</title> 
        <body> 
            <form method="POST" action="master"> 
                <input type="hidden" name="guess00" value="3"> 
                <div class="color3"></div> 
                <div class="spacer"></div> 
                <input type="hidden" name="guess01" value="2"> 
                <div class="color2"></div> 
                <div class="spacer"></div> 
                <input type="hidden" name="guess02" value="1"> 
                <div class="color1"></div> 
                <div class="spacer"></div> 
                <input type="hidden" name="guess03" value="0"> 
                <div class="color0"></div> 
                <div class="spacer"></div> 
                <input type="text" 
                       name="full0" value="0" size="1"> 
                <input type="text" 
                       name="partial0" value="2" size="1"> 
                <p> 
                <input type="hidden" name="guess10" value="5"> 
                <div class="color5"></div> 

...deleted content that just looks almost the same... 

                <p> 
                <input type="submit" value="submit"> 
            </form> 
        </body> 
    </head> 
</html>

```

该表单包含 DIV 标记形式的颜色，还包含隐藏字段中颜色的“字母”。这些输入字段在提交表单时发送到服务器，就像其他字段一样，但它们不会出现在屏幕上，用户无法编辑它们。完全匹配和部分匹配显示在文本输入字段中。由于无法在 HTML 文本中显示`Color`对象，因此我们使用`LetteredColor`和`LetteredColorFactory`，它们将单个字母指定给颜色。前 6 种颜色简单编号为`0`、`1`、`2`、`3`、`4`和`5`。CSS 文件可以控制颜色在浏览器窗口上的外观。您可能还记得，我们介绍了如何以及在何处实现单个颜色的显示。首先，我们创建了一个特殊的打印类，该类将字母分配给已经存在的颜色，但这只能在非常有限的环境中使用（主要是单元测试）。现在，问题又来了。我们有字母颜色，但现在我们需要真正的颜色，因为这一次我们有一个客户端显示器，能够显示颜色。现代网络技术的真正力量在这里闪耀。内容和格式可以相互分离。不同颜色的钉子在 HTML 中列为`div`标记。它们有一个格式化类，但实际外观是在 CSS 文件中定义的，该文件只负责外观：

```
.color0 { 
    background: red; 
    width : 20px; 
    height: 20px; 
    float:left 
} 
.color1 { 
    background-color: green; 
    width : 20px; 
    height: 20px; 
    float:left 
} 
... .color2 to .color5 is deleted, content is the same except different colors ... 

.spacer { 
    background-color: white; 
    width : 10px; 
    height: 20px; 
    float:left 
}

```

# Guice 依赖注入

servlet 类非常简单，如下所示：

```
package packt.java9.by.example.mastermind.servlet; 

import com.google.inject.Guice; 
import com.google.inject.Injector; 
import org.slf4j.Logger; 
import org.slf4j.LoggerFactory; 

import javax.servlet.ServletException; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
import java.io.IOException; 

public class Mastermind extends HttpServlet { 
    private static final Logger log = LoggerFactory.getLogger(Mastermind.class); 

    public void doGet(HttpServletRequest request, 
                      HttpServletResponse response) 
            throws ServletException, IOException { 
        doPost(request, response); 
    } 

    public void doPost(HttpServletRequest request, 
                       HttpServletResponse response) 
            throws ServletException, IOException { 

        Injector injector =  
            Guice.createInjector(new MastermindModule()); 
        MastermindHandler handler =  
            injector.getInstance(MastermindHandler.class); 
        handler.handle(request, response); 
    } 
}

```

由于许多线程同时使用 servlet，因此我们不能使用实例字段来保存单个命中的数据，servlet 类除了创建一个`MastermindHandler`类的新实例并调用其`handle`方法外，什么都不做。因为每个请求都有一个新的`MastermindHandler`实例，所以它可以在特定于请求的字段中存储对象。要创建处理程序，我们使用 Google 创建的 Guice 库。

我们已经讨论过依赖注入。处理程序需要一个`Table`对象来播放，一个`ColorManager`对象来管理颜色，一个`Guesser`对象来创建新的猜测，但创建这些或从某处获取一些预制实例不是处理程序的核心功能。处理程序必须做一件事：处理请求；执行此操作所需的实例应该从外部注入。这是由一个`Guice`喷油器完成的。

要使用 Guice，我们必须在`build.gradle`中列出依赖项中的库：

```
apply plugin: 'java' 
apply plugin: 'jetty' 

repositories { 
    jcenter() 
} 

dependencies { 
    providedCompile "javax.servlet:javax.servlet-api:3.1.0" 
    testCompile 'junit:junit:4.12' 
    compile 'org.slf4j:slf4j-api:1.7.7' 
    compile 'ch.qos.logback:logback-classic:1.0.11' 
    compile 'com.google.inject:guice:4.1.0' 
} 

jettyRun { 
    contextPath '/hello' 
}

```

然后我们必须创建一个`injector`实例来执行注入。使用 servlet 中的以下行创建喷油器：

```
Injector injector = Guice.createInjector(new MastermindModule());

```

`MastermindModule`的实例指定在何处注入什么。这本质上是一个 Java 格式的配置文件。其他依赖注入框架使用 XML 和注释来描述注入绑定以及在何处注入内容，但 Guice 仅使用 Java 代码。以下是 DI 配置代码：

```
public class MastermindModule extends AbstractModule { 
    @Override 
    protected void configure() { 
        bind(int.class) 
          .annotatedWith(Names.named("nrColors")).toInstance(6); 
        bind(int.class) 
          .annotatedWith(Names.named("nrColumns")).toInstance(4); 
        bind(ColorFactory.class).to(LetteredColorFactory.class); 
        bind(Guesser.class).to(UniqueGuesser.class); 
    } 
}

```

`configure`方法中使用的方法是以流畅的 API 方式创建的，这样方法可以一个接一个地链接起来，代码可以像英语句子一样阅读。有关 fluent API 的详细介绍，请访问[https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/) 。例如，第一个配置行可以用英语读作

*绑定到*`int`*类，无论该类在何处被注释为*`@Name`*注释，该注释对实例*`6`具有`"nrColor"`*值。*

（注意，`int`值`6`是自动装箱到`Integer`实例的。）

`MastermindHandler`类包含带`@Inject`注释的字段：

```
@Inject 
@Named("nrColors") 
private int NR_COLORS; 
@Inject 
@Named("nrColumns") 
private int NR_COLUMNS; 
@Inject 
private HtmlTools html; 
@Inject 
Table table; 
@Inject 
ColorManager manager; 
@Inject 
Guesser guesser;

```

此注释不是特定于 Guice 的。`@Inject`是`javax.inject`包的一部分，是 JDK 的标准部分。JDK 不提供**依赖注入器**（**DI**）框架，但支持不同的框架，以便它们可以使用标准的 JDK 注释，如果替换 DI 框架，注释可能保持不变，而不是特定于框架。

当调用 injector 创建一个`MastermindHandler`实例时，它查看该类，发现它有一个`int`字段，用`@Inject`和`@Named("nrColors")`注释，并在配置中发现该字段的值应为 6。它在返回`MastermindHandler`对象之前将值注入字段。类似地，它还将值注入到其他字段中，如果它应该创建任何要注入的对象，它就会这样做。如果这些对象中有字段，那么它们也是通过注入其他对象等方式创建的。

通过这种方式，DI 框架消除了程序员创建实例的负担。这是一件相当无聊的事情，而且无论如何也不是类的核心特性。相反，它创建了所有需要具有功能性`MastermindHandler`的对象，并通过 Java 对象引用将它们链接在一起。这样，不同对象的依赖关系（`MastermindHandler`需要`Guesser`、`ColorManager`和`Table`、`ColorManager`需要`ColorFactory`、`Table`也需要`ColorManager`等等）就变成了一个声明，使用字段上的注释来指定。这些声明在类的代码中，它是它们的正确位置。除了类本身之外，我们还能在哪里指定类需要什么才能正常工作？

我们示例中的配置规定，无论哪里需要`ColorFactory`，我们都将使用`LetteredColorFactory`，无论哪里需要`Guesser`，我们都将使用`UniqueGuesser`。这是从代码中分离出来的，它必须是这样的。如果我们想改变猜测策略，我们将替换配置，代码应该在不修改使用猜测器的类的情况下工作。

Guice 足够聪明，您无需指定需要`Table`的地方，我们将使用`Table`：没有`bind(Table.class).to(Table.class)`。首先，我在配置中创建了一行这样的代码，但是 Guice 给了我一条错误消息，现在，我又用简单的英语写了一遍，我觉得自己真的很愚蠢。如果我需要一张桌子，我需要一张桌子。真正地

# MastermindHandler 类

我们已经开始了`MastermindHandler`类的列表，因为这个类有一百多行，所以我不会把它作为一个整体包含在这里。本课程最重要的方法是`handle`：

```
public void handle(HttpServletRequest request, 
                   HttpServletResponse response) 
        throws ServletException, IOException { 

    Game game = buildGameFromRequest(request); 
    Guess newGuess = guesser.guess(); 
    response.setContentType("text/html"); 
    PrintWriter out = response.getWriter(); 
    if (game.isFinished() || newGuess == Guess.none) { 
        displayGameOver(out); 
    } else { 
        log.debug("Adding new guess {} to the game", newGuess); 
        game.addGuess(newGuess, 0, 0); 
        displayGame(out); 
    } 
    bodyEnd(out); 
}

```

我们执行三个步骤。第 1 步是创建表，我们根据请求进行创建。如果这不是游戏的开始，那么已经有一个表，HTML 表单包含所有以前的猜测颜色和这些颜色的答案。然后，作为第二步，我们在此基础上创建一个新的猜测。第 3 步是将新的 HTML 页面发送到客户端。

同样，这不是一种现代的方法，在 servlet 代码上创建 HTML，但通过一些框架演示 REST、JSON 和 JavaScript 的纯 servlet 功能将使本章仅长达数百页，而且它肯定会分散我们对 Java 的注意力。

在本书中，将 HTML 文本打印到`PrintWriter`对您来说并不是什么新鲜事；因此，我们不会在这里列出该代码。您可以在 GitHub 上下载工作示例。此版本代码的分支为`nosession`。我们将重点关注 servlet 参数处理，而不是打印。

请求参数可通过`getParameter`方法获得，该方法返回参数的字符串值。此方法假设任何参数，无论是`GET`还是`POST`，在请求中只出现一次。如果存在多次出现的参数，则该值应为字符串数组。在这种情况下，我们应该使用`getParameterMap`，它返回带有`String`键和`String[]`值的整个地图。即使我们这次没有任何键的多个值，并且我们也知道键的值作为`POST`参数，我们仍然将使用后一种方法。这样做的原因是我们稍后将使用会话来存储这些值，并且我们希望有一个在这种情况下可重用的方法。

如果您查看 Git 存储库中早期的提交，您将看到第一个版本使用了`getParameter`，我只是在稍后创建程序的第二个版本时对其进行了重构，该版本将状态存储在会话中。如果有人告诉你程序是在开发过程中完全预先创建的，没有任何重构，千万不要相信。不要为创建愚蠢的代码并在以后重构而感到羞耻。如果你不重构它，那才是可耻的。

为此，我们将请求的`Map<String,String[]>`转换为`Map<String,String>`：

```
private Game buildGameFromRequest(HttpServletRequest request) { 
    return buildGameFromMap(toMap(request)); 
} 
private Map<String, String> toMap(HttpServletRequest request) { 
    log.debug("converting request to map"); 
    return request.getParameterMap().entrySet(). 
            stream().collect( 
                    Collectors.toMap( 
                            Map.Entry::getKey, 
                            e -> e.getValue()[0])); 
}

```

然后，我们使用该地图重新创建游戏：

```
private Game buildGameFromMap(Map<String, String> params) { 
    final Guess secret = new Guess(new Color[NR_COLUMNS]); 
    final Game game = new Game(table, secret); 
    for (int row = 0; 
         params.containsKey(html.paramNameGuess(row, 0)); 
         row++) { 
        Color[] colors = getRowColors(params, row); 
        Guess guess = new Guess(colors); 
        final int full = Integer.parseInt(params.get(html.paramNameFull(row))); 
        final int partial = Integer.parseInt(params.get(html.paramNamePartial(row))); 
        log.debug("Adding guess to game"); 
        game.addGuess(guess, full, partial); 
    } 
    return game; 
}

```

从`String`到`int`的转换通过`parseInt`方法完成。当输入不是数字时，此方法抛出`NumberFormatException`。试着运行游戏，使用浏览器，看看当 servlet 抛出异常时 Jetty 是如何处理的。你在浏览器中看到多少有价值的信息可以被潜在的黑客使用？修复代码，以便它再次询问用户是否有任何数字格式不正确！

# 在服务器上存储状态

应用程序状态通常不应保存在客户端上。除了编写教育代码并希望演示如何操作之外，可能还有一些特殊情况。通常，与实际使用相关的应用程序状态存储在会话对象或某个数据库中。当应用程序要求用户输入大量数据并且不希望用户在客户端计算机出现故障时丢失工作时，这一点尤为重要。

你花了很多时间在网上商店里挑选合适的物品，选择合适的共同工作的物品，为你的新模型飞机创建一个配置，突然，你家里停电了。如果状态存储在客户机上，则必须从头开始。如果状态存储在服务器上，则状态保存到磁盘；服务器是复制的，由电池供电，当你重新启动你的客户机，当电源回到家里，你登录，奇迹般地，所有的东西都在你的购物篮里。嗯，这不是奇迹；这是网络编程。

在我们的例子中，第二个版本将在会话中存储游戏的状态。这将允许用户在会话存在时恢复游戏。如果用户退出并重新启动浏览器，会话将丢失，新游戏可以开始。

由于这次不需要在隐藏字段中发送实际颜色和匹配，因此 HTML 生成会稍微修改，生成的 HTML 也会更简单：

```
<html> 
<head> 
    <link rel="stylesheet" type="text/css" href="colors.css"> 
    <title>Mastermind guessing</title> 
<body> 
<form method="POST" action="master"> 
    <div class="color3"></div> 
    <div class="spacer"></div> 
    <div class="color2"></div> 
    <div class="spacer"></div> 
    <div class="color1"></div> 
    <div class="spacer"></div> 
    <div class="color0"></div> 
    <div class="spacer"></div>0 
    <div class="spacer"></div>2<p> 
    <div class="color5"></div> 
... 
    <div class="spacer"></div> 
    <div class="color1"></div> 
    <div class="spacer"></div> 
    <input type="text" name="full2" value="0" size="1"><input type="text" name="partial2" value="0" size="1"> 
    <p> 
        <input type="submit" value="submit"> 
</form> 
</body> 
</head></html>

```

完全匹配和部分匹配的颜色数显示为一个简单的数字，因此此版本不允许*欺骗*或更改以前的结果。（这些是 CSS 类为`spacer`的`div`标记后面的数字`0`和`2`。）

`MastermindHandler`中的`handle`方法也发生了变化，如下图：

```
public void handle(HttpServletRequest request, 
                   HttpServletResponse response) 
        throws ServletException, IOException { 

    Game game = buildGameFromSessionAndRequest(request); 
    Guess newGuess = guesser.guess(); 
    response.setContentType("text/html"); 
    PrintWriter out = response.getWriter(); 
    if (game.isFinished() || newGuess == Guess.none) { 
        displayGameOver(out); 
    } else { 
        log.debug("Adding new guess {} to the game", newGuess); 
        game.addGuess(newGuess, 0, 0); 
        sessionSaver.save(request.getSession()); 
        displayGame(out); 
    } 
    bodyEnd(out); 
}

```

这个版本的类获得一个由 Guice 注入器注入的`SessionSaver`对象。这是我们创建的一个类。此类将当前表转换为存储在会话中的内容，并且还将根据存储在会话中的数据重新创建表。`handle`方法使用`buildGameFromSessionAndRequest`方法恢复表，并添加用户刚才在请求中给出的完整和部分匹配答案。当该方法创建一个新的猜测并将其填入表中，并在响应中将其发送给客户端时，它通过`sessionSaver`对象调用`save`方法将状态保存在会话中。

`buildGameFromSessionAndRequest`方法取代了另一个版本，我们将其命名为`buildGameFromRequest`：

```
private Game buildGameFromSessionAndRequest(HttpServletRequest request) { 
    Game game = buildGameFromMap(sessionSaver.restore(request.getSession())); 
    Map<String, String> params = toMap(request); 
    int row = getLastRowIndex(params); 
    log.debug("last row is {}", row); 
    if (row >= 0) { 
        final int full = Integer.parseInt(params.get(html.paramNameFull(row))); 
        final int partial = Integer.parseInt(params.get(html.paramNamePartial(row))); 
        log.debug("setting full {} and partial {} for row {}", full, partial, row); 
        table.setPartial(row, partial); 
        table.setFull(row, full); 
        if (full == table.nrOfColumns()) { 
            game.setFinished(); 
        } 
    } 
    return game; 
}

```

请注意，这个版本与使用 JDK 中`Integer`类中的`parseInt`方法有相同的问题，该方法会引发异常。

# GameSessionSaver 类

此类有三个公共方法：

*   `save`：将一个表保存到用户会话
*   `restore`：从用户会话中获取一个表
*   `reset`：删除会话中可能存在的任何表

该类的代码如下所示：

```
public class GameSessionSaver { 
    private static final String STATE_NAME = "GAME_STATE"; 
    @Inject 
    private HtmlTools html; 
    @Inject 
    Table table; 
    @Inject 
    ColorManager manager; 

    public void save(HttpSession session) { 
        Map<String,String> params = convertTableToMap(); 
        session.setAttribute(STATE_NAME,params); 
    } 

    public void reset(HttpSession session) { 
        session.removeAttribute(STATE_NAME); 
    } 

    public Map<String,String> restore(HttpSession session){ 
        Map<String,String> map= 
                    (Map<String,String>) 
                            session.getAttribute(STATE_NAME); 
        if( map == null ){ map = new HashMap<>(); } 
        return map; 
    } 

    private Map<String,String> convertTableToMap() { 
        Map<String, String> params = new HashMap<>(); 
        for (int row = 0; row < table.nrOfRows(); row++) { 
            for (int column = 0; 
                 column < table.nrOfColumns(); column++) { 
                params.put(html.paramNameGuess(row,column), 
                           table.getColor(row,column).toString()); 
            } 
            params.put(html.paramNameFull(row), 
                           ""+table.getFull(row)); 
            params.put(html.paramNamePartial(row), 
                           ""+table.getPartial(row)); 
        } 
        return params; 
    } 
}

```

当我们保存会话并将表转换为映射时，我们使用`HashMap`。在这种情况下，实现非常重要。`HashMap`类实现`Serializable`接口；因此，我们可以放心地将其提交会议。仅此一点并不能保证`HashMap`中的所有内容都是`Serializable`。本例中的键和值是字符串，幸运的是，`String`类还实现了`Serializable`接口。这样，转换后的`HashMap`对象可以安全地存储在会话中。

还要注意的是，尽管序列化可能很慢，但在会话中存储`HashMap`是如此频繁，以至于它实现了自己的序列化机制。此实现经过优化，避免了序列化依赖于映射的内部结构。

现在是时候思考一下为什么我们在这门课上使用`convertTableToMap`方法，而在`MastermindHandler`中使用`buildGameFromMap`方法。将游戏和其中的桌子转换为`Map`和另一种方式应该一起实现。它们只是相同转换的两个方向。另一方面，`Table`至`Map`指令的执行应使用`Map`版本，即`Serializable`。这与会话处理密切相关。一般来说，将一个`Map`对象转换为`Table`对象需要更高一级，从存储表的任何位置（客户端、会话、数据库或云中）恢复表。会话存储只是一种可能的实现，方法应该在满足抽象级别的类中实现。
最好的解决方案可能是在单独的类中实现这些。你有作业！

处理程序未使用`reset`方法。这是从`Mastermind`类调用的，即 servlet 类在我们启动游戏时重置游戏：

```
public void doGet(HttpServletRequest request, 
                  HttpServletResponse response) 
        throws ServletException, IOException { 
    GameSessionSaver sessionSaver = new GameSessionSaver(); 
    sessionSaver.reset(request.getSession()); 
    doPost(request, response); 
}

```

如果没有这一点，在机器上玩一次游戏，每次我们想重新启动它时，只会显示完成的游戏，直到我们退出浏览器并重新启动它，或者在浏览器的高级菜单中明确删除`JSESSIONID`cookie。调用`reset`不会删除会话。会话保持不变，因此`JSESSIONID`的值也保持不变，但游戏将从 servlet 容器维护的会话对象中删除。

# 运行 JettyWebservlet

因为我们已经将 Jetty 插件包含在 Gradle 构建中，所以插件的目标是可用的。要启动 Jetty，只需键入以下内容：

```
    gradle jettyRun

```

这将编译代码，构建 WAR 文件，并启动 Jetty servlet 容器。为了帮助我们记住，它还在命令行上打印以下内容：

```
    Running at http://localhost:8080//hello

```

我们可以打开此 URL 并查看游戏的打开屏幕，其中的颜色是程序作为第一个猜测创建的：

![](../images/00046.jpeg)

现在是时候玩我们的游戏了，给我们的节目提供答案。不要让代码变得简单！请参阅以下屏幕截图：

![](../images/00047.jpeg)

同时，如果您查看输入了`gradle jettyRun`的控制台，您将看到代码正在打印日志消息，如以下屏幕截图所示：

![](../images/00048.gif)

这些打印输出通过我们代码中的记录器进行。在前面的章节中，我们使用`System.out.println`方法调用向控制台发送信息性消息。在任何比*hello world*更复杂的程序中，都不应遵循这种做法

# 登录中

Java 有几种可用的日志框架，每种都有其优缺点。`java.util.logging`包中有一个内置于 JDK 中，`System.getLogger`方法支持访问记录器：`System.Logger`和`System.LoggerFinder`类。尽管自 JDK1.4 以来，`java.util.logging`已在 Java 中可用，但许多程序使用其他日志解决方案。除了内置的日志记录之外，我们还要提到`log4j`、`slf4j`和 Apache Commons 日志记录。在深入了解不同框架的细节之前，让我们先讨论一下为什么使用日志记录而不仅仅是打印到标准输出非常重要。

# 可配置性

最重要的原因是可配置性和易用性。我们使用日志记录有关代码操作的信息。这不是应用程序的核心功能，但拥有可操作的程序是不可避免的。我们在日志中打印了一些信息，操作人员可以使用这些信息来识别环境问题。例如，当抛出一个`IOException`并记录它时，操作可能会查看日志并确定磁盘已满。他们可以删除文件，或者添加新磁盘并扩展分区。如果没有日志，唯一的信息就是程序无法运行。

这些日志也被多次用于查找 bug。有些 bug 不会在测试环境中出现，并且很难重现。在这种情况下，打印有关代码执行的详细信息的日志是查找某些错误的根本原因的唯一来源。

由于日志记录需要 CPU、IO 带宽和其他资源，因此应该仔细检查日志记录的内容和时间。这个检查和决定可以在编程期间完成，事实上，如果我们使用`System.out.println`进行日志记录，这是唯一的可能性。如果我们需要找到一个 bug，我们应该记录很多。如果我们记录很多日志，系统的性能就会下降。结论是，我们只有在需要时才需要记录。如果系统中存在无法复制的 bug，开发人员会要求操作在短时间内打开调试日志记录。当使用`System.out.println`时，无法打开和关闭记录的不同部分。打开调试级别日志时，性能可能会下降一段时间，但与此同时，日志可用于分析。同时，如果有一个小的（几百兆字节的日志文件）而不是大量的 2-GB 压缩日志文件来查找其中的行，那么当我们必须查找相关的日志行（并且您事先不知道哪些相关）时，分析就更简单了。

使用日志框架，您可以定义标识日志消息源和日志级别的记录器。字符串通常标识记录器，通常使用从中创建日志消息的类的名称。这是一种常见的做法，不同的日志框架提供工厂类，这些工厂类获取类本身，而不是其名称，以获取记录器。

在不同的日志框架中，可能的日志记录级别可能略有不同，但最重要的级别如下：

*   `FATAL`：当日志消息是关于阻止程序继续执行的某个错误时，使用此选项。
*   `ERROR`：当出现严重错误时使用，但程序仍可以继续运行，尽管可能以某种有限的方式运行。
*   `WARNING`：当存在一些不是直接问题的情况，但如果不注意，可能随后导致错误时，使用此选项。例如，程序会识别磁盘已接近满，某些数据库连接的响应在限制范围内但接近超时值，以及类似情况。
*   `INFO`：用于创建有关正常操作的消息，这些消息可能对操作感兴趣，而不是错误或警告。这些消息可能有助于操作调试操作环境设置。
*   `DEBUG`：这用于记录有关程序的信息，这些信息足够详细（希望如此），可以在代码中找到 bug。诀窍在于，当我们将 log 语句放入代码中时，我们不知道它可能是什么 bug。如果我们知道，我们最好把它修好。
*   `TRACE`：这是关于代码执行的更详细的信息。

日志框架通常使用一些配置文件进行配置。配置可能会限制日志记录，关闭某些级别。在正常的操作环境中，前三级通常打开，`INFO`、`DEBUG`和`TRACE`在真正需要时打开。也可以仅为某些记录器打开和关闭某些级别。如果我们知道错误肯定在`GameSessionSaver`类中，那么我们只能为该类打开`DEBUG`级别。

日志文件还可能包含我们没有直接编码的其他信息，打印到标准输出时会非常麻烦。通常，每条日志消息都包含创建消息的精确时间、日志记录器的名称，并且很多时候还包含线程的标识符。想象一下，如果你被迫把所有这些都放在每一个论点上；您可能很快就会编写一些额外的类来实现这一点。不要！它已经专业地完成了：它是记录器框架。

记录器还可以配置为将消息发送到不同的位置。登录到控制台只是一种可能性。日志框架准备将消息发送到文件、数据库、Windows 事件记录器、系统日志服务或任何其他目标。这种灵活性，即打印哪条消息、打印哪些额外信息以及打印到哪里，是通过按照单一责任原则将记录器框架执行的不同任务划分为几个类来实现的。

logger 框架通常包含创建日志的 logger、多次根据原始日志信息格式化消息（添加线程 ID 和时间戳等信息）的格式化程序，以及将格式化消息附加到某个目标的附加程序。这些类实现了日志框架中定义的接口，除了书的大小之外，没有什么可以阻止我们创建自己的格式化程序和附加程序。

配置日志时，将根据实现它们的类配置附加程序和格式化程序。因此，当您想要将一些日志发送到某个特殊的目的地时，您并不局限于框架作者提供的附加器。对于不同的日志框架，有许多独立的开源项目为不同的目标提供 appender。

# 表演

使用日志框架的第二个原因是性能。虽然在我们分析代码之前进行性能优化（过早优化）是不好的，但使用一些已知速度慢的方法并在性能关键的代码中插入几行代码，调用速度慢的方法也不是很专业。以行业最佳实践的方式使用一个完善的、高度优化的框架应该是毫无疑问的。

使用`System.out.println`将消息发送到流，并且仅在 IO 操作完成时返回。使用 real logging 将信息处理到 logger，并允许 logger 异步进行日志记录，而不等待完成。如果出现系统故障，日志信息可能会丢失，这确实是一个缺点，但考虑到这种情况很少发生，以及另一方面的问题：性能，这通常不是一个严重的问题。如果磁盘已满时缺少调试日志行，导致系统无法使用，我们会损失什么？

有一个例外情况：出于法律原因必须保存有关系统事务的某些日志信息，以便对操作和实际事务进行审核时，进行审核日志记录。在这种情况下，以事务方式保存日志信息，使日志成为事务的一部分。因为这是一种完全不同的需求类型，所以审计日志记录通常不会使用这些框架中的任何一个来完成。

另外，`System.out.println`是不同步的，这样不同的线程可能会扰乱输出。日志框架关注这个问题。

# 日志框架

使用最广泛的日志框架是**Apache****log4j**。它目前有一个第二个版本，完全重写了第一个版本。它是非常通用的，有许多附加器和格式化程序。log4j 的配置可以是 XML 或属性文件格式，也可以通过 API 进行配置。

log4j 版本 1 的作者创建了一个新的日志框架：**slf4j**。这个日志库本质上是一个 façade，可以与任何其他日志框架一起使用。因此，当您在开发的库中使用 slf4j，并且您的代码作为使用不同日志框架的依赖项添加到程序中时，很容易将 slf4j 配置为将日志发送到另一个框架的日志记录器。因此，日志将一起处理，而不是在单独的文件中，这有助于降低操作成本。在开发库代码或使用 slf4j 的应用程序时，无需选择其他日志框架来创建 slf4j。它有自己的简单实现，称为 backlog。

ApacheCommons 日志也是一种假象，如果没有其他失败的话，它有自己的日志实现。与 slf4j 的主要区别在于，它在配置和使用底层日志方面更加灵活，并且它实现了一个运行时算法，以发现可用的日志框架和要使用的日志框架。行业最佳实践表明，这种灵活性是不需要的，它还具有更高的复杂性和成本。

# Java9 日志记录

Java9 包括一个用于日志记录的 facade 实现。使用非常简单，我们可以预期日志框架将很快开始支持这种外观。该立面内置于 JDK 中这一事实有两大优势：

*   想要记录日志的库不再需要依赖于任何日志框架或日志 façade。唯一的依赖是 JDK 日志外观，不管怎样，它都在那里。
*   记录自己日志的 JDK 库使用这个 façade，因此它们将登录到与应用程序相同的日志文件中。

如果我们使用 JDK 提供的日志 façade，`ColorManager`类的开头将更改为以下内容：

```
package packt.java9.by.example.mastermind; 

import javax.inject.Inject; 
import javax.inject.Named; 
import javax.inject.Singleton; 
import java.util.HashMap; 
import java.util.Map; 
import java.lang.System.Logger; 

import static java.lang.System.Logger.Level.DEBUG; 

@Singleton 
public class ColorManager { 
    protected final int nrColors; 
    protected final Map<Color, Color> successor = new HashMap<>(); 
    private Color first; 
    private final ColorFactory factory; 
    private static final Logger log = System.getLogger(ColorManager.class.getName()); 

    @Inject 
    public ColorManager(@Named("nrColors") int nrColors, 
                                           ColorFactory factory) { 
        log.log(DEBUG,"creating colorManager for {0} colors", 
                                           nrColors);

```

在此版本中，我们不导入 slf4j 类。相反，我们导入`java.lang.System.Logger`类。

注意，我们不需要导入系统类，因为`java.lang`包中的类是自动导入的。对于在`System`类中嵌套的类，情况并非如此。

要访问记录器，调用`System.getLogger`静态方法。此方法查找可用的实际记录器，并为作为参数传递的名称返回一个记录器。没有接受类作为参数的方法`getLogger`版本。如果我们想遵守约定，那么我们必须编写`ColorManager.class.getName()`来获取类名，或者我们可以将类名作为字符串写入其中。第二种方法的缺点是，它不遵循类名称的更改。智能 IDE（如 IntelliJ、Eclipse 或 Netbeans）会自动重命名对类的引用，但当在字符串中使用类名时，它们会遇到困难。

接口`System.Logger`没有声明其他日志框架和 façade 所熟悉的方便方法`error`、`debug`、`warning`等。只有一个名为`log`的方法，该方法的第一个参数是我们发出的实际日志的级别。定义了八个级别：`ALL`、`TRACE`、`DEBUG`、`INFO`、`WARNING`、`ERROR,`和`OFF`。创建日志消息时，我们应该使用中间的六个级别之一。`ALL`和`OFF`将传递给`isLoggable`方法。此方法可用于检查是否记录了实际日志记录级别。例如，如果级别设置为`INFO`，则不会打印使用`DEBUG`或`TRACE`发送的消息。

实际实现由 JDK 使用服务加载器功能定位。日志实现必须位于通过某种实现提供接口`java.lang.System.LoggerFinder`的模块中。换句话说，模块应该有一个实现`LoggerFinder`接口的类，`module-info.java`应该声明它正在使用哪个类的代码：

```
provides java.lang.System.LoggerFinder with 
                            packt.java9.by.example.MyLoggerFinder;

```

`MyLoggerFinder`类必须使用`getLogger`方法扩展`LoggerFinder`抽象类。

# 测井实践

测井的实践非常简单。如果您不想花太多时间试验不同的日志记录解决方案，并且没有特殊要求，那么只需使用 slf4j，将 JAR 作为编译依赖项添加到依赖项列表中，并开始在源代码中使用日志记录。

由于日志记录不是特定于实例的，并且记录器实现线程安全，因此我们通常使用的日志对象存储在一个`static`字段中，并且由于只要使用该类，就使用它们，因此运行该字段的程序也是`final`。例如，使用 slf4j façade，我们可以使用以下命令获取记录器：

```
private static final Logger log = 
           LoggerFactory.getLogger(MastermindHandler.class);

```

要获取记录器，使用记录器工厂，它只创建记录器或返回已经可用的记录器。

变量的名称通常为`log`或`logger,`，但如果您看到`LOG`或`LOGGER`，请不要感到惊讶。将变量名称大写的原因是，一些静态代码分析检查器将`static final`变量视为常量，因为它们实际上是常量，Java 社区的惯例是对这些变量使用大写名称。这是品味的问题；很多时候`log`和`logger`都是小写的。

要创建日志项，请使用方法`trace`、`debug`、`info`、`warn`和`error`创建一条消息，其级别如名称所示。例如，考虑下面的一行：

```
log.debug("Adding new guess {} to the game", newGuess);

```

它会创建一条调试消息。Slf4j 支持在字符串中使用`{}`文本进行格式化。这样，就不需要从小部分追加字符串，如果实际的日志项没有发送到日志目标，则不会执行格式化。如果我们以任何形式使用`String`串联来传递字符串作为参数，那么即使按照示例不需要调试日志记录，也会发生格式化。

日志记录方法的版本也只有两个参数：一个`String`消息和一个`Throwable`。在这种情况下，日志框架将负责异常的输出和堆栈跟踪。如果您在异常处理代码中记录了某些内容，请记录该异常并让记录器对其进行格式化。

# 其他技术

我们讨论了 servlet 技术，一些 JavaScript、HTML 和 CSS。在真正的专业环境中编程时，通常会使用这些技术。然而，应用程序用户界面的创建并不总是基于这些技术。较旧的操作系统本机 GUI 应用程序以及 Swing、AWT 和 SWT 使用不同的方法创建 UI。它们通过程序代码构建面向用户的 UI，UI 构建为组件的层次结构。当 web 编程开始时，Java 开发人员拥有类似技术的经验，项目创建了试图隐藏 web 技术层的框架。

值得一提的一项技术是 GoogleWebToolkit，它用 Java 实现服务器和浏览器代码，但由于浏览器中没有实现 Java 环境，它将代码的客户端部分从 Java 传输（转换）到 JavaScript。该工具包的上一个版本创建于两年前的 2014 年，此后谷歌发布了其他类型的 web 编程工具包，支持原生 JavaScript、HTML 和 CSS 客户端开发。

**Vaadin**也是您可能会遇到的工具包。它允许您在服务器上用 Java 编写 GUI 代码。它建立在 GWT 之上，并得到商业支持。如果有开发人员具有 Java GUI 开发经验，但没有 web 本机技术的经验，并且应用程序不需要在客户端进行特殊的可用性调优，那么这可能是一个不错的选择。典型的企业内部网应用程序可以选择它作为一种技术。

**Java Server Faces**（**JSF**）是一种技术，它试图将应用程序的客户端开发从提供随时可用的小部件的开发人员和服务器端卸载。它是几个**Java 规范请求**（**JSR**的集合，有几个实现。组件及其关系在 XML 文件中配置，服务器创建客户端本机代码。在这种技术中，没有从 Java 到 JavaScript 的转换。这更像是使用一组有限但庞大的小部件，仅限于这些小部件，而放弃了对 web 浏览器的直接编程。但是，如果有经验和知识，他们可以用 HTML、CSS 和 JavaScript 创建新的小部件。

还有许多其他技术是为支持 Java 中的 web 应用程序而开发的。大多数大公司提倡的现代方法是使用单独的工具集和方法开发服务器端和客户端，并使用 REST 通信将两者连接起来。

# 总结

在本章中，您学习了 web 编程的结构。如果不了解 TCP/IP 网络的基础知识，这是不可能的，TCP/IP 网络是互联网的协议。通过 HTTP 使用的应用程序级协议，目前处于非常新的版本 2.0 中，servlet 标准仍然不支持该版本。我们创建了一个版本的智囊团游戏，这一次，可以真正使用浏览器来玩，我们在使用 Jetty 的开发环境中启动了它。我们研究了如何存储游戏状态，并实现了两个版本。最后，我们学习了日志记录的基础知识，并研究了其他技术。同时，我们还研究了谷歌的依赖注入实现 Guice，并研究了它在后台是如何工作的，以及为什么和如何使用它。

在本章之后，您将能够开始用 Java 开发 web 应用程序，并了解此类程序的体系结构。当您开始学习如何使用 Spring 框架对 web 应用程序进行编程时，您将了解其中的秘密，因为 Spring 框架隐藏了 web 编程的许多复杂性。