# 将 Java 知识提升到专业水平

现在，您已经了解了专业 Java 开发人员所需的最重要的领域和主题。在本书中，我们仍将讨论一些话题，这些话题将引导您从初级开发人员转变为高级开发人员。不过，阅读本章不会使任何人成为高级开发人员。前几章是我们走过的路。这一章只是地图。如果前面的每一章都涵盖了到达港口的编码旅程中几英里的短距离步行，那么这一章就是发现新大陆的航海地图。

我们将简要介绍一些非常深入和高级的专业领域，例如创建 Java 代理、编译时注释处理、多语言编程、一些架构设计和工具，以及团队合作的技术。我们只是想尝尝味道。现在，你有足够的知识来理解这些主题的重要性，尝一尝会让你对未来几年的自我发展产生兴趣，或者，至少，我的意图是让你，读者，上瘾。

# Java 深层技术

在本节中，我们将列出三种技术：

*   Java 代理
*   多语言编程
*   注释处理

对于 Java 专业人士来说，了解它们不是必须的。了解他们是一件好事。Java 代理主要用于开发环境和操作中。它们是与已经运行的*JVM*交互的复杂运行时技术。注释处理是另一端。注释处理器插入 Java 编译器。多语言编程处于中间地位。它是 JVM 编程，就像 Java 编程一样，但是通过使用一些不同的语言，或者，可能是一些不同的语言和 Java 一起使用。甚至包括许多语言，比如 Jython、Groovy、Clojure 和 Java。

我们将讨论这些技术，以便了解它们是什么，以及在哪里寻找更多信息，以防我们想了解更多。

# Java 代理

Java 代理是 Java 运行时以特殊方式加载的 Java 程序，可用于干扰加载类的字节码，从而改变它们。它们可用于：

*   在加载类时，在运行时列出或记录并报告加载的类
*   修改这些类，使这些方法包含报告运行时行为的额外代码
*   支持调试器在开发人员修改源代码时更改类的内容

例如，该技术用于[的**JRebel**和**XRebel**产品 https://zeroturnaround.com/](https://zeroturnaround.com/) 。

尽管 Java 代理处理 Java 的深层细节，但它们并不是魔术。它们有点复杂，您需要对 Java 有深入的了解，但是任何能用 Java 编程的人都可以编写 Java 代理。所需的只是该类（即代理）具有一些预定义的方法，与代理的其他类一起打包到一个*JAR*文件中，并且具有一个文件，该文件定义了实现`premain`和/或`agentmain`方法的类的名称，以及一些其他字段。

详细而精确的参考文件是*JDK JavaDoc*的一部分，可在[上找到 http://download.java.net/java/jdk9/docs/api/ `java.lang.instrument`包文件中的](http://download.java.net/java/jdk9/docs/api/)。

使用 Java 代理启动 Java 应用程序时，命令行必须包含以下选项：

```
    -javaagent:jarpath[=options]

```

这里，`jarpath`指向包含代理类和清单文件的 JAR 文件。该类必须具有名为`premain`或`agentmain`的方法。它可能有一个或两个参数。JVM 尝试在 JVM 初始化后首先调用两个参数版本：

```
public static void premain(String agentArgs, Instrumentation inst);

```

如果两个参数版本不存在，则使用一个参数版本，该版本与两个参数版本基本相同，但忽略了插装参数，在我看来，插装参数没有太多意义，因为 Java 代理没有`Instrumentation`对象无法做很多事情：

```
public static void premain(String agentArgs);

```

`agentArgs`参数是在命令行上作为选项传递的字符串。第二个参数`Instrumentation`提供了注册类转换器的方法，可以修改类字节码，还提供了可以要求 JVM 在运行时重新定义或重新转换类的方法。

Java 应用程序还可以在程序启动后加载代理。在这种情况下，不能在 Java 应用程序的主方法之前调用代理，因为此时它已经启动了。为了区分这两种情况，JVM 在这种情况下调用`agentmain`。请注意，`premain`或`agentmain`是为代理调用的，而不是两者都调用。单个代理可以同时实现这两个功能，以便能够执行在启动时加载、在命令行上指定或在 JVM 启动后加载的任务。

如果使用了`agentmain`，则其参数与`premain`相同。

`premain`和`agentmain`的调用之间有一个重要的区别。如果在启动期间无法加载代理，例如，如果找不到代理，如果 JAR 文件不存在，如果类没有`premain`方法，或者如果它抛出异常，JVM 将中止。如果在启动*JVM*后加载代理（本例中使用`agentmain`，如果代理出现错误，JVM 不会中止。

这种做法相当合理。假设有一个服务器应用程序运行在 TomcatServlet 容器上。启动新版本时，系统将关闭一段维护期。如果新版本无法启动，因为代理运行不正常，那么最好不要启动。调试并修复该情况，或将应用程序回滚到旧版本并调用更长的修复会话所造成的损害可能比启动应用程序且没有适当的代理功能要小。如果应用程序仅在没有代理的情况下启动，则可能无法立即识别次优操作。
另一方面，当稍后连接代理时，应用程序已经在运行。将代理附加到已运行的应用程序，以从已运行的实例获取信息。停止已经运行的实例并使其失败，特别是在操作环境中，比不连接代理更具破坏性。无论如何，它可能不会被忽视，因为最有可能连接的代理是由操作人员使用的。

`premain`或`agentmain`代理获取一个`Instrumentation`对象作为第二个参数。这个对象实现了几个方法。其中之一是：

```
void addTransformer(ClassFileTransformer transformer)

```

代理实现转换器，并具有`transform`方法签名：

```
byte[] transform(Module module, ClassLoader loader, 
                 String className, 
                 Class<?> classBeingRedefined, 
                 ProtectionDomain protectionDomain, 
                 byte[] classfileBuffer) 
throws IllegalClassFormatException

```

当类被加载或要转换时，JVM 会调用此方法。该方法获取类对象本身，但更重要的是，它获取包含类的字节码的字节数组。该方法应返回转换类的字节码。修改字节码需要了解字节码是如何构建的以及类文件的结构。有一些库可以帮助实现这一点，比如 Javassist（[http://www.javassist.org/](http://www.javassist.org/) 或 ASM（[http://asm.ow2.org/](http://asm.ow2.org/) ）。然而，在熟悉字节码的结构之前，我不会开始编码。

代理在单独的线程中运行，可能与用户或文件系统进行交互，并且基于任何时候的一些外部观察，可以调用以下方法来使用注册的转换器执行类的重新传输：

```
void retransformClasses(Class<?>... classes)

```

代理还可以调用以下方法，该方法将重新定义作为参数提供的类：

```
void redefineClasses(ClassDefinition... definitions)

```

`ClassDefinition`类只是`Class`和`byte[]`对。这将通过 JVM 的类维护机制重新定义类。

请注意，这些方法和 Java 代理与 JVM 的深层、底层部分交互。这也导致很容易破坏整个 JVM。与类的加载过程不同，字节码不会被检查，因此，如果其中有错误，结果可能不仅是异常，还可能是 JVM 崩溃。此外，重新定义和转换不应改变类的结构。他们不应该更改继承足迹、添加、重命名或删除方法，或者更改方法的签名，对于字段也是如此。

还要注意，已经创建的对象不会受到更改的影响；它们仍将使用类的旧定义，并且只会影响新实例。

# 多语言编程

多语言编程是一种在同一应用程序中使用不同编程语言的技术。这种方法不仅适用于应用程序的不同部分在不同环境中运行的情况。例如，客户端使用 JavaScript、CSS 和 HTML 在浏览器中执行，而服务器编程为在 Java 的 Tomcat 环境中运行。这是一个不同的故事，通常，当有人谈论多语言编程时，这不是典型的用法。

当运行在服务器上的应用程序部分使用 Java 和其他语言运行时，我们就可以讨论多语言编程了。例如，我们用 Java 创建订单处理应用程序，并且基于订单包含的特定于产品的代码检查订单正确性的一些代码是用 JavaScript 编写的。它响了吗？我们在本书中已经这样做了，以演示 JDK 的脚本 API。这是真正的多语言编程，即使我们没有提到它的方式。

运行编译过的 Java 代码的 JVM 是不同语言编译器的一个很好的目标，因此，有许多语言为它编译。当 JVM 运行一个类的字节码时，它不知道源语言是什么，也不在乎；一些编译器创建了字节码，它只是执行它。

我们可以使用不同的语言，比如 Jython、Groovy 和 Scala，来列举一些为 JVM 编译的流行语言。我们可以使用一种语言编写一个类，另一个使用另一种语言编写另一个类。当它们放在一个 JAR、WAR 或 EAR 文件中时，运行时系统将只运行它们。

我们什么时候使用多语言编程？

# 多批次配置

通常，当我们想要创建一个更灵活、更可配置的应用程序时，我们会转向多语言编程。安装在许多实例中的应用程序（通常位于不同的客户站点）都有一些配置。这些配置可以是 XML 文件、属性文件和 INI 文件（这些文件来自 Windows）。随着程序的开发，这些静态配置的可能性迟早会达到极限。应用程序开发人员很快就会发现，他们需要配置一些难以用这些技术描述的功能。配置文件开始变大，读取和解释配置文件的代码也会变大。优秀的开发人员必须意识到这一点，在配置文件和处理它们的代码变得不可管理之前，必须实现一些脚本配置、多语言编程。

![](../images/00064.gif)

优秀的开发人员团队在开发他们的配置语言和该语言的解释器时可能会达到某个程度。它可以基于 XML，也可以是任何其他语言。毕竟，写一种语言很有趣；我自己也做过几次。然而，其中大多数都是业余爱好，而不是专业项目。通常，制作另一种语言没有客户价值。我们可以更好地使用现有的。

就配置而言，Groovy 是一种非常方便的语言，它支持复杂的闭包和元类语法和实现。这样，该语言非常适合创建特定于领域的语言。由于 Groovy 是编译到 JVM 的，所以 Groovy 类可以直接从 Java 调用，反之，读取配置实质上是调用从配置文件编译的类。编译可以在应用程序构建期间进行，但在配置的情况下，在应用程序启动期间进行编译更有意义。我们已经看到，脚本 API 的 Groovy 实现或 Groovy 提供的特殊 API 完全能够做到这一点。

我们在书中看到过这样的例子吗？您可能会感到惊讶，但实际上我们已经多次使用 Groovy 来描述某些配置。*Gradle*构建文件只不过是主要在 Groovy 中开发的 Groovy DSL，用于支持项目构建配置。

# 多语言脚本

配置不是多语言编程的唯一应用。在程序启动时执行配置，然后将配置数据用作静态数据。我们可以在应用程序执行期间随时执行脚本，而不仅仅是在启动期间。这可用于为使用相同应用程序但提供不同脚本的安装的程序用户提供额外功能。

最早提供这种脚本功能的应用程序之一是 emacs 编辑器。应用程序的核心是用 C 语言编写的，它包含一个 Lisp 解释器，允许用户编写在编辑器环境中执行的脚本。工程程序 AutoCAD 也使用 Lisp 解释器用于类似目的。为什么 Lisp 用于此目的？
Lisp 的语法非常简单，因此很容易解析 Lisp 代码。同时，该语言功能强大，最后但并非最不重要的一点是，那时已经有了开源的 Lisp 解释器（至少一个）。

为了获得这种灵活性，应用程序常常提供插件 API，开发人员可以使用插件 API 扩展应用程序。然而，这需要开发人员设置编码工具，包括 IDE、构建工具、持续集成等，即专业编程环境。当插件要解决的任务很简单时，开销就太大了。在这种情况下，脚本解决方案更方便。

脚本不是万能的解决方案。当扩展应用程序的脚本变得过于复杂时，这意味着编写脚本的可能性太大了。然而，从孩子那里取回玩具是很困难的。如果用户习惯了脚本编写的可能性，那么如果我们发布的应用程序的下一个版本不提供这种可能性，他们将不会感到轻松。因此，评估脚本功能在我们的应用程序中的可能用途是非常重要的。脚本编写，更一般地说，我们的程序的任何功能都不会用于我们想要的目的。它们将被用于任何可能的用途。当涉及到滥用某些功能时，用户可能会超出想象。最好事先考虑限制脚本编写的可能性，限制脚本的运行时间或程序同意使用的脚本的大小。如果这些限制设置合理，并且用户理解并接受这些限制，那么除了脚本功能外，还必须考虑插件结构。

应用程序的安全性，包括插件或脚本扩展，也非常重要。脚本或插件与核心应用程序在同一 JVM 上运行。一些脚本语言提供了一些限制对核心应用程序对象和类的访问的脚本，但这是一个例外。通常，脚本以与核心应用程序相同的权限运行，这样它们就可以做任何事情。因此，脚本应该以与核心应用程序相同的方式受到信任。对于应用程序的非特权用户，永远不可能安装或修改脚本。这样的操作几乎总是保留给系统管理员。

如果一个没有特权的用户可以上传一个脚本到服务器，然后让它执行，我们就在应用程序中打开了一个安全漏洞。由于访问限制是由应用程序强制执行的，因此使用不受控制的脚本很容易覆盖这些限制。黑客可以轻松地访问其他用户的数据（他无权访问），并读取和修改我们的数据库。

# 商业数字用户线

当应用程序的代码可以分为业务代码和技术代码时，也可能出现多语言编程。业务代码包含我们实际为之编写应用程序的顶级业务逻辑，这是包含客户付费逻辑的代码。技术代码支持业务 DSL 中编码的算法。

大多数企业应用程序都包含这两种类型的代码，但许多应用程序并没有将它们分开。这导致了一个包含重复代码的单片应用程序。当您觉得在需要持久性或联网时正在编写相同类型的代码，而在编写某些业务规则时又在编写相同类型的代码时，这就是代码气味，表明这两种代码类型没有分开。DSL 和脚本不是一根魔杖，也不能解决由错误的应用程序结构引起的所有问题。在这种情况下，必须首先重构代码以分离业务逻辑和基础架构代码，而实现 DSL 和支持它的业务 API 并将业务代码重写到 DSL 中只是第二步。这样一个项目的每一步都为应用程序带来了价值，即使它永远无法实现 DSL 和脚本，投入的精力也不会白费。

业务 DSL 脚本与可插拔脚本非常相似，只是这次不是应用程序不时调用脚本来执行某些特殊的扩展功能。相反，DSL 代码通过它提供的业务 API 调用应用程序。提供 API 并使用 DSL 的优势在于，实现业务逻辑的代码可以摆脱技术细节，可以非常抽象，并且通过这种方式，更接近于问题的业务级描述，而不仅仅是程序代码。即使一些商人也能理解业务 DSL，尽管在现实生活中这不是一个目标，但他们甚至可以编写代码。

在维也纳大学，我们也使用了类似的方法，使半导体模拟更适用于半导体设计工程师。核心计算代码是用 Fortran 语言编写的。处理大量仿真数据输入和输出并嵌入 XLISP 解释器的 C 语言框架执行这些程序。Lisp 代码包含仿真配置数据，并且在对多个配置点执行仿真时，还可以包含简单的循环。
这是一个多语言编程，只是我们不知道这将是这个应用程序编码风格之后的几年。

# 多语言文字的问题

多语言编程不仅仅是为了优势。在跳进这个方向之前，开发商做出的决定必须考虑很多事情。

为应用程序使用另一种语言需要知识。最终，找到能用所用语言编写代码的人比找到只懂 Java 的开发人员要困难得多。（如果内核应用程序语言不是 Java，也是如此。）不同的语言需要不同的思维方式，很多时候，需要不同的人。团队还应该有一些精通两种语言的成员，如果大多数人对另一种语言至少了解一点，这也是一种优势。

支持 Java 的工具集非常出色。与其他语言相比，构建工具、集成开发环境、库、调试可能性和日志框架都非常好。Polyglot 开发也需要对其他语言的支持，这可能不如对 Java 的支持那么先进。很多时候，调试 DSL 解决方案确实是一个问题，IDE 支持也可能滞后。

当我们用 Java 编程时，很多时候，我们认为 IDE 读取库的元数据是理所当然的，每当我们需要调用一个方法或引用一个类时，IDE 都会给出最好的建议。还可能支持 XML 和属性文件，IDE 可能知道一些最常用的框架，例如*Spring*，并且理解将类名作为超链接处理的 XML 配置，即使类名位于某些属性字符串中。

对于其他语言来说，这远没有这么容易。对于具有广泛用户基础的语言，工具支持可能很好，但是如果您选择一些外来语言，您就只能靠自己了。语言越是异国情调，你可能得到的支持就越少。

您可以创建一些工具来支持您开发的 DSL。使用[等工具来实现这一点并不难 http://www.eclipse.org/Xtext/](http://www.eclipse.org/Xtext/) 。在这种情况下，您与*Eclipse*绑定，这可能是问题，也可能不是问题。您可以选择一种特殊的语言，例如，*Kotlin*，这是由*IntelliJ*广泛支持的，因为同一家公司支持该语言和 IDE，但同样，您购买了一种特殊的技术，如果您不得不更换，这种技术可能会很昂贵。这通常不仅适用于语言，也适用于开发中包含的任何技术。当你选择一个，你应该考虑的支持和成本下车下车，如果或当它开始死亡。

# 注释处理

我们已经非常详细地讨论了注释。您可能还记得，我们使用以下注释定义了注释接口：

```
@Retention(RetentionPolicy.RUNTIME)

```

这告诉 Java 编译器保留注释并将其放入 JVM 代码中，以便代码可以在运行时使用反射来访问它。默认值为`RetentionPolicy.CLASS`，这意味着注释进入字节码，但 JVM 不使其可用于运行时系统。如果我们使用`RetentionPolicy.SOURCE`，注释甚至不会进入类文件。在这种情况下，只有一种可能对注释执行任何操作：编译时。

我们如何编写在编译时运行的代码？Java 支持注释处理器的概念。如果编译器的类路径上有一个类实现了`javax.annotation.processing.Processor`接口，那么编译器将调用实现的方法一次或多次，传递有关编译器实际处理的源文件的信息。这些方法将能够访问已编译的方法、类或任何注释，以及触发处理器调用的注释。但是，重要的是，此访问与运行时中的访问不同。注释处理器访问的既不是已编译的类，也不是已加载的类，也就是说，当代码使用反射时，它是可用的。此时的源文件正在编译中；因此，描述代码的数据结构实际上是编译器的结构，我们将在下一个示例中看到。

注释处理器被调用一次或多次。它被多次调用的原因是编译器使注释处理器能够根据它在部分编译的源代码中看到的内容生成源代码。如果注释处理器生成任何 Java 源文件，编译器必须编译新的源代码，可能还要重新编译一些已经编译的文件。这个新的编译阶段需要注释处理器的支持，直到没有更多的循环可执行为止。

注释处理器一个接一个地执行，它们在同一组源文件上工作。无法指定注释处理器的执行顺序；因此，两个协同工作的处理器应该执行它们的任务，不管它们以什么顺序被调用。另外，请注意，这些代码在编译器内部运行。如果注释处理器抛出异常，那么编译过程很可能会失败。因此，只有在出现无法恢复的错误并且注释处理器确定该错误后的编译无法完成时，才应该从注释处理器抛出异常。

当编译器进入执行注释处理器的阶段时，它会查看实现`javax.annotation.processing.Processor`接口的类，并创建这些类的实例。这些类必须有一个公共的无参数构造函数。为了简化处理器的执行，并仅为处理器可以处理的注释调用处理器，该接口包含两种方法：

*   `getSupportedSourceVersion`返回批注处理器可以支持的最新版本
*   `getSupportedAnnotationTypes`返回一组`String`对象，其中包含此处理器可以处理的注释的完全限定类名

如果注释处理器是为 Java1.8 创建的，那么它可以与 Java9 一起工作，但也可能不工作。如果它声明支持的最新版本是 1.8，那么 Java 9 环境中的编译器将不会调用它。最好不要调用注释处理器，而不要调用注释处理器并扰乱编译过程，这甚至可能会创建已编译但错误的代码。

对于注释处理器，这些方法返回的值是相当恒定的。注释处理器将返回它可以处理的相同源版本，并返回相同的注释集。因此，在源代码中以声明的方式定义这些值是明智的。

这可以在扩展`javax.annotation.processing.AbstractProcessor`类而不是直接实现`Processor`接口时完成。这个抽象类实现了这些方法。它们都从注释中获取信息，以便我们可以修饰扩展抽象类的类。例如，`getSupportedAnnotationTypes`方法查看注释，并返回注释中列出的注释类型字符串数组。

现在，这有点让人绞尽脑汁，一开始也会让人困惑。我们在编译时执行注释处理器。但是编译器本身是一个 Java 应用程序，这样，编译器内部运行的代码的运行时间就是运行时间。`AbstractProcessor`的代码使用反射方法将`SupportedAnnotationTypes`注释作为运行时注释进行访问。这里面没有魔力。JDK 9 中的方法如下所示：

```
public Set<String> getSupportedAnnotationTypes() { 
    SupportedAnnotationTypes sat = this.getClass().getAnnotation 
    (SupportedAnnotationTypes.class); 
    if  (sat == null) { 
        ... error message is sent to compiler output ... 
        return Collections.emptySet(); 
    } 
    else 
        return arrayToSet(sat.value()); 
}

```

（为了简洁起见，对代码进行了编辑。）

举个例子，我们将看一看 polyglot 注释处理器的代码。我们非常简单的注释处理器将处理一个简单的注释：`com.javax0.scriapt.CompileScript`，它可以指定一个脚本文件。注释处理器将加载脚本文件，并使用 Java 9 的脚本接口执行它。

这段代码是几年前由本书作者作为演示代码开发的，可以从 GitHub 获得 Apache 许可证。因此，类的包被保留。

注释处理器包含两个代码文件。处理器将处理的注释本身之一：

```
@Retention(RetentionPolicy.SOURCE) 
@Target(ElementType.TYPE) 
public @interface  { 
    String value(); 
    String engine() default ""; 
}

```

如您所见，此注释在编译后不会进入类文件；因此，在运行时将没有跟踪，因此任何类源都可能偶尔使用此注释。注释的`Target`是`ElementType.TYPE`，这意味着该注释只能应用于那些属于某种类型的 Java 9 语言构造：`class`、`interface`和`enum`。

注释有两个参数。该值应指定脚本文件的名称，引擎可以选择定义该文件中脚本的类型。我们将创建的实现将尝试从文件扩展名中识别脚本的类型，但是如果有人想将一些 Groovy 代码嵌入具有`.jy`扩展名（通常用于 Jython）的文件中，那就这样吧。

处理器扩展了`AbstractProcessor`，通过这种方式，继承了一些方法，但牺牲了类中使用的一些注释：

```
package com.javax0.scriapt; 
import ... 
@SupportedAnnotationTypes("com.javax0.scriapt.CompileScript") 
@SupportedSourceVersion(SourceVersion.RELEASE_9) 
public class Processor extends AbstractProcessor {

```

不需要执行`getSupportedAnnotationTypes`和`getSupportedSourceVersion`方法。这些被类上注释的使用所取代。我们在这个处理器中只支持一个注释，即我们在前面列出的源文件中定义的注释，并且我们准备管理 Java 版本 9 之前的源代码。我们必须覆盖的唯一方法是`process`：

```
@Override 
public boolean process( 
    final Set<? extends TypeElement> annotations, 
    final RoundEnvironment roundEnv) { 
        for (final Element rootElement : 
            roundEnv.getRootElements()) { 
                try { 
                    processClass(rootElement); 
                }  
                catch (Exception e) { 
                    throw new RuntimeException(e); 
                } 
            } 
        return false; 
    }

```

此方法获取两个参数。第一个是为其调用的注释集。第二个是圆形环境。因为处理器可以被多次调用，不同的调用可能有不同的环境。每次调用都是在一轮中进行的，`RoundEnvironment`参数是一个对象，可用于获取有关给定轮的信息。它可用于获取调用此注释的回合的根元素。在我们的例子中，这将是一组具有`CompileScript`注释的类元素。我们迭代这个集合，对于每个类，我们调用`processClass`方法（参见下一个代码片段）。该方法可能会抛出一些已检查的异常，而该方法进程不能，因为它应该与接口的相同方法匹配。因此，我们捕获任何可能抛出的异常，并重新抛出封装在`RunTimeException`中的异常。如果这些异常中的任何一个是由被调用的方法引发的，则编译无法运行脚本，应将其视为失败。在这种情况下，汇编不应成功：

```
private void processClass(final Element element) 
    throws ScriptException, FileNotFoundException { 
        for (final AnnotationMirror annotationMirror : 
            element.getAnnotationMirrors()) { 
                processAnnotation(annotationMirror); 
        } 
    }

```

正如我们已经提到的，实际的注释在编译时不可用。因此，我们可用的只是注释的编译时镜像。它具有`AnnotationMirror`类型，可用于获取注释的实际类型以及注释的值。注释的类型在编译时可用。编译器需要它；否则，它无法编译注释。这些值可从注释本身获得。我们的`processAnnotation`方法将得到的每个注释作为参数进行处理：

```
private void processAnnotation( 
    final AnnotationMirror annotationMirror) 
    throws ScriptException, FileNotFoundException { 
        final String script = 
            FromThe.annotation(annotationMirror). 
            getStringValue(); 
        final String engine = 
            FromThe.annotation(annotationMirror). 
            getStringValue("engine"); 
        execute(script, engine); 
    }

```

我们的`@CompileScript`注释定义了两个参数。第一个值是脚本文件名，第二个值是脚本引擎名称。如果未指定第二个，则将空字符串设置为默认值。每次注释都会调用`execute`方法：

```
private void execute(final String scriptFileName, 
                    final String engineName) 
    throws ScriptException, FileNotFoundException { 
        final ScriptEngineManager factory = 
        new ScriptEngineManager(); 
        final ScriptEngine engine; 
        if (engineName != null && engineName.length() > 0) { 
            engine = factory.getEngineByName(engineName); 
        }  
        else { 
            engine = 
            factory.getEngineByExtension 
            (getExtensionFrom(scriptFileName)); 
        } 
        Reader scriptFileReader = new FileReader 
        (new File(scriptFileName)); 
        engine.eval(scriptFileReader); 
    }

```

该方法尝试基于文件名加载脚本，并尝试基于给定名称实例化脚本引擎。如果没有指定名称，则使用文件扩展名来标识脚本引擎。默认情况下，JavaScript 引擎位于类路径上，因为它是 JDK 的一部分。如果正在使用任何其他基于 JVM 的脚本引擎，那么它必须在类路径或模块路径上可用。

类的最后一个方法是一个简单的脚本操作方法，没有什么特别的。它只需删除文件扩展名，以便根据扩展字符串识别引擎：

```
private String getExtensionFrom(final String scriptFileName) { 
    final int indexOfExtension = scriptFileName.lastIndexOf('.'); 
    if (indexOfExtension == -1) { 
        return ""; 
    }  
    else { 
        return scriptFileName.substring(indexOfExtension + 1); 
    } 
}

```

为了完整起见，我们有这个类的右括号：

```
}

```

# 企业中的程序设计

当一名专业人士为一家企业工作时，她不会独自工作。有很多人，开发人员以及其他同事，我们必须与他们合作。企业的 IT 部门越老，企业越大，人们所扮演的角色就越专业。您肯定会遇到业务分析师、项目经理、测试工程师、构建工程师、主题专家、测试人员、架构师、scrum 大师和自动化工程师，仅举几个角色。其中一些角色可能会重叠，任何人都不可能有一个以上的责任，而在其他情况下，一些角色甚至可能更加专业化。有些角色技术性很强，需要的业务相关知识较少；其他人则更注重商业。

与这么多人和这么多不同角色的团队合作并不简单。对于新手开发人员来说，任务的复杂性可能是压倒性的，如果没有操作的所有成员或多或少都遵循的明确策略，就无法完成任务。也许你的经验会表明，这是多多少少，但这是一个不同的故事。

对于开发人员合作的方式，有成熟的行业实践。它们支持使用瀑布、敏捷或以某种方式混合使用这两种模型的**软件开发生命周期**（**SDLC**）。在下面的部分中，我们将介绍在每个软件开发组织中使用或至少应该使用的工具和技术。这些是：

*   控制检查源代码的代码质量的静态代码分析工具
*   源代码版本控制，用于存储源代码的所有版本，并帮助获取任何旧版本开发的源代码
*   软件版本控制，以保持我们如何识别不同版本的一些顺序，并且不会在不同版本之间丢失
*   代码审查和工具有助于消除测试中未发现的针尖缺陷，并有助于知识共享
*   记录和记录调查结果的知识库工具
*   问题跟踪工具，用于记录错误、客户问题和其他必须处理的任务
*   外部产品和库的选择过程和注意事项
*   持续集成，使软件保持一致状态，并根据错误代码的开发方式，在错误传播到其他版本或其他代码之前立即报告其中是否存在错误
*   发布管理，它跟踪软件的不同发布版本
*   代码存储库，它存储编译和打包的工件

下图显示了这些任务中使用最广泛的工具：

![](../images/00065.gif)

# 静态代码分析

静态代码分析工具像编译器一样读取代码并对其进行分析，但它们不进行编译，而是试图找出其中的错误或错误。不是语法错误。为此，我们已经有了 Java 编译器。错误，例如在循环外使用循环变量，这可能是绝对有效的，但通常是不好的风格，而且很多时候，这种用法来自一些简单的错误。他们还检查代码是否遵循我们设置的样式规则。

静态代码分析器有助于识别代码中的许多小错误和明显错误。有时，他们很烦人，对一些可能不是真正问题的事情发出警告。在这种情况下，最好以稍微不同的方式编写程序，而不是因为我们希望静态代码分析在没有警告的情况下运行。我们不应该因为工具而修改代码。如果我们以某种方式编码某件东西，使它通过某种质量检查工具，而不是因为它更好，那么我们就是在为工具服务，而不是为我们服务的工具。

更改代码以通过代码分析的原因是，如果代码不违反编码风格，则普通程序员很可能更容易阅读代码。您或其他团队成员可以是非常优秀的程序员，即使代码使用了一些特殊的构造，也可以非常容易地理解代码。但是，对于将来维护您的代码的所有程序员，您不能这样说。代码的使用寿命很长。我使用一些 50 年前编写的程序。它们仍然由 30 岁左右的年轻专业人士运行和维护。这意味着他们甚至在代码开发时还没有出生。在编写代码时，维护代码的人甚至还没有出生，这很容易发生。你不能告诉任何关于他们的聪明和编码实践。我们所能做的最好的事情就是为平均值做准备，而这正是静态代码分析工具所要做的。

这些工具执行的检查没有硬连线到工具中。工具中的一些特殊语言描述了规则，可以删除这些规则，也可以添加其他规则，还可以修改规则。这样，您就可以适应您工作的企业的编码标准。不同的规则可以分为装饰性的、次要的、主要的和关键的。装饰性的东西主要是警告，我们并不真正关心它们，即使解决这些问题也很好。有时候，这些小事可能预示着一些真正的大问题。在检查被宣布为失败之前，我们可以设置次要和主要错误的数量限制，也可以设置关键错误的数量限制。在最后一种情况下，该限制通常为零。如果一个编码错误看起来很关键，那么最好不要在代码中有任何错误。

最常用的工具是**Checkstyle**、**FindBugs**和**PMD**。这些工具的执行通常是自动化的，尽管它们可以从 IDE 或开发人员的命令行执行，但它们的主要用途是在**持续集成**（**CI**服务器上。在构建过程中，这些工具在 CI 服务器上配置为运行，并且可以进行配置，以便在静态代码分析因某些限制而失败时，构建应该中断。执行静态代码分析通常是编译和单元测试执行之后、实际打包之前的下一步。

**SonarQube**工具（[https://www.sonarqube.org/](https://www.sonarqube.org/) 是静态代码分析工具之外的特殊工具。SonarQube 维护以前检查的历史记录，支持单元测试代码覆盖率，并可以报告质量随时间的变化。通过这种方式，您可以看到代码样式错误的质量、覆盖率和不同限定条件的数量是如何变化的。很多时候，您可以看到，当临近发布日期时，代码质量会随着人们的匆忙而降低。这是非常糟糕的，因为这是应该消除大多数 bug 的时候。对质量进行统计可能有助于改变实践，因为在质量出现之前就看到了趋势，因此代码的可维护性就失控了。

# 源代码版本控制

源代码版本控制系统存储不同版本的源代码。如今，我们无法想象没有它的专业软件开发。情况并非总是如此，但免费在线存储库的可用性鼓励爱好开发人员使用一些版本控制，当这些开发人员后来为企业工作时，显然必须使用这些系统。

有许多不同的版本控制系统。使用最广泛的是 Git。以前广泛使用的版本控制是**SVN**和**CVS**。这些日子越来越少用了。我们可以看到**SVN**是**CVS**的继任者，而 Git 是**SVN**的继任者。除此之外，还有其他版本控制系统，如**Mercurial**、**Bazaar**或**Visual Studio 团队服务**。有关可用工具的全面列表，请访问维基百科页面[https://en.wikipedia.org/wiki/List_of_version_control_software](https://en.wikipedia.org/wiki/List_of_version_control_software) 。

我敢打赌，您首先会遇到 Git，在为企业编程时很有可能遇到 SVN。水星可能会出现在你的实践中，但目前存在的任何其他水星都是非常罕见的，被用于某一特定区域，或者干脆就灭绝了。

版本控制系统允许开发团队以有组织的方式将软件的不同版本存储在维护（以可靠的方式定期备份）的存储器上。这对于不同的目的很重要。

首先，不同版本的软件可能部署到不同的实例。如果我们为客户开发软件，并且我们有许多客户，我们希望与他们建立良好的业务，那么不同的客户可能有不同的版本。这不仅是因为一些客户不愿意为升级付费，我们也不想免费提供新版本。很多时候，客户方面的成本上升会在很长一段时间内阻止升级。软件产品不能在孤立的环境中独立工作。不同的客户有不同的集成环境；该软件与其他不同的应用程序进行通信。在企业环境中引入新版本时，必须对其进行测试，以确定其是否能与所有需要配合的系统协同工作。这种测试需要花费大量的精力和金钱。如果新版本比旧版本提供的新功能或其他价值不能证明成本合理，那么部署新版本将是浪费金钱。我们的软件有一个新版本并不意味着旧版本不可用。

如果客户端有一些 bug，那么我们在该版本中修复 bug 是至关重要的。要做到这一点，bug 必须在开发环境中重现，这最终意味着该版本的源代码必须可供开发人员使用。

这确实需要客户数据库包含对安装在客户站点上的软件产品的不同版本的引用。更复杂的是，一个客户在不同的系统中一次可能有多个版本，也可能有不同的许可证，因此问题比最初看起来更复杂。如果我们不知道客户机的版本，那么我们就有麻烦了。
由于为客户和现实生活注册版本的数据库可能会不同步，软件产品会在启动时记录其版本。在本章中，我们有一个关于版本控制的单独章节。

如果在客户端的版本中修复了错误，那么在部署之后，客户端的事件可能会得到解决。但是，如果版本不是软件的前一版本，问题仍然存在。在旧版本软件中引入的 bug 修复可能仍然潜伏在较新版本或早期版本中。开发团队必须确定哪些版本与客户相关。例如，不再在任何客户端站点安装的旧版本不值得调查。之后，必须对相关版本进行调查，以检查它们是否存在缺陷。这只能在我们有源版本的情况下完成。如果导致错误的代码是在以后的版本中引入的，则某些旧版本可能没有错误。一些新版本也可能对该错误免疫，因为该错误在以前的版本中已经修复，或者仅仅是因为导致该错误的代码片段甚至在该错误出现之前就已被重构。有些 bug 甚至可能影响特定版本，而不是一系列产品。大补丁可能应用于不同的版本，它们可能需要稍微不同的补丁。所有这些都需要一个维护的源版本存储库。

即使我们没有使用不同版本的不同客户，我们也很可能有多个版本的软件在开发中。主要版本的开发即将结束，因此，团队中负责测试和 bug 修复的一部分将重点放在这些活动上。与此同时，下一版本的功能开发仍在继续。实现下一版本功能的代码不应进入即将发布的版本。新代码可能非常新鲜，未经测试，可能会引入新的 bug。在发布过程中引入冻结时间是非常常见的。例如，可能禁止实现即将发布的版本的任何新功能。这称为功能冻结。

修订控制系统处理这些冻结期，维护代码的不同分支。该版本将在一个分支中维护，后续版本的版本将在另一个分支中维护。当版本发布时，应用于它的 bug 修复也应该传播到新版本；否则，下一个版本可能会包含上一个版本中已修复的错误。为此，发布分支与正在进行的分支合并。因此，版本控制系统维护一个版本图，其中每个版本的代码是图中的一个节点，更改是顶点。

Git 在这个方向上走得很远。它非常支持分支创建和合并，以至于开发人员为他们创建的每个更改创建单独的分支，然后在功能开发完成后将其与主分支合并。这也为代码审查提供了一个很好的机会。进行功能开发或 bug 修复的开发人员在 GitHub 应用程序中创建一个 pull 请求，并请求另一个开发人员查看更改并执行 pull。这是一种应用于代码开发的四眼原则。

一些版本控制系统将存储库保存在服务器上，任何更改都会传到服务器上。这样做的好处是，任何提交的更改都会进入定期备份的服务器磁盘，因此是安全的。由于服务器端访问是受控制的，因此发送到服务器的任何代码都不能在没有跟踪的情况下回滚。所有版本，甚至错误的版本，都存储在服务器上。这可能是某些法律控制所要求的。另一方面，如果提交需要网络访问和服务器交互，那么它可能会很慢，从长远来看，这将激励开发人员不要频繁提交他们的更改。更改在本地计算机上保留的时间越长，丢失部分代码的风险就越大，随着时间的推移，合并变得越来越困难。为了解决这种情况，Git 分发了存储库，提交发生在本地存储库上，这与某些服务器上的远程存储库完全相同。当一个存储库将更改推送到另一个存储库时，存储库将同步。这鼓励开发人员频繁提交到存储库，并给出简短的提交消息，这有助于跟踪对代码所做的更改。

一些较旧的版本控制系统支持文件锁定。这样，当开发人员签出代码文件时，其他人就不能处理同一段代码。这从本质上避免了代码合并期间的冲突。多年来，这种方法似乎不适合开发方法。与签出和遗忘的文件相比，合并问题不是什么问题。SVN 支持文件锁定，但这并不严重，也不会阻止开发人员将更改提交给其他人锁定的文件。这与其说是真正的锁定，不如说只是一个建议。

源代码存储库非常重要，但不应与发行版存储库混淆，发行版存储库以二进制形式存储已编译的代码发行版。源存储库和发布存储库协同工作。

# 软件版本控制

软件版本控制很神奇。想想 Windows 或星球大战电影的不同版本。后者不是真正的软件版本控制，但它表明问题非常普遍。就 Java 而言，版本控制并没有那么复杂。首先，我们现在使用的 Java 版本是 9。之前的版本是 1.8，之后是 1.7，依此类推，一直到 1.0。Java 的早期版本被称为 Oak，但这已经成为历史。毕竟，也就是说，谁能说出 Java2 是什么？

幸运的是，当我们创建 Java 应用程序时，情况更简单。从 Java 1.3 时代起，Oracle 就提出了一个关于如何对 JAR 进行版本转换的建议：

[http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/versioning.html](http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/versioning.html)

本文件区分规范版本和实施版本。如果 JAR 内容的规范发生了变化，代码的行为必须与之前的行为有所不同；规范版本应该更改。如果规范没有改变，但实现确实改变了——例如，当我们修复一个 bug 时——那么实现版本就会改变。

在实践中，没有人使用这个方案，尽管将实现版本和规范版本分开是一个绝妙的想法，至少在理论上是这样。我甚至打赌，您的大多数同事甚至从未听说过这种版本控制。我们在实践中使用的是语义版本控制。

语义版本控制（[http://semver.org/](http://semver.org/) 将规范和实现版本混合为一个版本号三元组。此三联体的格式为**mmp，**，即：

*   **m**：主要版本号
*   **m**：次要版本号
*   **p**：补丁号

说明书上说这些数字从零开始，然后增加一。如果主数字为零，则表示该软件仍在开发中。在此状态下，API 不稳定，可能会在没有新的主要版本号的情况下更改。软件发布时，主版本号变为 1。稍后，当应用程序（库）的 API 与以前的版本发生更改，并且应用程序与以前的版本不向后兼容时，必须增加该 API。当更改仅影响实现但更改非常重要时，次要版本号会增加，甚至 API 也在更改，但以向后兼容的方式更改。当某些 bug 被修复时，补丁版本会增加，但变化不大，API 也没有变化。如果任何三元组前面的任何版本号增加，则必须将次要版本和修补程序级别重置为零：主要版本号增加将重置次要版本和修补程序版本；小版本号增加会重置修补程序号。

这样，语义版本控制将保留规范版本的三元组的第一个元素。次要版本是规范和实现版本的混合。补丁版本更改显然是实现版本更改。

除此之外，语义版本控制还允许附加预发布字符串，例如`-RC1`和`-RC2`。它还允许附加元数据，例如加号后面的日期，例如，`+20160120`作为日期。

语义版本控制的使用有助于使用该软件的用户轻松发现兼容版本，并查看哪个版本较旧，哪个版本较新。

# 代码审查

当我们以专业的方式创建程序时，它是在团队中完成的。除了业余爱好或配合教程之外，并没有单人表演节目。这不仅是因为团队合作更有效，还因为一个人容易受到伤害。如果你独自一人工作，被公共汽车撞了，或者你中了彩票，失去了从事项目的能力或动机，那么你的客户就有麻烦了。这是不专业的。专业项目应对任何成员的流失具有弹性。

团队合作需要合作，合作的一种形式是代码审查。这是一个开发人员或一组开发人员读取其他团队成员编写的部分代码的过程。这项活动有直接收益；

*   阅读代码的开发人员可以获得更多关于代码的知识；他们学习代码。这样，如果创建代码的开发人员出于任何原因退出了流程，其他人可以以最小的冲击继续工作。
*   编码样式可以对齐。开发人员，甚至是高年级的开发人员，如果非常注意，就会犯代码错误。这可能是一个 bug，也可能是编码风格冲突。编码风格很重要，因为代码可读性越高，出现未被注意到的错误的可能性就越小。（另请参见下一个要点。）同样重要的是，团队的编码风格是相同的。所有团队成员应使用相同的样式。查看与我编写的代码风格不同的代码时，要理解和理解会有点困难。这些差异可能会分散读者的注意力，团队成员必须能够阅读代码。代码属于团队，而不是单个开发人员。任何团队成员都应该知道代码并能够修改它。
*   在代码审查过程中，会发现很多 bug。查看代码并试图理解其工作原理的各方可能偶尔会从代码结构中发现 bug，否则使用测试很难发现这些 bug。如果需要，代码检查是最白的白盒测试。人们的思维方式不同，不同的思维模式捕捉到不同的错误。

代码审查可以在线和离线进行。这可以通过团队或点对点的方式完成。

大多数团队遵循 GitHub 支持的代码审查过程，这是最简单的。对代码的更改将提交到分支，并且不会直接与代码合并，而是在 web 界面上创建一个 pull 请求。本地策略可能要求其他开发人员执行拉取。web 界面将突出显示更改，我们可以向更改的代码添加注释。如果注释很重要，那么请求拉取的原始开发人员应该修改代码以回答注释并再次请求拉取。这确保至少有两个开发人员看到任何更改；知识是共享的。

反馈是点对点的。它不是一个高中生教一个初中生。这需要一个不同的渠道。GitHub 中的注释不适合此用途；至少，有更好的渠道。也许是面对面交谈。评论可能来自一个高年级到一个低年级或从一个低年级到一个高年级。在这项工作中，对代码质量给予反馈，高年级和低年级学生是平等的。

最简单、也许也是最常见的注释如下：
*我可以看到在修改中 Xyz.java 发生了更改，但我没有看到对**XyzTest.java 进行任何更改。* 这几乎是对合并的即时拒绝。如果开发了新特性，则必须创建单元测试来测试该特性。如果一个 bug 被修复了，那么必须创建单元测试来防止 bug 再次出现。我个人多次收到这样的评论，甚至是来自年轻人。其中一人告诉我，“我们知道你在测试我们是否敢于给出反馈。”
天知道我不是。他们不相信。

虽然 ChangeReview 和 GitHub 在开发过程中是一个很好的工具，但在需要检查更大的代码块时，它可能并不合适。在这种情况下，必须使用其他工具，如**鱼眼**。在这个工具中，我们可以选择要查看的源文件，即使它们最近没有更改。我们还可以选择审核人和截止日期。注释类似于 GitHub。最后，这种类型的代码审查以一个代码审查会议结束，在这个会议上，开发人员亲自收集并讨论代码。

在组织这样一次会议时，有管理他人经验的人在这些会议中进行调解是很重要的。关于样式的代码和讨论可能会变得非常个人化。同时，在参加这样的会议时，你也应该注意不要涉及个人隐私。将有足够多的参与者可能不知道这一点或纪律性较差。

在未使用在线工具首先查看代码之前，切勿参加审查会议。当你发表评论时，语言应该非常礼貌，因为我已经提到了这个原因。最后，会议调解人应该能够区分重要和不太重要的问题，并停止对琐事的辩论。不知何故，不太重要的问题更加敏感。我个人不关心制表符大小的格式，如果它是两个或四个空格，如果文件应该只包含空格，或者如果允许制表符字符，但是人们倾向于在这些问题上浪费时间。

在代码审查会议期间，最重要的问题是我们是专业的，今天我可能会审查和评论您的代码，但明天，情况正好相反，我们必须一起工作，我们必须作为一个团队一起工作。

# 知识库

知识库在几年前还是一个时髦词。很少有公司宣传 wiki 技术，也没有人使用它。今天，知识库的情况完全不同了。所有企业都使用某种 wiki 实现来共享知识。他们大多使用 Confluence，但也有其他可用的 wiki 解决方案，商业和免费的。

知识库存储您作为开发人员将记录在纸质笔记本中供日后参考的信息，例如，开发服务器的 IP 地址、安装 JAR 文件的目录、要使用的命令、收集的库以及使用它们的原因。主要区别在于，您以格式化的方式将其写入 wiki，其他开发人员可以立即使用它。编写这些页面对开发人员来说有点负担，首先需要自律。以开发服务器的 IP 地址和安装目录为例，您不仅需要编写服务器的 IP 地址，还需要编写一些文本来解释信息是什么，因为其他人可能无法理解。将包含信息的页面以良好的名称放置在 wiki 系统中，将其链接到其他页面，或者在页面树中找到页面的适当位置，这也是一项工作。如果你用的是纸质笔记本，你可以把 IP 地址和目录写在这本书的第一个免费页上，你就可以记住所有其他的。

当同事不需要自己查找信息时，wiki 方法将得到回报；您可以更轻松地找到这些信息，因为其他同事也在知识库中记录了他们的发现，最后但并非最不重要的是，几个月后，您可以找到您自己记录的信息。在纸质笔记本的情况下，您将翻页查找 IP 地址，您可能会记得，也可能不记得哪个是主服务器，哪个是辅助服务器。到那时，您甚至可能会忘记有两台服务器（或者它是一个双集群？）。

要获得可用 wiki 软件的详细列表，请访问[https://en.wikipedia.org/wiki/Comparison_of_wiki_software](https://en.wikipedia.org/wiki/Comparison_of_wiki_software) 。

# 问题跟踪

问题跟踪系统跟踪问题、bug 和其他任务。创建第一个问题跟踪系统是为了维护错误列表以及错误修复过程的状态，以确保识别和记录的错误不会被遗忘。后来，这些软件解决方案被开发出来，成为成熟的问题跟踪工具，成为每个企业不可避免的项目管理工具。

许多企业中使用最广泛的问题跟踪应用程序是 Jira，但在[上 https://en.wikipedia.org/wiki/Comparison_of_issue-tracking_systems](https://en.wikipedia.org/wiki/Comparison_of_issue-tracking_systems) 页面，您可以找到列出的许多其他应用程序。

问题跟踪器应用程序最重要的功能是，它必须以可编辑的方式详细记录问题。它必须记录记录问题的人员，以防在问题处理过程中需要更多信息。问题的根源很重要。同样，问题必须分配给负责人，负责问题处理的进度。

现代问题跟踪系统提供复杂的访问控制、工作流管理、关系管理以及与其他系统的集成。

访问控制只允许与某个问题有关的人访问该问题，因此其他人无法更改问题的状态，甚至无法读取问题附带的信息。

根据问题的类型，问题可能会经历不同的工作流步骤：可能会报告或复制错误、分析根本原因、开发或测试修复程序、创建补丁程序、与下一版本合并或在版本中发布修复程序。这是一个带有几个状态的简单工作流。

关系管理允许在问题之间设置不同的关系，并允许用户沿着这些关系从一个问题导航到另一个问题。例如，一个客户端报告一个 bug，并且该 bug 被识别为与另一个已经修复的 bug 相同。在这种情况下，按照原来的工作流程为同一个 bug 创建一个新补丁是非常愚蠢的。相反，问题获取指向原始问题的关系，并将状态设置为关闭。

与其他系统的集成也有助于保持一致的开发状态。版本控制可能要求，对于每个提交，提交消息都包含对描述代码修改支持的需求、bug 或更改的问题的引用。问题可以通过 web 链接链接到知识库文章或敏捷项目管理软件工具。

# 测试

当我们谈到单元测试时，我们已经讨论了测试。单元测试在敏捷开发中非常重要，它有助于保持代码的整洁并减少错误的数量。但这并不是您在企业开发中看到的唯一测试类型。

# 测试类型

执行测试有很多原因，但至少有两个原因需要提及。一种是尽可能地查找 bug 并创建无错误代码。另一个目的是证明应用程序是可用的，并且可以用于其预期目的。从企业的角度来看，它很重要，并且考虑了很多单元测试没有考虑的方面。虽然单元测试集中在一个单元上，因此是指出错误所在的一个非常好的工具，但在发现来自模块间错误接口的错误时，它是完全不可用的。单元测试模拟外部模块，从而测试单元是否按预期工作。但是，如果此预期中存在错误，并且其他模块的行为方式与单元测试模拟不同，则不会发现错误。

为了发现这个级别上的错误，也就是单元测试之上的下一个级别，我们必须使用集成测试。在集成测试期间，我们测试各个单元如何协同工作。当我们用 Java 编程时，单元通常是类；因此，集成测试将测试不同类如何协同工作。虽然对于 Java 编程中的单元测试是什么有一个共识（或多或少），但在集成测试中就不是这样了。

在这方面，外部依赖性，例如可通过网络或数据库层访问的其他模块，可以被模拟，或者可以在集成测试期间使用一些测试实例来设置。争论的焦点不是这些部分是否应该被嘲笑，而是术语。模拟某些组件（如数据库）既有优点也有缺点。与任何模拟一样，缺点是设置模拟的成本以及模拟行为与实际系统不同的事实。这样的差异可能会导致一些 bug 仍然留在系统中，并潜伏在那里，直到稍后的测试或者，上帝饶恕，生产被使用。

集成测试通常以类似于单元测试的方式实现自动化。然而，它们通常需要更多的时间来执行。这就是为什么不在每次源代码更改时执行这些测试的原因。通常，会创建一个独立的 maven 或 Gradle 项目，该项目依赖于应用程序 JAR，并且只包含集成测试代码。该项目通常每天进行编译和执行。

日常执行的频率可能不足以及时发现集成问题，但更频繁地执行集成测试仍然是不可行的。在这种情况下，集成测试用例的子集被更频繁地执行，例如，每小时执行一次。这种类型的测试称为烟雾测试。
下图显示了不同测试类型的位置：

![](../images/00066.gif)

当应用程序在完全设置的环境中进行测试时，该测试称为系统测试。这样的测试应该发现所有可能在之前的测试阶段潜伏和覆盖的集成 bug。不同类型的系统测试也可以发现非功能性问题。功能测试和性能测试都是在这个级别上完成的。

功能测试检查应用程序的功能。它确保应用程序按预期运行，或者至少具有值得在生产环境中安装的功能，并且可以节省成本或增加利润。在现实生活中，程序几乎从来不会提供任何需求文档中设想的所有功能，但是如果程序能够正常使用，那么安装它是值得的，假设没有安全问题或其他问题。

如果应用程序中有很多功能，那么功能测试可能会花费很多成本。在这种情况下，一些公司会执行一项健全测试。此测试不检查应用程序的全部功能，只检查一个子集，以确保应用程序达到最低质量要求，并且值得在功能测试上花钱。

在设计应用程序时，可能存在一些未预见到的测试用例，因此功能测试计划中没有测试用例。这可能是一些奇怪的用户行为，用户在没有人认为可能的情况下按下屏幕上的按钮。用户，即使是仁慈的，也会碰巧按下或触摸任何东西，并将所有可能不现实的输入输入到系统中。特别测试试图弥补这一不足。测试人员在临时测试期间会尝试所有可能的应用程序使用方法，这些方法是他或她在执行测试时可以想象的。

这也与安全测试有关，在发现系统漏洞时也称为渗透测试。这些是由在安全领域拥有核心专业知识的专业人员执行的特殊类型的测试。开发人员通常不具备这种专业知识，但至少，开发人员应该能够讨论在此类测试中发现的问题，并修改程序以修复安全漏洞。这在互联网应用程序中非常重要。

性能测试检查应用程序在合理的环境中是否能够处理用户在系统上施加的预期负载。负载测试模拟攻击系统的用户并测量响应时间。如果响应时间合适，即低于最大负载下所需的最大值，则试验通过；否则，它将失败。如果负载测试失败，则不一定是软件错误。应用程序可能需要更多或更快的硬件。负载测试通常只以有限的方式测试应用程序的功能，并且只测试对应用程序造成读取负载的使用场景。

许多年前，我们在测试一个响应时间必须为 2 秒的 web 应用程序。负载测试非常简单：发出`GET`请求，以便同时最多有 10000 个活动请求。我们从 10 个客户端开始，然后一个脚本将并发用户增加到 100 个，然后是 1000 个，然后每分钟增加 1000 个。这样，负载测试长达 12 分钟。脚本打印了平均响应时间，我们准备在周五下午 4:40 执行负载测试。
平均响应时间从几毫秒开始，随着负载增加到 5000 个并发用户，平均响应时间上升到 1.9 秒，然后随着负载增加到 10000 个用户，平均响应时间下降到 1 秒。你可以理解人们在周五下午的态度，很高兴我们满足了要求。我的同事们愉快地去度周末了。我继续进行更多的测试，因为当我们将负载增加到 5000 以上时，响应时间会减少，这一现象让我感到困扰。首先，我复制了测量结果，然后开始查看日志文件。晚上 7 点，我已经知道了原因。
当负载超过 5000 时，Apache 服务器正在管理的连接开始耗尽，web 服务器开始发回 500 个内部错误代码。这是 Apache 可以非常有效地做到的。它很快就告诉你，你不能得到服务。当负载大约为 10000 个并发用户时，70%的响应已经有 500 个错误。平均值下降了，但用户实际上没有得到服务。我重新配置了 Apache 服务器，以便它能够服务于所有请求，并将每个请求转发给我们的应用程序，只是为了了解应用程序在最大负载下的响应时间大约为 10 秒。晚上 10 点左右，当我妻子第三次打电话给我的手机时，我也知道我应该在 JVM 选项中的 Tomcat 启动文件中设置多大的内存，以便在 10000 个并发用户的情况下获得所需的 2 秒响应时间。

压力测试也是一种你也可能面临的性能测试。这种类型的测试会增加系统的负载，直到无法处理负载为止。该测试应确保系统能够自动或手动从极端负载中恢复，但在任何情况下，都不会做不应该做的事情。例如，烘焙系统不应该提交未确认的事务，无论负载有多大。如果负荷太高，那么面团应保持生面团，但不应烘烤额外的面包。

层次结构顶部最重要的测试是用户验收测试。这通常是一个正式测试，由购买软件的客户执行，如果成功执行，则为软件支付价格。因此，这在专业发展中极为重要。

# 测试自动化

测试可以自动化。这不是一个是否有可能自动化测试的问题，而是这样做是否值得。单元测试和集成测试是自动化的，随着时间的推移，随着我们向**用户验收测试**（**用户验收测试**迈进，越来越多的测试实现自动化。UAT 不太可能实现自动化。毕竟，这个测试检查应用程序和用户之间的集成。虽然用户作为一个外部模块，可以在较低的级别上使用自动化进行模拟，但我们应该在没有模拟的情况下达到集成测试的级别。

有许多工具可以帮助测试自动化。如今，阻碍测试自动化的是这样做的工具成本、学习和开发测试的成本，以及对自动化测试没有发现某些错误的恐惧。

的确，使用程序比不使用程序更容易出错。这不仅适用于测试，而且适用于几乎任何东西。我们仍然使用程序；不然你为什么要读这本书？一些错误可能在自动功能测试期间不会被发现，否则会使用手动测试发现。同时，当同一个开发人员第一百次执行同一个测试时，很容易跳过错误。自动化测试永远不会做到这一点。最重要的是，自动化测试的成本不是运行一次测试成本的 100 倍。

我们在本书中使用了测试自动化工具。**SoapUI**是一个帮助您创建可以自动执行的测试的工具。其他值得一看的测试工具有**Cumber**、**Concordion**、**Fintnesse**和**JBehave**。在[上有一个很好的工具比较 https://www.qatestingtools.com/](https://www.qatestingtools.com/) 。

# 黑盒子对白盒子

您可能多次听说测试是黑盒测试。这仅仅意味着测试不知道被测系统（SUT）是如何实现的。测试仅依赖于为外部世界导出的 SUT 接口。天平另一端的白盒测试测试 SUT 的内部工作，并在很大程度上依赖于实现：

![](../images/00067.gif)

这两种方法各有优缺点。我们应该使用一种或两种方法的混合，一种最适合实际测试需要的方法。如果实现发生变化，不依赖于实现的黑盒测试不需要改变。如果被测试系统的接口发生变化，则测试也应发生变化。如果实现发生变化，即使接口保持不变，白盒测试也可能需要改变。白盒测试的优点是，在很多情况下，创建这样的测试更容易，测试也更有效。

为了充分利用这两个方面，系统被设计为可测试的。不过要小心。这意味着很多时候，被测试系统内部的功能会传播到接口。这样，测试将只使用接口，因此可以声明为黑盒，但它没有帮助。如果被测系统的内部工作发生变化，则测试必须随之进行。唯一的区别是，如果接口也发生更改，您可以将其称为黑盒测试。这不会节省任何工作。相反，它增加了它：如果依赖接口的所有模块也需要任何更改，我们必须检查它们。

我并不是说我们不应该关注创建可测试系统。很多时候，使系统可测试会产生更干净、更简单的代码。但是，如果代码变得更混乱、更长，因为我们想使其可测试，那么我们可能没有走上正确的道路。

# 选择图书馆

如果不使用外部库，就无法为企业编程，甚至不能为中等规模的项目编程。在 Java 世界中，我们使用的大多数库都是开源的，或多或少都是免费的。当我们购买一个以金钱出售的图书馆时，通常有一个由采购部门执行的标准流程。在这种情况下，有一个关于如何选择供应商和库的书面策略。在“自由”软件的情况下，他们通常不关心，尽管他们应该关心。在这种情况下，选择过程主要取决于 IT 部门，因此，在选择图书馆之前，即使是免费的，也必须了解需要考虑的要点。

在上一段中，我把 free 放在引号之间。这是因为没有免费的软件。正如人们所说，没有免费的午餐。您已经听过很多次了，但是对于您将要选择的开源代码库或框架来说，这可能并不明显。任何购买或实施的主要选择因素是成本、价格。如果该软件是免费的，这意味着您不需要为该软件支付预付费。然而，集成和使用它是有成本的。支持需要钱。有人可能会说，这种支持是社区支持，也是免费的。问题是，你花在寻找一个能帮助你克服错误的解决方法上的时间仍然是金钱。这是你的时间，或者如果你是一名经理，这是你所在部门的专业人员的时间，他们的时间由你支付，或者，事实上，如果你没有解决问题的内部专业知识，外部承包商会给你一大笔账单。

由于自由软件没有附加价格标签，我们必须考虑选择过程中的其他重要因素。最终，它们都会以某种方式影响成本。有时，标准改变成本的方式并不明显，也不容易计算。然而，对于每一个库，我们都可以根据技术决策来设置禁行级别，并且我们可以根据每个标准来比较库的优劣。

# 适切

也许，这是最重要的因素。其他因素可能会因重要性的大小而引起争论，但如果一个图书馆不适合我们想要使用的目的，那么无论发生什么，这肯定是不可选择的。在许多情况下，这可能是显而易见的，但您可能会惊讶地发现，有多少次我看到一个产品被选中，因为它是其他项目中某个人的最爱，而该库被强制用于新项目中，尽管要求完全不同。

# 许可证

许可证是一个重要的问题，因为并非所有的自由软件都是免费的。一些许可证允许免费使用爱好项目和教育，但要求您购买该软件用于专业、以盈利为导向的用途。

最广泛使用的许可证及其解释（以及许可证全文）可在**开源倡议**（[的网页上获得 https://opensource.org/licenses](https://opensource.org/licenses) ）。它列出了九个不同的许可证，为了使情况更复杂一些，这些许可证有不同的版本。

最古老的许可证之一是代表 GNU 的**通用公共许可证**（**GPL**）。本许可证包含以下句子：

例如，如果您分发此类计划的副本，无论是免费的还是收费的，您必须将您获得的相同自由传递给接收者。您必须确保他们也能接收或获得源代码。

如果您为营利性企业创建软件，而该公司打算销售软件，则可能无法使用 GPL 许可软件中的任何代码行。这意味着您需要传递自己的源代码，这可能不是最好的销售策略。另一方面，Apache 许可证对您的公司来说可能还可以。这应该由律师来决定。

尽管这是律师的工作，但有一点我们开发人员必须意识到并密切关注。有时，这些库包含来自其他项目的代码，它们的许可证（如广告所示）可能不是真正的许可证。库可以在 Apache 许可下分发，但包含 GPL 许可的代码。这显然违反了 GPL 许可证，这是由一些开源开发人员犯下的。你为什么会在乎？下面通过一个想象的情况来解释。

您为企业开发软件。比如说，这家公司是世界上最大的汽车制造商之一，或者是最大的银行、制药公司等等。GPL 软件的所有者寻求对其软件滥用的补救措施。她会起诉拥有 20 万总财富的软件开发人员 John Doe，还是你的公司，声称你没有及时检查代码的许可证？她当然不会在没有金子的地方挖金子。起诉你工作的公司可能不会成功，但肯定不是你或公司任何人想要的好程序。

作为软件专业人员，我们能做什么？

我们必须使用知名的、广泛使用的图书馆。我们可以检查库的源代码，看看是否有复制的代码。一些包名可能会提供一些线索。您可以通过谷歌搜索部分源代码来查找匹配项。最后但并非最不重要的一点是，该公司可以订阅为图书馆提供类似研究的服务。

# 文档

文档是一个重要方面。如果文档不合适，将很难学习如何使用该库。一些团队成员可能已经知道该库，但对于以后的团队成员来说，情况可能并非如此。我们应该考虑我们的同事，他们是普通的程序员，他们必须学习图书馆的使用。因此，文件编制很重要。

当我们谈到文档时，我们不仅应该考虑*JavaDoc*参考文档，还应该考虑教程和书籍（如果有的话）。

# 活生生的计划

不要选择一个不活动的库来使用，这一点很重要。查看库的路线图、上一次发布的时间以及提交的频率。如果图书馆不存在，我们应该考虑不使用它。库在一个环境中工作，环境会发生变化。库可以连接到数据库。新版本的数据库可能会提供新的功能，只有在修改库以适应这些新功能的情况下，才能提供更好的性能。库通过 HTTP 进行通信；它是否支持该协议的新 2.0 版本？如果没有其他变化，Java 环境的版本将随着时间的推移而改变，我们使用的库迟早会跟随它来利用新特性。

不能保证一个活着的库总是活着的。然而，一个已经死了的图书馆肯定不会复活。

即使该项目目前仍在进行中，也有一些要点可以为该库的未来提供一些提示。如果开发该图书馆的公司已建立良好且财务稳定，且图书馆的开发具有合理的商业模式，则该项目死亡的风险较低。如果有很多公司使用该库，那么即使原始团队停止工作或原始融资结构发生变化，该项目也有可能继续存在。然而，这些只是小因素，并不是公认的事实。没有保证，告诉未来与其说是一门科学，不如说是一门艺术。

# 成熟

成熟度与之前的标准类似。一个项目可能在刚开始的时候还活着，但如果它还处于初级阶段，我们最好不要将该库用于大型项目。当一个项目处于早期阶段时，代码中可能存在很多 bug，API 可能会发生根本性的变化，并且可能只有少数公司依赖代码。这也意味着社区支持度较低。

当然，如果所有项目都只选择成熟的开源代码，那么任何开源项目都不会达到成熟状态。我们应该评估这个项目的重要性。项目是否对业务至关重要？该项目是否会成为业务关键型项目？

如果项目不是业务关键型的，公司可能有能力发明一个不那么成熟的新库。如果没有用于此目的的成熟库，这可能是合理的，因为您将要使用的技术相对较新。在这种情况下，公司中的项目可能也是新的，并且还不是业务关键型的。我们希望，经过一段时间后，它将是业务关键型的，但到那时，该库将成熟，或者可能会消亡，我们可以在项目变得过于昂贵而无法切换之前选择一个竞争解决方案。

判断一个库的成熟度总是很困难的，必须与我们想要使用该库的项目的成熟度和重要性保持一致。

# 用户数

如果图书馆还活着，还很成熟，但是用户不多，那么有些东西就很臭。如果图书馆好的话，为什么人们不使用它呢？如果一个库或框架的用户数量很低，并且用户中没有大公司，那么它可能不是一个好的库或框架。没有人使用它可能表明我们对其他标准的评估可能不合适。

还要注意的是，如果图书馆只有少数用户，那么社区中的知识也很稀缺，我们可能无法获得社区支持。

# “我喜欢”的因素

最后但并非最不重要的是，*我喜欢它*因素非常重要。问题不在于你是否喜欢这个库，而在于开发者有多喜欢它。开发人员会喜欢一个易于使用和有趣的库，这将导致低成本。如果库很难使用，而且开发人员不喜欢它，那么他们就不会学习如何使用它达到高质量所需的专业水平，而只是达到所需的水平。最终结果将是次优软件。

# 持续集成和部署

持续集成意味着，每当将新版本推送到源代码存储库时，持续集成服务器就会启动，将代码拉到磁盘上，并开始构建。它首先编译代码，然后运行单元测试，启动静态代码分析工具，如果一切顺利，它会打包快照版本并将其部署到开发服务器上。

CI 服务器具有可用于创建版本的 web 界面。在这种情况下，部署甚至可以转到测试服务器，甚至可以转到生产服务器，具体取决于本地业务需求和相应创建的策略。

构建和部署过程的自动化与任何其他自动化具有相同的优点：重复的任务可以在没有人工干预的情况下执行，这是乏味的、枯燥的，因此，如果由人工完成，则容易出错。突出的优点是，如果源代码中有一些可以通过自动构建过程发现的错误，就会被发现。新手开发人员说，在本地构建代码更便宜、更容易，不管怎样，开发人员都会这样做，如果构建过程已经被检查，然后将代码推送到服务器上。这在一定程度上是正确的。在将代码发送给中央回购之前，开发人员必须检查代码的质量和构建是否良好。然而，这并非总能实现。某些错误可能不会在本地环境中显示。

可能会发生这样的情况：一个开发人员意外地使用了比支持的版本更新的 Java，并使用了新版本的新功能。企业一般不使用最新技术。他们倾向于使用经过验证、拥有众多用户且成熟的版本。今年，在 2017 年，当 Java 9 将于 7 月发布时，大型企业仍在使用 Java 1.6 和 1.7。由于 Java9 有许多新特性，实现起来并不简单，因此我预计采用该技术可能比采用 Java1.8 需要更长的时间，因为 Java1.8 为我们提供了函数式编程和 lambda。

也可能会出现这样的情况：一个新的库被添加到构建的依赖项中，并且将它添加到构建文件（`pom.xml`或`build.gradle`中的开发人员可以在其本地计算机上使用它，而不会出现任何问题。这并不意味着该库已正式添加到项目中，而且它可能在中央代码存储库（Artifactory、Nexus 或代码存储库的其他实现）中不可用。该库可能只存在于开发人员的本地存储库中，并且她可能认为既然代码已经编译，构建就可以了。

一些大型组织为不同的项目使用不同的代码存储库。经过仔细的检查和决策，图书馆进入这些存储库。一些图书馆可能到达那里，而其他图书馆可能无法到达。拥有不同存储库的原因可能很多。有些项目是为一个客户开发的，这个客户对开源项目的政策与另一个不同。如果企业为自己开发代码，可能会出现某些库被淘汰或不再受支持的情况，并且只能用于旧项目。维护版本可能不需要替换库，但新项目可能不允许使用正在消亡的软件库。

CI 服务器可以在一台机器上运行，也可以在多台机器上运行。如果它服务于多个项目，可以将其设置为一个中央服务器，在不同的机器上运行多个代理。当必须启动某些生成过程时，中央服务器将此任务委托给其中一个代理。代理可能具有不同的负载，运行多个不同的构建过程，并且可能具有不同的硬件配置。构建过程可能对处理器的速度或可用内存有要求。一些代理可能会为较小的项目运行更简单的构建，但无法执行大型项目的构建，或者执行某些测试仍然需要大量内存的小型项目的构建。

当构建失败时，构建服务器会向开发人员发送电子邮件，向代码存储库发送最后一次更新的人有义务毫不延迟地修复错误。这鼓励开发人员频繁地提交。更改越小，出现构建问题的可能性就越小。BuildServerWeb 界面可用于查看项目的实际状态，哪个项目无法生成，哪个项目还可以。如果构建失败，则在构建行中有一个红色标志，如果构建正常，则标志为绿色。

很多时候，这些报告会在一些旧机器上使用巨大的显示器持续显示，以便每个开发人员或任何进入房间的人都可以看到构建的实际状态。你甚至可以买一些特殊的硬件，它们有红、黄、绿三种颜色的指示灯来跟踪构建的状态，并在构建失败时鸣钟。

# 发布管理

开发软件意味着不断变化的代码库。并不是每个版本的软件都应该安装在生产环境中。大多数版本都是在一个分支上推送到存储库的。有些版本仅用于测试，有些版本将在生产中安装，即使其中只有一部分最终将投入生产。

几乎所有的版本都遵循我们在前面一节中讨论的语义版本控制。仅用于测试的版本通常在版本号末尾有`-SNAPSHOT`修饰符。例如，`1.3.12-SNAPSHOT`版本是曾经调试过的版本，将成为`1.3.12`版本。快照版本不是确定的版本。到那时，它们就是代码。由于快照版本从未在生产环境中安装，因此不需要为维护复制快照版本。因此，快照版本不会不断增加。有时，它们可能会改变，但这是一个罕见的例外。

我们可能会修复一个 bug，`1.3.12-SNAPSHOT`，在开发过程中，我们更改了太多代码，以至于我们决定发布时必须是`1.4.0`，并将快照重命名为`1.4.0-SNAPSHOT`。这是一个罕见的案例。很多时候，版本创建会从`1.3.12-SNAPSHOT`创建`1.4.0`版本，因为在创建版本时会决定新的版本号。

发布过程开始时，通常从 CI 服务器的 web 界面开始，创建发布的开发人员必须指定发布版本。这通常与没有`-SNAPSHOT`后缀的快照版本相同。在这种情况下，构建过程不仅创建构建，还标记它正在使用的源代码存储库版本，并将打包的程序（工件）加载到代码存储库中。稍后可以使用该标记访问用于创建发行版的源代码的确切版本。如果特定版本中存在错误，则必须在开发人员机器上签出该版本，以重现错误并找到根本原因。

如果版本的构建失败，可以回滚，或者您最好跳过该版本号，并将其记为失败的版本构建。现有版本不能有两个版本。源代码是该版本的唯一代码，生成的代码必须与任何存储中的代码完全一致。例如，如果使用不同版本的 Java 来创建后一个源代码，那么对同一源代码的后续编译可能会产生稍微不同的代码。即使在这种情况下，构建服务器首先创建的版本也是属于该版本的版本。当一个 bug 被复制并且代码被从完全相同的源代码重新编译时，它已经是一个快照版本了。同一源代码版本可能有多个版本，例如，使用 Java 版本 1.5 到 1.8 以及版本 9 编译，但单个版本始终属于完全相同的源代码。

如果在 QA 检查期间，本应为发布版本的发布失败，则必须创建一个新的发布，并将失败的发布记录下来。市场营销用于命名不同版本的版本不应与我们使用的技术版本号有任何关系。很多时候是这样，而且会引起很多头痛。如果你意识到这两件事完全不同，一件不必和另一件做任何事情，生活就会变得简单。看看 Windows 操作系统或 Java 的不同版本。作为市场营销，Java 先使用 1.0，然后使用 1.1，但 Java 1.2 被宣传为 Java 2，代码中仍然包含 1.2（现在 7 个主要版本后来也变成了 9，而不是 1.9）

发布管理的最后一部分是部署应注册版本号。公司必须知道哪个版本安装在哪个服务器上，哪个客户端。

# 代码库

代码存储库存储库并帮助管理不同库的依赖关系。在旧时代，当 Java 项目使用 ANT 作为构建工具，并且没有后来添加的 Ivy 依赖关系管理时，项目所需的库被下载到源代码中，通常下载到`lib`库中。如果一个库需要另一个库，那么这些库也会被手动下载和存储，直到已经下载的库需要的所有库都被复制到源代码树中。

这需要大量的手工工作，而且库代码以许多副本的形式存储在源代码存储库中。编译后的库不是源代码，与源代码存储库无关。可以自动化的手工工作必须自动化。不是因为开发人员懒惰（是的，我们是，我们必须是），而是因为手工工作容易出错，因此成本高昂。

这是 ApacheIvy 发明的时候，Maven 跟随 ANT 已经支持内置的存储库管理。它们都将库存储在目录中，并支持描述与其他库的依赖关系的元数据。幸运的是 Gradle 没有发明自己的代码库。相反，它支持 Maven 和 Ivy 存储库。

使用存储库，构建工具会自动下载所需的库。如果库有新版本，那么开发人员只需在构建配置中更新所需库的版本，所有任务（包括下载该版本所需的其他库的所有新版本）都会自动完成。

# 爬上梯子

现在，您已经获得了许多信息，这些信息将推动您作为企业 Java 开发人员的起步。你有一个基本的知识，你可以建立。要成为一名专业的 Java 开发人员还有很长的路要走。有很多文档需要阅读，有很多代码需要扫描和理解，还有很多代码需要编写，直到你可以自称是一名专业的 Java 开发人员。你可能会面临多年的继续教育。好的是，即使在那之后，你也可以继续你的旅程，你可以自学成才，因为作为一名专业的 Java 开发人员，人们很少会退休。不，不！并不是因为他们死了！相反，获得经验的专业软件开发人员开始越来越少地编写代码，并以不同的方式支持开发过程，这将更多地利用他们的经验。他们可以成为业务分析师、项目经理、测试工程师、主题专家、架构师、scrum 大师、自动化工程师等等。这是一份熟悉的清单吗？是的，这些是作为开发人员与您一起工作的人。他们中的许多人可能是从开发人员开始的。
下图显示了这些角色的相对位置：

![](../images/00068.gif)

让我们更详细地了解这些角色在企业发展中所起的作用：

*   业务分析师与客户机合作，创建开发人员开发代码所需的文档、规范、用例和用户故事。
*   项目经理管理项目，并帮助团队与其他团队合作完成工作，关心开发人员无法处理或不必要地浪费他们本应用于编码的时间的所有项目事项。
*   主题专家在了解业务需求方面更为先进，因此开发人员成为一个主题专家有点罕见，但如果您所在的行业是以技术为导向的，那么成为一个主题专家可能并不令人难以置信。
*   测试工程师控制 QA 过程，不仅了解测试方法和测试要求，还了解开发过程，以便他们能够支持错误修复，并且不仅能够识别错误，这将是很糟糕的。
*   架构师与 BAs 合作，设计应用程序和代码的高级结构，并以一种帮助开发人员专注于他们必须执行的实际任务的方式记录它。架构师还负责使用技术、解决方案和结构的解决方案，这些技术、解决方案和结构符合目的，经得起未来考验，价格合理，等等。
*   Scrum 伙伴帮助开发团队遵循敏捷方法，并帮助团队控制管理和解决问题。

作为一名软件开发人员，有很多方法可以选择，我只列出了今天在企业中可以找到的一些职位。随着技术的发展，我可以想象，在 20 年后的今天，软件开发人员将教授和管理人工智能系统，这就是我们今天所说的编程。谁知道呢？

# 总结

朝这个方向走是个不错的选择。作为一名 Java 开发人员，成为 it 专业人士，肯定会在未来 10 到 20 年甚至更晚的时间里获得丰厚的回报。同时，我个人觉得这项技术很吸引人，也很有趣，经过 10 多年的 Java 编程和 35 年的编程，我仍然每天从中学习新的东西。

在本书中，您学习了 Java 编程的基础知识。我还不时地提到一些问题、建议的方向，并警告您注意一些不特定于 Java 的陷阱。然而，我们也做了学习 Java 语言、基础设施、库、开发工具和 Java 网络的家庭作业。您还学习了只有 Java8 和 Java9 才能使用的最现代的方法，例如 Java 中的函数式编程、流式编程和反应式编程。如果您知道我在这本书中写的所有内容，您可以开始作为 Java 开发人员工作。下一步是什么？去吧，在编程和 Java 中找到你的宝藏！