# 优化排序代码

在本章中，我们将开发排序代码并使其更通用。我们不仅要对字符串数组进行排序。本质上，我们将编写一个程序，可以对任何可排序的内容进行排序。这样，我们将充分利用 Java 的一个主要优势：*抽象*。

然而，抽象并不是没有价格标签的。当您有一个对字符串进行排序的类，并且您意外地将一个整数或其他非字符串的内容混合到可排序数据中时，编译器会对此进行抱怨：Java 不允许您将`int`放入`String`数组中。当代码更抽象时，这样的编程错误可能会溜进来。我们将研究如何处理此类异常情况—捕获和抛出异常。

为了识别 bug，我们将使用单元测试，应用行业标准 JUnit 版本 4。由于 JUnit 大量使用注释，而且注释很重要，所以您将对它有一点了解。

之后，我们将修改代码以使用 Java 的*泛型*特性，该特性是在版本 5 中引入该语言的。利用这种可能性，我们将在编译时捕获编码错误，这比在运行时更好。越早发现 bug，修复的成本就越低。

对于构建，我们仍将使用 Maven，但这一次，我们将把代码拆分为几个小模块。因此，我们将有一个多模块项目。对于排序模块的定义和不同的实现，我们将有单独的模块。这样，我们将了解类如何相互扩展并实现接口，通常，我们将真正开始以面向对象的方式编程。

我们还将讨论**测试驱动开发**（**TDD**），在本节末尾，我们将开始使用 Java 9 的全新特性：模块支持。

在本章中，我们将介绍以下主题：

*   面向对象编程原理
*   单元测试实践
*   算法复杂性和快速排序
*   异常处理
*   递归方法
*   模块支持

# 通用排序程序

在上一章中，我们实现了一个简单的排序算法。代码可以对`String`数组的元素进行排序。我们这样做是为了学习。为了实际使用，JDK 中有一个现成的排序解决方案，可以对`collections`的成员进行排序，这些成员具有可比性。

JDK 包含一个名为`Collections`的实用程序类。此类包含一个静态`Collections.sort`方法，该方法能够对任何具有`Comparable`成员的`List`进行排序。`List`和`Comparable`是 JDK 中定义的接口。因此，如果要对字符串列表进行排序，最简单的解决方案如下：

```
public class SimplestStringListSortTest { 
    @Test 
    public void canSortStrings() { 
        ArrayList actualNames = new ArrayList(Arrays.asList( 
                "Johnson", "Wilson", 
                "Wilkinson", "Abraham", "Dagobert" 
        )); 
        Collections.sort(actualNames); 
        Assert.assertEquals(new ArrayList<String>(Arrays.<String>asList( 
                "Abraham", "Dagobert", "Johnson", "Wilkinson", "Wilson")), actualNames); 
    } 
}

```

此代码片段来自 JUnit 测试示例，这就是我们在方法前面有`@Test`注释的原因。我们稍后将详细讨论这一点。要执行该测试，可以发出以下命令：

```
$ mvn -Dtest=SimplestStringListSortTest test

```

然而，这种实现并不适合我们的需要。首先，因为它已经准备好了（不需要编码），并且使用它不需要您在前面章节中没有学到的任何新东西。除了方法前面的注释外，代码中没有您无法理解的新内容。您可以通过返回一些页面进行刷新，或者查阅 JDK 的 oracle 在线文档（[https://docs.oracle.com/javase/8/docs/api/](https://docs.oracle.com/javase/8/docs/api/) ），但仅此而已。你已经知道这些事情了。

您可能想知道为什么我要将 JavaVersion8API 的 URL 写到链接中。好吧，现在是我写这本书时诚实和真实的时刻，Java9JDK 没有最终版本。我在 Mac Book 上使用 Java8 创建了大多数示例，并且只测试了 Java9 特有的特性。目前在 IDE 中对 Java9 的支持并不完美。当您阅读本书时，Java9 将是可用的，因此您可以尝试将 URL 中的一位数字从 8 更改为 9，并获得版本 9 的文档。目前，我得到 HTTP 错误 404。
有时，您可能需要旧版本的文档。您可以在 URL 中使用 3、4、5、6 或 7 而不是 8。3 和 4 的文档不能在线阅读，但可以下载。希望你不再需要它。也许是第五版。版本 6 仍然在大型公司中广泛使用。

虽然您可以从阅读其他程序员编写的代码中学到很多东西，但我不建议您在学习的早期阶段尝试学习 JDK 源代码。这些代码块经过了大量优化，不是教程代码，而且很旧。这些年来，它们并没有生锈，但随着 Java 的成熟，它们并没有按照 Java 的编码风格进行重构。在某些地方，您可以在 JDK 中找到非常难看的代码。

好吧，说我们需要开发一个新的排序代码，因为我们可以从中学习，这有点做作。我们需要排序实现的真正原因是，我们需要的不仅仅是能够对`List`数据类型进行排序的东西，还需要能够实现`Comparable`接口的`List`东西。我们要对一堆对象进行排序。我们所需要的是，包含对象的*串*提供了简单的方法，这些方法足以对对象进行排序，并具有已排序的*串*。

本来我想用*collection*这个词来代替*bunch*，但是 Java 中有一个`Collection`接口，我想强调的是，我们不是在谈论对象的`java.util.Collection`。

我们也不希望对象实现`Comparable`接口。如果我们要求对象实现`Comparable`接口，可能会违反**单一责任原则**（**SRP**）。

当我们设计一个类时，它应该对现实世界中的一些对象类进行建模。我们将用类对问题空间进行建模。类应该实现表示它所建模的对象行为的特性。如果我们看第二章中的学生示例，那么`Student`类应该代表所有学生都具有的特征，并且从建模的角度来看*很重要*。`Student`对象应该能够说出学生的姓名、年龄、去年的平均分数等。所有学生都有脚，当然每个脚都有大小，所以我们可能认为`Student`类也应该实现一个方法，返回学生脚的大小（一个用于左边，一个用于右边，只是为了精确），但我们没有。我们没有，因为脚的大小与模型的角度无关。如果我们想要对包含`Student`对象的列表进行排序，`Student`类必须实现`Comparable`接口。但是等等！你如何比较两个学生？按名字，按年龄。还是按他们的平均分数？

比较一个学生和另一个学生不是`Student`的特征。每个类，或者就此而言，包、库或编程单元都应该有一个职责，它应该只实现这个职责，而不实现其他职责。这并不准确。这不是数学。有时，很难判断某个功能是否适合承担责任。有一些简单的技术。例如，对于一个学生，你可以询问真实的人他的名字和年龄，他们也可以告诉你他们的平均分数。如果你让他们中的一个去`compareTo`（另一个学生），因为`Comparable`接口需要这种方法，他们可能会回问，但是通过什么属性？或者如何？或者只是，什么？在这种情况下，您可能会怀疑实现该特性可能不在该类和该关注点的范围内；比较应该与原始类的实现分离。这也称为**关注点分离**，与 SRP 密切相关。

JDK 开发人员知道这一点。`Collections.sort`对`Comparable`元素中的`List`进行排序并不是此类中唯一的排序方法。另一种方法是，如果您传递第二个参数和对象来实现`Comparator`接口，并且能够比较`List`的两个元素，则可以对任何`List`进行排序。这是分离关注点的干净模式。在某些情况下，不需要分离比较。在其他情况下，这是可取的。`Comparator`接口声明了实现类必须提供的一个方法：`compare`。如果两个参数相等，则此方法返回`0`。如果它们不同，它应该返回一个否定或肯定的`int`，这取决于哪个参数在哪个参数之前。

JDK 类中还有`sort`方法`java.util.Arrays`。它们对数组进行排序，或者仅对数组的一部分进行排序。该方法是方法重载的一个很好的例子。有一些方法具有相同的名称，但具有不同的参数，可以为每个基元类型对整个数组进行排序，为每个基元类型的一个片段排序，也有两个方法用于实现`Comparable`接口的对象数组，以及要使用`Comparator`进行排序的对象数组。如您所见，JDK 中提供了一系列的排序实现，在 99%的情况下，您不需要自己实现排序。排序使用相同的算法，这是一种经过一些优化的稳定合并排序。

我们将要实现的是一种通用方法，它可以用来对列表、数组或任何包含元素的东西进行排序，并且可以交换其中的任意两个元素；解决方案将能够使用我们已经开发的冒泡排序和其他算法。

# 各种排序算法的简要概述

有许多不同的排序算法。正如我所说，有更简单和更复杂的算法，在许多情况下，更复杂的算法运行得更快。在本章中，我们将实现冒泡排序和快速排序。在前一章中，我们已经实现了字符串的冒泡排序，因此在本例中，实现将主要集中于对一般可排序对象排序的重新编码。实现快速排序需要一些算法方面的兴趣。

请注意，本节仅为您提供算法复杂性的体验。这远远不够精确，我徒劳地希望没有数学家读到这篇文章并诅咒我。有些解释含糊不清。如果你想深入学习计算机科学，那么在读完这本书之后，找一些其他的书或者访问在线课程。

当我们讨论一般排序问题时，我们会考虑一些可以比较的一般对象集，并且在排序时可以交换任意两个对象。我们还将假设这是一种就地排序；因此，我们不会创建另一个列表或数组来按排序顺序收集原始对象。当我们谈论算法的速度时，我们谈论的是一些抽象的东西，而不是毫秒。当我们想要谈论毫秒，实际的真实世界的持续时间时，我们应该已经有一些在真实计算机上运行的编程语言的实现。

算法，以其抽象形式，在没有实现的情况下是不会这样做的。不过，值得一提的是算法的时间和内存需求。当我们这样做的时候，我们通常会研究算法对于大量数据的行为。对于一小部分数据，大多数算法都很快。对两个数字进行排序通常不是问题，是吗？

在排序的情况下，我们通常会检查需要多少比较来对*n*元素的集合进行排序。气泡排序大约需要 n<sup class="calibre29">2</sup>（n 次*n*比较。我们不能说这就是*n*<sup class="calibre29">2</sup>，因为在*n=2*的情况下，结果是 1，*n=3*是 3，*n=4*是 6，依此类推。然而，随着*n*开始变大，所需的实际比较次数和*n*n<sup class="calibre29">2</sup>将逐渐具有相同的值。我们说冒泡排序的算法复杂度是*O（n<sup class="calibre29">2</sup>*。这也被称为 big-O 符号。如果你有一个算法是*O（n<sup class="calibre29">2</sup>*，它可以在一秒钟内完成 1000 个元素，那么你应该期望在大约十天或一个月内完成 100 万个元素的相同算法。如果算法是线性的，比如说*O（n）*，那么在一秒钟内完成 1000 个元素应该使您预计在 1000 秒内完成 100 万个元素。这比喝咖啡的时间长一点，午餐时间太短。

这使得如果我们想要一些严肃的业务排序对象，我们需要比冒泡排序更好的东西成为可能。许多不必要的比较不仅浪费了我们的时间，而且还浪费了 CPU 功率、消耗能源和污染环境。然而，问题是：排序能有多快？是否存在我们无法克服的可证明的最低限度？

答案是肯定的。

当我们实现任何排序算法时，实现将执行比较和元素交换。这是对对象集合进行排序的唯一方法。比较的结果可以有两个值。比如说，这些值是*0*或*1*。这是一点信息。如果比较的结果是*1*，那么我们交换，如果结果是*0*，那么我们不交换。

在开始比较之前，我们可以将对象分为不同的顺序，不同的顺序数为*n！*（*n*阶乘）。也就是说，数字从 1 乘以*n*，换句话说*n！*=1*2*3*…*（*n*-1）**n*。

假设我们将单个比较的结果存储在一个数字中，作为排序的每个可能输入的一系列位。现在，如果我们反转排序的执行，从排序的集合开始运行算法，使用描述比较结果的位控制交换，我们使用位的另一种方式，首先进行最后一次交换，然后在排序过程中首先进行交换，我们应该恢复对象的原始顺序。这样，每个原始顺序都与一个表示为位数组的数字唯一关联。

现在，我们可以这样表达原始问题：需要多少位来描述*n*阶乘不同的数？这正是我们需要对*n*元素进行排序的比较数量。位数为*log<sub class="calibre30">2</sub>（n！）*。通过一些数学，我们会知道*log<sub class="calibre30">2</sub>（n！）*与*log<sub class="calibre30">2</sub>（1）+log<sub class="calibre30">2</sub>（2）+log<sub class="calibre30">2</sub>（n）*是相同的。如果我们看这个表达式的渐近值，那么我们可以说这是相同的*O（n*logn）*。我们不应该期望任何通用排序算法更快。

对于特殊情况，有更快的算法。例如，如果我们想对 100 万个数字进行排序，每个数字都在 1 到 10 之间，那么我们只需要计算不同数字的数量，然后创建一个包含那么多个 1、2 等的集合。这是一个*O（n）*算法，但不适用于一般情况。

同样，这不是一个正式的数学证明。

# 快速排序

查尔斯·安东尼·理查德·霍尔爵士于 1959 年开发了快速排序算法。这是一个典型的分治算法。要对长数组进行排序，请从数组中选择一个元素作为轴心元素。然后，对数组进行分区，使左侧包含小于轴的所有元素，右侧包含大于或等于轴的所有元素。完成此操作后，可以通过递归调用 sort 对数组的左侧和右侧进行排序。为了停止递归，当数组中只有一个元素时，我们将声明它已排序。

当算法部分地使用自身定义时，我们讨论递归算法。最著名的递归定义是 Fibonacci 数列，前两个元素和任何后面的元素为 0 和 1，*n*<sup class="calibre31">th</sup>元素是（*n-1】*<sup class="calibre31">th</sup>和（*n-2】*<sup class="calibre31">th</sup>元素之和。递归算法多次在现代编程语言中实现，实现了一种进行某些计算但有时会调用自身的方法。在设计递归算法时，最重要的是要有停止递归调用的东西；否则，递归实现将为程序堆栈分配所有可用内存，并在出现错误时停止程序。

分区算法如下：我们将开始使用从开始到结束的两个索引读取数组。我们将首先从较小的索引开始，增加索引，直到它小于较大的索引，或者直到找到大于或等于枢轴的元素。在此之后，我们将开始减少较大的索引，只要它大于较小的索引，并且索引的元素大于或等于轴。当我们停止时，我们交换两个指数所指向的两个元素，如果指数不相同，我们将分别增加和减少小指数和大指数。如果索引相同，那么我们就完成了分区。数组的左侧是从开始到索引满足-1 的索引；右侧从索引开始，一直持续到待排序数组的末尾。

该算法通常为*O（n logn）*，但在某些情况下，它可以降级为*O（n<sup class="calibre29">2</sup>*，具体取决于如何选择枢轴。选择轴心点有不同的方法。在本书中，我们将使用最简单的方法：我们将选择可排序集合的第一个元素作为轴心。

# 项目结构和构建工具

这次的项目将包含许多模块。在本章中，我们仍将使用 Maven。我们将在 Maven 中建立一个所谓的多模块项目。在这样一个项目中，目录包含模块和`pom.xml`的目录。此顶级目录中没有源代码。此目录中的`pom.xml`文件有以下两个用途：

*   它引用模块，并可用于编译、安装和部署所有模块
*   它为所有模块定义了相同的参数

每个`pom.xml`都有一个父目录，这个`pom.xml`是模块目录中`pom.xml`文件的父目录。为了定义模块，`pom.xml`文件包含以下行：

```
<project> 
... 
    <modules> 
        <module>SortInterface</module> 
        <module>bubble</module> 
        <module>quick</module> 
    </modules> 
</project>

```

这些是模块的名称。这些名称在`pom.xml`模块中用作目录名和`artifactId`。此设置中的目录如下所示：

```
$ tree 
   |-SortInterface 
   |---src/main/java/packt/java9/by/example/ch03 
   |-bubble 
   |---src 
   |-----main/java/packt/java9/by/example/ch03/bubble 
   |-----test/java/packt/java9/by/example/ch03/bubble 
   |-quick/src/ 
   |-----main/java 
   |-----test/java

```

# Maven 依赖关系管理

依赖关系在 POM 文件中也很重要。上一个项目没有任何依赖项，但这次我们将使用 JUnit。依赖项在`pom.xml`中使用`dependencies`标记定义。例如，“气泡排序”模块包含以下代码：

```
<dependencies> 
    <dependency> 
        <groupId>packt.java9.by.example</groupId> 
        <artifactId>SortInterface</artifactId> 
    </dependency> 
    <dependency> 
        <groupId>junit</groupId> 
        <artifactId>junit</artifactId> 
    </dependency> 
</dependencies>

```

您可以下载的代码集中的实际`pom.xml`将包含更多的代码。在印刷品中，我们通常会呈现一个版本或只是一小部分，这有助于理解我们当时正在讨论的主题。

它告诉 Maven 模块代码使用在这些模块中定义的类、接口和`enum`类型，这些模块可以从一些存储库中获得。

使用 Maven 编译代码时，代码使用的库可以从存储库中获得。当 Ant 被开发出来时，存储库的概念并没有被发明出来。当时，开发人员将使用过的库版本复制到源代码结构中的一个文件夹中。通常，目录`lib`用于此目的。这种方法有两个问题。一个是源代码存储库的大小。例如，如果 100 个不同的项目使用 JUnit，那么 JUnit 库的 JAR 文件被复制了 100 次。另一个问题是收集所有的图书馆。当一个库使用另一个库时，开发人员必须阅读该库的文档，这些文档描述了使用该库所需的其他库（很多时候已经过时且不精确）。这些库必须以同样的方式下载和安装。这既耗时又容易出错。当一个库丢失而开发人员没有注意到它时，错误会在编译时出现，此时编译器找不到该类，甚至只有在运行时 JVM 无法加载该类。

为了解决这个问题，Maven 附带了一个内置的 repository manager 客户端。存储库是包含库的存储。因为存储库中可能有其他类型的文件，而不仅仅是库，所以 Maven 术语是工件。`groupId`、`artifactId`和`version`号标识了一个工件。有一个非常严格的要求，工件只能放入存储库一次。即使在发布过程中有一个错误在错误的发布被上传后被识别，工件也不能被覆盖。对于相同的`groupId`、`artifactId`和`version`，只有一个文件永远不会更改。如果有错误，那么将创建一个具有新版本号的新工件，并且可以删除错误工件，但不能替换。

如果版本号以`-SNAPSHOT`结尾，则不保证或不要求此唯一性。快照通常存储在单独的存储库中，不会发布到世界各地。

存储库包含以定义方式组织的目录中的工件。当 Maven 运行时，它可以使用`https`协议访问不同的存储库。

以前，还使用了`http`协议，对于非付费客户，只能通过`http`使用中央存储库。然而，发现从存储库下载的模块可能是中间人安全攻击和 Sonatype（[的目标 http://www.sonatype.com](http://www.sonatype.com) 更改了策略，仅使用`https`协议。切勿使用`http`协议配置或使用存储库。永远不要信任从 HTTP 下载的文件。

开发人员机器上有一个本地存储库，通常位于`~/.m2/repository`目录下。当您发出`mvn install`命令时，Maven 将创建的工件存储在这里。Maven 还将通过 HTTPS 从存储库下载的工件存储在这里。这样，后续编译就不需要到网络上查找工件。

公司通常设置自己的存储库管理器（支持 Maven 的公司 Sonatype 正在提供 Nexus）。这些应用程序可以配置为与其他几个存储库通信，并根据需要从存储库中收集工件，基本上实现了代理功能。如果项目的打包类型为`war`、`ear`或包含依赖工件的其他格式，则工件将从远端存储库移动到构建中更靠近本地 repo 的层次结构中的存储库，并基本上移动到最终工件。这本质上是无需重新验证和缓存逐出的文件缓存。这是因为工件唯一性的严格规则。这就是为什么要有如此严格的规定。

如果项目气泡是一个独立的项目，而不是多模块项目的一部分，那么依赖项将如下所示：

```
<dependencies> 
    <dependency> 
        <groupId>packt.java9.by.example</groupId> 
        <artifactId>SortInterface</artifactId> 
        <version>1.0.0-SNAPSHOT</version> 
    </dependency> 
    <dependency> 
        <groupId>junit</groupId> 
        <artifactId>junit</artifactId> 
        <version>4.12</version> 
    </dependency> 
</dependencies>

```

如果没有为依赖项定义`version`，Maven 将无法识别要使用的工件。如果是多模块项目，可以在父项目中定义`version`，模块可以继承版本。由于父项不依赖于实际依赖项，因此只定义了附在`groupId`和`artifactId`上的版本；XML 标记不是`dependencies`，而是顶层`project`标记下的`dependencyManagement/dependencies`，如下例所示：

```
<dependencyManagement> 
    <dependencies> 
        <dependency> 
            <groupId>packt.java9.by.example</groupId> 
            <artifactId>SortInterface</artifactId> 
            <version>${project.version}</version> 
        </dependency> 
        <dependency> 
            <groupId>junit</groupId> 
            <artifactId>junit</artifactId> 
            <version>4.12</version> 
            <scope>test</scope> 
        </dependency> 
    </dependencies> 
</dependencyManagement>

```

如果父 POM 直接使用 dependencies 标记，Maven 无法确定父 POM 是依赖于该工件还是依赖于某些模块。当模块想要使用`junit`时，不需要指定版本。他们将从定义为 4.12 的父项目获得它，这是*JUnit 4*的最新版本。如果有新版本 4.12.1，并且修复了一些严重的错误，那么修改版本号的唯一地方就是父 POM，模块将从下一次执行 Maven 编译开始使用新版本。

然而，当新版本*JUnit 5*问世时，所有模块都必须进行修改，因为*JUnit*不仅仅是一个新版本。JUnit 的版本 5 被分为几个模块，这样，`groupId`和`artifactId`也将改变。

还值得注意的是，实现`SortInterface`模块接口的模块最终依赖于该模块。在这种情况下，版本定义如下：

```
<version>${project.version}</version>

```

这似乎有点重复（事实上是这样）。`${project.version}`属性是项目的版本，由`SortInterface`模块继承。这是其他模块所依赖的工件的版本。换句话说，模块始终取决于我们当前开发的版本。

# 分类编码

为了实现排序，首先，我们将定义排序库应该实现的接口。在实际编码之前定义接口是一个很好的实践。当有许多实现时，有时建议首先创建一个简单的实现并开始使用它，以便在该阶段接口可能会发生变化，当更复杂的实现到期时，则要实现的接口或多或少已经固定。

# 创建接口

本例中的接口非常简单。

```
package packt.java9.by.example.ch03; 

public interface Sort { 
    void sort(SortableCollection collection); 
}

```

接口应该只做一件事，对可排序的内容进行排序。由于我们希望在这种方法中非常通用，我们还必须定义什么是可排序的。为此，我们需要另一个接口。

```
package packt.java9.by.example.ch03; 

public interface SortableCollection { 
}

```

# 创建气泡运动

现在，我们可以开始创建实现`Sort`接口的冒泡排序：

```
package packt.java9.by.example.ch03.bubble; 

import packt.java9.by.example.ch03.*; 
import java.util.Comparator; 

public class BubbleSort implements Sort { 
    @Override 
    public void sort(SortableCollection collection) { 
        int n = collection.size(); 
        while (n > 1) { 
            for (int j = 0; j < n - 1; j++) { 
                if (comparator.compare(collection.get(j), 
                        collection.get(j + 1)) > 0) { 
                    swapper.swap(j, j + 1); 
                } 
            } 
            n--; 
        } 
    }

```

通常，要执行的算法需要我们上次在代码中针对`String`数组实现的两个操作：比较两个元素和交换两个元素。由于这一次排序实现本身不知道使用了什么类型的元素，也不知道它所排序的东西是数组、列表还是其他东西，所以它需要在需要时为排序做一些事情。更准确地说，它需要一个能够比较两个元素的`comparator`对象，需要一个能够交换集合中两个元素的`swapper`对象。

为了得到这些，我们可以实现两个 setter 方法，它们可以在调用 sort 之前为此目的设置对象。由于这不是特定于冒泡排序算法，而是相当通用的，因此这两种方法也应该成为接口的一部分，因此实现将覆盖它。

```
    private Comparator comparator = null; 

    @Override 
    public void setComparator(Comparator comparator) { 
        this.comparator = comparator; 
    } 

    private Swapper swapper = null; 

    @Override 
    public void setSwapper(Swapper swapper) { 
        this.swapper = swapper; 
    } 
}

```

`@Override`注释向 Java 编译器发出信号，表示该方法正在重写父类的方法，或者在本例中重写接口的方法。方法可以重写没有此注释的父方法；但是，如果我们使用注释，如果方法实际上没有重写某些内容，编译就会失败。这有助于您在编译时发现父类或接口中的某些内容发生了更改，而我们在实现中没有遵循这些更改，或者我们只是犯了一些错误，认为我们将重写一个方法，而实际上我们没有这样做。由于注释在单元测试中大量使用，我们将在后面更详细地讨论注释。

# 修改接口

修改后的`Sort`界面如下：

```
public interface Sort { 
    void sort(SortableCollection collection); 
    void setSwapper(Swapper swap); 
    void setComparator(Comparator compare); 
}

```

这也意味着我们需要两个新接口：`Swapper`和`Comparator`。幸运的是，Java 运行时已经定义了一个正好符合目的的`Comparator`接口。您可能已经从以下导入语句中猜到：

```
import java.util.Comparator;

```

当你需要一些非常基本的东西时，比如`comparator`接口，它很可能是在运行时定义的。在编写自己的版本之前，建议先咨询运行时。然而，`Swapper`接口，我们将不得不创建。

```
package packt.java9.by.example.ch03; 

public interface Swapper { 
    void swap(int i, int j); 
}

```

由于它用于交换`SortableCollection`中索引指定的两个元素，因此有一种方法，非常简单地称为`swap`。但是，我们还没有准备好。如果您试图编译前面的代码，编译器将抱怨`get`和`size`方法。算法需要它们来实现排序，但它们本身并不是排序本身的一部分。这是一项不应以类似方式实施的责任。由于我们不知道将对哪种类型的集合进行排序，因此在排序中实现这些功能不仅是不明智的，而且也是不可能的。看来我们什么都分类不了。我们必须设置一些限制。排序算法必须知道我们排序的集合的大小，并且应该能够通过索引访问元素，以便将其传递给比较器。

这些限制在`SortableCollection`接口中表示，在第一次排序实现之前，我们不知道那里需要什么。

```
package packt.java9.by.example.ch03; 

public interface SortableCollection { 
    Object get(int i); 
    int size(); 
}

```

现在，我们已经准备好了接口和实现，可以继续测试代码了。但是，在此之前，我们将简要重申我们所做的以及我们为什么这样做。

# 建筑考虑

我们创建了一个接口和它的一个简单实现。在实现过程中，我们发现该接口需要支持该算法的其他接口和方法。这通常发生在代码的架构设计期间，在实现之前。出于教学上的原因，我在开发代码时遵循了接口的构建。在现实生活中，当我创建接口时，我一步就创建了它们，因为我有足够的经验。1983 年左右，我用 Fortran 编写了第一个快速排序代码。然而，这并不意味着我遇到了任何问题，就拿出了最终的解决方案。碰巧这类问题太有名了。如果在开发过程中需要修改接口或设计的其他方面，请不要感到尴尬。这是一个自然的结果，也是一个证明，随着时间的推移，你对事物的理解会越来越好。如果体系结构需要更改，那么做总比不做要好，而且越快越好。在现实的企业环境中，我们设计界面只是为了在开发过程中了解一些我们忘记的方面。它们是非常真实的，并且比对集合进行排序要复杂一些。

在排序问题的例子中，我们抽象了我们想要排序到最可能极端的*某物*。Java 内置排序可以对数组或列表进行排序。如果要对非列表或数组的对象进行排序，则必须创建一个类来实现`java.util.List`接口，该接口需要 24 个以上的方法来包装可排序对象，以便通过 JDK 排序对其进行排序。老实说，这不是太多，在现实世界的项目，我会认为这是一种选择。

但是，我们不知道，也不知道内置排序使用的接口方法。那些被使用的应该在功能上实现，而那些没有，可以包含一个简单的`return`语句，因为它们从来没有被调用过。开发人员可以参考 JDK 的源代码，查看实际使用的方法，但这不是搜索实现的契约。不能保证新版本仍然只使用这些方法。如果一个新版本开始使用我们用一个`return`语句实现的方法，排序将神奇地失败。

另外一个有趣的性能问题是，如何通过仅使用`List`接口的搜索来实现两个元素的交换。`List`界面中没有`put(int, Object)`方法。有`add(int Object)`，但它插入了一个新元素，如果对象存储在磁盘上，那么将列表中的所有元素向上推可能会非常昂贵（消耗 CPU、磁盘、能量）。此外，下一步可能是删除我们刚刚插入的元素之后的元素，再次移动列表尾部的代价高昂的过程。也就是说，排序可能遵循也可能不遵循的`put(int,Object)`的琐碎实现。同样，这是不应该假设的。

当开发人员使用来自 JDK、开源或商业库的库、类和方法时，开发人员可以参考源代码，但不应依赖于实现。您应该只依赖于合同和库附带的 API 定义。当您从某个外部库实现一个接口时，您不需要实现它的某些部分，也不需要创建一些虚拟方法，您会感到危险。这是一次伏击。很可能是因为该库质量差，或者您不了解如何使用它。

在本例中，我们将交换和比较与排序分开。集合应实现这些操作，并为排序提供这些操作。契约就是接口，要使用排序，您必须实现我们定义的接口的所有方法。

`Sort`接口定义了设置`Swapper`和`Comparator`的设置器。以这种方式设置依赖项可能会导致代码创建实现`Sort`接口的类的新实例，但在调用`Sort`之前不会设置`Swapper`和`Comparator`。这将导致`NullPointerException`第一次调用`Comparator`（或者在实现首先调用`Swapper`的情况下调用`Swapper`，这不太可能，但可能）。调用方法应该在使用类之前注入依赖项。通过设定器进行时，称为**设定器注射**。当我们使用 Spring、Guice 或其他一些容器等框架时，大量使用这个术语。创建这些服务类并将实例注入到我们的类中一直是非常相似的。

容器实现以一般方式包含功能，并提供配置选项来配置要注入到其他对象中的实例。通常，这会导致代码更短、更灵活、更可读。但是，依赖项注入并不是容器独有的。当我们在下一节中编写测试代码并调用 setter 时，我们实际上进行了依赖项注入。

还有另一种依赖项注入方法可以避免未设置依赖项的问题。这称为**构造函数注入**。依赖项是没有值的`final private`字段。请记住，这些字段应该在构造函数完成时获得最终值。构造函数注入将注入的值作为参数传递给构造函数，构造函数设置字段。这样，可以保证在构建对象时设置字段。但是，不能在接口中定义此注入。

现在，我们已经有了代码，并且我们知道了如何创建接口的注意事项。这是做一些测试的时候了。

# 创建单元测试

当我们编写代码时，我们应该测试它。至少在进行一些测试运行之前，还没有任何代码投入生产。不同级别的测试具有不同的目标、技术、行业实践和名称。

顾名思义，单元测试测试一个代码单元。集成测试测试单元如何集成在一起。冒烟测试测试一组有限的特性，只是为了确保代码并没有完全被破坏。还有其他测试，直到最终测试，这是工作的证明：用户验收测试。吃布丁就是证明。如果用户接受代码，则代码是好的。

很多时候，我告诉年轻人，名称用户验收测试有点误导，因为接受项目结果的不是用户，而是客户。根据定义，客户是付账单的人。专业发展是有偿的；否则就不专业了。然而，术语是用户验收测试。只有当用户可以使用该程序时，客户才会接受该项目。

当我们用 Java 开发时，单元测试就是测试独立类。换句话说，在 Java 开发中，当我们谈论单元测试时，单元就是一个类。为了提供单元测试，我们通常使用 JUnit 库。还有其他库，比如 TestNG，但是 JUnit 是使用最广泛的库，所以我们将使用*JUnit*。要将其用作库，首先，我们必须将其作为依赖项添加到 Maven POM 中。

# 添加 JUnit 作为依赖项

回想一下，我们有一个多模块项目，依赖版本在父 POM 中的`dependencyManagement`标记下维护。

```
<dependencyManagement> 
    <dependencies> 
        ... 
        <dependency> 
            <groupId>junit</groupId> 
            <artifactId>junit</artifactId> 
            <version>4.12</version> 
            <scope>test</scope> 
        </dependency> 
    </dependencies> 
</dependencyManagement>

```

依赖项的范围是 test，这意味着该库仅用于编译测试代码和执行测试期间。JUnit 库不会进入最终发布的产品；没有必要。如果您在已部署的生产**Web 存档**（**WAR**文件）中发现 JUnit 库，请怀疑有人没有正确管理库的作用域。

Maven 支持在项目生命周期中编译和执行 JUnit 测试。如果我们想要执行测试，只有我们可以发出`mvn test`命令。IDE 还支持单元测试的执行。通常，可以使用相同的菜单项来执行具有`public static main`方法的类。如果该类是一个使用 JUnit 的单元测试，IDE 将识别它并执行测试，通常会给出一个图形反馈，说明哪些测试执行得很好，哪些测试失败，以及如何执行。

# 编写 BubbleSortTest 类

测试类与生产类分开。他们进入`src/test/java`目录。当我们有一个名为`BubbleSort`的类时，测试将被命名为`BubbleSortTest`。此约定有助于执行环境将测试与不包含测试但执行测试所需的类分开。为了测试我们刚刚创建的排序实现，我们可以提供一个类，该类目前只包含一个`canSortStrings`方法。

单元测试方法名称用于记录正在测试的功能。由于 JUnit 框架调用了每一个具有`@Test`注释的方法，因此测试的名称在代码中的任何地方都不会被引用。我们可以勇敢地使用任意长的方法名；它不会影响调用方法的位置的可读性。

```
package packt.java9.by.example.ch03.bubble; 

// imports deleted from print 

public class BubbleSortTest { 

    @Test 
    public void canSortStrings() { 
        ArrayList actualNames = new ArrayList(Arrays.asList( 
                "Johnson", "Wilson", 
                "Wilkinson", "Abraham", "Dagobert" 
        ));

```

该方法包含`ArrayList`以及我们已经熟悉的实际名称。由于我们有一个需要`SortableCollection`的排序实现和接口，我们将创建一个由`ArrayList`备份的排序实现和接口。

```
        SortableCollection namesCollection = new SortableCollection() { 

            @Override 
            public Object get(int i) { 
                return actualNames.get(i); 
            } 

            @Override 
            public int size() { 
                return actualNames.size(); 
            } 
        };

```

我们声明了一个具有`SortableCollection`类型的新对象，它是一个接口。要实例化实现`SortableCollection`的东西，我们需要一个类。我们不能实例化接口。在这种情况下，在实例化的位置定义类。这在 Java 中称为匿名类。该名称来源于源代码中未定义新类的名称这一事实。Java 编译器将自动为新类创建一个名称，但程序员对此并不感兴趣。我们只需编写`new SortableCollection()`并在`{`和`}`之间立即提供所需的实现。在方法中定义这个匿名类非常方便，因为这样，它可以访问`ArrayList`，而无需在类中传递对`ArrayList`的引用。

事实上，引用是必需的，但是 Java 编译器会自动完成这项工作。在本例中，Java 编译器还注意以这种方式传递的自动引用只能使用初始化的变量来完成，并且在匿名类实例化后的代码执行期间不会更改。变量`actualNames`已设置，不应在以后的方法中更改。事实上，我们甚至可以将`actualNames`定义为最终版本，如果我们使用 Java1.7 或更早版本，这将是一个要求。从 1.8 开始，要求变量实际上是 final，但不需要声明它是 final。

接下来我们需要的是`ArrayList`的`Swapper`实现。在本例中，我们将在方法中定义一个完整的类。它也可以是一个匿名类，但这次我决定使用一个命名类来证明一个类可以在一个方法中定义。通常，我们不会在生产项目中这样做。

```
        class SwapActualNamesArrayElements implements Swapper { 
            @Override 
            public void swap(int i, int j) { 
                final Object tmp = actualNames.get(i); 
                actualNames.set(i,actualNames.get(j)); 
                actualNames.set(j, tmp); 

            } 
        }

```

最后，但并非最不重要的一点是，在调用排序之前，我们需要一个比较器。正如我们要比较的，这是简单而直接的。

```
        Comparator stringCompare = new Comparator() { 
            @Override 
            public int compare(Object first, Object second) { 
                final String f = (String) first; 
                final String s = (String) second; 
                return f.compareTo(s); 
            } 
        };

```

在为排序做好准备之后，我们最终需要一个排序实现的实例，设置`comparator`和`swapper`，并调用排序。

```
        Sort sort = new BubbleSort(); 
        sort.setComparator(stringCompare); 
        sort.setSwapper(new SwapActualNamesArrayElements()); 
        sort.sort(namesCollection);

```

测试的最后一个也是最重要的部分是断言结果是我们期望的结果。JUnit 在`Assert`类的帮助下帮助我们做到这一点。

```
        Assert.assertEquals(Arrays.asList("Abraham", "Dagobert", "Johnson", "Wilkinson", "Wilson"), actualNames); 
    } 

}

```

调用`assertEquals`检查第一个参数（预期结果）是否等于第二个参数（排序后的`actualNames`）。如果它们不同，则抛出`AssertionError`；否则，测试就可以顺利完成。

# 良好的单元测试

这是一个好的单元测试吗？如果你在像这样的教程中读到它，它必须是。事实并非如此。这是演示 JUnit 提供的一些工具和一些 Java 语言特性的好代码，但作为一个真正的 JUnit 测试，我不会在实际项目中使用它。

什么使单元测试好？为了回答这个问题，我们必须找到单元测试的好处以及我们使用它的目的。

我们将创建单元测试，以验证单元的操作并记录。

单元测试不是为了发现 bug。开发人员最终在调试会话期间使用单元测试，但很多时候，为调试创建的测试代码是临时的。当 bug 修复后，用于查找它的代码将不会进入源代码。对于每一个新的 bug，都应该创建一个新的测试来覆盖不能正常工作的功能，但是很难用测试代码来查找 bug。这是因为单元测试主要用于文档。您可以使用*JavaDoc*来记录一个类，但经验表明，这些文档通常会过时。开发人员修改代码，但他们不修改文档，文档变得过时和误导。但是，单元测试是由构建系统执行的，如果**持续集成**（**CI**）正在使用中（在专业环境中应该是这样），那么如果测试失败，构建将被破坏，所有开发人员都将收到关于它的邮件通知，它将促使开发人员破坏构建来修复代码或测试。通过这种方式，测试验证了持续开发没有破坏代码中的任何东西，或者至少没有破坏使用单元测试可以发现的东西。

# 好的单元测试是可读的

我们的测试远非易读。如果你看一个测试用例，它是可读的，并且在 15 秒内你可以知道它是做什么的。当然，它假定读者有一些 Java 方面的经验，但你明白了。我们的测试充斥着不是测试核心的支持类。

我们的测试也很难验证代码是否正常工作。事实并非如此。其中有一些我故意放在那里的 bug，我们将在下面的部分找到并消除它们。对单个`String`数组进行排序的单个测试远远不能验证排序实现。如果我要将这个测试扩展到现实世界的测试，我们需要名称为`canSortEmptyCollection`、`canSortOneElementCollection`、`canSortTwoElements`、`canSortReverseOrder`或`canSortAlreadySorted`的方法。如果你看一下这些名字，你就会知道我们需要什么样的测试。由于排序问题的性质，实现可能对这些特殊情况下的错误相当敏感。

除了作为一个可接受的演示工具之外，我们的单元测试还有哪些优点？

# 单元测试很快

我们的单元测试运行得很快。当我们每次执行单元测试时，CI 会启动一个构建，测试的执行不会持续很长时间。您不应该创建对数十亿个元素进行排序的单元测试。这是一种稳定性或负载测试，它们应该在单独的测试期间运行，而不是每次构建运行时。我们的单元测试对五个合理的元素进行排序。

# 单元测试是确定性的

我们的单元测试是确定性的。非确定性单元测试是开发人员的噩梦。如果您所在的团队中有一些构建在 CI 服务器上中断，并且当一个构建中断时，您的开发伙伴会说您只需再试一次；不可能！如果单元测试运行，它应该一直运行。如果失败了，不管你启动它多少次，它都应该失败。在我们的例子中，一个不确定的单元测试是呈现随机数并对其进行排序。我们将在每次测试运行中使用不同的数组，并且，如果在某些数组的代码中出现一些 bug，我们将无法复制它。更不用说断言代码运行良好也很困难。

如果我们在单元测试中对一个随机数组进行排序（我们没有这样做），我们可以假设，断言数组已排序，逐个比较元素，检查它们是否按升序排列。这也是一种完全错误的做法。

# 断言应该尽可能简单

如果断言很复杂，则在断言中引入错误的风险更高。断言越复杂，风险越高。我们将编写单元测试来简化我们的生活，而不是有更多的代码需要调试。

此外，一个测试只能断言一件事。这个断言可以用多个`Assert`类方法逐个编码。尽管如此，这些测试的目的还是为了证明该单元的一个单一特征的正确性。记住 SRP：一个测试，一个特性。一个好的测试就像一个好的狙击手：一枪一杀。

# 单元测试是孤立的

当我们测试一个单元*a*时，另一个单元*B*中的任何变化，或者不同单元中的错误，都不应影响我们针对该单元*a*的单元测试。在我们的例子中，这很容易，因为我们只有一个单元。稍后，当我们为快速排序开发测试时，我们将看到这种分离并不是那么简单。

如果单元测试正确地分开，失败的单元测试会清楚地指出问题的位置。它位于单元测试失败的单元中。如果测试没有将单元分开，那么一个测试中的失败可能是由不同单元中的错误引起的，而不是我们预期的。在这种情况下，这些测试实际上不是单元测试。

在实践中，你应该保持平衡。如果单元的隔离成本太高，您可以决定创建集成测试；如果它们运行速度仍然很快，则由*CI 系统*执行。同时，你也应该试着找出为什么隔离很难。如果在测试中无法轻松隔离单元，则意味着单元之间的耦合太强，这可能不是一个好的设计。

# 单元测试涵盖了代码

单元测试应该测试功能的所有常规和特殊情况。如果单元测试未涵盖代码的特殊情况，则代码处于危险中。对于排序实现，一般情况下是排序，比如说五个元素。特殊情况通常要多得多。如果只有一个元素或者没有元素，我们的代码是如何工作的？如果有两个呢？如果元素的顺序相反怎么办？如果它们已经分类了呢？

通常，规范中未定义特殊情况。程序员在编码之前必须考虑它，在编码过程中会发现一些特殊情况。困难的是，您无法判断是否涵盖了所有特殊情况和代码的功能。

您可以判断的是，是否所有的代码行都是在测试期间执行的。如果 90%的代码行是在测试期间执行的，那么代码覆盖率是 90%，这在现实生活中是相当好的，但是您永远不应该满足于低于 100%的内容。

代码覆盖率与功能覆盖率不同，但存在相关性。如果代码覆盖率小于 100%，则以下两条语句中至少有一条为真：

*   功能覆盖率不是 100%
*   测试单元中有未使用的代码，可以直接删除

代码覆盖率可以测量，功能覆盖率不能测量。这些工具和 IDE 支持代码覆盖率度量。这些测量值被集成到编辑器中，这样您不仅可以获得覆盖率的百分比，而且编辑器还可以准确地显示哪些线没有被覆盖率覆盖（例如，在 Eclipse 中）或编辑器窗口左侧的边沟（IntelliJ）所覆盖。图中显示，在 IntelliJ 中，测试覆盖了排水沟上绿色指示的线条。（在打印版本中，这只是一个灰色矩形）。

![](../images/00037.jpeg)

# 重构测试

现在我们已经讨论了什么是好的单元测试，让我们改进我们的测试。第一件事是将支持类移动到单独的文件中。我们将创建`ArrayListSortableCollection`：

```
package packt.java9.by.example.ch03.bubble; 

import packt.java9.by.example.ch03.SortableCollection; 

import java.util.ArrayList; 

public class ArrayListSortableCollection implements SortableCollection { 
    final private ArrayList actualNames; 

    ArrayListSortableCollection(ArrayList actualNames) { 
        this.actualNames = actualNames; 
    } 

    @Override 
    public Object get(int i) { 
        return actualNames.get(i); 
    } 

    @Override 
    public int size() { 
        return actualNames.size(); 
    } 
}

```

该类封装`ArrayList`后实现`get`和`size`方法对`ArrayList`的访问。`ArrayList`本身声明为`final`。回想一下，`final`字段必须在构造函数完成时定义。这保证了当我们开始使用对象时，字段就在那里，并且在对象的生命周期内它不会改变。然而，请注意，对象的内容，在这种情况下，`ArrayList`的元素可能会改变。如果不是这样，我们将无法对其进行排序。

下一节课是`StringComparator`。这是如此简单，我不会在这里列出它；我将让您实现可以比较两个字符串的`java.util.Comparator`接口。这应该不难，特别是因为这个类已经是以前版本的`BubbleSortTest`类的一部分（提示：它是一个匿名类，我们存储在名为`stringCompare`的变量中）。

我们还必须实施`ArrayListSwapper`，这也不应该是一个大惊喜。

```
package packt.java9.by.example.ch03.bubble; 

import packt.java9.by.example.ch03.Swapper; 

import java.util.ArrayList; 

public class ArrayListSwapper implements Swapper { 
    final private ArrayList actualNames; 

    ArrayListSwapper(ArrayList actualNames) { 
        this.actualNames = actualNames; 
    } 

    @Override 
    public void swap(int i, int j) { 
        Object tmp = actualNames.get(i); 
        actualNames.set(i, actualNames.get(j)); 
        actualNames.set(j, tmp); 
    } 
}

```

最后，我们的测试将如下所示：

```
package packt.java9.by.example.ch03.bubble; 

// ... imports deleted from print ... 
public class BubbleSortTest { 
    @Test 
    public void canSortStrings() { 
        ArrayList actualNames = new ArrayList(Arrays.asList( 
                "Johnson", "Wilson", 
                "Wilkinson", "Abraham", "Dagobert" 
        )); 
        ArrayList expectedResult = new ArrayList(Arrays.asList( 
                "Abraham", "Dagobert", 
                "Johnson", "Wilkinson", "Wilson" 
        )); 
        SortableCollection names = 
                new ArrayListSortableCollection(actualNames); 
        Sort sort = new BubbleSort(); 
        sort.setComparator( 
                new StringComparator()); 
        sort.setSwapper( 
                new ArrayListSwapper(actualNames)); 
        sort.sort(names); 
        Assert.assertEquals(expectedResult, actualNames); 
    } 
}

```

现在这已经是一个可以在 15 秒内理解的测试。它很好地记录了如何使用我们定义的排序实现。正如我承诺的那样，它仍然有效，并且不会暴露任何错误。

# 包含错误元素的集合

这个 bug 并不是微不足道的，和往常一样，这不在算法的实现中，而是在定义中，或者说是缺少它。如果我们对集合中的字符串进行排序，那么程序应该怎么做？

如果我创建一个以以下行开头的新测试，它将抛出`ClassCastException`：

```
@Test 
public void canNotSortMixedElements() { 
    ArrayList actualNames = new ArrayList(Arrays.asList( 
            42, "Wilson", 
            "Wilkinson", "Abraham", "Dagobert" 
    )); 
... the rest of the code is the same as the previous test

```

这里的问题是 Java 集合可以包含任何类型的元素。您永远无法确定集合（如`ArrayList`）只包含您期望的类型。即使您使用泛型（我们还没有学到，但我们将在本章中学习），一个 bug 以某种方式将某个不适当类型的对象变为集合的可能性较小，但仍然存在。不要问我怎么做；我不能告诉你。这就是 bug 的本质，除非你消灭它们，否则你无法知道它们是如何工作的。问题是你必须为这种特殊情况做好准备。

# 异常处理

异常情况应该使用异常在 Java 中处理。`ClassCastException`在那里，当排序尝试使用`StringComparator`来比较`String`和`Integer`时会发生这种情况，为此，它尝试将`Integer`转换为`String`。

当程序使用`throw`命令或 Java 运行时引发异常时，程序的执行将在该点停止，而不是执行下一个命令，它将在捕获异常的位置继续。它可以在同一个方法中，也可以在调用链中的某个调用方法中。要捕获异常，引发异常的代码应该位于`try`块内，`try`块后面的 catch 语句应该指定与引发的异常兼容的异常。

如果未捕获异常，则 Java 运行时将打印出异常消息以及堆栈跟踪，该堆栈跟踪将包含异常发生时调用堆栈上的所有类、方法和行号。在我们的例子中，`mvn test`命令将在输出中产生以下跟踪：

```
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 
    at packt.java9.by.example.ch03.bubble.StringComparator.compare(StringComparator.java:9) 
    at packt.java9.by.example.ch03.bubble.BubbleSort.sort(BubbleSort.java:13) 
    at packt.java9.by.example.ch03.bubble.BubbleSortTest.canNotSortMixedElements(BubbleSortTest.java:49) 
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
    at java.lang.reflect.Method.invoke(Method.java:498) 
... some lines deleted from the print 
    at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141) 
    at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112) 
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 
... some lines deleted from the print 
    at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85) 
    at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115) 
    at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)

```

这个堆栈跟踪不是很长。在应用服务器上运行的应用程序的生产环境中，堆栈跟踪可能包含几百个元素。在这个跟踪中，您可以看到 Maven 正在启动测试执行，涉及 Maven surefire 插件，然后是 JUnit 执行器，直到我们完成了对 comparator 的测试，在那里引发了实际的异常。

Java 运行时没有将此异常打印到控制台。JUnit 库代码捕获此异常，并使用 Maven 日志记录工具将堆栈跟踪注销到控制台。

这种方法的问题在于，真正的问题不是类转换失败。真正的问题是集合包含混合元素。只有当 Java 运行时试图强制转换两个不兼容的类时，它才被实现。我们的代码可以更智能。我们可以修改比较器。

```
package packt.java9.by.example.ch03.bubble; 
import java.util.Comparator; 
public class StringComparator implements Comparator { 
    @Override 
    public int compare(Object first, Object second) { 
        try { 
            final String f = (String) first; 
            final String s = (String) second; 
            return f.compareTo(s); 
        } catch (ClassCastException cce) { 
            throw new NonStringElementInCollectionException ( 
                    "There are mixed elements in the collection.", cce); 
        } 
    } 
}

```

此代码捕获`ClassCastException`并抛出一个新的。抛出一个新异常的优点是，您可以确保这个异常是从比较器中抛出的，问题实际上是集合中存在混合元素。类转换问题也可能发生在代码的其他地方，在某些排序实现中。一些应用程序代码可能希望捕获异常并处理该情况；例如，发送特定于应用程序的错误消息，而不是仅向用户转储堆栈跟踪。此代码也可以捕获`ClassCastException`，但无法确定异常的真正原因是什么。另一方面，`NonStringElementInCollectionException`是确定的。

`NonStringElementInCollectionException`是 JDK 中不存在的异常。我们必须创造它。异常是 Java 类，我们的异常如下所示：

```
package packt.java9.by.example.ch03.bubble; 

public class NonStringElementInCollectionException extends RuntimeException { 
    public NonStringElementInCollectionException (String message, Throwable cause) { 
        super(message, cause); 
    } 
}

```

Java 有检查异常的概念。这意味着任何不扩展`RuntimeException`的异常都应该在方法定义中声明。假设我们的异常声明如下：

```
public class NonStringElementInCollectionException extends Exception

```

然后，我们必须声明`compare`方法如下：

```
public int compare(Object first, Object second) throws NonStringElementInCollectionException

```

问题是方法抛出的异常是方法签名的一部分，这样`compare`不会覆盖接口的`compare`方法，这样类就不会实现`Comparator`接口。因此，我们的异常必须是运行时异常。

应用程序中可能存在异常的层次结构，新手程序员通常会创建大量的异常层次结构。如果你能做些什么，并不意味着你应该去做。层次结构应尽可能保持平坦，对于异常尤其如此。如果 JDK 中有一个描述异常情况的异常，那么使用现成的异常。和任何其他类一样：如果它已经准备好了，就不要再实现它。

同样重要的是要注意，只有在异常情况下才应该抛出异常。它不是用来表示某些正常操作条件的信号。这样做会妨碍代码的可读性，也会消耗 CPU。抛出异常对于 JVM 来说不是一件容易的任务。

可以抛出的不仅仅是异常。`throw`命令可以抛出，`catch`命令可以捕获扩展`Throwable`类的任何内容。`Throwable`有两个子类：`Error`和`Exception`。如果在 Java 代码执行过程中发生错误，将引发`Error`异常。两个最臭名昭著的错误是`OutOfMemoryError`和`StackOverflowError`。如果发生上述任何一种情况，您都无法可靠地捕获错误。

JVM 中也有`InternalError`和`UnknownError`，但由于 JVM 相当稳定，您几乎不会遇到这些错误。

当这些错误发生时，试着调试代码，找出为什么要使用这么多内存或这么深的方法调用，并尝试优化解决方案。我刚才所说的创建异常层次结构对于捕获错误也是正确的。您可以捕获错误的事实并不意味着您应该这样做。相反，你永远不应该捕捉错误，尤其是永远不应该捕捉`Throwable`。

这样，当一些程序员意外地在名称中写入 42 个时，我们处理了这种特殊情况，但是如果在编译时识别错误，会更好吗？为此，我们将引入泛型。

在我们去那里之前，最后想一想。我们用`canNotSortMixedElements`单元测试测试什么类行为？测试在`BubbleSortTest`测试类中，但功能在比较器实现`StringComparator`中。此测试检查单元测试类范围之外的内容。我可以使用它进行演示，但这不是单元测试。排序实现的真正功能可以这样公式化：比较器抛出的任何异常都由排序实现抛出。您可以尝试编写此单元测试，也可以继续阅读；我们将在下一节中介绍。

`StringComparator`类没有测试类，因为`StringComparator`是测试的一部分，我们永远不会为测试编写测试。否则，我们将陷入一个无尽的兔子洞。

# 仿制药

泛型特性是在版本 5 中引入 Java 的。首先举一个例子，我们的`Sortable`界面到目前为止是这样的：

```
package packt.java9.by.example.ch03; 
public interface SortableCollection { 
    Object get(int i); 
    int size(); 
}

```

在引入泛型之后，将如下所示：

```
package packt.java9.by.example.ch03; 

public interface SortableCollection<E> { 
    E get(int i); 
    int size(); 
}

```

`E`标识符表示一种类型。它可以是任何类型。如果类实现了接口，即两个方法-`size`和`get`，则表示该类是可排序的集合。`get`方法应该返回属于`E`类型的内容，不管`E`是什么。到目前为止，这可能没有太多意义，但你很快就会明白这一点。毕竟，泛型是一个困难的话题。

`Sort`接口将变为以下内容：

```
package packt.java9.by.example.ch03; 
import java.util.Comparator; 
public interface Sort<E> { 
    void sort(SortableCollection<E> collection); 
    void setSwapper(Swapper swap); 
    void setComparator(Comparator<E> compare); 
}

```

这仍然没有提供比没有泛型的前一个版本更多的价值，但是，至少，它做了一些事情。在实现`Sort`接口的实际类中，`Comparator`应该接受`SortableCollection`使用的相同类型。`SortableCollection`不可能在字符串上工作，我们为整数注入了一个比较器。

`BubbleSort`的执行情况如下：

```
package packt.java9.by.example.ch03.bubble; 
import packt.java9.by.example.ch03.*; 
import java.util.Comparator; 
public class BubbleSort<E> implements Sort<E> { 
    @Override 
    public void sort(SortableCollection<E> collection) { 
        ... sort code same as before 
    } 
    private Comparator<E> comparator = null; 
    @Override 
    public void setComparator(Comparator<E> comparator) { 
        this.comparator = comparator; 
    } 
        ... method swapper same as before 
}

```

当我们编写测试时，泛型的真正威力就会显现出来。第一个测试没有太大变化，尽管对于泛型，它更明确。

```
@Test 
public void canSortStrings() { 
    ArrayList<String> actualNames = new ArrayList< >(Arrays.asList( 
            "Johnson", "Wilson", 
            "Wilkinson", "Abraham", "Dagobert" 
    )); 
    ArrayList<String> expectedResult = new ArrayList<>(Arrays.asList( 
            "Abraham", "Dagobert", 
            "Johnson", "Wilkinson", "Wilson" 
    )); 
    SortableCollection<String> names = 
            new ArrayListSortableCollection<>(actualNames); 
    Sort<String> sort = new BubbleSort<>(); 
    sort.setComparator(String::compareTo); 
    sort.setSwapper(new ArrayListSwapper<>(actualNames)); 
    sort.sort(names); 
    Assert.assertEquals(expectedResult, actualNames); 
}

```

当我们定义`ArrayList`时，我们还将声明列表中的元素将是字符串。当我们分配新的`ArrayList`时，不需要再次指定元素是字符串，因为它来自那里的实际元素。每一根都是一根弦；因此，编译器知道，`<`和`>`字符之间唯一可以出现的是`String`。

两个字符`<`和`>`之间没有类型定义，称为**菱形运算符**。类型是推断的。如果您习惯了泛型，那么这段代码将为您提供有关集合所处理的类型的更多信息，并且代码的可读性也会提高。可读性和额外的信息不是唯一的问题。

正如我们所知，`Comparator`参数现在是`Comparator<String>`，我们可以使用 Java 8 提供的高级特性，并可以将`String::compareTo`方法引用传递给比较器 setter。

第二个考验现在对我们来说很重要。这是确保`Sort`不会干扰比较器抛出的异常的测试。

```
@Test(expected = RuntimeException.class) 
public void throwsWhateverComparatorDoes () { 
    ArrayList<String> actualNames = new ArrayList<>(Arrays.asList( 
            42, "Wilson", 
            "Wilkinson", "Abraham", "Dagobert" 
    )); 
    SortableCollection<String> names = 
            new ArrayListSortableCollection<>(actualNames); 
    Sort<String> sort = new BubbleSort<>(); 
    sort.setComparator((String a, String b) -> { 
        throw new RuntimeException(); 
    }); 
    final Swapper neverInvoked = null; 
    sort.setSwapper(neverInvoked);  
    sort.sort(names); 
}

```

问题是，它甚至不编译。编译器说它无法推断第三行的`ArrayList<>`类型。当`asList`方法的所有参数都是字符串时，该方法返回一个`String`元素列表，因此新操作符生成`ArrayList<String>`。这一次，有一个整数，因此，编译器无法推断`ArrayList<>`是针对`String`元素的。

将类型定义从`ArrayList<>`更改为`ArrayList<String>`不是解决方法。在这种情况下，编译器将抱怨值`42`。这就是泛型的力量。当您使用具有类型参数的类时，编译器可以检测您何时提供了错误类型的值。要将值放入`ArrayList`以检查实现是否真的抛出异常，我们必须将值放入其中。我们可以尝试用空的`String`替换`42`值，然后添加以下仍无法编译的行：

```
actualNames.set(0,42);

```

编译器仍然会知道您要在`ArrayList`中设置的值应该是`String`。要获得带有`Integer`元素的阵列，您必须明确解锁安全手柄并扣动扳机，射击自己：

```
((ArrayList)actualNames).set(0,42);

```

现在，测试如下所示：

```
@Test(expected = RuntimeException.class) 
public void throwsWhateverComparatorDoes() { 
    ArrayList<String> actualNames = new ArrayList<>(Arrays.asList( 
            "", "Wilson", 
            "Wilkinson", "Abraham", "Dagobert" 
    )); 
    ((ArrayList) actualNames).set(0, 42); 
    SortableCollection<String> names = 
            new ArrayListSortableCollection<>(actualNames); 
    Sort<String> sort = new BubbleSort<>(); 
    sort.setComparator((a, b) -> { 
        throw new RuntimeException(); 
    }); 
    final Swapper neverInvoked = null; 
    sort.setSwapper(neverInvoked); 
    sort.sort(names); 
}

```

我们将交换程序设置为 null，因为它从未被调用。当我第一次写这段代码时，我很清楚。几天后，我读了代码，然后停了下来。*为什么交换程序为空？*过了一两秒钟我就想起来了。但是任何时候，当阅读和理解代码时，我倾向于考虑重构。
我可以在行中添加一条注释，说明`//never invoked`，但即使功能发生变化，注释也会保留在那里。2006 年，当一个错误的注释使我看不到代码是如何执行的时，我以艰难的方式学会了这一点。我在调试时阅读了注释，而不是代码，在系统关闭时修复错误花了两天时间。
我倾向于使用让代码表达发生了什么的结构，而不是注释。额外的变量可能会使类文件大几个字节，但 JIT 编译器会对其进行优化，因此最终代码不会运行得较慢。

引发异常的比较器作为 lambda 表达式提供。Lambda 表达式可用于只有一个简单方法的匿名类或命名类的情况。Lambda 表达式是匿名方法，存储在变量中或传入参数以供以后调用。我们将在[第 8 章](08.html)*扩展我们的电子商务应用*中讨论 lambda 表达式的细节。

目前，我们将继续实施`QuickSort`，为此，我们将使用 TDD 方法。

# 测试驱动开发

测试驱动开发（TDD）是一种代码编写方法，开发人员首先根据规范编写测试，然后编写代码。这与开发人员社区所习惯的正好相反。我们遵循的传统方法是编写代码，然后为其编写测试。老实说，很多时候真正的实践是编写代码，并使用特殊测试进行测试，而根本不进行单元测试。作为一名专业人士，顺便说一句，你永远不会这么做。你总是写测试。（现在，把它写一百遍：我会一直写测试。）

TDD 的优点之一是测试不依赖于代码。由于代码在测试创建时不存在，开发人员不能依赖单元的实现，因此，它不能影响测试创建过程。这通常是好的。单元测试应尽可能采用黑盒测试。

黑盒测试是一种不考虑被测系统实现的测试。如果一个系统被重构，以不同的方式实现，但是它提供给外部世界的接口是相同的，那么黑盒测试应该可以正常运行。
白盒测试取决于被测系统的内部工作。当代码更改白盒测试时，可能还需要调整代码以跟随更改。白盒测试的优点是测试代码更简单。不总是这样。
灰盒试验是两者的混合。

单元测试应该是黑盒测试，但是，很多时候，编写黑盒测试并不简单。开发人员将编写一个他们认为是黑盒的测试，但很多时候，这种想法被证明是错误的。当实现发生变化时，一些东西被重构，测试不再工作，需要纠正。开发人员，尤其是编写单元的开发人员，在了解了实现之后，将编写一个依赖于代码内部工作的测试。在编写代码之前编写测试是防止这种情况发生的一种工具。如果没有代码，您就不能依赖它。

TDD 还表示，开发应该是一种迭代方法。您在开始时只编写一个测试。如果你跑，它会失败。当然失败了！由于还没有代码，它必须失败。然后，您将编写完成此测试的代码。除此之外，只有使此测试通过的代码。然后，您将继续为规范的另一部分编写新的测试。您将运行它，但它失败了。这证明了新测试确实测试了一些尚未开发的东西。然后，您将开发代码以满足新的测试，并且还可能修改在以前的迭代中已经编写的代码块。当代码准备就绪时，测试将通过。

很多时候，开发人员不愿意修改代码。这是因为他们害怕破坏已经在工作的东西。当你遵循 TDD 时，你不应该，同时，你也不必害怕这一点。已经开发的所有功能都有测试。如果某些代码修改破坏了某些功能，测试将立即发出错误信号。关键是在修改代码时尽可能频繁地运行测试。

# 实现快速排序

正如我们已经讨论过的，快速排序由两个主要部分组成。一个是分区，另一个是递归地进行分区，直到整个数组被排序。为了使我们的代码模块化并准备好演示 Java9 模块处理特性，我们将把分区和递归排序开发成单独的类并放在单独的包中。代码的复杂性不能证明这种分离是合理的。

# 分区类

分区类应该提供一个基于枢轴元素移动集合元素的方法，并且我们需要在方法完成后知道枢轴元素的位置。方法的签名应如下所示：

```
public int partition(SortableCollection<E> sortable, int start, int end, E pivot);

```

该类还应具有访问`Swapper`和`Comparator`的权限。在这种情况下，我们定义了一个类而不是一个接口；因此，我们将使用构造函数注入。

这些构造，如 setter 和 constructor-injector，是如此常见和频繁发生，以至于 ide 支持这些构造的生成。您需要在代码中创建`final`字段，并使用*代码生成*菜单创建构造函数。

分区类将如下所示：

```
package packt.java9.by.example.ch03.qsort; 

import packt.java9.by.example.ch03.SortableCollection; 
import packt.java9.by.example.ch03.Swapper; 

import java.util.Comparator; 

public class Partitioner<E> { 

    private final Comparator<E> comparator; 
    private final Swapper swapper; 
    public Partitioner(Comparator<E> comparator, Swapper swapper){ 
        this.comparator = comparator; 
        this.swapper = swapper; 
    } 

    public int partition(SortableCollection<E> sortable, int start, int end, E pivot){ 
        return 0; 
    } 
}

```

这段代码什么都不做，但 TDD 就是这样开始的。我们将创建需求的定义，提供代码的框架和调用它的测试。要做到这一点，我们需要一些可以进行分区的东西。最简单的选择是`Integer`数组。`partition`方法需要一个`SortableCollection<E>`类型的对象，我们需要一些东西来包装数组并实现这个接口。我们把那个班命名为`ArrayWrapper`。该类具有通用性，并且不仅仅用于测试。因此，我们将其创建为生产代码，因此我们将其放在目录`main`中，而不是目录`test`中。由于该包装器独立于`Sort`的实现，因此该类的正确位置在新的`SortSupportClasses`模块中。我们将创建新模块，因为它不是接口的一部分。实现依赖于接口，但不依赖于支持类。也可能有一些应用程序使用我们的库，可能需要接口模块和一些实现，但当它们自己提供包装功能时，仍然不需要支持类。毕竟，我们无法实现所有可能的包装功能。SRP 也适用于模块。

Java 库往往包含不相关的功能。从短期来看，它使库的使用更加简单。您只需要在 POM 文件中指定一个依赖项，就可以拥有所需的所有类和 API。从长远来看，应用程序变得越来越大，携带了许多属于某些库的类，但应用程序从不使用它们。

要添加新模块，必须创建模块目录以及源目录和 POM 文件。该模块必须添加到父 POM 中，并且还必须添加到`dependencyManagement`部分，以便`QuickSort`模块的测试代码可以使用该模块，而无需指定版本。新模块依赖于接口模块，因此必须将此依赖项添加到支持类的 POM 中。

`ArrayWrapper`类简单而通用。

```
package packt.java9.by.example.ch03.support; 
import packt.java9.by.example.ch03.SortableCollection; 
public class ArrayWrapper<E> implements SortableCollection<E> { 
    private final E[] array; 
    public ArrayWrapper(E[] array) { 
        this.array = array; 
    } 
    public E[] getArray() { 
        return array; 
    } 
    @Override 
    public E get(int i) { 
        return array[i]; 
    } 
    @Override 
    public int size() { 
        return array.length; 
    } 
}

```

我们也需要的`ArraySwapper`类进入同一个模块。它和包装器一样简单。

```
package packt.java9.by.example.ch03.support; 
import packt.java9.by.example.ch03.Swapper; 
public class ArraySwapper<E> implements Swapper { 
    private final E[] array; 
    public ArraySwapper(E[] array) { 
        this.array = array; 
    } 
    @Override 
    public void swap(int k, int r) { 
        final E tmp = array[k]; 
        array[k] = array[r]; 
        array[r] = tmp; 
    } 
}

```

有了这些类，我们可以创建第一个测试。

```
package packt.java9.by.example.ch03.qsort; 

// imports deleted from print 

public class PartitionerTest {

```

在创建`@Test`方法之前，我们需要两个进行断言的助手方法。断言并不总是简单的，在某些情况下，它们可能涉及一些编码。一般规则是测试和其中的断言应该尽可能简单；否则，它们只是编程错误的可能来源。此外，我们创建它们是为了避免编程错误，而不是创建新的错误。

`assertSmallElements`方法认定`cutIndex`之前的所有元素都小于`pivot`。

```
    private void assertSmallElements(Integer[] array, int cutIndex, Integer pivot) { 
        for (int i = 0; i < cutIndex; i++) { 
            Assert.assertTrue(array[i] < pivot); 
        } 
    }

```

`assertLargeElements`方法确保`cutIndex`之后的所有元素至少与`pivot`一样大。

```
    private void assertLargeElemenents(Integer[] array, int cutIndex, Integer pivot) { 
        for (int i = cutIndex; i < array.length; i++) { 
            Assert.assertTrue(pivot <= array[i]); 
        } 
    }

```

该测试使用一个常量数组`Integers`并将其包装成一个`ArrayWrapper`类。

```
    @Test 
    public void partitionsIntArray() { 
        Integer[] partitionThis = new Integer[]{0, 7, 6}; 
        Swapper swapper = new ArraySwapper<>(partitionThis); 
        Partitioner<Integer> partitioner = 
                new Partitioner<>((a, b) -> a < b ? -1 : a > b ? +1 : 0, swapper); 
        final Integer pivot = 6; 
        final int cutIndex = partitioner.partition(new ArrayWrapper<>(partitionThis), 0, 2, pivot); 
        Assert.assertEquals(1, cutIndex); 
        assertSmallElements(partitionThis, cutIndex, pivot); 
        assertLargeElemenents(partitionThis, cutIndex, pivot); 
    } 
}

```

JDK 中没有针对`Integer`类型的`Comparator`，但很容易将其定义为 lambda 函数。现在我们可以编写`partition`方法，如下所示：

```
public int partition(SortableCollection<E> sortable, int start, int end, E pivot){ 
    int small = start; 
    int large = end; 
    while( large > small ){ 
        while( comparator.compare(sortable.get(small), pivot) < 0 && small < large ){ 
            small ++; 
        } 
        while( comparator.compare(sortable.get(large), pivot) >= 0 && small < large ){ 
            large--; 
        } 
        if( small < large ){ 
            swapper.swap(small, large); 
        } 
    } 
    return large; 
}

```

![](../images/00038.jpeg)

如果我们运行测试，它运行良好。然而，如果我们使用覆盖率运行测试，那么 IDE 告诉我们覆盖率只有 92%。该测试仅涵盖了`partition`方法 14 行中的 13 行。

第**28**行边沟上有一个红色矩形。这是因为测试数组已经分区。当 pivot 值为`6`时，不需要交换其中的任何元素。这意味着我们的测试很好，但还不够好。如果那一行有错误怎么办？

为了修正这个问题，我们将扩展测试，将测试阵列从`{ 0, 7, 6 }`更改为`{ 0, 7, 6, 2}`。运行测试，它失败了。为什么？经过一些调试之后，我们会意识到我们调用了方法`partition`，并将固定参数`2`作为数组的最后一个索引。但是，我们使阵列变长了。为什么我们首先要在那里写一个常数？这是一种坏习惯。让我们用`partitionThis.length-1`替换它。现在，它说`cutIndex`是`2`，但我们预期`1`。我们忘记将断言调整为新数组。让我们把它修好。现在它起作用了。

最后一件事是重新思考这些断言。代码越少越好。断言方法非常通用，我们将在单个测试数组中使用它。断言方法非常复杂，它们值得自己测试。但是，我们不编写代码进行测试。相反，我们可以简单地删除这些方法并获得测试的最终版本。

```
@Test 
public void partitionsIntArray() { 
    Integer[] partitionThis = new Integer[]{0, 7, 6, 2}; 
    Swapper swapper = new ArraySwapper<>(partitionThis); 
    Partitioner<Integer> partitioner = 
            new Partitioner<>((a, b) -> a < b ? -1 : a > b ? +1 : 0, swapper); 
    final Integer pivot = 6; 
    final int cutIndex = partitioner.partition(new ArrayWrapper<>(partitionThis), 0, partitionThis.length-1, pivot); 
    Assert.assertEquals(2, cutIndex); 
    final Integer[] expected = new Integer[]{0, 2, 6, 7}; 
    Assert.assertArrayEquals(expected,partitionThis); 
}

```

再说一遍，这是一个黑盒测试吗？如果分区返回`{2, 1, 7, 6}`怎么办？这符合定义。我们可以创建更复杂的测试来覆盖这些情况。但是更复杂的测试本身也可能有缺陷。作为一种不同的方法，我们可以创建可能更简单但依赖于实现内部结构的测试。这些不是黑盒测试，因此也不是理想的单元测试。我会选择第二个，但如果有人选择另一个，我不会争辩。

# 递归排序

我们将使用`qsort`包中的一个额外类以及分区类实现快速排序，如下所示：

```
package packt.java9.by.example.ch03.qsort; 

// imports deleted from the print 

public class Qsort<E>  { 
// constructor injected final fields deleted from the print 
    public void qsort(SortableCollection<E> sortable, int start, int end) { 
        if (start < end) { 
            final E pivot = sortable.get(start); 
            final Partitioner<E> partitioner = new Partitioner<>(comparator, swapper); 
            int cutIndex = partitioner.partition(sortable, start, end, pivot); 
            if (cutIndex == start) { 
                cutIndex++; 
            } 
            qsort(sortable, start, cutIndex - 1); 
            qsort(sortable, cutIndex, end); 
        } 
    } 
}

```

该方法得到`SortableCollection<E>`和两个指标参数。它不会对整个集合进行排序；它只对`start`和`end`索引之间的元素进行排序。

非常精确的索引总是很重要的。通常，Java 中的开始索引没有问题，但是许多错误源于`end`索引的解释方式。
在该方法中，`end`的值可能意味着该索引已经不是待排序区间的一部分。在这种情况下，应使用`end-1`调用`partition`方法，并使用`cutIndex`作为最后一个参数调用第一个递归调用。这是品味的问题。重要的是要精确并定义指数参数的解释。

如果只有一个元素`(start == end)`，则无需排序，方法返回。这是递归的最终标准。该方法还假设`end`指数不小于`start`指数。由于这种方法只在我们目前正在开发的库中使用，所以这样的假设风险不大。

如果有要排序的内容，那么该方法将获取要排序区间的第一个元素，并将其用作枢轴并调用`partition`方法。当分区完成时，该方法递归地为两部分调用自己。

该算法是递归的。这意味着该方法调用自身。当执行方法调用时，处理器在名为**堆栈**的区域中分配一些内存，并将局部变量存储在该区域中。这个属于堆栈中方法的区域称为**堆栈帧**。当该方法返回时，释放该区域并恢复堆栈，只需将堆栈指针移动到其原来的状态即可。这样，一个方法可以在调用另一个方法后继续执行；局部变量就在那里。

当一个方法调用自己时，它没有什么不同。局部变量是方法实际调用的局部变量。当该方法调用自身时，它会在堆栈上再次为局部变量分配空间。换句话说，这些是局部变量的新的*实例*。

当算法的定义是递归的时，我们将在 Java 和其他编程语言中使用递归方法。理解当处理器代码运行时，它不再是递归的，这一点非常重要。在这个级别上，有指令、寄存器存储、内存加载和跳转。没有什么像函数或方法，因此，在这个层次上，没有什么像递归。

如果你明白了这一点，很容易理解任何递归都可以被编码为循环。

事实上，每个循环的另一种方式也可以被编码为递归，但在开始函数式编程之前，这并不是很有趣。

Java 和许多其他编程语言中递归的问题是，它可能会耗尽堆栈空间。在快速排序的情况下，情况并非如此。您可以安全地假设 Java 中方法调用的堆栈只有几百个级别。快速排序需要一个大约为*log<sub class="calibre30">2</sub>n*深的堆栈，其中*n*是要排序的元素数。在 10 亿元素的情况下，这是 30 个刚好合适的元素。

为什么堆栈没有移动或调整大小？这是因为耗尽堆栈空间的代码通常是糟糕的样式。它们可以以某种循环的形式表达得更具可读性。一个更健壮的堆栈实现只会吸引新手进行一些可读性较差的递归编码。

递归有一个特例，叫做尾部递归。尾部递归方法将自己作为该方法的最后一条指令调用。当递归调用返回代码时，执行该方法除了释放用于该方法调用的堆栈框架外，什么也不做。换句话说，我们将在递归调用期间保留堆栈帧，以便在调用之后将其丢弃。为什么不在电话前把它扔掉呢？在这种情况下，具有相同大小和调用的实际帧将进行分配，因为这与保留的方法相同，递归调用被转换为跳转指令。这是 Java 没有做的优化。函数式语言正在这样做，但 Java 并不是真正的函数式语言，因此应该避免使用尾部递归函数，并将其转换为 Java 源代码级别的循环。

# 非递归排序

为了证明即使是非尾部递归方法也可以用非递归方式表示，下面是一种快速排序方式：

```
public class NonRecursiveQuickSort<E> { 
    // injected final fields and constructor deleted from print  
    private static class Stack { 
        final int begin; 
        final int fin; 
        public Stack(int begin, int fin) { 
            this.begin = begin; 
            this.fin = fin; 
        } 
    } 

    public void qsort(SortableCollection<E> sortable, int start, int end) { 
        final List<Stack> stack = new LinkedList<>(); 
        final Partitioner<E> partitioner = new Partitioner<>(comparator, swapper); 
        stack.add(new Stack(start, end)); 
        int i = 1; 
        while (!stack.isEmpty()) { 
            Stack iter = stack.remove(0); 
            if (iter.begin < iter.fin) { 
                final E pivot = sortable.get(iter.begin); 
                int cutIndex = partitioner.partition(sortable, iter.begin, iter.fin, pivot); 
                if( cutIndex == iter.begin ){ 
                    cutIndex++; 
                } 
                stack.add(new Stack(iter.begin, cutIndex - 1)); 
                stack.add(new Stack(cutIndex, iter.fin)); 
            } 
        } 
    } 
}

```

这段代码在 Java 级别实现了一个堆栈。虽然它看到在`stack`中仍然有一些要排序的内容，但它从堆栈中取出它并进行排序分区，并对这两部分进行排序。

这段代码比前一段代码更复杂，您必须了解`Stack`类的作用及其工作原理。另一方面，程序只使用`Partitioner`类的一个实例，也可以使用线程池来安排后续排序，而不是在单个进程中处理任务。在多 CPU 机器上执行排序时，这可能会加快排序速度。然而，这是一个有点复杂的任务，本章包含了很多没有多任务的新事物；因此，我们将在后面的两章中介绍多线程代码。

在排序的第一个版本中，我对它进行了编码，没有将`cutIndex`与间隔 start 进行比较并在`if`分支中增加它的三行。这是非常需要的。但是，我们在本书中创建的单元测试没有发现错误，如果我们错过了这些行。我建议您删除这些行，并尝试编写一些失败的单元测试。然后，试着理解当这些行非常重要时的特殊情况是什么，并尝试修改单元测试，以便尽可能简单地发现该 bug。（最后，将这四行放回原处，看看代码是否有效。）
此外，找出一些不将此修改放在方法`partition`中的架构原因。如果是`large == start`，该方法可以返回`large+1`。

# 实现 API 类

完成所有这些之后，我们最不需要的就是将`QuickSort`作为一个简单的类（所有真正的工作已经在不同的类中完成）。

```
public class QuickSort<E> implements Sort<E> { 
    public void sort(SortableCollection<E> sortable) { 
        int n = sortable.size(); 
        Qsort<E> qsort = new Qsort<>(comparator,swapper); 
        qsort.qsort(sortable, 0, n-1); 
    } 
// ... setter injectors were deleted from the print 
}

```

别忘了，我们还需要一个测试！但是，在这种情况下，这与`BubbleSort`的情况没有太大区别。

```
@Test 
public void canSortStrings() { 
    final String[] actualNames = new String[]{ 
            "Johnson", "Wilson", 
            "Wilkinson", "Abraham", "Dagobert" 
    }; 
    final String[] expected = new String[]{"Abraham", "Dagobert", "Johnson", "Wilkinson", "Wilson"}; 
    Sort<String> sort = new QuickSort<>(); 
    sort.setComparator(String::compareTo); 
    sort.setSwapper(new ArraySwapper<String>(actualNames)); 
    sort.sort(new ArrayWrapper<>(actualNames)); 
    Assert.assertArrayEquals(expected, actualNames); 
}

```

这次我们使用了`String`数组而不是`ArrayList`。这使得这个测试更简单，而且，这一次，我们已经有了支持类。

您可能认识到这不是单元测试。在`BubbleSort`的情况下，该算法在单个类中实现。测试单个类是一个单元测试。在`QuickSort`的情况下，我们将功能分为不同的类，甚至分为不同的包。`QuickSort`类的真实单元测试将揭示该类对其他类的依赖性。当该测试运行时，它涉及到执行`Partitioner`和`Qsort`；因此，它实际上不是一个单元测试。

我们应该为此烦恼吗？不是真的。我们希望创建涉及单个单元的单元测试，以便在单元测试失败时知道问题所在。如果只有集成测试，那么失败的测试用例在指出问题所在方面不会有很大帮助。它所说的只是测试中涉及的类中存在一些问题。在这种情况下，本测试中只涉及有限数量的类（三个），并且它们被绑定在一起。它们实际上是紧密联系在一起的，彼此之间的关系如此密切，以至于在实际的生产代码中，我会在单个类中实现它们。我在这里将它们分开，以演示如何测试单个单元，并演示 Java 9 模块支持，它需要的不仅仅是 JAR 文件中的单个类。

# 创建模块

模块处理，也称为 project**Jigsaw，**是一个仅在 Java9 中可用的特性。这是开发人员期待已久的特性。首先，它是为 Java7 设计的，但它太复杂了，所以被推迟到 Java8，然后是 Java9。一年前，它似乎会再次被推迟，但最终，项目代码进入了早期版本，现在没有什么可以阻止它成为版本的一部分。

# 为什么需要模块

我们已经看到 Java 中有四个访问级别。当没有提供修改器时，方法或字段可以是`private`、`protected`、`public`或`default`（也称为包专用）。当您开发一个用于多个项目的复杂库时，库本身将包含许多包中的许多类。当然会有一些类和方法，这些类和方法中的字段是由来自不同包的其他类在库中使用的，但是库外的代码不会使用这些类。使它们比`public`更不可见将使它们在库中无法使用。制作它们`public`将使它们从外部可见。

在我们的代码中，编译成 JAR 的 Maven 模块`quick`只有在方法 sort 可以调用`qsort`的情况下才能使用。但是，我们不希望`qsort`直接从外部使用。在下一个版本中，我们可能希望开发一个使用`NonRecursiveQuickSort`类中的`qsort`的版本，我们不希望客户因为库的小升级而抱怨代码无法编译或工作。我们可以证明内部方法和类仍然是公共的，但不是供使用的，而是徒劳的。使用我们的库的开发人员不阅读文档。这也是我们不写过多评论的原因。没有人会读它，即使是执行代码的处理器也不会读。

这个问题最著名、最臭名昭著的例子是 JDK 中的`sun.misc.Unsafe`类。顾名思义，其中包含一些真正不安全的代码。您可以从堆外访问内存，在不初始化的情况下创建对象，等等。你不应该。为什么要麻烦？您是一个行为良好的开发人员，只需遵守规则，而不使用该软件包。无论何时在新版本的 JDK 中进行更改，您的程序都可以安全地使用公共的、有良好文档记录的 JDK API。正当

错误的在没有意识到这一点的情况下，您可能会使用一些依赖于使用该包的其他库的库。Mockito 和 Spring 框架只是众多处于危险中的两个。此外，Java9 肯定会附带此包的新版本。但是，它也将与模块处理一起提供。虽然 Java 9 将为使用`Unsafe`包的库提供一些有用的 API，因为没有为它们所需的功能提供 API，但它将提供模块，以避免再次出现相同的问题。

# 什么是 Java 模块

Java 模块是 JAR 或目录中的类集合，其中还包含一个名为`module-info`的特殊类。如果 JAR 或目录中有此文件，则它是一个模块，否则它只是`classpath`上（或不是）的类的集合。Java8 和早期版本将忽略该类，因为它从未用作代码。这样，使用旧的 Java 不会造成任何伤害，并且可以保持向后兼容性。

模块信息定义了模块导出的内容及其所需的内容。它有一种特殊的格式。例如，我们可以在我们的`SortInterface`Maven 模块中放置`module-info.java`。

```
module packt.java9.by.example.ch03{ 
        exports packt.java9.by.example.ch03; 
        }

```

这意味着，`public`和`packt.java9.by.example.ch03`包内的任何类都可以从外部使用。此包从模块导出，但其他包中的其他类从模块外部看不到，即使它们是`public`。模块的名称与包的名称相同，但这只是在仅导出一个包的情况下的约定。要求与包的情况相同：应该有一个不可能与其他模块名称冲突的名称。反向域名是一个不错的选择，但它不是一个必须的，因为你可以在这本书中看到。目前还没有顶级域名`packt`。

我们还应该配置父 POM，以确保我们使用的编译器是 Java 9，

```
<build> ... 
    <plugins> ... 
        <plugin> 
            <groupId>org.apache.maven.plugins</groupId> 
            <artifactId>maven-compiler-plugin</artifactId> 
            <version>3.5.1</version> 
            <configuration> 
                <source>1.9</source> 
                <target>1.9</target> 
            </configuration> 
        </plugin> 
...

```

旧版本会与`module-info.java`文件混淆。（顺便说一句，即使是我在本书中使用的 Java 9 的早期 access 版本，有时也会遇到困难。）

我们还在 Maven 模块中创建了一个`module-info.java`文件`quick`，如下所示：

```
module packt.java9.by.example.ch03.quick{ 
        exports packt.java9.by.example.ch03.quick; 
        requires packt.java9.by.example.ch03; 
        }

```

此模块导出另一个包，需要我们刚刚创建的`packt.java9.by.example.ch03`模块。现在，我们可以编译模块，`./quick/target`和`./SortInterface/target`目录中创建的 JAR 现在是 Java 9 模块。

由于 Maven 还没有完全支持模块，当我发出`mvn install`命令时，我得到以下错误消息：
`[ERROR] .../genericsort/quick/src/main/java/module-info.java:[3,40] module not found: packt.java9.by.example.ch03`
Maven 将编译后的模块放在`classpath`上，而 Java 9 则为模块寻找`modulepath`。Maven 还没有处理`modulepath`。要将`modulepath`破解到编译器中，我们必须将以下配置行添加到编译器插件`configuration`的父 POM 中：`<compilerArgs>`
`<arg>-modulepath</arg>`
`<arg>${project.parent.basedir}/SortInterface/target/SortInterface-1.0.0-SNAPSHOT.jar: ...</arg>`
`</compilerArgs>`
实际文件应该列出 Maven 生成的所有以冒号分隔的 JAR 文件，以及一些模块所依赖的。这些是`SortInterface`、`quick`和`SortSupportClasses`。

为了测试模块支持的功能，我们将创建另一个名为`Main`的 Maven 模块。它只有一个名为`Main`的类，带有`public static void main`方法：

```
package packt.java9.by.example.ch03.main; 

// ... imports deleted from the print 

public class Main { 
    public static void main(String[] args) throws IOException { 
        String fileName = args[0]; 
        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(fileName)))); 
        List<String> lines = new LinkedList<>(); 
        String line; 
        while ((line = br.readLine()) != null) { 
            lines.add(line); 
        } 
        br.close(); 
        String[] lineArray = lines.toArray(new String[0]); 
        Sort<String> sort = new QuickSort<>(); 
        Qsort<String> qsort = new Qsort<>(String::compareTo,new ArraySwapper<>(lineArray)); 
        sort.setComparator(String::compareTo); 
        sort.setSwapper(new ArraySwapper<>(lineArray)); 
        sort.sort(new ArrayWrapper<>(lineArray)); 
        for (final String outLine : lineArray) { 
            System.out.println(outLine); 
        } 
    } 
}

```

它接受第一个参数（不检查是否有，我们不应该在生产代码中使用它），并将其用作文件名。然后，它将文件的行读入`String`数组，对其进行排序，并将其打印到标准输出。

由于模块支持仅适用于模块，因此此 Maven 模块还必须是 Java 模块并具有`module-info.java`文件。

```
module packt.java9.by.example.ch03.main{ 
        requires packt.java9.by.example.ch03.quick; 
        requires packt.java9.by.example.ch03; 
        requires packt.java9.by.example.ch03.support; 
        }

```

此外，我们必须为支持模块创建一个`module-info.java`文件；否则，我们将无法从模块中使用它。

使用`mvn install`编译模块后，我们可以运行它来打印父 POM。

```
    java -cp Main/target/Main-1.0.0-SNAPSHOT.jar:SortInterface/target/SortInterface-1.0.0-SNAPSHOT.jar:quick/target/quick-1.0.0-SNAPSHOT.jar:SortSupportClasses/target/SortSupportClasses-1.0.0-SNAPSHOT.jar packt.java9.by.example.ch03.main.Main pom.xml 

```

请注意，这是一行命令，打印会分成几行。

现在，如果我们试图直接访问`Qsort`，在`main`方法中插入以下行`Qsort<String> qsort = new Qsort<>(String::compareTo,new ArraySwapper<>(lineArray));`，Maven 会抱怨，因为模块系统对我们的`Main`类隐藏了它：

```
    [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.5.1:compile (default-compile) on project Main: Compilation failure: Compilation failure:
[ERROR] .../Main/src/main/java/packt/java9/by/example/ch03/main/Main.java:[4,41] package packt.java9.by.example.ch03.qsort does not exist
[ERROR] .../Main/src/main/java/packt/java9/by/example/ch03/main/Main.java:[25,9] cannot find symbol

```

模块系统还支持基于`java.util.ServiceLoader`的类加载机制，这在本书中将不再讨论。当使用 Spring、Guice 或其他依赖项注入框架时，这是一种很少在企业环境中使用的老技术。如果您看到一个包含`uses`和`provides`关键字的`module-info.java`文件，那么请首先查阅位于[的关于`ServiceLoader`类的 Java 文档 http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html](http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html) ，然后是关于模块支持的 Java 9 语言文档（ [http://openjdk.java.net/projects/jigsaw/quick-start](http://openjdk.java.net/projects/jigsaw/quick-start) 。

# 总结

在本章中，我们开发了一种实现快速排序的通用排序算法。我们将我们的项目修改为多模块 Maven 项目，并使用 Java 模块定义。我们使用 JUnit 开发单元测试，并使用 TDD 开发代码。我们使用泛型将旧式 Java 代码转换为新代码，并使用异常处理。这些是在接下来的章节中需要的基本工具，我们将在这里开发一个猜谜游戏。首先，我们将开发一个更简单的版本，在接下来的章节中，我们将开发一个使用并行计算和多处理器的版本。