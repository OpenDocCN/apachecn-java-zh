<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemalocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css"/>

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style>

</head>
<body>
<p id="_idParaDest-408" class="chapter-number"><em class="italic"><a id="_idTextAnchor414"/>第 17 章</em>：</p>
			<h1 id="_idParaDest-409"><a id="_idTextAnchor415"/>函数式编程</h1>
			<p>您可能知道，Java 不像 Haskell 那样是一种纯粹的函数式编程语言，但从版本 8 开始，Java 添加了一些函数式支持。添加这种支持的努力是成功的，函数式代码被开发人员和公司广泛采用。函数式编程支持更易于理解、维护和测试的代码。然而，以函数式风格编写 Java 代码需要认真了解 lambdas、流 API、<strong class="source-inline">可选</strong>和函数接口等。所有这些函数式编程主题也可以是访谈主题，在本章中，我们将介绍一些热门问题，这些问题是通过常规 Java 访谈必须知道的。我们的议程包括以下主题：</p>
			<ul>
				<li>简而言之，Java 函数式编程</li>
				<li>问题和编码挑战</li>
			</ul>
			<p>让我们开始吧！</p>
			<h1 id="_idParaDest-410"><a id="_idTextAnchor416"/>Java 函数式编程简而言之</h1>
			<p>与往常一样，本<a id="_idIndexMarker1613"/>部分旨在强调和更新本主题的主要概念，并为回答技术面试中可能出现的基本问题提供全面的资源。</p>
			<h2 id="_idParaDest-411"><a id="_idTextAnchor417"/>函数式编程的关键概念</h2>
			<p>因此，函数式编程的关键概念包括：</p>
			<ul>
				<li>作为一级对象的函数</li>
				<li>纯函数</li>
				<li>高阶函数</li>
			</ul>
			<p>让我们简要介绍一下这些概念。</p>
			<h3 id="sigil_toc_id_543">作为一级对象的函数</h3>
			<p>说<a id="_idIndexMarker1615"/>函数是一级对象意味着我们可以创建一个函数的<em class="italic">实例</em>，因为它有一个引用该函数实例的变量。这类似于引用<strong class="source-inline">字符串</strong>、<strong class="source-inline">列表</strong>或任何其他对象。此外，函数可以作为参数传递给其他函数。但是，Java 方法不是一流的对象。我们所能做的最好的事情就是依赖 Java lambda 表达式。</p>
			<h3 id="sigil_toc_id_544">纯函数</h3>
			<p><em class="italic">纯</em>函数<a id="_idIndexMarker1616"/>是一个执行无<em class="italic">副作用</em>的函数，返回值仅取决于其输入参数。以下 Java 方法是纯函数：</p>
			<pre>public class Calculator {
  public int sum(int x, int y) {
    return x + y;
  }
}</pre>
			<p>如果一个方法使用成员变量或改变成员变量的状态，那么它不是一个<em class="italic">纯</em>函数。</p>
			<h3 id="sigil_toc_id_545">高阶函数</h3>
			<p>高阶<a id="_idIndexMarker1617"/>函数将一个或多个函数作为参数和/或返回另一个函数作为结果。Java 通过 lambda 表达式模拟高阶函数。换句话说，在 Java 中，高阶函数是获取一个（或多个）lambda 表达式作为参数和/或返回另一个 lambda 表达式的方法。</p>
			<p>例如，以<strong class="source-inline">比较器</strong>为参数的<strong class="source-inline">Collections.sort（）</strong>方法是一个高阶函数：</p>
			<pre>Collections.sort(list, (String x, String y) -&gt; {
  return x.compareTo(y);
});</pre>
			<p><strong class="source-inline">Collections.sort（）</strong>的第一个参数是<strong class="source-inline">列表</strong>，第二个参数是 lambda<a id="_idIndexMarker1618"/>表达式。这个 lambda 表达式参数使<strong class="source-inline">Collections.sort（）</strong>成为一个高阶函数。</p>
			<h3 id="sigil_toc_id_546">纯函数式编程规则</h3>
			<p>现在，让我们简要地讨论一下纯函数式编程规则。纯函数式编程也有一套规则要遵循。详情如下:</p>
			<ul>
				<li>无州</li>
				<li>无副作用</li>
				<li>不变变量</li>
				<li>支持递归而不是循环</li>
			</ul>
			<p>让我们简要介绍一下这些规则。</p>
			<h3 id="sigil_toc_id_547">无州</h3>
			<p>通过<em class="italic">无状态</em>，我们<a id="_idIndexMarker1620"/>并不意味着函数式编程消除状态。通常，无状态意味着函数没有外部状态。换句话说，函数可以在内部使用包含临时状态的局部变量，但不能引用它所属的类/对象的任何成员变量。</p>
			<h3 id="sigil_toc_id_548">无副作用</h3>
			<p>通过<em class="italic">无副作用</em>，我们<a id="_idIndexMarker1621"/>应该理解函数不能改变（变异）函数之外的任何状态（在其功能范围之外）。函数外部的状态包括以下内容：</p>
			<ul>
				<li>类/对象中包含该函数的成员变量</li>
				<li>作为参数传递给函数的成员变量</li>
				<li>或外部系统（例如，数据库或文件）中的状态。</li>
			</ul>
			<h3 id="sigil_toc_id_549">不变变量</h3>
			<p>函数式<a id="_idIndexMarker1622"/>编程鼓励并支持使用不可变变量。依靠不可变变量可以帮助我们更容易、更直观地避免<em class="italic">副作用</em>。</p>
			<h3 id="sigil_toc_id_550">支持递归而不是循环</h3>
			<p>由于递归依赖于重复的函数调用来模拟循环，因此代码的功能更加强大。这意味着函数式编程不鼓励使用以下迭代方法计算阶乘：</p>
			<pre>static long factorial(long n) {
  long result = 1;
  for (; n &gt; 0; n--) {
    result *= n;
  }
  return result;
}</pre>
			<p>函数式编程鼓励以下递归方法：</p>
			<pre>static long factorial(long n) {
  return n == 1 ? 1 : n * factorial(n - 1);
}</pre>
			<p>我们使用<em class="italic">尾部递归</em>来提高性能损失，因为在前面的示例中，每个函数调用都保存为递归堆栈中的一个帧。当有许多递归调用时，首选尾部递归。在尾部递归中，函数执行递归调用是最后一件事，因此编译器不需要将函数调用保存为递归堆栈中的帧。大多数编译器将优化尾部递归，从而避免性能损失：</p>
			<pre>static long factorialTail(long n) {
  return factorial(1, n);
}
static long factorial(long acc, long v) {
  return v == 1 ? acc : factorial(acc * v, v - 1);
}</pre>
			<p>或者，可以通过 Java Stream API 实现循环<a id="_idIndexMarker1623"/>，该 API 受功能启发：</p>
			<pre>static long factorial(long n) {
  return LongStream.rangeClosed(1, n)
     .reduce(1, (n1, n2) -&gt; n1 * n2);
}</pre>
			<p>现在，是时候练习一些问题和编码挑战了。</p>
			<h1 id="_idParaDest-412"><a id="_idTextAnchor418"/>问题和编码挑战</h1>
			<p>在本节中，我们将讨论 21 个在访谈中非常流行的问题和编码挑战。开始吧！</p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor419"/>编码挑战 1–Lambda 零件</h2>
			<p><strong class="bold">问题</strong>：描述 Java 中<a id="_idIndexMarker1625"/>lambda 表达式的<a id="_idIndexMarker1624"/>部分。此外，lambda 表达式的特征是什么？</p>
			<p><strong class="bold">解决方案</strong>：如下图所示，lambda 有三个主要部分：</p>
			<p><img src="img/Figure_17.1_B15403.jpg" alt="Figure 17.1 – Lambda parts "/></p>
			
			<p class="figure-caption">图 17.1–Lambda 零件</p>
			<p>lambda 表达式的各部分如下所示：</p>
			<ul>
				<li>在箭头的左侧，有 lambda 主体中使用的该 lambda 的参数。在本例中，这些是<strong class="source-inline">FilenameFilter.accept（文件夹，字符串文件名）</strong>方法的参数。</li>
				<li>箭头右侧是 lambda 主体。在本例中，lambda 主体检查是否可以读取找到文件（<strong class="source-inline">文件名</strong>）的文件夹（<strong class="source-inline">文件夹</strong>），以及该文件的名称是否以<em class="italic">.pdf</em>字符串作为后缀。</li>
				<li>位于参数列表和 lambda 主体之间的箭头用作分隔符。</li>
			</ul>
			<p>接下来，让我们讨论 lambda 表达式的<a id="_idIndexMarker1627"/>特征。因此，如果我们从前面的图中编写 lambda 的匿名类版本，那么它将如下所示：</p>
			<pre>FilenameFilter filter = new FilenameFilter() {
  @Override
  public boolean accept(File folder, String fileName) {
    return folder.canRead() &amp;&amp; fileName.endsWith(".pdf");
  }
};</pre>
			<p>现在，如果我们比较匿名版本和 lambda 表达式，那么我们注意到 lambda 表达式是一个简洁的匿名函数，可以作为参数传递给方法，也可以保存在变量中。</p>
			<p>下图中所示的四个单词表示 lambda 表达式：</p>
			<p><img src="img/Figure_17.2_B15403.jpg" alt="Figure 17.2 – Lambda characteristics "/></p>
			
			<p class="figure-caption">图 17.2–λ特性</p>
			<p>根据经验，请记住 lambdas 支持行为参数化设计<a id="_idIndexMarker1628"/>模式（行为<a id="_idIndexMarker1629"/>作为函数的参数传递），并且只能在函数接口的上下文中使用。</p>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor420"/>编码挑战 2–功能接口</h2>
			<p><strong class="bold">问题</strong>：什么是<a id="_idIndexMarker1630"/>功能接口？</p>
			<p><strong class="bold">解决方案</strong>：在 Java 中，<a id="_idIndexMarker1631"/>函数接口是只包含一个抽象方法的接口。换句话说，函数接口只包含一个未实现的方法。因此，函数接口将函数包装为接口，函数由接口上的单个抽象方法表示。</p>
			<p>除此抽象方法外，函数接口还可以具有默认和/或静态方法。功能接口通常用<strong class="source-inline">@FunctionInterface</strong>注释。这只是一种用于标记函数接口的信息性注释类型。</p>
			<p>以下是功能接口的示例：</p>
			<pre>@FunctionalInterface
public interface Callable&lt;V&gt; {
  V call() throws Exception;
}</pre>
			<p>根据经验，如果一个接口有更多没有实现的方法（即抽象方法），那么它就不再是功能接口。这意味着这样的接口<a id="_idIndexMarker1632"/>不能由 Java lambda 表达式<a id="_idIndexMarker1633"/>实现。</p>
			<h2 id="_idParaDest-415"><a id="_idTextAnchor421"/>编码挑战 3–收集与流</h2>
			<p><strong class="bold">问题</strong>：集合和流的主要区别是什么？</p>
			<p><strong class="bold">解决方案</strong>：集合<a id="_idIndexMarker1635"/>和<a id="_idIndexMarker1636"/>流非常不同。其中一些差异如下：</p>
			<ul>
				<li><strong class="bold">概念上的差异</strong>：集合和流之间的主要差异在于它们在概念上是两个不同的东西。集合用于存储数据（例如，<strong class="source-inline">列表</strong>、<strong class="source-inline">集合</strong>和<strong class="source-inline">映射</strong>），流用于对该数据应用操作（例如，<em class="italic">过滤</em>、<em class="italic">映射</em>和<em class="italic">匹配</em>。换句话说，流对由存储在集合上的数据表示的视图/源应用复杂的操作。此外，对流执行的任何修改/更改都不会反映在原始集合中。</li>
				<li><strong class="bold">数据修改</strong>：我们可以在集合中添加/删除元素，但不能在流中添加/删除元素。实际上，流使用视图/源，对其执行操作，并在不修改视图/源的情况下返回结果。</li>
				<li><strong class="bold">迭代</strong>：当一个流使用一个视图/源时，它会自动在内部执行该视图/源的迭代。迭代的发生取决于应应用于视图/源的所选操作。另一方面，集合必须在外部进行迭代。</li>
				<li><strong class="bold">遍历</strong>：虽然集合可以遍历多次，但流只能遍历一次。因此，默认情况下，不能重用 Java 流。尝试两次遍历流将导致错误读取<em class="italic">流已在</em>上运行或关闭。</li>
				<li><strong class="bold">构造</strong>：集合被急切地构造（所有元素从<a id="_idIndexMarker1637"/>开始就存在）。另一方面，流是延迟构造的（所谓的<em class="italic">中间</em>操作<a id="_idIndexMarker1639"/>在调用<em class="italic">终端</em>操作之前不会进行评估）。</li>
			</ul>
			<h2 id="_idParaDest-416"><a id="_idTextAnchor422"/>编码挑战 4–map（）函数</h2>
			<p><strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">问题</strong>：<a xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" id="_idIndexMarker1641"/>map（）函数的<a xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" id="_idIndexMarker1640"/>功能是什么？您为什么要使用它？</p>
			<p><strong class="bold">解决方案</strong>：<strong class="source-inline">map（）</strong>函数是名为<em class="italic">映射</em>的中间操作，可通过<strong class="source-inline">流</strong>API 获取。它用于通过简单地应用给定函数将一种类型的对象转换为另一种类型。因此，<strong class="source-inline">map（）</strong>通过应用给定函数并将结果累积到新的<strong class="source-inline">流</strong>中，遍历给定流并将每个元素转换为新版本的元素。给定的<strong class="source-inline">流</strong>未修改。例如，通过<strong class="source-inline">流映射（）</strong>将<strong class="source-inline">列表&lt;字符串&gt;</strong>转换为<strong class="source-inline">列表&lt;整数&gt;</strong>可以如下操作：</p>
			<pre>List&lt;String&gt; strList = Arrays.asList("1", "2", "3");
List&lt;Integer&gt; intList = strList.stream()
  .map(Integer::parseInt)
  .collect(Collectors.toList());</pre>
			<p>挑战自己，练习更多的例子。尝试应用<strong class="source-inline">map（）</strong>将一个数组转换为另一个数组。</p>
			<h2 id="_idParaDest-417"><a id="_idTextAnchor423"/>编码挑战 5–flatMap（）函数</h2>
			<p><strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">问题</strong>：<a xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" id="_idIndexMarker1643"/>flatMap（）函数的<a xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" id="_idIndexMarker1642"/>功能是什么？您为什么要使用它？</p>
			<p><strong class="bold">解决方案</strong>：<strong class="source-inline">flatMap（）</strong>函数是名为<em class="italic">展平</em>的中间操作，可通过<strong class="source-inline">流</strong>API 获取。此函数是<strong class="source-inline">map（）</strong>的扩展，意味着除了将给定对象转换为另一种类型的对象外，还可以将其展平。例如，有一个<strong class="source-inline">列表&lt;列表&lt;对象&gt;&gt;</strong>，我们可以通过<strong class="source-inline">流【平面图】</strong>将其转化为<strong class="source-inline">列表&lt;对象&gt;</strong>，如下所示：</p>
			<pre>List&lt;List&lt;Object&gt;&gt; list = ...
List&lt;Object&gt; flatList = list.stream()
  .flatMap(List::stream)
  .collect(Collectors.toList());</pre>
			<p>下一个编码 To.T0.挑战与 T1 T1 相关，所以也要考虑这一点。</p>
			<h2 id="_idParaDest-418"><a id="_idTextAnchor424"/>编码挑战 6–map（）与 flatMap（）的比较</h2>
			<p><strong class="bold">问题</strong>：<strong class="source-inline">map（）</strong>和<strong class="source-inline">flatMap（）</strong>函数之间的<a id="_idIndexMarker1647"/>区别<a id="_idIndexMarker1648"/>是什么？</p>
			<p><strong class="bold">解决方案</strong>：这两个函数都是中间操作，能够通过应用给定函数将给定类型的对象转换为另一类型的对象。此外，<strong class="source-inline">flatMap（）</strong>函数还可以展平给定对象。换句话说，<strong class="source-inline">flatMap（）</strong>也可以展平<strong class="source-inline">流</strong>对象。</p>
			<p>为什么这很重要？嗯，<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">map（）</strong>知道如何在<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">流</strong>中包装元素序列，对吗？这意味着，<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">map（）</strong>可以生成<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">流&lt;字符串[]&gt;</strong>、<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">流&lt;列表&lt;字符串&gt;&gt;</strong>、<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">流&lt;集&lt;&gt;&gt;</strong>甚至【T12 流【T30 流】&lt;等流&gt;&gt;。但问题是这些类型的流无法通过<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">sum（）</strong>、<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">distinct（）</strong>和<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">filter（）</strong>等流操作成功操作（即，正如我们预期的）。</p>
			<p>例如，让我们考虑下面的清单 T0。</p>
			<pre>List&lt;List&lt;String&gt;&gt; melonLists = Arrays.asList(
  Arrays.asList("Gac", "Cantaloupe"),
  Arrays.asList("Hemi", "Gac", "Apollo"),
  Arrays.asList("Gac", "Hemi", "Cantaloupe"));</pre>
			<p>我们试图从这个列表中获得不同的瓜名。如果可以通过<strong class="source-inline">Arrays.stream（）</strong>将数组包装成流，那么对于集合，我们有<strong class="source-inline">collection.stream（）</strong>。因此，第一次尝试可能如下所示：</p>
			<pre>melonLists.stream()
  .map(Collection::stream) // Stream&lt;Stream&lt;String&gt;&gt;
  .distinct();</pre>
			<p>但这不起作用，因为<strong class="source-inline">map（）</strong>将返回<strong class="source-inline">流&lt;流&lt;字符串&gt;&gt;</strong>。<strong class="source-inline">flatMap（）</strong>提供的解决方案如下：</p>
			<pre>List&lt;String&gt; distinctNames = melonLists.stream()
  .flatMap(Collection::stream) // Stream&lt;String&gt;
  .distinct()
  .collect(Collectors.toList());</pre>
			<p><a id="_idIndexMarker1649"/>输出<a id="_idIndexMarker1650"/>如下：<strong class="source-inline">Gac</strong>、<strong class="source-inline">哈密瓜</strong>、<strong class="source-inline">海米</strong>、<strong class="source-inline">阿波罗</strong>。</p>
			<p>此外，如果您<a id="_idIndexMarker1651"/>发现理解这些函数式编程方法有困难，那么我强烈建议您阅读我的另一本书<em class="italic">Java 编码问题</em>，可从 Packt（<a href="https://www.packtpub.com/programming/java-coding-problems">上获得 https://www.packtpub.com/programming/java-coding-problems </a>）。这本书包含两个关于 Java 函数式编程的综合章节，提供了详细的解释、图表和应用程序，有助于深入研究这个主题。</p>
			<h2 id="_idParaDest-419"><a id="_idTextAnchor425"/>编码挑战 7–filter（）函数</h2>
			<p><strong class="bold">问题</strong>：<strong class="source-inline">过滤器（）</strong>功能<a id="_idIndexMarker1653"/>有什么<a id="_idIndexMarker1652"/>功能，您为什么要使用它？</p>
			<p><strong class="bold">解决方案</strong>：<strong class="source-inline">filter（）</strong>函数是通过<strong class="source-inline">流</strong>API 提供的名为<em class="italic">filter</em>的中间操作。用于过滤<strong class="source-inline">流</strong>中满足一定条件的元素。该条件通过<strong class="source-inline">java.util.function.Predicate</strong>函数指定。这个谓词函数只不过是一个函数，它接受一个<strong class="source-inline">对象</strong>作为参数，并返回一个<strong class="source-inline">布尔值</strong>。</p>
			<p>假设我们有以下<strong class="source-inline">整数列表</strong>：</p>
			<pre>List&lt;Integer&gt; ints
  = Arrays.asList(1, 2, -4, 0, 2, 0, -1, 14, 0, -1);</pre>
			<p>流式传输此列表并仅提取非零元素可以按如下方式完成：</p>
			<pre>List&lt;Integer&gt; result = ints.stream()
  .filter(i -&gt; i != 0)
  .collect(Collectors.toList());</pre>
			<p>结果列表将包含以下元素：<strong class="source-inline">1</strong>、<strong class="source-inline">2</strong>、<strong class="source-inline">-4</strong>、<strong class="source-inline">2</strong>、<strong class="source-inline">-1</strong>、<strong class="source-inline">14</strong>、<strong class="source-inline">-1</strong>。</p>
			<p>注意，对于几个常见的操作，Java<strong class="source-inline">流</strong>API 已经提供了现成的中间<a id="_idIndexMarker1654"/>操作。例如，对于以下操作，不需要使用<strong class="source-inline">过滤器（）</strong>和<a id="_idIndexMarker1655"/>定义<strong class="source-inline">谓词</strong>：</p>
			<ul>
				<li><strong class="source-inline">distinct（）</strong>：从流中删除重复项</li>
				<li><strong class="source-inline">跳过（n）</strong>：丢弃前<strong class="source-inline">n</strong>元素</li>
				<li><strong class="source-inline">限制</strong>：截断流长度不超过<strong class="source-inline">s</strong></li>
				<li><strong class="source-inline">排序（）</strong>：根据自然顺序对流进行排序</li>
				<li><strong class="source-inline">排序（比较器&lt;？超级 T&gt;比较器）</strong>：根据给定的<strong class="source-inline">比较器</strong>对流进行排序</li>
			</ul>
			<p>所有这些函数都内置在<strong class="source-inline">流</strong>API 中。</p>
			<h2 id="_idParaDest-420"><a id="_idTextAnchor426"/>编码挑战 8–中间操作与终端操作</h2>
			<p><strong class="bold">问题</strong>：中间操作和终端操作的主要区别是什么？</p>
			<p><strong class="bold">解决方案</strong>：中间<a id="_idIndexMarker1657"/>操作<a id="_idIndexMarker1658"/>返回另一个<strong class="source-inline">流</strong>，而终端操作产生的结果不是<strong class="source-inline">流</strong>（例如，集合或标量值）。换句话说，中间操作允许我们在名为<em class="italic">管道</em>的查询类型中链接/调用多个操作。</p>
			<p>在调用终端操作之前，不会执行中间操作。这意味着中间操作是惰性的。主要是在实际需要某些给定处理的结果时执行。终端操作触发<strong class="source-inline">流</strong>的<a id="_idIndexMarker1659"/>遍历，执行管道。</p>
			<p>在中间操作中，我们有<strong class="source-inline">map（）</strong>、<strong class="source-inline">flatMap（）</strong>、<strong class="source-inline">filter（）</strong>、<strong class="source-inline">limit（）</strong>和<strong class="source-inline">skip（）</strong>。在终端操作中，我们有<strong class="source-inline">sum（）</strong>、<strong class="source-inline">min（）</strong>、<strong class="source-inline">max（）</strong>、<strong class="source-inline">count（）</strong>和<strong class="source-inline">collect（）</strong>。</p>
			<h2 id="_idParaDest-421"><a id="_idTextAnchor427"/>编码挑战 9–peek（）函数</h2>
			<p><strong class="bold">问题</strong>：<a id="_idIndexMarker1661"/>的<strong class="source-inline">peek（）</strong>函数的<a id="_idIndexMarker1660"/>功能是什么？您为什么要使用它？</p>
			<p><strong class="bold">解决方案</strong>：<strong class="source-inline">peek（）</strong>函数是通过<strong class="source-inline">流</strong>API 提供的名为<em class="italic">peek</em>的中间操作。它可以让我们透过<strong class="source-inline">流</strong>管道看到。主要是，<strong class="source-inline">peek（）</strong>应该对当前元件执行某种<em class="italic">非干扰</em>动作，并将元件转发到管道中的下一个操作。通常，此操作包括在控制台上打印有意义的消息。换句话说，<strong class="source-inline">peek（）</strong>对于调试与流和 lambda 表达式处理相关的问题是一个很好的选择。例如，假设我们有以下地址列表：</p>
			<pre>addresses.stream()
  .peek(p -&gt; System.out.println("\tstream(): " + p))
  .filter(s -&gt; s.startsWith("c"))
  .sorted()
  .peek(p -&gt; System.out.println("\tsorted(): " + p))
  .collect(Collectors.toList());</pre>
			<p>值得一提的是，即使可以使用<strong class="source-inline">peek（）</strong>来改变状态（修改流的数据源），它也代表<em class="italic">外观，但不要触摸</em>。在平行流管道的情况下，通过<strong class="source-inline">peek（）</strong>的变异状态可能会成为一个真正的问题，因为上游操作可以在任何时间和任何线程调用变异操作。因此，如果操作修改了共享状态，它将负责提供所需的同步。</p>
			<p>根据经验，在使用<strong class="source-inline">peek（）</strong>变异状态之前，请三思。另外，请注意，这种做法是开发人员争论的焦点，可以归类为不良做法，甚至是<a id="_idIndexMarker1662"/>反模式保护伞。</p>
			<h2 id="_idParaDest-422"><a id="_idTextAnchor428"/>编码挑战 10–惰性流</h2>
			<p><strong class="bold">问题</strong>：说<a id="_idIndexMarker1664"/>流是懒惰的<a id="_idIndexMarker1663"/>是什么意思？</p>
			<p><strong class="bold">解决方案</strong>：说流是惰性的意思是流定义了一个中间操作的管道，只有当管道遇到终端操作时才执行。此问题与本章<em class="italic">编码挑战 8</em>相关。</p>
			<h2 id="_idParaDest-423"><a id="_idTextAnchor429"/>编码挑战 11–功能接口与常规接口</h2>
			<p><strong class="bold">问题</strong>：功能接口和常规接口的主要区别是什么？</p>
			<p><strong class="bold">解决方案</strong>：<a id="_idIndexMarker1667"/>功能接口与常规接口的主要<a id="_idIndexMarker1666"/>区别在于，一个常规接口可以包含任意数量的抽象方法，而一个功能接口只能有一个抽象方法。</p>
			<p>您可以参考本书的<em class="italic">编码挑战 2</em>以获得更深入的理解。</p>
			<h2 id="_idParaDest-424"><a id="_idTextAnchor430"/>编码挑战 12–供应商与消费者</h2>
			<p><strong class="bold">问题</strong>：<strong class="source-inline">供应商</strong>和<strong class="source-inline">消费者</strong>之间的<a id="_idIndexMarker1669"/>主要<a id="_idIndexMarker1670"/>区别是什么？</p>
			<p><strong class="bold">解决方案</strong>：<strong class="source-inline">供应商</strong>和<strong class="source-inline">消费者</strong>是两个内置的功能接口。<strong class="source-inline">供应商</strong>充当工厂方法或<strong class="source-inline">新</strong>关键字。换句话说，<strong class="source-inline">供应商</strong>定义了一个名为<strong class="source-inline">get（）</strong>的方法，该方法不接受参数并返回一个类型为<strong class="source-inline">t</strong>的对象。因此，一个<strong class="source-inline">供应商</strong>对<em class="italic">提供</em>一些价值是有用的。</p>
			<p>另一方面，<strong class="source-inline">消费者</strong>定义了一个名为<strong class="source-inline">无效接受（T T）</strong>的方法。此方法接受单个参数并返回<strong class="source-inline">void</strong>。<strong class="source-inline">使用者</strong>接口<em class="italic">使用</em>给定值并对其应用一些操作。与其他功能接口不同，<strong class="source-inline">消费者</strong>可能会导致<em class="italic">副作用</em>。例如，<strong class="source-inline">消费者</strong>可以用作 setter 方法。</p>
			<h2 id="_idParaDest-425"><a id="_idTextAnchor431"/>编码挑战 13–谓词</h2>
			<p><strong class="bold">问题</strong>：什么是<strong class="source-inline">谓词</strong>？</p>
			<p><strong class="bold">解决方案</strong>：<strong class="source-inline">谓词</strong>是一个<a id="_idIndexMarker1672"/>内置功能接口，包含一个抽象方法，其签名为<strong class="source-inline">布尔测试（T 对象）</strong>：</p>
			<pre>@FunctionalInterface
public interface Predicate&lt;T&gt; {
  boolean test(T t);
  // default and static methods omitted for brevity
}</pre>
			<p><strong class="source-inline">test（）</strong>方法测试一个条件，如果满足该条件，则返回<strong class="source-inline">true</strong>，否则返回<strong class="source-inline">false</strong>。<strong class="source-inline">谓词</strong>的一个常见用法是与<strong class="source-inline">流&lt;T&gt;过滤器（谓词&lt;？超级 T&gt;谓词）</strong>方法结合使用，用于过滤流中不需要的元素。</p>
			<h2 id="_idParaDest-426"><a id="_idTextAnchor432"/>编码挑战 14–findFirst（）与 findAny（）的对比</h2>
			<p><strong class="bold">问题</strong>：<strong class="source-inline">findFirst（）</strong>和<strong class="source-inline">findAny（）</strong>之间的<a id="_idIndexMarker1674"/>主要<a id="_idIndexMarker1675"/>区别是什么？</p>
			<p><strong class="bold">解决方案</strong>：<strong class="source-inline">findFirst（）</strong>方法从流中返回第一个元素，特别适用于从序列中获取第一个元素。只要流具有定义的顺序，它就返回流中的第一个元素。如果没有遭遇顺序，则<strong class="source-inline">findFirst（）</strong>返回流中的任何元素。</p>
			<p>另一方面，<strong class="source-inline">findAny（）</strong>方法返回流中的任何元素。换句话说，它从流中返回任意（非确定性）元素。<strong class="source-inline">findAny（）</strong>方法忽略遇到的顺序，并且在非并行操作中，它很可能返回第一个元素，但这无法保证。为了最大限度地提高性能，在并行操作中无法可靠地确定结果。</p>
			<p>注意，根据<a id="_idIndexMarker1676"/>流的源和中间操作，流可能有也可能没有定义的遭遇顺序。</p>
			<h2 id="_idParaDest-427"><a id="_idTextAnchor433"/>编码挑战 15–将数组转换为流</h2>
			<p><strong class="bold">问题</strong><a id="_idIndexMarker1677"/>您如何将<a id="_idIndexMarker1678"/>数组转换为流？</p>
			<p><strong class="bold">解决方案</strong>：将一组对象转换成流至少可以通过三种方式完成，如下所示：</p>
			<ol>
				<li>第一种是通过<strong class="source-inline">阵列#stream（）</strong>：<pre>public static &lt;T&gt; Stream&lt;T&gt; toStream(T[] arr) {</pre><pre>  return Arrays.stream(arr);</pre><pre>}</pre></li>
				<li>第二，我们可以使用（）的：<pre xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops">public static &lt;T&gt; Stream&lt;T&gt; toStream(T[] arr) {        </pre><pre xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops">  return Stream.of(arr);</pre><pre xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops">}</pre>的<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">流</strong></li>
				<li>最后一种技术是通过<strong class="source-inline">列表【流】</strong>：</li>
			</ol>
			<pre>public static &lt;T&gt; Stream&lt;T&gt; toStream(T[] arr) {        
  return Arrays.asList(arr).stream();
}</pre>
			<p>将基元数组（例如，整数）转换为流至少可以通过两种方式完成，如下所示：</p>
			<ol>
				<li value="1">首先，通过<strong class="source-inline">阵列【流】</strong>：<pre>public static IntStream toStream(int[] arr) {       </pre><pre>  return Arrays.stream(arr);</pre><pre>}</pre></li>
				<li>其次，通过使用（）的<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">IntStream】</strong></li>
			</ol>
			<pre>public static IntStream toStream(int[] arr) {
  return IntStream.of(arr);
}</pre>
			<p>当然，对于<a id="_idIndexMarker1679"/>Long，您<a id="_idIndexMarker1680"/>可以使用<strong class="source-inline">LongStream</strong>，对于 Double，您可以使用<strong class="source-inline">DoubleStream</strong>。</p>
			<h2 id="_idParaDest-428"><a id="_idTextAnchor434"/>编码挑战 16–并行流</h2>
			<p><strong class="bold">问题</strong>：什么<a id="_idIndexMarker1681"/>是<a id="_idIndexMarker1682"/>并行流？</p>
			<p><strong class="bold">解决方案</strong>：并行流是可以使用多个线程并行执行的流。例如，您可能需要过滤 1000 万个整数的流，以查找小于某个值的整数。您可以使用并行流，而不是使用单个线程顺序遍历流。这意味着多个线程将在流的不同部分同时搜索这些整数，然后合并结果。</p>
			<h2 id="_idParaDest-429"><a id="_idTextAnchor435"/>编码挑战 17–方法参考</h2>
			<p><strong class="bold">问题</strong>：什么<a id="_idIndexMarker1683"/>是<a id="_idIndexMarker1684"/>方法参考？</p>
			<p><strong class="bold">解决方案</strong>：简而言之，<em class="italic">方法引用</em>是 lambda 表达式的快捷方式。主要来说，方法引用是一种用于按名称而不是通过描述如何调用方法来调用方法的技术。主要的好处是可读性。方法引用是通过将目标引用放在分隔符<strong class="source-inline">：</strong>之前来编写的，并且在其之后提供方法的名称。我们有以下参考资料：</p>
			<ul>
				<li>对静态方法的方法引用：<em class="italic">类</em>：<em class="italic">静态方法</em>（例如，<strong class="source-inline">数学：：max</strong>相当于<strong class="source-inline">数学.max（</strong><em class="italic">x</em><strong class="source-inline">、</strong><em class="italic">y</em><strong class="source-inline"/>）</li>
				<li>构造函数的方法引用：<em class="italic">类</em>：<em class="italic">新</em>（例如<strong class="source-inline">原子整数：：新</strong>相当于<strong class="source-inline">新原子整数（</strong><em class="italic">x</em><strong class="source-inline"/>）</li>
				<li>实例<em class="italic">对象</em>：<em class="italic">实例方法</em>（<strong class="source-inline">System.out:：println</strong>等价于<strong class="source-inline">System.out.println（</strong><em class="italic">foo</em><strong class="source-inline"/>的方法引用实例方法</li>
				<li>类类型<em class="italic">类</em>：<em class="italic">实例方法</em>（<strong class="source-inline">字符串：：长度</strong>相当于<strong class="source-inline">str.length（）</strong>的实例方法引用）</li>
			</ul>
			<h2 id="_idParaDest-430"><a id="_idTextAnchor436"/>编码挑战 18–默认方法</h2>
			<p><strong class="bold">问题</strong>：什么是<a id="_idIndexMarker1685"/>默认<a id="_idIndexMarker1686"/>方法？</p>
			<p><strong class="bold">解决方案</strong>：Java 8 中增加了默认方法，主要是为了提供对接口的支持，使其能够超越抽象契约（即仅包含抽象方法）而发展。对于编写库并希望以兼容方式发展 API 的人来说，此功能非常有用。通过默认方法，可以在不中断现有实现的情况下丰富接口。</p>
			<p>默认方法直接在接口中实现，由<strong class="source-inline">default</strong>关键字识别。例如，下面的接口定义了一个名为<strong class="source-inline">area（）</strong>的抽象方法和一个名为<strong class="source-inline">Permission（）</strong>的默认方法：</p>
			<pre>public interface Polygon {
  public double area();
  default double perimeter(double... segments) {
    return Arrays.stream(segments)
      .sum();
  }
}</pre>
			<p>由于<strong class="source-inline">多边形</strong>具有<a id="_idIndexMarker1687"/>单一抽象方法，因此它也是一个功能接口。因此，可以用<strong class="source-inline">@functionanterface</strong>注释<a id="_idIndexMarker1688"/>。</p>
			<h2 id="_idParaDest-431"><a id="_idTextAnchor437"/>编码挑战 19–迭代器与拆分器</h2>
			<p><strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">问题</strong>：<a xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" id="_idIndexMarker1690"/>迭代器和<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">拆分器</strong>之间的<a xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" id="_idIndexMarker1691"/>主要区别是什么？</p>
			<p><strong class="bold">解决方案</strong>：<strong class="source-inline">集合</strong>API 创建了<strong class="source-inline">迭代器</strong>，而<strong class="source-inline">流</strong>API 创建了<strong class="source-inline">拆分器</strong>。</p>
			<p>通过分析它们的名称，我们注意到<em class="italic">拆分器</em>=<em class="italic">拆分表迭代器</em>。因此，<strong class="source-inline">拆分器</strong>可以拆分给定的源，也可以对其进行迭代。并行处理需要拆分。换句话说，<strong class="source-inline">迭代器</strong>可以顺序迭代<strong class="source-inline">集合</strong>中的元素，而<strong class="source-inline">拆分器</strong>可以并行或顺序迭代流中的元素。</p>
			<p><strong class="source-inline">迭代器</strong>只能通过<strong class="source-inline">hasNext（）</strong>/<strong class="source-inline">next（）</strong>遍历集合的元素，因为它没有大小。另一方面，<strong class="source-inline">拆分器</strong>可以通过<strong class="source-inline">estimateSize（）</strong>或<strong class="source-inline">getExactSizeIfKnown（）</strong>精确地近似提供集合的大小。</p>
			<p><strong class="source-inline">拆分器</strong>可以使用多个标志在内部禁用不必要的操作（例如，<strong class="source-inline">并发</strong>、<strong class="source-inline">不同</strong>、<strong class="source-inline">不可变</strong>）。<strong class="source-inline">迭代器</strong>没有这样的标志。</p>
			<p>最后，您可以围绕<strong class="source-inline">迭代器</strong>创建<strong class="source-inline">拆分器</strong>，如下所示：</p>
			<pre>Spliterators.spliteratorUnknownSize(
  your_Iterator, your_Properties);</pre>
			<p>在<em class="italic">Java 编码问题</em>（<a href="https://www.amazon.com/gp/product/B07Y9BPV4W/">一书中 https://www.amazon.com/gp/product/B07Y9BPV4W/ </a>），您可以找到有关此主题的更多详细信息，包括编写自定义<strong class="source-inline">拆分器</strong>的完整指南。</p>
			<h2 id="_idParaDest-432"><a id="_idTextAnchor438"/>编码挑战 20–可选</h2>
			<p><strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">问题</strong>：<a xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" id="_idIndexMarker1693"/>选修课的<a xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" id="_idIndexMarker1692"/>是什么？</p>
			<p><strong class="bold">解决方案</strong>：受 Haskell 和 Scala 的启发，在 Java 8 中引入了<strong class="source-inline">可选</strong>类，主要目的是缓解/避免<strong class="source-inline">NullPointerException</strong>。Java 语言架构师 Brian Goetz 的定义如下：</p>
			<p><em class="italic">Optional 旨在为库方法返回类型提供一种有限的机制，在这种情况下，需要有一种明确的方式来表示无结果，并且使用 null 表示这样的结果极有可能导致错误。</em></p>
			<p>简而言之，您可以将<strong class="source-inline">可选</strong>视为包含值或为空的单值容器。例如，空的<strong class="source-inline">可选</strong>如下所示：</p>
			<pre>Optional&lt;User&gt; userOptional = Optional.empty();</pre>
			<p>非空的<strong class="source-inline">可选</strong>如下所示：</p>
			<pre>User user = new User();
Optional&lt;User&gt; userOptional = Optional.of(user);</pre>
			<p>在<em class="italic">Java 编码问题</em>（<a href="https://www.amazon.com/gp/product/B07Y9BPV4W/">中 https://www.amazon.com/gp/product/B07Y9BPV4W/ </a>），您可以找到一个完整的章节，专门介绍使用<strong class="source-inline">可选</strong>的最佳实践。这是任何 Java 开发人员都必须阅读的一章。</p>
			<h2 id="_idParaDest-433"><a id="_idTextAnchor439"/>编码挑战 21–字符串：：valueOf</h2>
			<p><strong class="bold">问题</strong>：<strong class="source-inline">字符串：：</strong>值的<a id="_idIndexMarker1694"/>是什么意思？</p>
			<p><strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">解决方案</strong>：<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">字符串：：</strong>的值是<a xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" id="_idIndexMarker1695"/>对<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">字符串</strong>类的静态方法的<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="source-inline">值的方法引用。考虑阅读 Ty9 T9 编码挑战 17 Ty10T10 以及关于这方面的更多信息。</strong></p>
			<h1 id="_idParaDest-434"><a id="_idTextAnchor440"/>总结</h1>
			<p>在本章中，我们讨论了几个有关 Java 函数式编程的热门话题。虽然这个主题相当广泛，有很多专门的书籍，但这里所涉及的问题应该足以通过一次定期的 Java 访谈，该访谈涵盖 Java 8 语言的主要功能。</p>
			<p>在下一章中，我们将讨论与缩放相关的问题。</p>
		
	
</body>
</html>