<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemalocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css"/>

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style>

</head>
<body>
<p id="_idParaDest-180" class="chapter-number"><em class="italic"><a id="_idTextAnchor181"/>第 9 章</em>：</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/>位操作</h1>
			<p>本章涵盖了位操作的最重要方面，当它成为技术面试的一部分时，您应该了解这些方面。这些问题在面试中经常遇到，而且并不容易。人类的大脑不是设计用来操纵比特的；计算机就是为此而设计的。这意味着操作 BIT 相当困难，并且极易出错。因此，建议始终对每个位操作进行双重检查。</p>
			<p>有两件事对于掌握这类问题非常重要，如下所示：</p>
			<ul>
				<li>你必须很好地理解位的理论（例如，位运算符）</li>
				<li>您必须尽可能多地练习位操作</li>
			</ul>
			<p>在处理以下主题时，我们需要牢记这两种说法：</p>
			<ul>
				<li>理解位操作</li>
				<li>编码挑战</li>
			</ul>
			<p>让我们从理论部分开始。强烈建议您从本节中提取图表。在本章的第二部分，他们将是你最好的朋友。</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor183"/>技术要求</h1>
			<p>本章中的所有代码都可以在 GitHub 的<a href="https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter09">上找到 https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter09 </a>。</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>简言之，钻头操纵</h1>
			<p>在 Java 中，我们可以操作以下数据类型的<a id="_idIndexMarker571"/>位：<strong class="source-inline">字节</strong>（8 位）、<strong class="source-inline">短</strong>（16 位）、<strong class="source-inline">int</strong>（32 位）、<strong class="source-inline">长</strong>（64 位）和<strong class="source-inline">字符</strong>（16 位）。</p>
			<p>例如，让我们使用正数 51。在这种情况下，我们有以下声明：</p>
			<ul>
				<li>51 的二进制表示是 110011。</li>
				<li>因为 51 是一个<strong class="source-inline">int</strong>，所以它被表示为一个 32 位的值；也就是说，1 或 0 的 32 个值（从 0 到 31）。</li>
				<li>110011 左侧的所有位置实际上都用零填充，总共高达 32 位。</li>
				<li>这意味着 51 是 00000000 00000000 00000000 00110011（我们将其呈现为 110011，因为显示二进制表示通常不需要<a id="_idIndexMarker572"/>额外的零）。</li>
			</ul>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor185"/>获取 Java 整数的二进制表示</h2>
			<p>我们怎么知道 110011 是 51 的二进制表示？我们如何计算 112 或任何其他 Java 整数的二进制表示？一种简单的方法是将数字连续除以 2，直到<a id="_idIndexMarker574"/>商小于 1，然后将余数解释为 0 或 1。0 的余数解释为 0，而大于 0 的余数解释为 1。例如，让我们将其应用于 51：</p>
			<ol>
				<li>51/2=25.5 的商为 25，余数为 5-&gt;存储 1</li>
				<li>25/2=12.5 的商为 12，余数为 5-&gt;存储 1</li>
				<li>12/2=6 的商为 6，余数为 0-&gt;存储 0</li>
				<li>6/2=3 的商为 3，余数为 0-&gt;存储 0</li>
				<li>3/2=1.5 的商为 1，余数为 5-&gt;存储 1</li>
				<li>1/2=0.5 的商为 0，余数为 5-&gt;存储 1</li>
			</ol>
			<p>因此，我们存储了 110011，这是 51 的二进制表示。其余 26 位为零（00000000000000000000000000<strong class="bold">110011</strong>。相反的过程从右到左开始，在位等于 1 的情况下增加 2 的幂。这里，51=20+21+24+25。下图可以帮助我们理解这一点：</p>
			<p><img src="img/Figure_9.1_B15403.jpg" alt="Figure 9.1 – Binary to decimal (32-bit integer) "/></p>
			
			<p class="figure-caption">图 9.1–二进制到十进制（32 位整数）</p>
			<p>在 Java 中，我们可以通过<strong class="source-inline">整数#toString（int i，int 基数）</strong>或<strong class="source-inline">整数#toBinaryString（int i）</strong>快速看到数字的二进制表示。例如，基数为 2 表示二进制：</p>
			<pre>// 110011
System.out.println("Binary: " + Integer.toString(51, 2));
System.out.println("Binary: " + Integer.toBinaryString(51));</pre>
			<p>反向过程（从二进制到十进制）可通过<strong class="source-inline">整数#parseInt（字符串 nr，int 基数）</strong>获得：</p>
			<pre>System.out.println("Decimal: " 
  + Integer.parseInt("110011", 2));  //51</pre>
			<p>接下来，让我们处理按位<a id="_idIndexMarker575"/>运算符。这些运算符允许我们<a id="_idIndexMarker576"/>操作位，因此理解它们非常重要。</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor186"/>位运算符</h2>
			<p>操作位涉及<a id="_idIndexMarker577"/>几个运算符。这些经营者如下：</p>
			<ul>
				<li><strong class="bold">一元逐位补码运算符[~]</strong>：作为<a id="_idIndexMarker578"/>一元运算符，此<a id="_idIndexMarker579"/>运算符需要一个位于数字之前的操作数。此<a id="_idIndexMarker580"/>运算符获取数字的每一位并翻转其值，因此 1 变为 0，反之亦然；例如，5=101，~5=010。</li>
				<li><strong class="bold">按位 AND[&amp;</strong>：此运算符需要两个操作数，且位于两个数字之间。此运算符<a id="_idIndexMarker581"/>逐个比较两个数字<a id="_idIndexMarker582"/>的位。充当逻辑 AND（&amp;&amp;），即仅当比较位等于 1 时才返回 1；例如，5=101，7=111，5&amp;7=101&amp;111=101=5。</li>
				<li><strong class="bold">按位 OR[</strong><strong class="bold"/><strong class="bold"/>：此运算符<a id="_idIndexMarker583"/>需要两个操作数，且位于两个<a id="_idIndexMarker584"/>数之间。此运算符逐个比较两个数字的位<a id="_idIndexMarker585"/>。它充当逻辑 OR（| |），这意味着如果至少一个比较位为 1（或两者都为 1），它将返回 1。否则返回 0；例如，5=101，7=111，5 | 7=101 | 111=111=7。</li>
				<li><strong class="bold">位异或（XOR）</strong><strong class="bold">^</strong><strong class="bold"/>：此运算符<a id="_idIndexMarker586"/>需要两个操作数，且位于两个数字之间。此运算符<a id="_idIndexMarker587"/>逐个比较两个数字的位。仅当比较的位具有不同的值时，它才会返回 1。否则返回 0；例如，5=101，7=111，5^7=101 | 111=010=2。</li>
			</ul>
			<p>下图是一个方便的工具，当您需要处理 BIT 时，应该将其放在旁边。基本上，它总结了位运算符的工作原理（我建议您在<a id="_idIndexMarker588"/>阅读<em class="italic">编码挑战</em>部分时，将此表关闭）：</p>
			<p><img src="img/Figure_9.2_B15403.jpg" alt="Figure 9.2 – Bitwise operators "/></p>
			
			<p class="figure-caption">图 9.2–按位运算符</p>
			<p>此外，下图显示了一些对操作位非常有用的提示。0s 符号<a id="_idIndexMarker589"/>表示一系列的零，而 1s 符号表示一系列的一：</p>
			<p><img src="img/Figure_9.3_B15403.jpg" alt="Figure 9.3 – Bitwise tips "/></p>
			
			<p class="figure-caption">图 9.3–按位提示</p>
			<p>慢慢来，探索一下这些技巧。拿一张纸和一支笔，把它们逐一检查一遍。此外，还可以尝试发现其他提示。</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>位移位运算符</h2>
			<p>在处理位时，移位是一种常见的<a id="_idIndexMarker591"/>操作。在这里，我们有<strong class="bold">符号左移位</strong>&lt;&lt;、<strong class="bold">符号右移位</strong>&gt;&gt;、<strong class="bold">符号右移位</strong>&gt;&gt;&gt;。移位<a id="_idIndexMarker592"/>用于<strong class="source-inline">字节</strong>（8 位）、<strong class="source-inline">短</strong>（16 位）、<strong class="source-inline">int</strong>（32 位）、<strong class="source-inline">长</strong>（64 位）和<strong class="source-inline">字符</strong>（16 位）；位移位运算符不会抛出异常。</p>
			<h3 id="sigil_toc_id_510">有符号左移[&lt;</h3>
			<p>有符号左移位，或简称左移位，需要两个操作数。左移位获取第一个操作数（左侧操作数）的位模式，并将其向左移位第二个<a id="_idIndexMarker593"/>操作数（右侧操作数）给出的位置数。</p>
			<p>例如，以下是将 23 向左移动 3 个位置，23&lt;&lt;3 的结果：</p>
			<p><img src="img/Figure_9.4_B15403.jpg" alt="Figure 9.4 – Signed Left Shift "/></p>
			
			<p class="figure-caption">图 9.4–有符号左移</p>
			<p>如我们所见，整数 12（10111）的每一位<a id="_idIndexMarker594"/>向左移动 3 个位置，而向右的所有位置都自动用零填充。</p>
			<p class="callout-heading">重要提示</p>
			<p class="callout">以下是两个在某些情况下非常有用的提示：</p>
			<p class="callout">1.将一个数字左移<em class="italic">n</em>位相当于乘以 2n（例如，23&lt;&lt;3 等于 184，相当于 184=23*23）。</p>
			<p class="callout">2.要移动的位置数自动减少到模 32；也就是说，23&lt;&lt;35 等于 23&lt;</p>
			<h3 id="sigil_toc_id_511">Java 中的负整数</h3>
			<p>首先，重要的是要记住，二进制表示本身并不能告诉我们一个数字是否为负数。这意味着计算机<a id="_idIndexMarker596"/>需要一些表示负数的规则。通常情况下，计算机以所谓的<em class="italic">二的补码</em>表示形式存储整数。Java 也使用<a id="_idIndexMarker597"/>这种表示。</p>
			<p>简言之，<em class="italic">2 的补码</em>表示采用负数的二进制表示，并翻转（否定）其所有位。之后，它加 1 并将其追加到位号的左侧。如果最左边的位为 1，则数字为负数。否则，它是积极的。</p>
			<p>让我们以 4 位整数，-5 为例。符号有一位，值有三位。我们知道 5（正数）表示为 101，而-5（负数）表示为<strong class="bold">1</strong>011。这是通过翻转 101 使其变为 010，添加 1 以获得 011，并将其附加到符号位（<strong class="bold">1</strong>的左侧以获得<strong class="bold">1</strong>011。粗体的 1 是符号位。我们有一位表示符号，三位表示值。</p>
			<p>另一种方法是<a id="_idIndexMarker598"/>知道作为<em class="italic">n</em>位<a id="_idIndexMarker599"/>数的<em class="italic">-Q</em>（负<em class="italic">Q</em>）的二进制表示是通过将 1 与 2n-1–<em class="italic">Q</em>串联得到的。</p>
			<h3 id="sigil_toc_id_512">签名右移[&gt;&gt;]</h3>
			<p>有符号右移或算术右移[&gt;&gt;]接受两个操作数。有符号右移位获取<a id="_idIndexMarker600"/>第一个操作数（左侧操作数）的位模式，并通过保留符号将其向右移位第二个操作数（右侧操作数）给定的位置数。</p>
			<p>例如，<a id="_idIndexMarker601"/>以下是-75&gt;&gt;1 的结果（-75 是一个 8 位整数，其中符号位是<strong class="bold">最高有效位</strong>（<strong class="bold">MSB</strong>）：</p>
			<p><img src="img/Figure_9.5_B15403.jpg" alt="Figure 9.5 – Signed Right Shift "/></p>
			
			<p class="figure-caption">图 9.5–有符号右移</p>
			<p>我们可以看到，-75（10110101）的每一位都向右移动了 1 个位置（注意，<strong class="bold">最低有效位</strong>（<strong class="bold">LSB</strong>）已更改），并且<a id="_idIndexMarker602"/>位符号被保留。</p>
			<p class="callout-heading">重要提示</p>
			<p class="callout">以下是在某些场景中非常有用的三个提示：</p>
			<p class="callout">将数字右移<em class="italic">n</em>位置相当于除以 2n（例如，24&gt;&gt;3 等于 3，相当于 3=24/23）。</p>
			<p class="callout">要移动的位置数自动减少到模 32；也就是说，23&gt;&gt;35 相当于 23&gt;&gt;（35%32），这相当于 23&gt;&gt;3。</p>
			<p class="callout">二进制（有符号）中所有 1 的序列表示十进制形式的-1。</p>
			<h3 id="sigil_toc_id_513">无符号右移[&gt;&gt;&gt;]</h3>
			<p>无符号右移位，或<a id="_idIndexMarker603"/>逻辑右移位[&gt;&gt;【T3]，接受两个操作数。无符号右移位获取第一个操作数（左侧操作数）的位模式，并按第二个操作数（右侧操作数）给定的位置数将其向右移位。MSB 设置为 0。这意味着，对于正数，有符号和无符号右移返回相同的结果，而负数总是变为正数。</p>
			<p>例如，<a id="_idIndexMarker604"/>以下是-75&gt;&gt;&gt;1 的结果（-75 是一个 8 位整数，其中符号位是 MSB）：</p>
			<p><img src="img/Figure_9.6_B15403.jpg" alt="Figure 9.6 – Unsigned Right Shift "/></p>
			
			<p class="figure-caption">图 9.6–无符号右移</p>
			<p class="callout-heading">重要提示</p>
			<p class="callout">要移动的位置数自动减少到模 32；也就是说，23&gt;&gt;&gt;35 相当于 23&gt;&gt;（35%32），这相当于 23&gt;&gt;&gt;3。</p>
			<p>现在您已经了解了位移位运算符是什么，是时候解决更多的技巧和技巧了。</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor188"/>小窍门</h2>
			<p>操作 bits 涉及到<a id="_idIndexMarker606"/>与 bits 操作员合作时的高超技能，并了解一些技巧和窍门。您已经在本章前面看到了一些提示。现在，让我们再添加一些要点列表：</p>
			<ul>
				<li>如果我们将一个数与其自身进行偶数次异或运算，那么结果是 0（<em class="italic">x^x=</em>0；<em class="italic">x^x^x=</em>（<em class="italic">x^x</em>）<em class="italic"/>（<em class="italic">x^x</em><em class="italic">=</em>0^0=0）。</li>
				<li>如果我们将一个数与其自身进行异或运算奇数次，那么结果就是这个数（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x^x^x=</em>（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x^</em>（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x^x</em>））<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">=</em>（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x^</em>0】<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">=x；x^x^x^x=</em>（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x^</em>（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x^<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">）</em>（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x^x</em>）<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">=</em>（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x^</em>0^0】<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">=x</em>）。</em></li>
				<li>我们可以用<em class="italic">p</em>&gt;0、<em class="italic">q</em>&gt;0 计算表达式<em class="italic">p%q</em>的值，其中<em class="italic">q</em>是 2 的幂；即<em class="italic">p</em>&amp;（<em class="italic">q</em>-1）。您可以看到的一个简单应用程序是<em class="italic">ComputeModuloDivision</em>。</li>
				<li>对于给定的正整数<em class="italic">p</em>，如果（<em class="italic">p</em>&amp;1）！=0，即使（<em class="italic">p</em>&amp;1）==0，我们说它是奇数。您可以看到的一个简单应用程序是<em class="italic">奇偶</em>。</li>
				<li>对于两个给定的<a id="_idIndexMarker607"/>数<em class="italic">p</em>和<em class="italic">q</em>，我们可以说<em class="italic">p</em>等于<em class="italic">q</em>if（（<em class="italic">p</em>^<em class="italic">q</em>==0）。您可以看到的一个简单应用程序是<em class="italic">CheckEquality</em>。</li>
				<li>对于两个给定的整数<em class="italic">p</em>和<em class="italic">q</em>，我们可以通过<em class="italic">p</em>=<em class="italic">p</em>^<em class="italic">q</em>^（<em class="italic">q</em>=<em class="italic">p</em>进行交换。您可以看到的一个简单应用程序是<em class="italic">SwapTwoIntegers</em>。</li>
			</ul>
			<p>好的，现在是解决一些编码挑战的时候了。</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor189"/>编码挑战</h1>
			<p>在接下来的 25 个编码<a id="_idIndexMarker608"/>挑战中，我们将利用位操作的不同方面。因为这类问题真的是脑筋急转弯，所以在面试中它们是首选。理解一段处理比特的代码不是一件容易的事情，所以花点时间仔细分析每个问题和代码片段。这是获得一些模式和模板以解决此类问题的唯一方法。</p>
			<p>下图包含一组四位掩码，这些掩码在工具带中很重要：</p>
			<p><img src="img/Figure_9.7_B15403.jpg" alt="Figure 9.7 – Bit-masks "/></p>
			
			<p class="figure-caption">图 9.7–位掩码</p>
			<p>它们对于解决需要处理位的各种问题非常有用。</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/>编码挑战 1–获取位值</h2>
			<p>问题 T1：考虑到 T2 T2：32 位整数，AUT T3。编写一段<a id="_idIndexMarker611"/>代码，返回给定位置<em class="italic">k</em>处<em class="italic">n</em>的位值。</p>
			<p>Po.T0.溶液：To T2：n，T2，T3＝423。其二进制表示为 1<strong class="bold">1</strong>0100111。我们怎么能说出位置<em class="italic">k</em>=7 的位的值是多少（位置 7 的粗体位的值为 1）？解决方案包括通过<em class="italic">k</em>位置（<em class="italic">n</em>&gt;&gt;<em class="italic">k</em>位置）将给定数字右移。这样，<em class="italic">k</em>第位成为位置 0 处的位（1<strong class="bold">1</strong>0100111&gt;&gt;7=00000001<strong class="bold">1</strong>。接下来，我们可以将 AND[&amp;运算符应用为 1&amp;（<em class="italic">n</em>T30]&gt;<em class="italic">k</em>：</p>
			<p><img src="img/coding_challenge_1_%28Fig_9.1%29.jpg" alt="Figure 9.8 Binary representation "/></p>
			
			<p class="figure-caption">图 9.8–二进制表示法</p>
			<p>如果位置 0 处的位值为 1，则 AND[&amp;]运算符将返回 1；否则，它将返回 0。在代码方面，我们有以下内容：</p>
			<pre>public static char getValue(int n, int k) {
  int result = n &amp; (1 &lt;&lt; k);
  if (result == 0) {
    return '0';
  }
  return '1';
}</pre>
			<p>另一种方法是将表达式 1&amp;（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">n</em>&gt;&gt;<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">k</em>替换为表达式<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">n</em>&amp;（1&lt;&lt;<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">k</em>）。慢慢来，试着解剖它。完整的应用程序称为<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">GetBitValue</em>。</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>编码挑战 2–设置位值</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong>、<strong class="bold">微软</strong>、<strong class="bold">Flipkart</strong></p>
			<p>问题 T1A:考虑一个 32 位整数，AUT T2。编写一段代码，将给定位置<em class="italic">n</em>的位<a id="_idIndexMarker613"/>值<em class="italic">k</em>设置为 0 或 1。</p>
			<p>Po.T0.溶液：To T2：n，T2，T3＝423。其二进制表示为 1<strong class="bold">1</strong>0100111。我们如何将位从位置<em class="italic">k</em>=7（现在为 1）设置为 0？将逐位运算符表放在我们面前有助于我们看到 AND[&amp;运算符是唯一具有两个操作数的运算符，允许我们写入 1&amp;0=0 或第 7 位&amp;0=0。此外，我们有 1&amp;1=1、0&amp;1=0 和 0&amp;0=0，因此我们可以将位掩码设为 1…101111111 并写入以下内容：</p>
			<p><img src="img/coding_challenge_2_%28Fig_9.9%29.jpg" alt="Figure 9.9 Binary representation "/></p>
			
			<p class="figure-caption">图 9.9–二进制表示法</p>
			<p>这正是我们想要的。我们想把第 7 位从 1 变成 0，剩下的保持不变。但是我们如何获得 1…101111。。。面具嗯，有两个小面具你需要知道。首先，一个位掩码，它有一个 1，其余的是 0（10000…）。这可以通过将 1 左移<em class="italic">k</em>位置来获得（例如，位掩码 1000 可以获得为 1&lt;&lt;3，但如果我们将其表示为 32 位掩码，则获得 00000000000000000000000<strong class="bold">1000</strong>。另一个位掩码包含 0，其余为 1s（01111…）。这可以通过将一元逐位补码运算符[~]应用于位掩码 10000。。。。（例如，~（1000）=0111，但如果我们将其表示为 32 位掩码，则得到 111111111111111111111<strong class="bold">0111</strong>。所以，我们可以得到 1…101111。。。位掩码为（1&lt;&lt;<em class="italic">k</em>。最后，我们需要做的就是使用 AND[&amp;操作符，如下代码所示：</p>
			<pre>public static int setValueTo0(int n, int k) {       
  return n &amp; ~(1 &lt;&lt; k);
}</pre>
			<p>如果我们取<em class="italic">k</em>=3、4 或 6，那么我们得到 0&amp;0=0。</p>
			<p>让我们考虑一下，t0＝n1，t1＝295。其二进制表示为 1<strong class="bold">0</strong>0100111。我们如何将位从位置<em class="italic">k</em>=7（现在为 0）设置为 1？将按位运算符表放在前面有助于我们看到 OR[|]和 XOR[^]运算符是具有两个操作数的运算符，这两个操作数允许我们分别写入 0 | 1=1 或 0^1=1。</p>
			<p>或者，我们可以写出第七个| 1=1 和第七个^1=1。</p>
			<p>通过进一步<a id="_idIndexMarker614"/>一步，我们可以看到在 OR[|]运算符的情况下，我们可以编写以下内容：</p>
			<p>1 | 1=1，而在<a id="_idIndexMarker615"/>XOR[^]运算符的情况下，我们写 1^1=0。</p>
			<p>因为我们想要将第 7 位值从 0 变为 1，所以我们可以使用这两个运算符中的任何一个。然而，如果<em class="italic">k</em>表示初始值为 1 的位，那么 1^1=0 不再对我们有帮助，而 1|1=1 正是我们想要的。所以在这里，我们应该使用 10000。。。位掩码，如下所示：</p>
			<p><img src="img/coding_challenge_2_%28Fig_9.10%29.jpg" alt="Figure 9.10 Binary representation "/></p>
			
			<p class="figure-caption">图 9.10–二进制表示法</p>
			<p>在代码方面，我们有以下内容：</p>
			<pre>public static int setValueTo1(int n, int k) {       
  return n | (1 &lt;&lt; k);
}</pre>
			<p>如果我们取<em class="italic">k</em>=0、1、2、5 或 8，那么我们得到 1|1=1。</p>
			<p>完整的应用程序称为<em class="italic">SetBitValue</em>。</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>编码挑战 3–清除位</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong></p>
			<p>问题 T1：考虑一个 32 位的 To2 T2 整数。编写一段代码<a id="_idIndexMarker617"/>，用于清除 MSB 和给定<em class="italic">k</em>之间的<em class="italic">n</em>（将其值设置为 0）位。</p>
			<p>Po.T0.溶液：To T2：n，T2，T3＝423。其二进制表示为<strong class="bold">110</strong>100111。我们如何清除 MSB 和位置<em class="italic">k</em>=6 之间的位，以便有 110 位？前面有位运算符表有助于我们看到需要 0001111 类型的位掩码。让我们看看如果在<em class="italic">n</em>和该位掩码之间应用 AND[&amp;运算符会发生什么：</p>
			<p><img src="img/coding_chh_3_%28Fig_9.11%29.jpg" alt="Figure 9.11 Binary representation "/></p>
			
			<p class="figure-caption">图 9.11–二进制表示法</p>
			<p>因此，我们清除了 MSB 和<em class="italic">k</em>=6 之间的<a id="_idIndexMarker618"/>位。一般来说，我们需要一个位掩码，它在 MSB 和<em class="italic">k</em>（含）之间包含 0，在<em class="italic">k</em>（不含）和 LSB 之间包含 1。我们可以通过将 1 的位左移到<em class="italic">k</em>位置（例如，对于<em class="italic">k</em>=6，我们得到 1000000）并减去 1 来实现这一点。通过这种<a id="_idIndexMarker619"/>方式，我们获得所需的位掩码 011111。因此，在代码方面，我们有以下内容：</p>
			<pre>public static int clearFromMsb(int n, int k) {        
  return n &amp; ((1 &lt;&lt; k) - 1);
}</pre>
			<p>清除给定的<em class="italic">k</em>和 LSB 之间的位如何？让我向您展示代码：</p>
			<pre>public static int clearFromPosition(int n, int k) {        
  return n &amp; ~((1 &lt;&lt; k) - 1);
}</pre>
			<p>现在，慢慢来，仔细分析这个解决方案。此外，我们可以用以下溶液替换此溶液：<em class="italic">n</em>&amp;（-1&lt;&lt;（<em class="italic">k</em>+1））。</p>
			<p>同样，使用纸和笔，一步一步地进行。完整的应用程序称为<em class="italic">ClearBits</em>。</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/>编码挑战 4–在纸上对二进制文件求和</h2>
			<p>问题 T1：考虑几个 T2 的正 32 位整数。拿一支笔和一些纸，告诉我你如何总结他们的二进制表示法。</p>
			<p><strong class="bold">注意</strong>：这不是一个编码挑战，但了解它很重要。</p>
			<p><strong class="bold">解决方案</strong>：二进制数求和有几种方法。一种简单的方法是执行以下操作：</p>
			<ol>
				<li value="1">对当前列的所有位求和（第一列是 LSB 的列）。</li>
				<li>将结果转换为二进制（例如，通过连续除以 2）。</li>
				<li>保留最右边的位作为结果。</li>
				<li>将剩余的位带入其余列（每列一位）。</li>
				<li>转到下一列并从<em class="italic">步骤 1</em>重复。</li>
			</ol>
			<p>举个例子就能说明问题。让我们加上 1（1）+9（1001）+29（011101）+124（1111100）=163（10100011）。</p>
			<p>下图显示了这些数字相加的结果：</p>
			<p><img src="img/Figure_9.12_B15403.jpg" alt="Figure 9.12 – Summing binary numbers "/></p>
			
			<p class="figure-caption">图 9.12–二进制数求和</p>
			<p>现在，让我们一步一步地来看看这个（粗体部分被携带）：</p>
			<ul>
				<li>列 0 上的总和位：1+1+1+0=3=<strong class="bold">1</strong>1</li>
				<li>第 1 列上的总和位：<strong class="bold">1</strong>+0+0+0=1=1</li>
				<li>第 2 列上的和位：0+1+1=2=<strong class="bold">1</strong>0</li>
				<li>第 3 列上的总和位：<strong class="bold">1</strong>+1+1+1=4=<strong class="bold">10</strong>0</li>
				<li>第 4 列上的总和位：<strong class="bold">0</strong>+1+1=2=<strong class="bold">1</strong>0</li>
				<li>第 5 列和位：<strong class="bold">1</strong>+<strong class="bold">1</strong>+0+1=3=<strong class="bold">1</strong>1</li>
				<li>第 6 列上的总和位：<strong class="bold">1</strong>+1=2=<strong class="bold">1</strong>0</li>
				<li>第 7 列和位：<strong class="bold">1</strong>=1=1</li>
			</ul>
			<p>所以，<a id="_idIndexMarker621"/>的结果是 10100011。</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor194"/>编码挑战 5–对代码中的二进制文件求和</h2>
			<p>问题 T1：考虑两个 32 位整数，即 T2，Q，T3，3，P 4。编写一段代码，使用二进制的<a id="_idIndexMarker622"/>表示法计算<em class="italic">q</em>+<em class="italic">p</em>。</p>
			<p><strong class="bold">解决方案</strong>：我们可以尝试前面编码挑战中提出的算法的<a id="_idIndexMarker623"/>实现，或者我们可以尝试另一种方法。该方法引入了一个方程，该方程有助于了解：</p>
			<p><img src="img/coding_ch_5%2C_image_1.jpg" alt=""/></p>
			
			<p>注意存在 AND[&amp;]和 XOR[^]位运算符。如果我们用<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">和</em>表示<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">p</em>&amp;<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>，用<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">xor</em>表示<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">p</em><em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>，那么我们可以这样写：</p>
			<p><img src="img/Coding_ch_5%2C_image_2.jpg" alt=""/></p>
			
			<p>如果<em class="italic">p</em>和<em class="italic">q</em>没有公共位，那么我们可以将其简化为以下内容：</p>
			<p><img src="img/coding_ch_5%2C_image_3.jpg" alt=""/></p>
			
			<p>例如，如果<em class="italic">p</em>=1010 且<em class="italic">q</em>=0101，则<em class="italic">p</em>&amp;<em class="italic">q</em>=0000。由于 2*0000=0，我们仍然使用<em class="italic">p</em>+<em class="italic">q</em>=<em class="italic">xor</em>或<em class="italic">p</em>+<em class="italic">q</em>=1111。</p>
			<p>但是，如果<em class="italic">p</em>和<em class="italic">q</em>有公共位，那么我们必须处理<em class="italic">和</em>以及<em class="italic">xor</em>的相加。因此，如果我们强制<em class="italic">和</em>表达式返回 0，则<em class="italic">和+xor</em>可以解决。这可以通过递归实现。</p>
			<p>通过递归，我们可以将递归的第一步写成：</p>
			<p><img src="img/Coding_ch_5%2C_image_4.jpg" alt=""/></p>
			
			<p>或者，如果我们表示<em class="italic">和</em>{1}=2*<em class="italic">和</em>&amp;<em class="italic">xor</em>和<em class="italic">xor</em>{1}=2*<em class="italic">和</em>^<em class="italic">xor</em>，其中{1}表示递归的一步，那么我们可以这样写：</p>
			<p><img src="img/Coding_ch_5%2C_image_5.jpg" alt=""/></p>
			
			<p>但是这个<a id="_idIndexMarker624"/>递归什么时候停止？那么当<em class="italic">和</em>{<em class="italic">n</em>表达式中的两个位序列（<em class="italic">p</em>和<em class="italic">q</em>的交集返回 0 时，应该停止<a id="_idIndexMarker625"/>。因此，在这里，我们强制<em class="italic">和</em>表达式返回 0。</p>
			<p>在代码方面，我们有以下内容：</p>
			<pre>public static int sum(int q, int p) {
  int xor;
  int and;
  int t;
  and = q &amp; p;
  xor = q ^ p;
  // force 'and' to return 0
  while (and != 0) {
    and = and &lt;&lt; 1; // this is multiplication by 2
    // prepare the next step of recursion
    t = xor ^ and;
    and = and &amp; xor;
    xor = t;
  }
  return xor;
}</pre>
			<p><a id="_idIndexMarker626"/>完整的<a id="_idIndexMarker627"/>应用程序称为<em class="italic">求和二进制文件</em>。</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor195"/>编码挑战 6–将二进制文件在纸上相乘</h2>
			<p>问题 T1A:考虑两个 T2 阳性 32 位整数，AUT3，Q，T4，4，P T5。拿几张纸和一支笔，告诉我你是如何将这两个数字的二进制表示法相乘的（<em class="italic">q</em>*<em class="italic">p</em>。</p>
			<p><strong class="bold">注意</strong>：这不是一个编码挑战，但了解它很重要。</p>
			<p><strong class="bold">解决方案</strong>：当我们将二进制数相乘时，我们必须记住，将二进制数乘以 1 会返回完全相同的二进制数，而将二进制数乘以 0 会返回 0。将两个二进制数相乘的步骤如下：</p>
			<ol>
				<li value="1">从最右边的列（第 0 列）开始，将第二个二进制数的每一位乘以第一个二进制数的每一位。</li>
				<li>总结结果。</li>
			</ol>
			<p>让我们做 124（1111100）*29（011101）=3596（111000001100）。</p>
			<p>下图显示了我们的计算结果：</p>
			<p><img src="img/Figure_9.13_B15403.jpg" alt="Figure 9.13– Multiplying binary numbers "/></p>
			
			<p class="figure-caption">图 9.13–二进制数相乘</p>
			<p>因此，我们将 29 的每一位乘以 124 的每一位。接下来，我们总结这些二进制文件，正如您在前面的<em class="italic">编码挑战 4–在纸上总结二进制文件</em>部分中看到的<a id="_idIndexMarker629"/>。</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor196"/>编码挑战 7–在代码中乘以二进制文件</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong></p>
			<p>问题 T1：考虑两个 32 位整数，即 T2，Q，T3，3，P 4。编写一段代码，使用二进制的<a id="_idIndexMarker630"/>表示法计算<em class="italic">q</em>*<em class="italic">p</em>。</p>
			<p><strong class="bold">解决方案</strong>：我们可以尝试前面编码挑战中提出的算法的实现<a id="_idIndexMarker631"/>，或者我们可以尝试另一种方法。这种方法首先假设<em class="italic">p</em>=1，所以这里有<em class="italic">q</em>*1=<em class="italic">q</em>。我们知道任何<em class="italic">q</em>乘以 1 就是<em class="italic">q</em>，所以我们可以说<em class="italic">q</em>*1 跟在下一个和之后（我们从 0 到 30，所以我们忽略位置 31 上的有符号位）：</p>
			<p><img src="img/Figure_9.14_B15403.jpg" alt="Figure 9.14 Multiplying binaries in a code "/></p>
			
			<p class="figure-caption">图 9.14–在代码中乘以二进制文件</p>
			<p>例如，如果<em class="italic">q</em>=5（101），则 5*1=0*230+0*229+…1*22+0*21+1*20=5。</p>
			<p>所以，5*1=5。</p>
			<p>到目前为止，这还没什么大不了的，但是让我们继续 5*2；也就是说，101*10。如果我们认为 5*2=5*0+10*1，那么这意味着 101*10=101*0+1010*1。所以，我们左移了 5 个<a id="_idIndexMarker632"/>位置，右移了 2 个<a id="_idIndexMarker632"/>位置。</p>
			<p>让我们继续 5*3。这是 101*011。然而，5*3=5*1+10*1。因此它就像 101*1+1010*1。</p>
			<p>让我们继续 5*4。这是 101*100。但是，5*4=5*0+10*0+20*1。因此，它类似于 101*0+1010*0+10100*1。</p>
			<p>现在，我们可以开始<a id="_idIndexMarker633"/>查看遵循以下步骤的模式（最初，<em class="italic">结果</em>=0）：</p>
			<ol>
				<li value="1">If the LSB of <em class="italic">p</em> is 1, then we write the following:<p><img src="img/Figure_9.15_B15403.jpg" alt="Figure 9.15 – LSB of p is 1 "/></p><p class="figure-caption">图 9.15–p 的 LSB 为 1</p></li>
				<li>我们将<em class="italic">q</em>左移一个位置，将<em class="italic">p</em>逻辑右移一个位置。</li>
				<li>我们从<em class="italic">步骤 1</em>重复，直到<em class="italic">p</em>为 0。</li>
			</ol>
			<p>如果我们将这三个步骤编入代码，那么我们将获得以下输出：</p>
			<pre>public static int multiply(int q, int p) {
  int result = 0;
  while (p != 0) {
    // we compute the value of q only when the LSB of p is 1            
    if ((p &amp; 1) != 0) {
      result = result + q;
    }
    q = q &lt;&lt; 1;  // q is left shifted with 1 position
    p = p &gt;&gt;&gt; 1; // p is logical right shifted with 1 position
  }
  return result;
}</pre>
			<p><a id="_idIndexMarker634"/>完整的应用程序是<a id="_idIndexMarker635"/>称为<em class="italic">乘法二进制文件</em>。</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/>编码挑战 8–在纸上减去二进制文件</h2>
			<p>问题 T1A:考虑两个正 32 位整数，即 T2，Q，To，T3，和 T4。拿几张纸和一支笔，告诉我你如何<a id="_idIndexMarker636"/>减去这两个数字的二进制表示（<em class="italic">q</em>-<em class="italic">p</em>。</p>
			<p><strong class="bold">注意</strong>：这不是一个编码挑战，但了解它很重要。</p>
			<p><strong class="bold">解决方案</strong>：为了计算 0 减 1，可以减少二进制数的减法运算。主要是，我们知道 1 减 1 等于 0，0 减 0 等于 0，1 减 0 等于 1。要计算 0 减去 1，我们必须遵循以下步骤：</p>
			<ol>
				<li value="1">从当前列中，我们搜索左列，直到找到 1 位。</li>
				<li>我们借用这个位，将它作为两个值 1 放在前一列中。</li>
				<li>然后，我们从上一列中借用这两个值 1 中的一个作为 1 中的另两个。</li>
				<li>对每列重复<em class="italic">步骤 3</em>，直到到达当前列。</li>
				<li>现在，我们可以进行计算了。</li>
				<li>如果我们遇到另一个 0 减 1，那么我们从<em class="italic">步骤 1</em>重复这个过程。</li>
			</ol>
			<p>让我们做 124（1111100）-29（011101）=95（1011111）。</p>
			<p>下图显示了我们的计算结果：</p>
			<p><img src="img/Figure_9.16_B15403.jpg" alt="Figure 9.16 – Subtracting binary numbers "/></p>
			
			<p class="figure-caption">图 9.16–减去二进制数</p>
			<p>现在，让我们一步一步来看看：</p>
			<ol>
				<li value="1">从<a id="_idIndexMarker637"/>列 0 开始，从 0 减 1 开始。我们在左列中搜索，直到找到 1。我们在第 2 列找到它（该位对应于 22=4）。我们在第 1 列借用该位，并将其用作 1 的两个值（换句话说，2 中的两个为 21+21）。我们在列 0 中借用这两个值 1 中的一个（这是 21=2），并将它们用作 1 的另外两个值（换句话说，1 中的两个值是 20+20）。现在，我们可以用 2 减 1 等于 1 来计算。我们写下 1，然后转到第 1 列。</li>
				<li>我们继续第 1 列，所以 1 减 0 等于 1。我们写下 1，然后移到第 2 栏。</li>
				<li>然后我们继续第 2 列，0 减去 1。我们在左列中搜索，直到找到 1。我们在第 3 列找到它（该位对应于 23=8）。我们从第 2 列借用该位，并将其用作 1 的两个值（换句话说，2 中的 2 是 22+22）。现在，我们可以用 2 减 1 等于 1 来计算。我们写下 1，然后移到第 3 栏。</li>
				<li>我们继续第 3 列，0 减去 1。我们在左列中搜索，直到找到 1。我们在第 4 列找到它（该位对应于 24=16）。我们借用第 3 列中的这一位，并将其用作 1 的两个值（换句话说，2 中的 2 是 23+23）。现在，我们可以用 2 减 1 等于 1 来计算。我们写下 1，然后转到第 4 栏。</li>
				<li>我们继续第 4 列，0 减去 1。我们在左列中搜索，直到找到 1。我们在第 5 列找到它（该位对应于 25=32）。我们借用第 4 列中的<a id="_idIndexMarker638"/>位，将其用作 1 的两个值（换句话说，2 中的两个为 24+24）。现在，我们可以用 2 减 1 等于 1 来计算。我们写下 1，然后转到第 5 列。</li>
				<li>我们继续第 5 列，所以是 0 减去 0。我们写下 0，然后移到第 6 列。</li>
				<li>我们继续第 6 列，所以是 1 减 0。我们写下 1，然后我们就完成了。</li>
			</ol>
			<p>结果是 1011111。</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor198"/>编码挑战 9–在代码中减去二进制文件</h2>
			<p>问题 T1A:考虑两个 32 位的 To2 T2，整数，3，3，q，4，4 和 5。编写一段代码，使用二进制表示法计算<em class="italic">q-p</em>。</p>
			<p><strong class="bold">解决方案</strong>：从<a id="_idIndexMarker640"/>之前的编码挑战中我们已经知道，减去二进制数可以简化为计算 0 减去 1。此外，我们知道如何使用<em class="italic">借用</em>技术求解 0 减去 1。除了借用技巧之外，重要的是要注意|<em class="italic">q-p</em>|=<em class="italic">q</em>^<em class="italic">p</em>；例如：</p>
			<p>|1-1 |=1^1=0，| 1-0 |=1^0=1，| 0-1 |=0^1=1 和| 0-0 |=0^0=0。</p>
			<p>基于这两条语句，我们可以实现两个二进制文件的减法，如下所示：</p>
			<pre>public static int subtract(int q, int p) {
  while (p != 0) {
    // borrow the unset bits of q AND set bits of p
    int borrow = (~q) &amp; p;
    // subtraction of bits of q and p 
    // where at least one of the bits is not set
    q = q ^ p;
    // left shift borrow by one position            
    p = borrow &lt;&lt; 1;
  }
  return q;
}</pre>
			<p><a id="_idIndexMarker641"/>完整的<a id="_idIndexMarker642"/>应用程序称为<em class="italic">减法二进制文件</em>。</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor199"/>编码挑战 10–在纸上分割二进制文件</h2>
			<p>问题 T1：考虑两个正 32 位整数，即 T2，Q，T3，3，P 4。拿几张纸和一支笔，让我看看你是如何将这两个数字的<a id="_idIndexMarker643"/>二进制表示法（<em class="italic">q</em>/<em class="italic">p</em>）分开的。</p>
			<p><strong class="bold">注意</strong>：这不是一个编码挑战，但了解它很重要。</p>
			<p><strong class="bold">解决方案</strong>：在二进制除法中，只有两种可能：0 或 1。除法包括<em class="italic">股息</em>（<em class="italic">q</em>）、<em class="italic">除数</em>（<em class="italic">p</em>）<em class="italic">、</em>商<em class="italic">商</em>和<em class="italic">余数</em>。例如，我们知道 11（被除数）/2（除数）=5（商）1（余数）。或者，在二进制表示中，我们有 1011（被除数）/10（除数）=101（商）1（余数）</p>
			<p>我们首先将除数与股息的 MSB 进行比较（我们称之为<em class="italic">次级股息</em>，并执行以下操作：</p>
			<p>a、 如果除数不适合分红利（除数&gt;分红利），那么我们在商后面加上 0。</p>
			<p>a、 a）我们将股息的下一位附加到子股息上，并从<em class="italic">步骤 a</em>继续。</p>
			<p>b、 如果除数与次除数相匹配（除数&lt;=次除数），那么我们在商后面加上 1。</p>
			<p>b、 a）我们从当前次级股息中减去<a id="_idIndexMarker644"/>除数。</p>
			<p>b、 b）我们将被除数的下一位附加到减法结果上（这是新的子除数），并从<em class="italic">步骤 a</em><em class="italic">重复。</em></p>
			<p>c、 当我们处理了被除数的所有位后，我们应该得到商和余数，这是除法的结果。</p>
			<p>c、 a）我们可以停在这里，用得到的商和余数表示结果。</p>
			<p>c、 b）我们可以在商上加一个点（“<strong class="bold">”、</strong>），在当前余数上加一个 0（这是新的子股息），然后从<em class="italic">步骤 a</em>继续，直到余数为 0 或者我们对结果感到满意。</p>
			<p>下图表示 11/2 分区：</p>
			<p><img src="img/Figure_9.17_B15403.jpg" alt="Figure 9.17 – Dividing binary numbers "/></p>
			
			<p class="figure-caption">图 9.17–二进制数的除法</p>
			<p>现在，让我们一步一步地看这个（集中在前面图表的左侧）：</p>
			<ul>
				<li>次级股息=1，10&gt;1，因为 2&gt;1，所以我们在商后面加上 0。</li>
				<li>次级股息=10，10=10，因为 2=2，所以我们在商后面加上 1。</li>
				<li>做减法，10-10=0。</li>
				<li>次级股息=01，10&gt;01，因为 2&gt;1，所以我们在商后面加上 0。</li>
				<li>次级股息=011，10&lt;011，因为 2&lt;3，所以我们在商后面加 1。</li>
				<li>做减法，011-10=1。</li>
				<li>被除数的<a id="_idIndexMarker645"/>处理没有更多的位，因此我们可以说 11/2 有商 101（即 5），余数是 1。</li>
			</ul>
			<p>如果你看上图的右侧，你会发现我们可以通过应用给定的<em class="italic">步骤 c.b</em>继续计算，直到余数为 0。</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>编码挑战 11–在代码中划分二进制文件</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong></p>
			<p>问题 T1：考虑两个 32 位整数，即 T2，Q，T3，3，P 4。编写一段代码，使用二进制的<a id="_idIndexMarker646"/>表示法计算<em class="italic">q</em>/<em class="italic">p</em>。</p>
			<p><strong class="bold">解决方案</strong>：有几种<a id="_idIndexMarker647"/>方法可以用来分割两个二进制文件。让我们专注于实现一个只计算商的解决方案，这意味着我们跳过余数。</p>
			<p>这种方法非常简单。我们知道一个 32 位整数包含的位对我们来说是 31 到 0 之间的。我们所要做的就是将除数（<em class="italic">p</em>左移<em class="italic">i</em>位置（<em class="italic">i</em>=31,30,29，…，2,1,0），然后检查结果是否小于被除数（<em class="italic">q</em>。每次我们找到这样的位，我们都会更新第<em class="italic">i</em>位的位置。我们累积结果并将其传递到下一个位置。以下代码不言自明：</p>
			<pre>private static final int MAX_BIT = 31;
...
public static long divideWithoutRemainder(long q, long p) {
  // obtain the sign of the division
  long sign = ((q &lt; 0) ^ (p &lt; 0)) ? -1 : 1;
  // ensure that q and p are positive
  q = Math.abs(q);
  p = Math.abs(p);
  long t = 0;
  long quotient = 0;
  for (int i = MAX_BIT; i &gt;= 0; --i) {
    long halfdown = t + (p &lt;&lt; i);
    if (halfdown &lt;= q) {
      t = t + p &lt;&lt; i;
      quotient = quotient | 1L &lt;&lt; i;
    }
  }
  return sign * quotient;
}</pre>
			<p>完整的应用程序称为<em class="italic">DividingBinaries</em>。它还包含<a id="_idIndexMarker648"/>计算<a id="_idIndexMarker649"/>余数的实现。</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor201"/>编码挑战 12–替换位</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong></p>
			<p>问题 T1 题：考虑两个正项 T2，32 位整数，O.T3，Q，T4，To，T5，P，T6，2 位，AUT T7。编写一段代码<a id="_idIndexMarker651"/>，将位置<em class="italic">i</em>和<em class="italic">j</em>之间的<em class="italic">q</em>中的位替换为<em class="italic">p</em>的位。您可以假设，在<em class="italic">i</em>和<em class="italic">j 之间，</em>有足够的空间容纳<em class="italic">p</em>的所有位。</p>
			<p>Po.T0.解决方案 To1 T1：让我们考虑，T2 T2，Q，T3，Ty＝4914（二进制，1001100110010），Po.T4，P，Po.T5，To＝63（二元，111111），Apple T6。下图显示了我们拥有的以及我们想要获得的：</p>
			<p><img src="img/Figure_9.18_B15403.jpg" alt="Figure 9.18 – Replacing the bits between i and j "/></p>
			
			<p class="figure-caption">图 9.18–替换 i 和 j 之间的位</p>
			<p>正如我们所看到的，解决方案应该完成三个主要步骤。首先，我们需要清除<em class="italic">i</em>和<em class="italic">j</em>之间的<em class="italic">q</em>位。第二，我们需要通过<em class="italic">i</em>位置左移<em class="italic">p</em>（这样，我们将<em class="italic">p</em>放置在右侧位置）。最后，我们将<em class="italic">p</em>和<em class="italic">q</em>合并在最终结果中。</p>
			<p>为了清除<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">i</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">j</em>之间的<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>位（将这些位设置为 0，无论其初始值如何），我们可以使用 and[&amp;运算符。我们知道只有 1&amp;1 返回 1，所以如果我们有一个在<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">i</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">j</em>之间包含 0 的位掩码，那么<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>&amp;<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">位掩码</em>将导致自 1&amp;起在【T14 i 和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">j</em>之间只包含 0 的位序列 0 和 0&amp;0 都是 0。此外，在位掩码的 MSB 和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">j</em>（独占）以及<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">i</em>（独占）和 LSB 之间，我们应该只有值 1。这样，<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>&amp;<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">位掩码</em>将保留<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>位，因为 1&amp;1=1 和 0&amp;1=0。所以，我们的位掩码应该是 1110000001111。让我们在工作中看到它：</p>
			<p><img src="img/coding_ch_12._1_%28Fig_9.19%29.jpg" alt="Figure 9.19 – Bit-mask (a) "/></p>
			
			<p class="figure-caption">图 9.19–位掩码（a）</p>
			<p>但是我们怎么才能得到这个面具呢？我们可以通过 OR[|]运算符获得它，如下所示：</p>
			<p><img src="img/coding_ch_12%2C_2_%28Fig_9.20%29.jpg" alt="Figure 9.20 – Bit-mask (b) "/></p>
			
			<p class="figure-caption">图 9.20–位掩码（b）</p>
			<p>1110000000000 位掩码可通过将-1 左移<em class="italic">j</em>+1 个位置获得，而 000000000 1111 位掩码可通过将 1 左移<em class="italic">i</em>个位置并减去 1 获得。</p>
			<p>在这里，我们<a id="_idIndexMarker652"/>解决了前两个步骤。最后，我们<a id="_idIndexMarker653"/>需要将<em class="italic">p</em>放在正确的位置。这很简单：我们只是在<em class="italic">i</em>位置左移<em class="italic">p</em>。最后，我们在<em class="italic">q</em>之间应用 OR[|]运算符，清除位在<em class="italic">i</em>和<em class="italic">j</em>之间，移位的<em class="italic">p</em>：</p>
			<p><img src="img/coding_ch_12%2C_3_%28Fig_9.21%29.jpg" alt="Figure 19.21 Binary representation "/></p>
			
			<p class="figure-caption">图 9.21–二进制表示法</p>
			<p>我们完了！现在，让我们将其转化为代码：</p>
			<pre>public static int replace(int q, int p, int i, int j) {
  int ones = ~0; // 11111111 11111111 11111111 11111111          
  int leftShiftJ = ones &lt;&lt; (j + 1);
  int leftShiftI = ((1 &lt;&lt; i) - 1);
  int mask = leftShiftJ | leftShiftI;
  int applyMaskToQ = q &amp; mask;
  int bringPInPlace = p &lt;&lt; i;
  return applyMaskToQ | bringPInPlace;
}</pre>
			<p>完整的<a id="_idIndexMarker654"/>应用程序被<a id="_idIndexMarker655"/>称为<em class="italic">替换位</em>。</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/>编码挑战 13–1 的最长序列</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">Adobe</strong>、<strong class="bold">微软</strong>、<strong class="bold">Flipkart</strong></p>
			<p>问题 T1A:考虑一个 32 位整数，AUT T2。101 的序列可视为 111。编写一段代码，<a id="_idIndexMarker656"/>计算 1 的最长序列的长度。</p>
			<p><strong class="bold">解决方案</strong>：我们将看几个<a id="_idIndexMarker657"/>示例（以下三列表示整数及其二进制表示，以及最长序列 1 的长度）：</p>
			<p><img src="img/coding_challenge_13%2C_1_%28Fig_9.22%29.jpg" alt="Figure 9.22 Longest sequence of 1 "/></p>
			
			<p class="figure-caption">图 9.22–三个示例</p>
			<p>如果我们知道<em class="italic">n</em>的 LSB 为 1 时<em class="italic">n</em>1=1，如果<em class="italic">n</em>的 LSB 为 0 时<em class="italic">n</em>n&amp;0=0，那么这个问题的解决方案是很容易实现的。让我们关注第一个示例 67534（100000<strong class="bold">11111</strong>001110）。在这里，我们执行以下操作：</p>
			<ul>
				<li>初始化最长序列=0。</li>
				<li>申请并[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">11111</strong>001110&amp;1=0，最长序列=0。</li>
				<li>右移并应用[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">11111</strong>00111&amp;1=1，最长顺序=1。</li>
				<li>右移并应用[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">11111</strong>0011&amp;1=1，最长顺序=2。</li>
				<li>右移并应用[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">11111</strong>001&amp;1=1，最长顺序=3。</li>
				<li>右移并应用[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">11111</strong>00&amp;1=0，最长顺序=0</li>
				<li>右移并应用[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">11111</strong>0&amp;1=0，最长顺序=0。</li>
				<li>右移并应用和[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">11111</strong>&amp;1=1，最长顺序=1。</li>
				<li>右移并应用和[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">1111</strong>&amp;1=1，最长顺序=2。</li>
				<li>右移并应用和[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">111</strong>&amp;1=1，最长顺序=3。</li>
				<li>右移并应用和[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">11</strong>&amp;1=1，最长顺序=4。</li>
				<li>右移并应用[&amp;]：100000<strong xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="bold">1</strong>&amp;1=1，最长顺序=5。</li>
				<li>右移并应用和[&amp;]：100000&amp;1=0，最长序列=0。</li>
			</ul>
			<p>因此，只要我们在最长的 1 序列中没有任何 0 交错，我们就可以实现前面的方法。然而，这种方法不适用于第三种情况，即 339809（10100<strong class="bold">101111011</strong>00001）。在这里，我们需要做一些额外的检查；否则，最长序列的长度将等于 4。但由于 101 可以被视为 111，正确答案是 9。这意味着当我们有<em class="italic">n</em>&amp;1=0 时，我们必须执行以下检查（主要是检查 0 的当前位是否由 1 的两个位作为 101 进行保护）：</p>
			<ul>
				<li>检查下一位是否为 1 或 0，（<em class="italic">n</em>&amp;2）==1 或 0</li>
				<li>如果下一位为 1，则检查前一位是否为 1</li>
			</ul>
			<p>我们可以将其转化为代码，如下所示：</p>
			<pre>public static int sequence(int n) {
  if (~n == 0) {
    return Integer.SIZE; // 32
  }
  int currentSequence = 0;
  int longestSequence = 0;
  boolean flag = true;
  while (n != 0) {
    if ((n &amp; 1) == 1) {
      currentSequence++;
      flag = false;
    } else if ((n &amp; 1) == 0) {
      currentSequence = ((n &amp; 0b10) == 0) // 0b10 = 2
        ? 0 : flag 
        ? 0 : ++currentSequence;
      flag = true;
    }
    longestSequence = Math.max(
      currentSequence, longestSequence);
    n &gt;&gt;&gt;= 1;
  }
  return longestSequence;
}</pre>
			<p><a id="_idIndexMarker660"/>完整的应用程序是<a id="_idIndexMarker661"/>称为<em class="italic">最长序列</em>。</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor203"/>编码挑战 14–下一个和上一个数字</h2>
			<p><strong class="bold">Adobe</strong>、<strong class="bold">微软</strong></p>
			<p>问题 T1A:考虑一个 32 位整数，AUT T2。编写一段代码，返回下一个最大的数字，<a id="_idIndexMarker662"/>包含完全相同的 1 位数字。</p>
			<p>Po.T0.溶液：To T2，n，T3，124344＝11110010110111000。要获得另一个具有相同 1 位数字<a id="_idIndexMarker663"/>的数字，我们必须翻转 1 位将其转换为 0，再翻转 0 位将其转换为 1。结果数字将不同于给定数字，并包含相同数量的 1 位。现在，如果我们希望这个数字大于给定的数字，那么从 0 翻转到 1 的位应该在从 1 翻转到 0 的位的左边。换言之，如果有两个位位置<em class="italic">i</em>和<em class="italic">j</em>，并且将<em class="italic">i</em>位置的位从 1 翻转到 0，将<em class="italic">j</em>位置的位从 0 翻转到 1，这将导致新的数字小于给定的数字，如果<em class="italic">i&gt;j</em>，而如果<em class="italic">i&lt;j</em>分别较大。</p>
			<p>这意味着我们必须找到 0 的第一位，它的右边不只是零（换句话说，非尾随零的第一位）。这样，如果我们将这个位从 0 翻转到 1，那么我们知道在这个位的右边至少有一个 1 的位可以从 1 翻转到 0。这意味着我们用相同数量的 1 位获得一个更大的数字。下图以图形形式显示了这些数字：</p>
			<p><img src="img/Figure_9.23_B15403.jpg" alt="Figure 9.23 – The non-trailing zero "/></p>
			
			<p class="figure-caption">图 9.23–非尾随零位</p>
			<p>因此，对于我们的数字，第一个非尾随零位于第 6 位。如果我们将这个位从 0 翻转到 1，那么得到的数字比给定的数字大。但是现在，我们必须从这个位的右边选择一个位，它将从 1 翻转到 0。基本上，我们必须在位置 3、4 和 5 的位之间进行选择。然而，这是正确的逻辑吗？请记住，我们必须返回下一个最大的数字，而不是大于给定数字的任何数字。在位置 5 翻转位比从位置 3 或 4 翻转位要好，但这不是第二大数字。检查以下关系（下标是对应于二进制表示的十进制值）：</p>
			<p><img src="img/coding_challenge_14_%28Fig_9.24%29.jpg" alt="Figure 9.24 Decimal value corresponding to the binary representation "/></p>
			
			<p class="figure-caption">图 9.24——几种关系</p>
			<p>到目前为止，我们可以得出结论<a id="_idIndexMarker665"/>1111001011<strong class="bold">10</strong>11000124376 看起来是正确的选择。然而，我们也应注意以下几点：</p>
			<p>1111001011<strong class="bold">10</strong>11000124376&gt;11110010111000011124355</p>
			<p>因此，如果我们计算位置 6（独占）和 0 之间 1 的位数（让我们用<em class="italic">k</em>=3 表示），清除位置 6（独占）和 0 之间的所有位数（将它们设置为 0），并在位置<em class="italic">k</em>-1 和 0 之间将<em class="italic">k</em>-1 位设置为 1，则得到下一个最大的数字。</p>
			<p>好啊到目前为止，一切都很好！现在，让我们把这个算法编成代码。首先，我们需要找到非尾随零的第一位的位置。这意味着我们需要将尾随零的计数与 1 的计数相加，直到得到第一个 0。计算尾随零的方法如下（我们正在制作一份<em class="italic">n</em>的副本，因为我们不想移动给定数字的位）：</p>
			<pre>int copyn = n;
int zeros = 0;
while ((copyn != 0) &amp;&amp; ((copyn &amp; 1) == 0)) {
  zeros++;
  copyn = copyn &gt;&gt; 1;
}</pre>
			<p>按如下方式计算 1，直到第一个 0：</p>
			<pre>int ones=0;
while ((copyn &amp; 1) == 1) {
  ones++;
  copyn = copyn &gt;&gt; 1;
}</pre>
			<p>现在，<strong class="source-inline">标记=0+1</strong>给我们<a id="_idIndexMarker666"/>搜索的位置。接下来，我们将位从该位置从 0 翻转到 1，并清除该位置（独占）和 0 之间的所有位：</p>
			<pre>n = n | (1 &lt;&lt; marker);</pre>
			<p>在我们的例子中，<strong class="source-inline">标记</strong>=6。该线的<a id="_idIndexMarker667"/>效应产生以下输出：</p>
			<p><img src="img/coding_chh_14%2C_2_%28Fig_9.25%29.jpg" alt="Figure 9.25 – Output (1) "/></p>
			
			<p class="figure-caption">图 9.25–输出（1）</p>
			<pre>n = n &amp; (-1 &lt;&lt; marker);</pre>
			<p><img src="img/coding_chh_14%2C3_%28Fig_9.26%29.jpg" alt="Figure 9.26 – Output (2) "/></p>
			
			<p class="figure-caption">图 9.26–输出（2）</p>
			<p>最后，我们将位设置在（<strong class="source-inline">个</strong>-1）和 0 到 1 之间：</p>
			<pre>n = n | (1 &lt;&lt; (ones - 1)) - 1;</pre>
			<p>在我们的例子中，<strong class="source-inline">个</strong>=3。该行的效果产生以下输出：</p>
			<p><img src="img/coding_ch_14%2C_4_%28Fig_9.27%29.jpg" alt="Figure 9.27 Output (3) "/></p>
			
			<p class="figure-caption">图 9.27–输出（3）</p>
			<p>因此，最终的<a id="_idIndexMarker668"/>结果是 11110010111000011，即 124355。因此，最终的方法<a id="_idIndexMarker669"/>如下所示：</p>
			<pre>public static int next(int n) {
  int copyn = n;
  int zeros = 0;
  int ones = 0;
  // count trailing 0s
  while ((copyn != 0) &amp;&amp; ((copyn &amp; 1) == 0)) {
    zeros++;
    copyn = copyn &gt;&gt; 1;
  }
  // count all 1s until first 0
  while ((copyn &amp; 1) == 1) {
    ones++;
    copyn = copyn &gt;&gt; 1;
  }
  // the 1111...000... is the biggest number 
  // without adding more 1
  if (zeros + ones == 0 || zeros + ones == 31) {
    return -1;
  }
  int marker = zeros + ones;
  n = n | (1 &lt;&lt; marker);
  n = n &amp; (-1 &lt;&lt; marker);
  n = n | (1 &lt;&lt; (ones - 1)) - 1;
  return n;
}</pre>
			<p>完整的应用程序称为<em class="italic">下一个编号</em>。它还包含一个方法，该方法返回下一个最小的数字，该数字包含完全相同数量的 1 位。接受挑战，尝试<a id="_idIndexMarker670"/>自己提供解决方案。完成后，只需<a id="_idIndexMarker671"/>将您的解决方案与捆绑代码中的解决方案对抗即可。作为提示，您将需要尾随 1 的数量（让我们用<em class="italic">k</em>表示），以及尾随 1 左侧的 0 数量，直到您到达第一个 1 为止。将这些值相加将得到应该从 1 翻转到 0 的位的位置。接下来，清除该位置右侧的所有位，并立即将该位置右侧的（<em class="italic">k</em>+1）位设置为 1。</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor204"/>编码挑战 15–转换</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong></p>
			<p>问题 T1：考虑两个 T2 阳性 32 位的 T3，整数，T4，Q，T5，5 和 P5。写一段代码，计算我们应该在<em class="italic">q</em>中翻转的位数，以便将其转换为<em class="italic">p</em>。</p>
			<p><strong class="bold">解决方案</strong>：如果我们观察到 XOR[^]运算符仅在操作数不同时返回 1，那么这个问题的解决方案就变得清晰了。让我们考虑一下，T2，q，T3，Ty＝290932（100011100000111010）和 Po.T4，P，T5，To＝352345（101011000000101100）。让我们应用 XOR[^]运算符：</p>
			<p><img src="img/coding_ch_15%2C_1_%28Fig_9.28%29.jpg" alt="Figure 9.28 Conversion "/></p>
			
			<p class="figure-caption">图 9.28–转换</p>
			<p>换句话说，如果我们用<em class="italic">xor</em>（<em class="italic">xor</em>=<em class="italic">q</em>^<em class="italic">p</em>，来表示<em class="italic">q</em>^<em class="italic">p</em>，那么我们所要做的就是计算<em class="italic">xor</em>中 1 的位数（在我们的示例中，1 中有 6 位）。这可以使用 AND[&amp;运算符来完成，AND[<a id="_idIndexMarker674"/>运算符只为 1&amp;1=1 返回 1，因此我们可以为<em class="italic">异或</em>中的每一位计算<em class="italic">异或</em>异或&amp;1。每次比较后，我们将<em class="italic">异或</em>右移一个位置。代码本身就说明了<a id="_idIndexMarker675"/>：</p>
			<pre>public static int count(int q, int p) {
  int count = 0;
  // each 1 represents a bit that is 
  // different between q and p
  int xor = q ^ p;
  while (xor != 0) {
    count += xor &amp; 1; // only 1 &amp; 1 = 1
    xor = xor &gt;&gt; 1;
  }
  return count;
}</pre>
			<p><a id="_idIndexMarker676"/>完整的申请<a id="_idIndexMarker677"/>称为<em class="italic">转换</em>。</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor205"/>编码挑战 16–最大化表达式</h2>
			<p>问题 T1 题：考虑两个 T2 的正 32 位整数，AUT3，Q，T4，T4，P To.T6.≠ P 使表达式（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">s</em>）（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">p</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">s</em>最大化的<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">p</em>之间的关系是什么，其中和是逻辑运算符[&amp;？</p>
			<p><strong class="bold">解决方案</strong>：这类问题听起来很难，但非常简单。让我们从一个简单的<em class="italic">a*b</em>开始。<em class="italic">a*b</em>何时达到最大值？好吧，让我们考虑一下这个问题。<em class="italic">a*</em>4 何时达到最大值？让我们编写一些测试用例：</p>
			<p><em class="italic">a</em>=1，1*4=4</p>
			<p><em class="italic">a</em>=2，2*4=8</p>
			<p><em class="italic">a</em>=3，3*4=12</p>
			<p><em class="italic">a</em>=4，4*4=16</p>
			<p>所以，当<em class="italic">a=b</em>时，我们已经达到最大值 16。但是，<em class="italic">a</em>可以是 5，5*4=20&gt;16。这是正确的，但这意味着<em class="italic">b</em>也可以是 5，所以 5*5=，25&gt;20。这与数学演示相去甚远，但我们可以注意到，如果<em class="italic">a=b</em>，则<em class="italic">a*b</em>处于最大值。</p>
			<p>对于那些对数学演示感兴趣的人，假设我们有以下内容：</p>
			<p><img src="img/Figure_9.29_B15403_%282%29.jpg" alt="Figure 9.29 Maximizing expressions (1) "/></p>
			
			<p class="figure-caption">图 9.29–最大化表达式（1）</p>
			<p>这意味着我们有以下几点：</p>
			<p><img src="img/Figure_9.30_B15403_%282%29.jpg" alt="Figure 9.30 Maximizing expressions (2) "/></p>
			
			<p class="figure-caption">图 9.30–最大化表达式（2）</p>
			<p>此外，这意味着我们有以下几点：</p>
			<p><img src="img/coding_ch_16_%28Fig_9.31%29.jpg" alt="Figure 9.31 Maximizing expressions (3) "/></p>
			
			<p class="figure-caption">图 9.31–最大化表达式（3）</p>
			<p>现在，如果我们说当<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">a=b</em>时<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">a*b</em>是最大值，那么让我们表示<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">a</em>=（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">s</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">b</em>=（【t12p 和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">s</em>。因此，（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">s</em>）（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">p</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">s</em>在（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">q</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">s</em>＝（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">p</em>和<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">s</em>时达到最大值。</p>
			<p>让我们考虑，T0，T0，T1，Ty＝822（1100110110）和 Po.T2，P，T3，To＝663（1010010111）。<em class="italic">q</em>的 LSB 为 0，而<em class="italic">p</em>的 LSB 为 1，因此我们可以写以下内容：</p>
			<p>（1 和<em class="italic">s</em>=（0 和<em class="italic">s</em>）→  <em class="italic">s</em>=0→ （1&amp;0）=（0&amp;0）=0</p>
			<p>如果我们将<em class="italic">q</em>和<em class="italic">p</em>右移 1 位，那么<a id="_idIndexMarker679"/>我们发现<em class="italic">q</em>的 LSB 为 1，<em class="italic">p</em>的 LSB 为 1：</p>
			<p><img src="img/Fig_9.32.jpg" alt="Figure 9.32 – Right shifting q and p by 1 position "/></p>
			
			<p class="figure-caption">图 9.32–按 1 个位置右移 q 和 p</p>
			<p>在这里，我们还有两个病例可以通过以下方式进行插管：</p>
			<p><img src="img/Fig_9.%2C33.jpg" alt="Figure 9.33 – Two cases "/></p>
			
			<p class="figure-caption">图 9.33–两个案例</p>
			<p>在这里，我们可以看到我们问题的答案是<em class="italic">q</em>&amp;<em class="italic">p=s</em>。让我们在工作中看到这一点：</p>
			<p><img src="img/coding_ch_16%2C_2_%28Fig_9.34%29.jpg" alt="Figure 9.34 Answer "/></p>
			
			<p class="figure-caption">图 9.34–答案</p>
			<p>答案是 100001110，也就是 534。这意味着（822 和 534）=（663 和 534）。</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor206"/>编码挑战 17–交换奇偶位</h2>
			<p><strong class="bold">Adobe</strong>、<strong class="bold">微软</strong>、<strong class="bold">Flipkart</strong></p>
			<p>问题 T1：考虑一个 T2 的正 32 位整数。编写一段代码，交换这个整数的奇偶位。</p>
			<p>Po.T0.溶液：To T2，n，T3，663＝1010010111。如果我们手动执行掉期，那么我们应该<a id="_idIndexMarker681"/>获得 0101101011。我们可以通过两个步骤来实现这一点：</p>
			<ol>
				<li value="1">我们取奇数位，将它们向右移动一个位置。</li>
				<li>我们取偶数位，将它们向左移动一个位置。</li>
			</ol>
			<p>但我们如何才能做到这一点呢？</p>
			<p>我们可以通过 AND[&amp;]运算符和位掩码获取奇数位，该位掩码在奇数位置包含 1 位：10101010101010101010101010。让我们看看这一点：</p>
			<p><img src="img/Figure_9.35_B15403_%282%29.jpg" alt="Figure 9.35 Swapping odd and even bits (1) "/></p>
			
			<p class="figure-caption">图 9.35–交换奇偶位（1）</p>
			<p>结果显示 1010010111 在位置 1、7 和 9 处包含 1 的奇数位。接下来，我们将结果 1010000010 向右移动一个位置。结果是 0101000001。</p>
			<p>我们可以通过 AND[&amp;]运算符和位掩码获取偶数位，该位掩码包含偶数位置的 1 位：1010101010101010101010101。让我们看看这一点：</p>
			<p><img src="img/Figure_9.36_B15403_%282%29.jpg" alt="Figure 9.36 swapping odd and even bits (2) "/></p>
			
			<p class="figure-caption">图 9.36–交换奇偶位（2）</p>
			<p>结果显示 1010010111 在位置 0、2 和 4 处包含 1 的偶数位。接下来，我们将结果 0000010101 向左移动一个位置。这将导致 000010010。</p>
			<p>要获得最终结果，我们只需要对这两个结果应用 OR[|]运算符：</p>
			<p><img src="img/Figure_9.37_B15403_%282%29.jpg" alt="Figure 9.37 Final result "/></p>
			
			<p class="figure-caption">图 9.37–最终结果</p>
			<p>最终结果是 0101101011。实现遵循以下步骤<em class="italic">ad litteram</em>，所以这是<a id="_idIndexMarker682"/>简单的：</p>
			<pre>public static int swap(int n) {
  int moveToEvenPositions
    = (n &amp; 0b10101010101010101010101010101010) &gt;&gt;&gt; 1;
  int moveToOddPositions
    = (n &amp; 0b1010101010101010101010101010101) &lt;&lt; 1;
  return moveToEvenPositions | moveToOddPositions;
}</pre>
			<p>完整的<a id="_idIndexMarker683"/>应用程序称为<em class="italic">SwapOddEven</em>。</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor207"/>编码挑战 18–旋转位</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong>、<strong class="bold">微软</strong>、<strong class="bold">Flipkart</strong></p>
			<p>问题 T1：考虑一个正的 32 位整数，ORT T2。编写一段将<em class="italic">k</em>位向左或向右旋转的代码。通过<a id="_idIndexMarker684"/>旋转，我们了解到在二进制表示的一端脱落的位被发送到<a id="_idIndexMarker685"/>的另一端。因此，在左旋转中，从左端掉下来的比特被发送到右端，而在右旋转中，从右端掉下来的比特被发送到左端。</p>
			<p><strong class="bold">解决方案</strong>：让我们关注左旋转（通常，右旋转解决方案是镜像左旋转解决方案）。我们已经知道，通过将<em class="italic">k</em>位向左移动，我们将位向左移动，空点用零填充。然而，代替这些零，我们必须把从左端掉下来的位放进去。</p>
			<p>让我们考虑一下，T0，T1，T1＝423099897（000 011001001111111110111111001）和 PoT T2，k Ont3＝10＝10，所以我们向左旋转了 10 位。下图突出显示了下降位和最终结果：</p>
			<p><img src="img/Figure_9.38_B15403_%282%29.jpg" alt="Figure 9.38– Left rotating bits "/></p>
			
			<p class="figure-caption">图 9.38–左旋转钻头</p>
			<p>上图给出了解决方案。如果我们仔细观察 b）点和 c）点，我们将看到最终结果中会出现掉落的碎片。该结果可通过将下降位右移 32-10=22 个位置来获得。</p>
			<p>因此，如果我们将<em class="italic">n</em>左移 10 个位置，我们将得到一个二进制表示，在右侧用零填充（如上图中的 b 点或下一个除法的除数）。如果我们<a id="_idIndexMarker686"/>将<em class="italic">n</em>右移 22 个位置，我们将获得一个在左侧填充有零的二进制表示（作为下一个除法的除数）。此时，OR[|]操作符进入场景，如以下示例所示：</p>
			<p><img src="img/Figure_9.39_B15403.jpg" alt="Figure 9.39 OR [|] Operator "/></p>
			
			<p class="figure-caption">图 9.39–应用 OR[|]运算符</p>
			<p>左旋转的最终结果为 110111111011110010001100100。现在，我们可以很容易地将其转化为代码，如下所示：</p>
			<pre>public static int leftRotate(int n, int bits) {
  int fallBits = n &lt;&lt; bits;
  int fallBitsShiftToRight = n &gt;&gt; (MAX_INT_BITS - bits);
  return fallBits | fallBitsShiftToRight;
}</pre>
			<p>现在，通过实施正确的轮换来挑战自己。</p>
			<p>对于正确的<a id="_idIndexMarker688"/>循环，代码如下所示（您应该能够遵循此解决方案而不会出现任何问题）：</p>
			<pre>public static int rightRotate(int n, int bits) {
  int fallBits = n &gt;&gt; bits;
  int fallBitsShiftToLeft = n &lt;&lt; (MAX_INT_BITS - bits);
  return fallBits | fallBitsShiftToLeft;
}</pre>
			<p>完整的应用程序称为<em class="italic">RotateBits</em>。</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor208"/>编码挑战 19–计算数字</h2>
			<p>问题 T1A.问题：考虑两个 T2 的位置，AUTT3。编写一段代码，返回一个 32 位整数<a id="_idIndexMarker690"/>，其中包含介于<em class="italic">i</em>（含）和<em class="italic">j</em>（含）之间的 1（set），其余位为 0（未设置）。</p>
			<p>Po.T0.溶液：To T2：我认为 T3，T3＝3，而 T4，J，Ty5 T5＝7。我们知道所需的 32 位整数是 248，或者，在二进制表示中是 11111000（或者全部为 0，00000000000000000000000011111000）。</p>
			<p>如果您注意到<em class="italic">编码挑战 8–减去纸面上的二进制文件，</em>那么您应该知道 0 减去 1 是一个可以通过<em class="italic">从当前位左侧借用</em>位来完成的操作。<em class="italic">借用</em>技术向左传播，直到找到 1 位。此外，如果我们记住 1 减 0 等于 1，那么我们可以写出以下减法：</p>
			<p><img src="img/Figure_9.40_B15403.jpg" alt="Figure 9.40 Subtraction "/></p>
			
			<p class="figure-caption">图 9.40–减法</p>
			<p>看看这个减法的结果。1 正好位于位置<em class="italic">i</em>=3（含）和<em class="italic">j</em>=7（含）之间。这正是我们要找的数字：248。股息和除数分别通过<em class="italic"/>（<em class="italic">j</em>+1）位和<em class="italic">i</em>位左移 1 得到<a id="_idIndexMarker691"/>。</p>
			<p>有了这些<a id="_idIndexMarker692"/>语句，很容易将它们转换成代码：</p>
			<pre>public static int setBetween(int left, int right) {
  return (1 &lt;&lt; (right + 1)) - (1 &lt;&lt; left);
}</pre>
			<p>完整的应用程序名为<em class="italic">NumberWithOneInLR</em>。</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor209"/>编码挑战 20–独特元素</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong>、<strong class="bold">微软</strong>、<strong class="bold">Flipkart</strong></p>
			<p>问题 T1：考虑一个给定的整数数组。这个数组中的每个元素正好出现三次，除了<a id="_idIndexMarker693"/>一个元素只出现一次。这使得它独一无二。写一段<a id="_idIndexMarker694"/>代码，在 O（n）复杂度时间和 O（1）额外空间中找到这个独特的元素。</p>
			<p>Po.T0.解 To1 T1：让我们考虑给定的数组是 Po.t2。ARR ORD T3＝{= 4, 4, 3，1, 7, 7，7, 1, 1，4 }，所以 3 是唯一的元素。如果我们写下这些数字的二进制表示，我们会得到以下结果：100100011001111111111111001001100。现在，让我们对相同位置的位求和，并检查得到的和是否是 3 的倍数，如下所示：</p>
			<ul>
				<li>前位%3 的总和=0+0+1+1+1+1+1+1+1+0=7%3=1</li>
				<li>第二位%3 的和=0+0+1+0+1+1+0+0+0=4%3=1</li>
				<li>第三位的总和%3=1+1+0+0+1+1+1+0+0+1=6%3=0</li>
			</ul>
			<p>唯一编号为 011=3。</p>
			<p>让我们来看另一个例子。这次，<em class="italic">arr</em>={51,14,14,51,98,7,14,98,51,98}，所以 7 是唯一的元素。让我们将之前使用的相同逻辑应用于二进制表示：110011101110110111001111111111100010 1111111110101100010。这一次，让我们使用一个图表，因为这使事情更清楚：</p>
			<p><img src="img/Figure_9.41_B15403.jpg" alt="Figure 9.41 – Finding the unique element in the given array "/></p>
			
			<p class="figure-caption">图 9.41–在给定数组中查找唯一元素</p>
			<p>因此，基于这两个<a id="_idIndexMarker695"/>示例，我们可以详细阐述以下算法：</p>
			<ol>
				<li value="1">将<a id="_idIndexMarker696"/>相同位置上的位相加。</li>
				<li>对于每个<em class="italic">和</em>，计算模量 3。</li>
				<li>如果<em class="italic">和</em>%3=0（<em class="italic">和</em>是 3 的倍数），这意味着在给定元素中出现三次的元素中设置位。</li>
				<li>如果<em class="italic">总和</em>%3！=0（<em class="italic">和</em>不是 3 的倍数），这意味着该位在出现一次的元素中设置（<strong class="bold">但不确定该位是未设置还是在出现三次的元素中设置</strong>。</li>
				<li>我们必须对所有给定元素和位的所有位置重复<em class="italic">步骤 1</em>、<em class="italic">2</em>和<em class="italic">3</em>。通过<a id="_idIndexMarker697"/>这样做，我们将得到只出现<a id="_idIndexMarker698"/>一次的元素，正如您在上图中所看到的。</li>
			</ol>
			<p>其代码如下：</p>
			<pre>private static final int INT_SIZE = 32;
public static int unique(int arr[]) {
  int n = arr.length;
  int result = 0;
  int nr;
  int sumBits;
  // iterate through every bit 
  for (int i = 0; i &lt; INT_SIZE; i++) {
    // compute the sum of set bits at 
    // ith position in all array
    sumBits = 0;
    nr = (1 &lt;&lt; i);
    for (int j = 0; j &lt; n; j++) {
      if ((arr[j] &amp; nr) == 0) {
        sumBits++;
      }
    }
    // the sum not multiple of 3 are the 
    // bits of the unique number
    if ((sumBits % 3) == 0) {                
      result = result | nr;
    }
  }
  return result;
}</pre>
			<p>这是解决这个问题的一种方法。另一种方法是，当对同一个数字应用两次 XOR[^]运算符时，返回 0。此外，XOR[^]运算符是关联的（无论分组如何，都给出相同的结果：1^1^2^2=1^2^1^2=0）和可交换的（与顺序无关：1^2=2^1）。但是，如果我们对相同的数字进行三次异或[^]，那么结果将是相同的数字，因此在这里对所有数字使用异或[^]将没有帮助。但是，我们可以采用以下算法：</p>
			<p>使用变量可注意该变量是第一次出现的。</p>
			<ol>
				<li value="1">对于每个新元素，将其 XOR[^]放在一个变量中，<strong class="source-inline">oneAppearance</strong>。</li>
				<li>如果该元素再次出现，那么它将从<strong class="source-inline">一个外观</strong>中删除，我们将它的 XOR[^]放在另一个变量<strong class="source-inline">两个外观</strong>中。</li>
				<li>如果该元素第三次出现，则该元素将从<strong class="source-inline">一个外观</strong>和<strong class="source-inline">两个外观</strong>中删除。<strong class="source-inline">一个外观</strong>和<strong class="source-inline">两个外观</strong>变量变为 0，我们开始寻找新元素。</li>
				<li>对于所有出现三次的元素，<strong class="source-inline">一个外观</strong>和<strong class="source-inline">两个外观</strong>变量将为 0。另一方面，对于只出现一次的元素，<strong class="source-inline">oneAppearance</strong>变量将<a id="_idIndexMarker701"/>设置该值。</li>
			</ol>
			<p>就代码而言，这看起来<a id="_idIndexMarker702"/>如下所示：</p>
			<pre>public static int unique(int arr[]) {
  int oneAppearance = 0;
  int twoAppearances = 0;
  for (int i = 0; i &lt; arr.length; i++) {
    twoAppearances = twoAppearances
        | (oneAppearance &amp; arr[i]);
    oneAppearance = oneAppearance ^ arr[i];
    int neutraliser = ~(oneAppearance &amp; twoAppearances);
    oneAppearance = oneAppearance &amp; neutraliser;
    twoAppearances = twoAppearances &amp; neutraliser;
  }
  return oneAppearance;
}</pre>
			<p>这段代码的运行时是 O（n）加上 O（1）额外时间。完整的应用程序称为<em class="italic">oncetwice 三次</em>。</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor210"/>编码挑战 21–查找重复项</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong>、<strong class="bold">微软</strong>、<strong class="bold">Flipkart</strong></p>
			<p>问题 T1：考虑到你得到一个整数数组，从 1 到 Ty2 T2 阿纳尔 T3，其中，To4 T4 n n T5 的最多可以是 32000。数组可能包含重复项，您不知道<em class="italic">n</em>的值。编写一段代码，<a id="_idIndexMarker703"/>只使用 4KB 内存打印给定数组中的所有副本。</p>
			<p><strong class="bold">解决方案</strong>：解决方案应该从 4KB 内存相当于 4*8*210 位的事实开始<a id="_idIndexMarker704"/>。由于 4*8*210 大于 32000，我们可以创建 32000 位的向量，并将每个整数表示为 1 位。没有必要为位向量编写我们自己的实现；我们可以简单地使用 Java 内置的<strong class="source-inline">位集</strong>类（这个类实现了一个根据需要增长的位向量）。</p>
			<p>使用<strong class="source-inline">位集</strong>，我们可以迭代给定的数组，并且对于每个遍历的元素，将相应索引的位从 0 翻转到 1。如果我们试图翻转一个已经是 1 的位，那么我们会找到并打印一个副本。这方面的代码非常简单：</p>
			<pre>  private static final int MAX_N = 32000;
  public static void printDuplicates(int[] arr) {
    BitSet bitArr = new BitSet(MAX_N);
    for (int i = 0; i &lt; arr.length; i++) {
      int nr = arr[i];
      if (bitArr.get(nr)) {                
        System.out.println("Duplicate: " + nr);
      } else {
        bitArr.set(nr);
      }
    }
  }</pre>
			<p>完整的应用程序称为<em class="italic">FindDuplicates</em>。</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor211"/>编码挑战 22–两个非重复元素</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong></p>
			<p>问题 T1：考虑到一个整数数组，包含 2 个阿纳尔 T3，n 个 T4 个+ 2 个元素。2 个<em class="italic">n</em>元素是重复一次的<em class="italic">n</em>元素。因此，2<em class="italic">n</em>中的每个元素在给定的<a id="_idIndexMarker706"/>数组中出现两次。其余两个元素只显示一次。编写一段代码来查找这两个元素。</p>
			<p>Po.T0.解 To1 T1：让我们考虑给定的数组是 Po.t2。ARR ORD T3 TURE＝{ 2, 7, 1，5, 9, 4，1, 2, 5，4 }。我们要找的两个数字是 7 和 9。这两个数字在数组中只显示一次，而 2、1、5 和 4 显示两次。</p>
			<p>如果我们考虑蛮力方法，那么迭代数组并检查每个元素的出现次数是非常直观的。但是采访者不会对这个解决方案印象深刻，因为它的运行时间是 O（n2）。</p>
			<p>另一种方法是对给定数组进行排序。通过这种方式，重复的元素被分组在一起，以便我们可以计算每个组的出现次数。大小为 1 的组表示一个不重复的值。在寻找更好的解决方案的过程中，最好提及这种方法。</p>
			<p>更好的解决方案依赖于<em class="italic">散列</em>。创建一个<strong class="source-inline">映射&lt;</strong><em class="italic">元素</em><strong class="source-inline">、</strong><em class="italic">计数</em><strong class="source-inline">&gt;</strong>并用元素和出现次数填充它（例如，对于我们的数据，我们将有以下几对：（2,2）、（7,1）、（1,2）、（5,2）、（9,1）和（4,2））。现在，遍历地图并找到计数为 1 的元素。在寻找更好的解决方案的过程中，最好提及这种方法。</p>
			<p>在本章中，我们讨论的是位，因此最好的解决方案应该依赖于位操作。此解决方案依赖于 XOR[^]运算符和我们在<em class="italic">提示和技巧</em>部分中提到的提示：</p>
			<ul>
				<li>如果我们将一个数字与其自身进行偶数次异或运算，那么结果如下 0（<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x</em>^<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x</em>=0；<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x</em>^<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x</em>^<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x</em>^<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x</em>=（【T12 x^【T14 x】^<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">x</em>x<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">^<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">） = 0 ^ 0 = 0)</em></em></li>
			</ul>
			<p>另一方面，如果我们对两个不同的数字<em class="italic">p</em>和<em class="italic">q</em>应用异或[^]运算符，则结果是一个数字，其中包含位于<em class="italic">p</em>和<em class="italic">q</em>不同位置的一组位（1 位）。这意味着，如果我们对数组中的所有元素应用异或[^]，那么所有重复元素都将彼此无效。</p>
			<p>因此，如果我们取 XOR[^]结果的任何集合位（例如，最右边的位）并将数组的元素划分为两个集合，那么一个集合将包含具有相同位集合的元素，<a id="_idIndexMarker707"/>另一个集合将包含具有相同未设置位的元素。换句话说，我们通过比较 XOR[^]最右边的集合位与每个元素中相同位置的位，将元素划分为两个<a id="_idIndexMarker708"/>集合。这样，我们将在一组中获得<em class="italic">p</em>，在另一组中获得<em class="italic">q</em>。</p>
			<p>现在，如果我们对第一个集合中的所有元素应用 XOR[^]操作符，那么我们将得到第一个非重复元素。在另一个集合中执行相同操作将获得第二个非重复元素。</p>
			<p>让我们把这个流应用到我们的数据上，<em class="italic">arr</em>={2,7,1,5,9,4,1,2,5,4}。因此，7 和 9 是非重复值。首先，我们将 XOR[^]运算符应用于所有数字：</p>
			<p><em class="italic">异或</em>=2^7^1^5^9^4^1^2^5^4=0010（2）^0111（7）^0001（1）^0101（5）^1001（9）^0100（4）^0010（2）^0101（5）^0100（4）=1110=7^9=0111&amp;1001=1110=14。</p>
			<p>那么，7^9！=如果 7，则为 0！=9 因此，将至少有一个设置位（1 的至少一个位）。我们可以接受任何设置位，但最右边的位作为<em class="italic">xor</em>&amp;（<em class="italic">xor</em>-1）非常简单。我们有 1110&amp;~（1101）=1110&amp;0010=0010。请随意选择任何其他设置位。</p>
			<p>到目前为止，我们在这两个数字（7 和 9）的异或[^]中发现了这个集合位（0010），所以这个位必须出现在 7 或 9 中（在本例中，它出现在 7 中）。接下来，通过比较 XOR[^]最右边的集合位与每个元素中相同位置的位，将元素划分为两个集合。我们得到第一个集合，包含元素{2,7,2}，第二个集合，包含元素{1,5,9,4,1,5,4}。由于 2、7 和 2 包含集合位，因此它们位于第一个集合中，而 1、5、9、4、1、5 和 4 不包含集合位，这意味着它们是第二个集合的一部分。</p>
			<p>这样，我们就把一个集合中的第一个非重复元素（7）分离出来，把第二个非重复元素（9）放到另一个集合中。此外，每个重复的元素将在相同的位表示集合中（例如，{2，2}将始终在相同的集合中）。</p>
			<p>最后，我们对每个集合应用 XOR[^]。因此，我们有<em class="italic">xor_first_set</em>=2^7^2=010^111^010=111=7（第一个非重复元素）。</p>
			<p>对于第二组，我们有：</p>
			<p><em class="italic">异或第二集</em>=1^5^9^4^1^5^4=0001^0101^1001^0100^0001^0101^0100=1001=9（第二个<a id="_idIndexMarker709"/>非重复元素）。</p>
			<p>完成！</p>
			<p>就代码而言，我们<a id="_idIndexMarker710"/>有以下几点：</p>
			<pre>public static void findNonRepeatable(int arr[]) {
  // get the XOR[^] of all elements in the given array
  int xor = arr[0];
  for (int i = 1; i &lt; arr.length; i++) {
    xor ^= arr[i];
  }
  // get the rightmost set bit (you can use any other set bit)
  int setBitNo = xor &amp; ~(xor - 1);
  // divide the elements in two sets by comparing the 
  // rightmost set bit of XOR[^] with the bit at the same 
  // position in each element
  int p = 0;
  int q = 0;
  for (int i = 0; i &lt; arr.length; i++) {
    if ((arr[i] &amp; setBitNo) != 0) {
      // xor of the first set
      p = p ^ arr[i];
    } else {
      // xor of the second set
      q = q ^ arr[i];
    }
  }
  System.out.println("The numbers are: " + p + " and " + q);
}</pre>
			<p>此代码的运行时<a id="_idIndexMarker711"/>为 O（n），带有 O（1）个辅助空间（<em class="italic">n</em>是给定数组中的元素数）。完整的<a id="_idIndexMarker712"/>应用程序称为<em class="italic">Two 非重复</em>。</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor212"/>编码挑战 23–集合的幂集合</h2>
			<p><strong class="bold">亚马逊</strong>、<strong class="bold">谷歌</strong>、<strong class="bold">Adobe</strong></p>
			<p>问题 T1：考虑一个给定的 T2，T3。编写一段代码，返回<em class="italic">S</em>的幂集。集合<em class="italic">S</em>的幂集合 P（<em class="italic">S</em>是<em class="italic">S</em>的所有可能子集的集合，包括<a id="_idIndexMarker714"/>空集和<em class="italic">S</em>本身。</p>
			<p>【方法】To1 T1：考虑到给定的 T2，T3，T3，A，B，C，T5。如果是这样的话，发电机组包括：{{}，<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">5【T7<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">a【T9</em>T9</em>T9T9}【T10}如果是这样的话，发电机组包括：{{}，【t5}、【t5}、【t5}、【T6}【T6【T6【T6<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">T8【T8<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">a<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">a【T8【T8【T8【T8【T8【T8【T8【T8<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">a【T9【T9【T9【T9【T9【T9【T9【T9【T9【T9【T9</em>【T9【T9【T9【T9【T9【T9【T9【T9【T9</em>5】5】5】10】5】10】10【T11【T11【T11<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic"><em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">a，b，c</em>。请注意，对于包含三个元素的集合，幂集合包含 23=8 个元素。对于包含四个元素的集合，幂集合包含 24=16 个元素。一般来说，对于一组<em xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="italic">n</em>个元件，电源组包含 2n 个元件。</em></em></em></p>
			<p>现在，如果我们生成从 0 到 2n-1 的所有二进制数，那么我们得到类似于以下内容的结果（本例适用于 23-1）：</p>
			<p>20=000, 21=001, 22=010, 23=011, 24=100, 25=101, 26=110, 27=111</p>
			<p>接下来，如果我们列出这些 Ty0 T0 二进制文件，并且我们认为第一集合位（最右边的位）是与 Tyle T2 的关联的 T1 T1，一个 TA3 T3，第二个集合位与 PoT T4 B B OrthT5T 相关联，并且第三个集合位（最左边的位）与 OrthT6E.C OutT7T 相关，然后我们得到如下：</p>
			<p>20 = 000 = {}</p>
			<p>21=001={<em class="italic">a</em></p>
			<p>22=010={<em class="italic">b</em></p>
			<p>23=011={<em class="italic">a</em>、<em class="italic">b</em></p>
			<p>24=100={<em class="italic">c</em></p>
			<p>25=101={<em class="italic">a</em>、<em class="italic">c</em></p>
			<p>26=110={<em class="italic">b</em>、<em class="italic">c</em></p>
			<p>27=111={<em class="italic">a</em>、<em class="italic">b</em>、<em class="italic">c</em>}</p>
			<p>请注意，如果我们将 1 的位替换为<em class="italic">a</em>、<em class="italic">b</em>和<em class="italic">c</em>，那么我们将获得给定集合的功率集。基于这些语句，我们可以为给定集合创建以下伪代码，<em class="italic">S</em>：</p>
			<pre>Compute the Power Set size as 2 size of S
Iterate via i from 0 to Power Set size
     Iterate via j from 0 to size of S
          If jth bit in i is set then
               Add jth element from set to current subset
     Add the resulted subset to subsets
Return all subsets</pre>
			<p>因此，这个问题的解决方案可以写成如下：</p>
			<pre>public static Set&lt;Set&lt;Character&gt;&gt; powerSet(char[] set) {
  // total number of subsets (2^n)
  long subsetsNo = (long) Math.pow(2, set.length);
  // store subsets
  Set&lt;Set&lt;Character&gt;&gt; subsets = new HashSet&lt;&gt;();
  // generate each subset one by one
  for (int i = 0; i &lt; subsetsNo; i++) {
    Set&lt;Character&gt; subset = new HashSet&lt;&gt;();
    // check every bit of i
    for (int j = 0; j &lt; set.length; j++) {
      // if j'th bit of i is set, 
      // add set[j] to the current subset
      if ((i &amp; (1 &lt;&lt; j)) != 0) {                    
        subset.add(set[j]);
      }
    }
    subsets.add(subset);
  }
  return subsets;
}</pre>
			<p><a id="_idIndexMarker717"/>完整代码为<a id="_idIndexMarker718"/>称为<em class="italic">PowerSetOfSet</em>。</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor213"/>编码挑战 24–查找唯一设置位的位置</h2>
			<p><strong class="bold">Adobe</strong>、<strong class="bold">微软</strong></p>
			<p>问题 T1：考虑一个 T2 的正整数。该数字的二进制表示有一个单位集（1 的单位）。编写一段代码，返回该位的位置<a id="_idIndexMarker720"/>。</p>
			<p><strong class="bold">解决方案</strong>：问题本身给了我们一个重要的细节或约束：给定的数字包含一个 1 位。这意味着给定的数字必须是 2 的幂。只有 20、21、22、23、24、25、…、2n 具有包含单个位 1 的二进制表示。所有其他数字都包含 0 或多个值 1。</p>
			<p>一个<em class="italic">n</em>&amp;（<em class="italic">n</em>-1）公式可以告诉我们给定的数字是否是二的幂。查看下图：</p>
			<p><img src="img/Figure_9.42_B15403.jpg" alt="Figure 9.42 – The n &amp; (n-1) formula gives us the powers of two "/></p>
			
			<p class="figure-caption">图 9.42–n&amp;（n-1）公式给出了两个的幂</p>
			<p>所以，数字 0，1，2，8，16。。。将它们的二进制表示形式<em class="italic">n</em>&amp;（<em class="italic">n</em>-1）表示为 0000。到目前为止，我们可以说给定的数字是二的幂。如果不是，那么我们可以返回-1，因为没有 1 的位或者有多个 1 的位。</p>
			<p>接下来，我们可以在跟踪移位次数的同时，将<em class="italic">n</em>向右移位，只要<em class="italic">n</em>不是 0。当<em class="italic">n</em>为 0 时，这意味着<a id="_idIndexMarker721"/>我们已经移位了 1 的单个位，因此我们可以停止并返回<a id="_idIndexMarker722"/>计数的移位。基于这些语句，代码非常简单：</p>
			<pre>public static int findPosition(int n) {
  int count = 0;
  if (!isPowerOfTwo(n)) {
    return -1;
  }
  while (n != 0) {
    n = n &gt;&gt; 1;
    ++count;
  }
  return count;
}
private static boolean isPowerOfTwo(int n) {
  return (n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0);
}</pre>
			<p>完整的代码被称为<em class="italic">位置函数 Firstbitofone</em>。</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor214"/>编码挑战 25–将浮点转换为二进制，反之亦然</h2>
			<p>问题 T1：考虑 java 的 T2。浮点数 T3。编写一段代码，将此<strong class="source-inline">浮点</strong>转换为 IEEE 754<a id="_idIndexMarker723"/>单精度二进制浮点（binary-32），反之亦然。</p>
			<p><strong class="bold">解决方案</strong>：要解决这个<a id="_idIndexMarker724"/>问题，必须知道 Java 对<strong class="source-inline">浮点数</strong>使用 IEEE 754 单精度二进制浮点表示。IEEE 754 标准将二进制 32 指定为具有符号位（1 位）、指数宽度（8 位，可表示 256 个值）和有效精度（24 位（23 显式存储）），也称为尾数。</p>
			<p>下图表示 IEEE 754 标准中的二进制-32：</p>
			<p><img src="img/Figure_9.43_B15403.jpg" alt="Figure 9.43 – IEEE 754 single-precision binary floating-point (binary 32) "/></p>
			
			<p class="figure-caption">图 9.43–IEEE 754 单精度二进制浮点（二进制 32）</p>
			<p><strong class="source-inline">浮点</strong>值由 32 位二进制数据表示，带有给定符号、有偏指数、<em class="italic">e</em>（8 位无符号整数）和 23 位分数，如下所示：</p>
			<p><img src="img/Figure_9.44_B15403.jpg" alt="Figure 9.44 Float value "/></p>
			
			<p class="figure-caption">图 9.44–浮动值</p>
			<p>存储在 8 位上的指数使用 0 到 127 之间的值表示负指数（例如，2-3），使用 128-255 之间的值表示正指数。负指数 10-7 的值为-7+127=120。127 的值称为指数偏差。</p>
			<p>有了这些信息，您应该能够将<strong class="source-inline">浮点数</strong>转换为 IEEE 754 二进制-32 表示形式，反之亦然。在检查名为<em class="italic">FloatToBinaryAndBack</em>的源代码之前，请尝试使用您自己的实现。</p>
			<p>这是本章最后一个编码挑战。让我们快速总结一下！</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor215"/>总结</h1>
			<p>由于本章是位操作的综合资源，那么如果您走到了这一步，您已经大大提高了位操作技能。为了帮助您学习解决位操作问题的模式和模板，我们涵盖了主要的理论方面并解决了 25 个编码难题。</p>
			<p>在下一章中，我们将继续使用数组和字符串。</p>
		
	
</body>
</html>