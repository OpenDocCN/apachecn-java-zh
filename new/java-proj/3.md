# 优化制作代码专业人员

在本章中，我们将开发排序代码并使其更加普遍。 我们希望对更一般的东西进行排序，不仅是一系列字符串。 从本质上讲，我们将编写一个可以对其排序的任何可供选择的程序。 这样，我们将对 java-*抽象*的主要优势的一个主要优势进行全面。

然而，抽象没有价格标签。 当您有一个排序字符串的类时，您不小心将整数混合或其他不是字符串到可排序数据的其他内容，那么编译器将抱怨它。 Java 不允许您将`int`放入`String`数组中。 当代码更摘要时，这样的编程错误可能会滑入。我们将通过捕获和抛出异常来查看如何处理此类异常情况。 稍后，我们也将看一下泛型，这是 Java 的一个功能，可以帮助在编译时捕获此类编程错误。

要识别错误，我们将使用单元测试，应用行业标准 JUnit 版本 4.作为 JUnit 大量使用注释，而且因为注释很重要，我们还将学习注释一点。

之后，我们将修改代码以使用在版本 5 中引入语言的 Java 的泛型功能。使用，我们将在编译时捕获编码错误。 这比运行时期间处理异常好多了。 识别出较早的错误，它是为了修复的更便宜。

对于构建，我们仍将使用 Maven，但这一次，我们将代码拆分为小模块。 因此，我们将拥有一个多模块项目。 我们将有单独的模块，用于定义排序模块和不同的实现。 这样，我们将研究课程如何相互扩展并实现接口，通常，我们将以面向对象的方式开始编程。

我们还将讨论**测试驱动的开发**（ **TDD** ），并在该部分的末尾开始，我们将开始使用版本 9 模块支持中引入的全新功能 Java。

在本章中，我们将涵盖以下主题：

*   面向对象的编程原则
*   单位测试实践
*   算法复杂性和 Quicksort
*   异常处理
*   递归方法
*   模块支持

# 一般排序计划

在上一章中，我们实现了一种简单的排序算法。 代码可以对`String`数组的元素进行排序。 我们这样做是为了学习。 为了实际使用，JDK 中有一个现成的排序解决方案，可以对具有可比性的`Collection`对象的成员进行排序。

JDK 包含一个名为`Collections`的实用程序类，它本身包含一个静态方法`Collections.sort`。 此方法可以对具有`Comparable`的成员（更准确地说，是实现`Comparable`接口的类的成员）的任何`List`。 `List`和`Comparable`是 JDK 中定义的接口。 因此，如果我们要对`Strings`的列表进行排序，最简单的解决方案如下：

```
public class SimplestStringListSortTest {
    @Test
    public void canSortStrings() {
        var actualNames = new ArrayList(Arrays.asList(
                "Johnson", "Wilson",
                "Wilkinson", "Abraham", "Dagobert"
        ));
        Collections.sort(actualNames);
        Assert.assertEquals(new ArrayList<>(Arrays.asList(
                "Abraham", "Dagobert",
                "Johnson", "Wilkinson", "Wilson")),
                actualNames);
    }
}
```

此代码片段来自示例 JUnit 测试，这是我们在方法前面的`@Test`注释的原因。 我们稍后会详细讨论。 要执行该测试，我们可以发出以下命令：

```
$ mvn -Dtest=SimplestStringListSortTest test
```

但是，此排序实现不符合我们的需求。 主要原因是我们想要学习新的东西。 使用 JDK 的`sort()`方法不教会您的任何新的，除，除了站在方法前面的`@Test`注释。

如果您在上一个代码中无法遵循的东西，那么您可以在本书中备份一些页面，并咨询 jdk 的 Oracle 在线文档（ [https://docs.oracle.com/javase/9​​/ docs / api /](https://docs.oracle.com/javase/9/docs/api/) ），但这一切都是。 你已经知道了这些东西。

您可能想知道为什么我为链接写了 Java Version 9 API 的 URL。 好吧，那么这就是诚实和真理的时刻 - 当我写这本书时，Java 11 JDK 没有以最终形式提供。 事实上，即使是 Java 10 JDK 也只是预先发布。 我在第一版中使用 Java 8 创建了 MacBook 上的大多数示例，我只测试了稍后的 Java 9,10 或 11 的功能。 当您阅读本书时，Java 11 将可用，因此您可以在 URL 中尝试从 9 到 11 的单个数字从 9 到 11 更改，并获取版本 11 的文档。此刻，我获取 HTTP 错误 404.有时，您 可能需要旧版本的文档。 您可以在 URL 中使用 3,4,5,6,7,8 或 10 而不是 11。 3 和 4 的文档无法在线阅读，但可以下载。 希望你永远不需要。 版本 5，也许。 当本书的第一版出版时，版本 6 仍然广泛应用于大型公司，从那时起，它并没有改变太多。

虽然您可以从其他程序员编写的阅读代码中学习很多，但我不建议在学习早期阶段尝试从 JDK 源代码中学习。 这些代码块大量优化，并不意味着是教程代码，而且它们陈旧。 他们不生锈，但他们没有重构，以遵循 java 的更新编码风格。 在某些地方，您可以在 JDK 中找到一些非常丑陋的代码。

好的，说我们需要开发一个新的`sort()`，因为我们可以从它中学习有点同学。 我们需要一个排序实现的真正原因是我们希望不仅可以对实现`Comparable`界面的某些东西的`List`数据类型和`List`的东西; 我们想要对一堆对象进行排序。 我们所要求的只是*束*包含对象提供了简单的方法，足以对它们进行排序并具有排序的*束*。

最初我想使用*集合*而不是*束*，但是 java 中有一个`Collection`界面，我想强调我们没有谈论`java.util.Collection` 对象。

我们也不希望对象实现`Comparable`界面。 如果我们要求对象实现`Comparable`接口，它可能会违反**单责任原理**（ **SRP** ）。

当我们设计一个类时，它应该在现实世界中建模一些对象类。 我们将使用类模拟问题空间。 该类应该实现代表对象 IT 模型行为的功能。 如果我们从第二章中查看学生的示例，那么`Student`类应该代表所有学生的特征，从建模的角度来看，所有学生的共享和*很重要。 a `Student`对象应该能够告诉学生的名称，年龄，去年的平均分数，等等。 但是，我们应该专注于与我们的编程需求相关的功能。 例如，所有学生都有脚，当然，这些脚的每个脚都有一个尺寸，所以我们可能认为`Student`类也应该实现一种返回学生脚大小的方法。 为了使其非常荒谬只是为了突出荒谬，我们可以实现数据结构和 API，以注册左脚的尺寸和右脚的不同尺寸。 我们不是因为脚的大小与模型的角度无关紧要。*

但是，如果我们要对包含`Student`对象的列表进行排序，`Student`类必须实现`Comparable`接口。 可是等等！ 你如何比较两个学生？ 按名称，按年龄或平均分数？

将一个学生与另一个学生进行比较不是`Student`课程的重要特征。 每个班级，或者对于那些物质，包，图书馆或编程单元，应该有一个责任，它应该只实施那个，没有别的。 这不是精确的。 这不是数学。 有时，很难判断特征是否适合该责任。 可比性可以是某些数据类型的固有特征，例如`Integer`或`Double`。 其他类没有这样一个固有的比较特征。

有简单的技术可以确定特征是否应该是或不应该是类的一部分。 例如，在学生的情况下，您可以向真人询问他们的名字和年龄，他们可能也可以告诉你他们的平均分数。 如果您向其中一个`compareTo`（另一名学生），如果`Comparable`界面需要这种方法，它们可能会通过什么属性或*询问如果他们不是礼貌类型，他们可以通过简单地说*回复什么？* （更不用说缩写 wtf，它代表了一周的最后三个工作日并且在这样的情况下很受欢迎。）在这种情况下，您可能怀疑实施该功能可能不在区域中 那个课程及其担忧; 应从原始类的实施中进行比较。 这也称为**偏析**，其与 SRP 密切相关。*

JDK 开发人员了解这一点。 `Collections.sort`，其对`Comparable`元素的`List`进行分类，不是该类中唯一的排序方法。 还有另一个，如果您通过第二个参数，则只能对任何`List`进行排序，这应该是实现`Comparator`界面的对象，并且能够比较`List`的两个元素。 这是一个干净的模式，以分离问题。 在某些情况下，不需要分离比较。 在其他情况下，它是可取的。 `Comparator`接口声明了实现类必须提供的单个方法 - `compare`。 如果两个参数相等，则该方法返回`0`。 如果它们是不同的，则应返回一个负面或阳性`int`，具体取决于哪个参数之前。

JDK 类中还有`sort`方法`java.util.Arrays`。 它们排序阵列或仅阵列的切片。 该方法是方法重载的一个很好的例子。 有些方法具有相同的名称，但具有不同的参数，为每个原始类型对每个原始类型进行排序，每个阵列为每个原始类型，以及实现`Comparable` interface 的对象阵列，以及用于对象阵列进行排序 使用`Comparator`。 如您所见，JDK 中有一系列排序实现，在 99％的情况下，您不需要实施自己。 排序使用相同的算法，稳定的合并排序有一些优化。

我们将实现的是一种常规方法，可以用于排序列表，数组或只是*，其中有元素我们可以在比较器的帮助下比较的元素，以及可以交换任何两个元素 。 我们将实现可以与这些接口一起使用的不同排序算法。*

# 各种排序算法的简要概述

有许多不同的排序算法。 正如我所说，有更简单和更复杂的算法，并且在许多情况下，更复杂的算法是运行更快的算法。 （毕竟，如果它在本章中运行速度速度速度速度较慢的复杂性算法将是什么？）我们将实施泡沫排序和 QuickSort。 我们已经在上一章中实现了一个泡沫的字符串，所以在这种情况下，实现将主要关注一般可排序对象排序的编码。 实现 Quicksort 将涉及一些算法兴趣。

被警告说，这部分是在这里给你一个味道复杂性的味道。 它远非精确，我在徒劳的希望希望没有数学家读到这一点，并对我施加诅咒。 一些解释是模糊的。 如果您想深入学习计算机科学，那么在阅读本书后，请查找其他其他书籍或访问在线课程。

当我们谈论一般排序问题时，我们考虑一些可以比较任何两种的对象的一般有序集合，而我们排序。 我们还假设这是一个适当的排序。 这意味着我们不会创建另一个列表或数组来以排序顺序收集原始对象。 当我们谈论算法的速度时，我们正在谈论一些抽象的东西而不是毫秒。 当我们想谈论毫秒的时候，实际的真实持续时间，我们应该已经在一个真实计算机上运行的一些编程语言进行了实现。

算法，在没有实施的抽象形式中，不要这样做。 尽管如此，值得谈论算法的时间和内存需求。 当我们这样做时，我们通常会调查算法如何针对大量数据的行为方式。 对于一小组数据，大多数算法都很快。 排序两个数字通常不是问题，是吗？

在排序的情况下，我们通常会检查是否需要进行多少比较来对其进行分类 *N* 元素。 泡沫分类需要大约 n <sup>2</sup> （ *n 倍 *n *n* ）比较。 我们不能说这正是** 2 <sup>2</sup> 所以，在 *n = 2* 的情况下，结果为 1，对于 *n = 3* 是 3，对于 *n = 4* ，它是 6 等。 然而，如 *n* 开始变大，所需的实际比较数和 *n* 2 <sup>2</sup> 将渐近地具有相同的值。 我们说，气泡排序的算法复杂性是 *o（n <sup>2</sup> ）*。 这也被称为大 o 表示法。 如果您有一个 *o 的算法（n <sup>2</sup> ）*并且它工作只需 1,000 个元素，请在一秒钟内完成，然后您应该期待相同的算法完成 100 万个元素 在十天到一个月。 如果算法是线性的，则说 *o（n）*，然后在一秒钟内完成 1,000 个元素，应导致您预期 1000 万秒以 1000 秒完成。 这比喝咖啡休息时间长，但午餐太短。

这使得如果我们想要一些严肃的商业排序对象，我们将需要比泡沫排序更好的东西。 许多不必要的比较不仅浪费我们的时间，而且还浪费了 CPU 力量，消费能源，并污染了环境。

但是，这个问题是一种排序的速度速度有多快？ 有没有能量减少的最低限度？

答案是肯定的，有一个可提供的最低限度。 这是非常有趣的，并且在我谦虚的意见中，每个 IT 工程师都不应该知道实际答案，也应该知道它背后的推理。 毕竟，*证明*的必要最小值是纯粹的信息。 以下是，再次不是数学证明，只是一种模糊的解释。

当我们实现任何排序算法时，实现将执行比较和元素互换。 这是排序对象集合的唯一方法，或者至少可以减少所有其他可能的方式都可以减少到这些步骤。 比较结果可以有两个值。 说这些值是 *0* 或 *1* 。 这是信息的一点。 如果比较结果是 *1* ，那么我们交换; 如果结果是 *0* ，那么我们不交换。

在开始比较之前，我们可以在不同的订单中拥有对象，并且不同订单的数量是 *n！* （ *n* 因子），即，数字乘以 1 到 *n* ，换句话说， *n！* = 1 * 2 * 3 * ... *（ *n* -1）* *n* 。

让我们假设我们将数字中的各个比较结果作为一系列比特为每个可能的输入存储。 现在，如果我们反转排序的执行并从排序的集合开始运行算法，并且使用描述比较结果的比特来控制交换，并且我们使用比特的另一种方式执行最后一次交换 首先在排序期间首先完成的，我们应该恢复对象的原始顺序。 这样，每个原始顺序都唯一地绑定到表示为位数组的数字。

现在，我们可以以这种方式表达原始问题 - 描述 *n* 阶段需要多少位？ 这正是我们需要对 *N 元素进行排序的比较次数。*

区分 *n 的比特数！* 数字是 *log <sub>2</sub> （n！）*。 使用一些数学，我们将知道 *log <sub>2</sub> （n！）*与 *log <sub>2</sub> （1）+ log <sub>2</sub> （2）+ ... + log <sub>2</sub> （n）*。 如果我们查看此表达式的渐近值，那么我们可以说这与 *__o（n * log n）__* 相同。 我们不应该期望任何一般排序算法更快。

对于特殊情况，算法较快。 例如，如果我们想要对一到 10 之间的每个数字进行排序，那么我们只需要计算不同的数字，然后创建包含许多那些，Two 等的集合。 这是一个 *O（n）*算法，但这并不是通常适用。

同样，这不是正式的数学证据。

# Quicksort.

Charles Antony Richard 爵士在 1959 年开发了 Quicksort 算法。它是一种典型的划分和征服算法。 这是它的方式。

要对长数组进行排序，请从阵列中选择一个元素，该元素将是所谓的枢轴元件。 然后，分区阵列使左侧将包含小于枢轴的所有元素，并且右侧将包含大于或等于枢轴的所有元件。 当我们开始分区时，我们不知道左侧的时间是多长时间，右侧将开始。 我们努力解决这一点的精确方式将很快解释。 现在，我们将有一个阵列划分的阵列，使得从数组开始到某个索引的元素均小于枢轴，并且从那里的元素到阵列的末尾都大于 枢。 这也具有简单的结果，左侧的元素均小于右侧的任何元素。 这已经是一个部分排序。 由于从阵列中选择了枢轴，因此保证两侧可以包含整个原始阵列，因此将另一侧留给另一侧是空数组。

完成此操作时，可以通过递归调用该排序来对阵列的左侧和右侧进行排序。 在这些调用中，子阵列的长度始终小于前一级的整个阵列。 当我们要排序的实际级别的数组段中有一个元素时，我们会停止递归。 在这种情况下，我们只能在没有比较或重新排序的情况下从递归呼叫返回; 一个元素显然总是排序。

当算法部分使用本身定义时，我们讨论递归算法。 最着名的递归定义是 Fibonacci 系列，0 和 1 对于前两个元素，以及所有以下元素， *N* TH 元素是（ *N-1* ） <sup xmlns:epub="http://www.idpf.org/2007/ops">TH</sup> 和（ *N-2* TH <sup xmlns:epub="http://www.idpf.org/2007/ops">TH</sup> 元件。 递归算法通常以现代编程语言实现，实现一种方法，这些方法有一些计算，但有时会呼叫自己。 在设计递归算法时，有一些阻止递归呼叫的东西至关重要; 否则，递归实现将分配可用于程序堆栈的所有内存，并在内存中运行，它将停止具有错误的程序。

算法的分区部分进行了以下方式 - 我们将开始使用从开始和结束的两个索引使用两个索引读取阵列。 我们将首先从索引开始，增加索引，直到它小于大索引，或者直到我们找到大于或等于枢轴的元素。 在此之后，我们将开始减少较大的指数，只要它大于小索引，并且元素索引大于或等于枢轴。 当我们停止时，我们会交换两个指数指向的两个元素。 如果指数不一样，我们将分别开始增加和减少小型和大指数。 如果索引是相同的，那么我们就完成了分区。 阵列的左侧是从开始到索引的索引，其中指数 MET 减去一个; 右侧以索引完成在待排序阵列的末尾开始。

此 Quicksort 算法通常消耗 *O（n log n）*时间，但在某些情况下，它可以降低到 *o（n <sup>2</sup> ）*，具体取决于如何 选择枢轴。 例如，如果我们选择阵列的段的第一个元素作为枢轴，并且阵列已经排序，则此 Quicksort 算法降低到简单的泡沫排序。 修改该枢轴有不同的方法。 在本书中，我们将使用最简单的 - 我们将选择可排序集合的第一个元素作为枢轴。

# 项目结构和构建工具

该项目此时间将包含许多模块。 我们仍将在本章中使用 Maven。 我们将在 Maven 设置一个所谓的多模块项目。 在这样的项目中，目录包含模块的目录和`pom.xml`。 此顶级目录中没有源代码。 此目录中的`pom.xml`文件服务以下两种目的：

*   它引用了模块，可用于编译，安装和部署所有模块在一起
*   它定义了所有它们的模块的参数

每一个`pom.xml`都有一个父级，这个`pom.xml`是模块目录中`pom.xml`文件的父级。 要定义模块，`pom.xml`文件包含以下行：

```
<modules>
    <module>SortSupportClasses</module>
    <module>SortInterface</module>
    <module>bubble</module>
    <module>quick</module>
    <module>Main</module>
</modules>
```

这些是模块的名称。 这些名称用作目录名称，也用作`pom.xml`模块中的`artifactId`。 此设置中的目录外观如下：

```
$ tree
   |-SortInterface
   |---src/main/java/packt/java189fundamentals/ch03
   |-bubble
   |---src
   |-----main/java/packt/java189fundamentals/ch03/bubble
   |-----test/java/packt/java189fundamentals/ch03/bubble
   |-quick/src/
   |-----main/java
   |-----test/java
```

# Maven 依赖管理

依赖项也在 POM 文件中发挥着重要作用。 以前的项目没有任何依赖关系。 这次我们将使用 JUnit，所以我们依靠 JUnit。 依赖项使用`dependencies`标记在`pom.xml`文件中定义。 例如，泡沫排序模块包含以下代码：

```
<dependencies>
    <dependency>
        <groupId>packt.java189fundamentals</groupId>
        <artifactId>SortInterface</artifactId>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
    </dependency>
</dependencies>
```

您可以下载的代码集中的实际`pom.xml`将包含多于此的代码。 在打印中，我们经常呈现一个版本或只有一小部分，有助于了解我们在该点讨论的主题。

它告诉 Maven 模块代码使用在存储库中可用的模块或库中定义的类，接口和`enum`类型。

当您使用 Maven 编译代码时，您的代码使用的库可从存储库中获取。 当蚂蚁开发时，尚未发明储存库的概念。 此时，开发人员将库的版本复制到源代码结构中的文件夹中。 通常，`lib`目录用于此目的。

这种方法有两个问题。 一个是源代码存储库的大小。 例如，如果是 100 个不同的项目使用 JUnit，那么 JUnit 库的 JAR 文件已被复制 100 次。 另一个问题正在收集所有图书馆。 当库使用另一个库时，开发人员必须阅读库文档，该文档描述了使用此库所需的其他库。 这经常过时，不准确。 这些库必须以相同的方式下载和安装。 这是耗时和错误的。 当库丢失并且开发人员没有注意到它时，在编译时出现错误。 如果依赖项只有运行时可检测到，则 JVM 无法加载该类。

要解决此问题，Maven 附带内置的存储库管理器客户端。 存储库是包含库的存储。 由于存储库中可以存在其他类型的文件，而不仅仅是库，Maven 术语是 *Artifact* 。 `groupId`，`artifactId`和`version`数字识别伪像。 有一个非常严格的要求，伪像只能放入存储库一次。 即使在上载错误版本后识别的发布过程中存在错误，也不能覆盖伪像。 对于相同的`groupId`，`artifactId`和`version`，只能有一个永远不会改变的单个文件。 如果出现错误，则使用新版本号创建一个新的伪像，并且可能会删除错误的工件但从未替换。

如果版本号以`-SNAPSHOT`结尾，则不保证或需要此唯一性。 快照通常存储在单独的存储库中，并未向世界发布。

存储库包含以定义方式组织的目录中的文物。 当 Maven 运行时，它可以使用`https`协议访问不同的存储库。

以前，还使用`http`协议。 对于非支付客户（例如 FOSS 开发人员），中央存储库仅通过`http`可用。 但是，发现从存储库下载的模块可以通过中间人安全攻击来定位，因此 SONATYPE（ [http://www.sonatype.com](http://www.sonatype.com) ）更改了策略使用 `https`仅限协议。 切勿使用`https`协议配置或使用存储库，并不信任通过 HTTP 下载的文件。

开发人员的计算机上有一个本地存储库，通常在`~/.m2/repository`目录中。 在 Windows 上，用户的主目录通常是`C:\Users\your_username`。 在 UNIX 操作系统上，Shell 是 Windows 命令提示符应用程序的 shell，使用`~`字符引用此目录。 发出`mvn install`命令时，maven 在此存储创建的工件。 Maven 在通过 **https** 中从存储库下载时，Maven 还在这里存储了一个神器。 这样，随后的编译不需要向网络进行伪影。

公司通常设置自己的存储库经理。 这些应用程序可以被配置为与几个其他存储库通信，并根据需要，从那里收集伪像，基本上实现代理功能。 工件从远端存储库到构建，从分层结构到较近的，到本地回购，并且基本上在最终的工件中，如果项目的包装类型是`war`，`ear`，或一些 其他格式包含从属伪影。 这基本上是文件缓存而无需重新验证和缓存驱逐。 这可以是因为从未被替换的伪影是这样做的。

如果`bubble`项目是独立项目而不是多模块的项目，那么依赖项会如下所示：

```
<dependencies>
    <dependency>
        <groupId>packt.java189fundamentals</groupId>
        <artifactId>SortInterface</artifactId>
        <version>1.0.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
</dependencies>
```

如果`version`依赖项没有定义，Maven 将不能够识别神器使用。 在多模块项目的情况下，`version`可在父定义和模块继承的版本。 因为父母不依赖于实际的神器，它应该只定义连接到版本`groupId`和[HTG3。 因此，XML 标记不是`dependencies`，而是在顶层`project`标签中`ddependencyManagement/dependencies`，如下例所示：

```
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>packt.java189fundamentals</groupId>
            <artifactId>SortSupportClasses</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>packt.java189fundamentals</groupId>
            <artifactId>SortInterface</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>packt.java189fundamentals</groupId>
            <artifactId>quick</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

当模块想要使用`junit`时，它们无需指定版本。 它们将从定义为 4.12 的父项目中获取它，这是 *JUnit 4* 的最新项目。 如果有以前是一个新版本，4.12.1，用一些严重的错误修复，那么修改版本号的唯一位置是父 POM，并且当 Maven 执行下一个时，模块将使用新版本。

当项目开发人员决定使用新的 *JUnit 的 5 HTG3]版本，但是，所有的模块将被修改，因为 *JUnit 的 5 HTG5]不只是一个新的版本。 *JUNIT 5* 与旧版本 4 显着不同，它分为多个模块。 这样，`groupId`和`artifactId`也会改变。**

值得注意的是，从`SortInterface`模块实现接口的模块最终取决于模块。 在这种情况下，该版本定义如下：

```
<version>${project.version}</version>
```

这似乎有点是张力学（它实际上是）。 `${project.version}`属性是项目的版本，`SortInterface`模块继承此值。 这是其他模块依赖的工件的版本。 换句话说，模块始终取决于我们当前正在开发的版本。

# 编码这类

要实现排序，首先，我们将定义库应实现的接口。 在实际编码之前定义界面是一个很好的做法。 当有许多实现时，有时建议首先创建一个简单的，并开始使用它，以便在此开发阶段期间界面可以发展，并且当更复杂的实现到期时，界面已经固定。 实际上，没有任何东西是有的因编程中没有 Archimedean 点。

# 创建接口

我们案例中的界面非常简单：

```
public interface Sort {
    void sort(Sortable collection);
}
```

界面应该只做一件事，排序可排序的东西。 因此，我们定义一个接口和实现此接口的任何类将是`Sortable`：

```
public interface Sortable {
}
```

# 创造冒泡

现在，我们可以开始创建实现`Sort`界面的泡沫排序：

```
 ...
import java.util.Comparator;

public class BubbleSort implements Sort, SortSupport {
    @Override
    public void sort(Sortable collection) {
        var n = collection.size();
        while (n > 1) {
            for (int j = 0; j < n - 1; j++) {
                if (comparator.compare(collection.get(j),
                        collection.get(j + 1)) > 0) {
                    swapper.swap(j, j + 1);
                }
            }
            n--;
        }
    }
 ...
```

通常，该算法需要两个操作。 我们实现了一个特定于`String`数组的那些 - 比较两个元素并交换两个元素。 然而，这次排序实现本身不知道它应该排序的类型。 它还不知道如何存储元素。 它可以是阵列，列表或其他东西。 所有它都知道它可以比较元素，也可以交换两个元素。 如果提供这些，则排序工作。

在 Java 项中，它需要一个能够比较两个元素的`comparator`对象，并且需要一个能够在集合中交换两个元素的`swapper`对象。

排序对象应该可以访问这些对象。 有两个领域，参考这些对象是它的完美解决方案。 唯一的问题是字段如何获得对比较和交换对象的引用。 我们现在遵循的解决方案是我们提供了可用于将这些依赖项注入排序对象的 Setter。

这些定居者不具体到泡沫分类算法。 这些是相当一般的; 因此，定义泡沫排序可以实现的界面是有意义的：

```
public interface SortSupport {
    void setSwapper(Swapper swap);

    void setComparator(Comparator compare);
}
```

和`BubbleSort`类的实现只是以下代码：

```
    private Comparator comparator = null;

    @Override
    public void setComparator(Comparator comparator) {
        this.comparator = comparator;
    }

    private Swapper swapper = null;

    @Override
    public void setSwapper(Swapper swapper) {
        this.swapper = swapper;
    }
```

`@Override`向 Java 编译器注释信号，该方法是该方法覆盖父类的方法，或者在这种情况下，接口的方法。 没有这种注释的方法可以覆盖父方法; 但是，如果我们使用注释，如果该方法不覆盖，则编译失败。 这有助于您在编译时发现在父类或界面中更改的时间内，我们没有遵循实施的变化，或者我们刚刚犯了一些错误，以考虑我们实际上没有。 由于注释在单元测试中使用了大量使用，我们将在稍后更详细地讨论注释。

这也意味着我们需要两个新的接口 - `Swapper`和`Comparator`。 我们很幸运地，Java 运行时已经定义了一个只适合该目的的`Comparator`界面。 您可能会从以下导入语句中猜到：

```
import java.util.Comparator;
```

当您需要非常基本的东西时，例如`Comparator`接口，最可能在运行时定义。 建议在编写自己的版本之前查阅运行时。 但是，我们将必须创建`Swapper`界面：

```
public interface Swapper {
    void swap(int i, int j);
}
```

因为它用于交换`Sortable`中指数指定的两个元素，有一种方法，非常明显地命名为`swap`，以此目的。 但我们还没有准备好。 如果您尝试编译前述代码，则编译器将抱怨`get`和`get`方法。 算法需要它们来实现排序，但它们并不是分类本身的一部分。 这是一个不应在此类中实现的功能。 由于我们不知道我们将排序的类型类型，因此不仅是不可取的，而且不可能在排序中实现这些方法。 似乎我们只是无法对任何东西进行解决。 我们将必须设置一些限制。 排序算法必须知道我们排序的集合大小，也应该通过索引访问元素，以便它可以将其传递到比较器。 这些似乎是我们通常可以与之住的相当合理的制约因素。

这些限制在`Sortable`界面中，我们刚刚留空，不知道在第一次排序实施之前是必需的：

```
public interface Sortable {
    Object get(int i);
    int size();
}
```

现在，我们准备好接口和实现，我们可以继续测试代码。 但是，在此之前，我们将简要重新重申我们所做的事情以及为什么我们这样做。

# 建筑考虑因素

我们创建了一个界面和简单实现。 在实施过程中，我们发现接口需要支持算法所需的其他接口和方法。 这通常在执行之前在代码的架构设计期间发生。 对于教学原因，我在开发代码时遵循接口的积累。 在现实生活中，当我创建接口时，我在一步中创建了它们，因为我有足够的经验。 我在 1983 年在 Fortran 撰写了我的第一个 Quicksort 代码。 然而，这并不意味着我只用任何问题击中靶心并与最终解决方案出来。 它只是发生这种情况是一个太众所周知的问题。 如果您需要在开发期间修改您设计的接口或其他方面，请不要感到尴尬。 随着时间的推移，它是一种自然的后果和证据，你更好地了解事情。 如果架构需要改变，最好做到不是，而且更擅长。 在现实生活中的企业环境中，我们将在开发期间设计界面，以便我们忘记了一些方面。 它们比排序集合更复杂的操作。

在分拣问题的情况下，我们抽象了*的东西*我们想要排序到最可能的极端。 Java 内置排序可以对数组或列表进行排序。 如果要对列表或数组进行排序，则必须创建一个具有超过 24 种方法的类，它需要通过 jdk 排序来包装它需要超过 24 种方法。 24 种方法似乎是很多只是让我们的*某种东西*可供选择。 说实话，这并不是太多，在一个真实的项目中，我会认为是一种选择。

我们不知道，也不知道，接口的内置排序用途是什么方法。 应该在功能上实现的那些，它可以包含不包含的简单`return`语句，因为它们刚从从未调用。 开发人员可以咨询 JDK 的源代码，并查看实际使用的方法，但这不是搜索实现的合同。 它不保证新版本仍将使用*这些方法。 如果一个新版本开始使用我们用单个`return`语句实现的方法，那么排序将神奇地，并且恶劣失败。*

它也是一个有趣的性能问题，如何通过仅使用`List`接口来实现两个元素的交换。 `List`接口中没有`put(int, Object)`方法。 存在`add(int, Object)`，但插入一个新元素，如果对象存储在例如磁盘上，则可能是非常昂贵的（刻录 CPU，磁盘，能量）以推动列表的所有元素。 此外，下一步骤可以在我们刚插入的那个之后移除元件，从而执行再次移动列表尾部的昂贵过程。 这是`put(int, Object)`的琐碎实施。 排序可能或可能不遵循它。 同样，这是不应该假设的。

当您使用 JDK，开源或商业库中的库，类和方法时，您可以参考源代码，但您不应该依赖于实现。 您应该依赖于合同和图书馆附带的 API 的定义。 当您从某些外部库中实现接口时，您无需实施其中的某些部分，并创建一些虚拟方法，请感受空气中的危险。 这是一种伏击。 图书馆的质量差或者你不明白如何使用它很可能。 我不知道哪个是更糟糕的。

在我们的情况下，我们分开了交换和与排序的比较。 该集合应实施这些操作并为这些操作提供。 合同是界面，并使用排序，您必须实现我们定义的接口的所有方法。

`SortSupport`的界面定义设置`Swapper`和`Comparator`的 Setter。 具有这些方式的依赖项可能导致创建实现`Sort`和`SortSupport`接口的类的新实例的代码，但在调用`Sort`之前未设置`Swapper`和`Comparator`。 这将导致`NullPointerException`第一次调用`Comparator`（或者在执行此处调用的情况下调用`Swapper`时，这是不太可能的，但可能的）。 调用方法应该在使用类之前注入依赖项。 通过定居者完成，它被称为 **Setter 注入**。 当我们使用 Spring，Guice 或其他一些容器等框架时，此术语很大。 创建这些服务类并将实例注入我们的类中一直相似。

容器实现以一般方式包含功能，并提供配置选项以配置要将哪些实例注入其他对象。 通常，这导致更短，更灵活，更可读的代码。 但是，依赖注入不是容器的排他性。 当我们在下一节中编写测试代码并调用定居者时，我们实际上可以手动进行依赖项。

还有另一种依赖注入方法，避免了未设置的依赖性问题。 这称为**构造函数注射**。 在这种情况下，依赖项通常是没有值的`final private`字段。 请记住，这些字段应在完全创建对象时获得最终值。 构造函数注入将注入的值传递给构造函数作为参数，构造函数设置字段。 这样，可以保证字段的构建对象时设置。 然而，该注射不能在接口中定义，这可能在某些应用中可能不是问题。

现在，我们已经有了代码，我们知道如何创建接口的考虑因素。 这是做一些测试的时间。

# 创建单元测试

当我们编写代码时，我们应该测试它。 在至少做一些测试运行之前，没有代码已经进入生产。 （认识到讽刺！）有不同的测试水平，具有不同的目标，技术，行业实践和名称。

单位测试，顾名思义，测试代码单位。 集成测试测试单位如何集成在一起。 烟雾测试测试一组有限的功能，只是为了看到代码并不完全损坏。 还有其他测试，直到最终测试，这是工作的证明 - 用户验收测试。 布丁的证据是在吃饭中。 如果用户接受它，则代码很好。

很多时候，我告诉初中的名字用户验收测试是有点误导，因为它不是接受项目结果的用户，而是客户。 根据定义，客户是支付账单的人。 专业发展是支付的; 否则，它不是专业的。 但是，术语是用户验收测试。 只有在用户可以使用该程序时，客户才会发生客户接受该项目。

当我们在 Java 中开发时，一个单位测试测试独立类。 换句话说，在 Java 开发中，当我们谈论单元测试时，单位是一个类。 提供单位测试，我们通常使用 JUnit 库。 还有其他图书馆，如 testng，但 JUnit 是最广泛使用的，所以我们将使用 *JUnit* 。 要将其用作库，首先，我们将必须将其添加到 Maven Pom 作为依赖项。

# 将 JUNIT 添加为依赖项

回想一下，我们有一个多模块项目，依赖版本在`dependencyManagement`标签中父 POM 保持：

```
<dependencyManagement>
    <dependencies>
        ...
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

依赖的范围是`test`，这意味着需要此库仅在执行测试期间编译测试代码。 JUNIT 库无法进入最终发布的产品; 没有必要。 如果您在某些部署的生产中找到 JUnit 库 **Web Archive** （ **WAR** ）或**企业归档**（ **EAR** ）文件，可疑是某人 没有正确管理图书馆的范围。

Maven 支持汇编和在项目生命周期中的 JUnit 测试执行。 如果我们只想仅执行测试，我们应该发出`mvn test`命令。 IDE 还支持执行单元测试。 通常，可以使用相同的菜单项来执行具有`public static main()`方法的类。 如果类是利用 JUNIT 的单元测试，则 IDE 将识别并执行测试，并且通常会给哪些测试执行罚款的图形反馈，并且哪些故障，以及如何失败。

# 写下泡沫的阶级

测试类与生产类分开。 他们进入`src/test/java`目录。 当我们有一个名为的类时，例如`BubbleSort`，那么测试将命名为`BubbleSortTest`。 此公约有助于执行环境将测试与不包含测试的类别分离，但是需要执行测试。 要测试我们刚刚创建的排序实现，我们可以提供包含的类，目前单个`canSortStrings`方法。

单元测试方法名称用于记录正在测试的功能。 由于 JUnit 框架调用了具有`@Test`注释的每个方法，测试名称未在我们的代码中的任何位置引用。 我们可以勇敢地使用任意的长方法名称; 它不会阻碍调用方法的地方的可读性：

```
package packt.java189fundamentals.ch03.main.bubble.simple;

// import statements are deleted from the print for brevity

public class BubbleSortTest {
    @Test
    public void canSortStrings() {
        var actualNames = new ArrayList(Arrays.asList(
            "Johnson", "Wilson",
            "Wilkinson", "Abraham", "Dagobert"
        ));
```

该方法包含一个`ArrayList`，具有我们已经熟悉的实际名称。 由于我们有一个需要`Sortable`的排序和接口，我们将通过`ArrayList`创建一个备份：

```
var names = new Sortable() {
    @Override
    public Object get(int i) {
        return actualNames.get(i);
    }
    @Override
    public int size() {
        return actualNames.size();
    }
};
```

我们声明了一个具有`Sortable`类型的新对象，它是一个接口。 要实例化实现`Sortable`的东西，我们需要一个课程。 我们无法实例化接口。 在这种情况下，在实例化的位置定义类。 这被称为 Java 中的匿名类。 名称来自源代码中未定义新类的名称。 Java 编译器将自动为新类创建一个名称，但程序员对该类别不有趣。 我们将简单地写`new Sortable()`并立即提供所需的实现，在`{`和`}`之间进行。 在方法内定义此匿名类非常方便，以这种方式，它可以访问`ArrayList`而不传递类中的`ArrayList`。

事实上，需要参考，但 Java 编译器会自动执行此操作。 在这种情况下，Java 编译器还注意到这种方式的自动参考可以使用初始化的变量来完成，并且在匿名类的实例化之后在执行代码期间不会改变。 设置`actualNames`变量，稍后不应在方法中更改。 事实上，我们甚至可以将`actualNames`定义为`final`，如果我们使用 Java 1.7 或更早版本，这将是一个要求。 从 1.8 开始，要求是该变量是有效的最终的，我们可以跳过`final`声明。

我们需要的下一件事是`ArrayList`的`Swapper`实现。 在这种情况下，我们将在方法内定义一个整个类。 它也可能是一个匿名类，但这时间我决定使用命名类来演示类可以在方法内定义类。 通常，我们在生产项目中没有这样做：

```
class SwapActualNamesArrayElements implements Swapper {
    @Override
    public void swap(int i, int j) {
        final Object tmp = actualNames.get(i);
        actualNames.set(i, actualNames.get(j));
        actualNames.set(j, tmp);
    }
}
;
```

最后，但并非最不重要的是，我们需要一个比较器，然后我们可以调用排序。 正如我们要比较的`String`，这很简单且简单：

```
Comparator stringCompare = new Comparator() {
    @Override
    public int compare(Object first, Object second) {
        final String f = (String) first;
        final String s = (String) second;
        return f.compareTo(s);
    }
};
```

拥有为排序准备的一切，我们最终需要一个`Sort`实现的实例。 我们必须设置`Sort`和`Sort`，最后，我们调用排序：

```
var sort = new BubbleSort();
sort.setComparator(stringCompare);
sort.setSwapper(new SwapActualNamesArrayElements());
sort.sort(names);
```

测试的最后一个但最重要的部分是断言结果是我们期望的结果。 JUNIT 帮助我们借助`Assert`课程：

```
Assert.assertEquals(List.of(
    "Abraham", "Dagobert",
    "Johnson", "Wilkinson", "Wilson"
), actualNames);
```

调用`assertEquals`检查第一个参数，预期结果等于第二个参数，排序`actualNames`。 如果它们有所不同，则抛出`AssertionError`; 否则，测试只需精细完成。

# 好单位测试

这是一个很好的单位测试吗？ 如果您在这样的教程书中阅读它，则必须是。 实际上，它不是。 这是一个很好的代码，用于演示 JUnit 提供的一些工具和一些 Java 语言功能，但我不会在专业项目中使用它。

是什么让单位测试好？ 要回答这个问题，我们必须定义用于使用哪些单位测试。 单元测试服务了两个目的。 单元测试的目的是验证单位的正常运行并记录它。

单元测试不用于查找错误。 开发人员最终在调试会话期间使用单元测试，但多次，为调试创建的测试代码是临时的。 当错误修复时，用于查找它的代码将不会进入源代码存储库。 对于每个新的错误，应该有一个创建的新测试，涵盖了未正确工作的功能，但几乎不是用于查找错误的测试代码。 这是因为单元测试主要用于文档。 您可以使用 *javadoc* 记录一个类，但体验显示文档通常已过时。 开发人员修改代码，但它们不会修改文档。 该文件变得过时和误导。 单元测试，然而，通过构建系统执行，如果**持续集成**（ **CI** ）在使用（它应该是，在专业环境中），那么构建将 如果测试失败，则被打破。 所有开发人员都会收到关于它的邮件通知，它将驱动开发人员打破构建以修复代码或测试。 这样，测试在持续积分期间验证代码没有被损坏，至少不是可以使用单元测试发现的东西。

# 一个好的单元测试是可读的

我们的测试远非可读。 如果您查看它，并且在 15 秒内，可以读取一个测试用例，您可以告诉它所的内容。 当然，它假设 Java 代表读者的一些经验，但你得到了这一点。 我们的测试杂乱无章，支持类不是测试的核心。

我们的测试也几乎没有验证代码正常工作。 它实际上没有。 我有一些错误，我谨慎地放在那里，我们将在以下部分中找到和 zap。 对单个`String`阵列进行排序的单个测试远远不验证排序实现。 如果我要将此测试扩展到真实的测试，我们需要具有名称`canSortEmptyCollection`，`canSortOneElementCollection`，`canSortTwoElements`，`canSortReverseOrder`或`canSortAlreadySorted`的方法。 如果您查看名称，您将看到我们需要的测试。 来自排序问题的性质，在这些特殊情况下，实施可能合理敏感。

我们的单位测试中有哪些好点，除了是一个可接受的演示工具之外吗？

# 单元测试很快

我们的单元测试速度快。 当我们每次执行单元测试时，CI 都会击中构建并执行测试的执行不应该持续很长时间。 您不应该创建一个单元测试分类数十亿元素。 这是一种稳定性测试或负载测试。 它们应该在单独的测试期间运行，而不是每次构建运行时都不运行。 我们的单位测试排序五个元素，这是合理的。

# 单元测试是确定性的

我们的单位测试是确定性的。 非确定性单元测试是开发人员的噩梦。 如果您在某些组织在 CI 服务器上打破的组中，并且在构建休息时，您的 Coveleer 表示您只需再次尝试; 没门！ 如果一个单元测试运行，它应该始终运行。 如果失败，它不应该失败，无论您开始多少次。 在我们的情况下，一个非确定性单元测试将是呈现随机数并将其分类。 它最终会在每个测试运行中结束不同的数组，如果有一些阵列的代码中存在一些错误，我们将无法重现它。 更不用说断言确保代码运行罚款也难以生产。

如果我们在单元测试中对随机数组进行了排序（我们没有的东西），我们可以在假设上断言阵列被排序，并将元素进行比较，另一个检查它们以升序为单位。 这也是一个完全错误的做法。

# 断言应该尽可能简单

如果断言是复杂的，则在断言中引入错误的风险更高。 断言越复杂，风险越高。 我们编写单元测试以缓解我们的生活，而不是有更多的代码来调试。

此外，一个测试应该只宣称一件事。 这一个断言可以用多个`Assert`类方法编码，一个之后另一个。 尽管如此，这些目的是断言本机的一个单一特征的正确性。

记住 SRP-One 测试，一个功能。 一个好的测试就像一个好的狙击手 - 一枪，一次杀人。

# 单位测试是孤立的

当我们测试单位 *a* 时，另一个单元 *b* 或不同单位中的错误的任何变化都不应影响我们为单位 *a* 的单元测试 。 在我们的案例中，很容易，因为我们只有一个单位。 后来，当我们开发 Quicksort 的测试时，我们会看到这种分离并不那么简单。

如果单位测试正确分开，则故障单位测试明确指出问题的位置。 它位于单元测试失败的单元中。 如果测试不分隔单位，则一个测试中的失败可能是由不同单元中的错误引起的，而不是我们预期的错误。 在这种情况下，这些测试不是真正的单元测试。

在实践中，您应该进行平衡。 如果单位的隔离将太昂贵，您可以决定创建集成测试; 并且，如果它们仍然快速运行，请将它们由 *CI 系统*执行。 与此同时，您还应该尝试找出孤立很难的原因。 如果您不能轻易隔离测试中的单位，则意味着单位太大耦合，这可能不是一个很好的设计。

# 单元测试涵盖代码

单元测试应对所有特殊情况进行测试，也应对功能进行测试。 如果单元测试未涵盖的特殊代码，则代码处于危险之中。 在实现实施的情况下，常规案例是排序，例如五个元素。 通常情况下，特殊情况要多得多。 如果只有一个元素或没有元素，我们的代码是如何行动的？ 如果有两个人怎么办？ 如果元素以相反的顺序是多少？ 如果他们已经被分类了怎么办？

通常，特殊情况下未在规范中定义。 程序员必须在编码之前思考它，并且在编码期间发现了一些特殊情况。 很难的是，你无法判断你是否涵盖了所有特殊情况和代码的功能。

您可以说的是在测试期间是否在测试期间执行所有代码行。 如果在测试期间执行 90％的代码行，则代码覆盖率为 90％，这在现实生活中相当擅长，但您永远不应该满足于任何小于 100％的内容。

代码覆盖与功能覆盖范围不同，但存在相关性。 如果代码覆盖率小于 100％，则以下两个语句中的至少一个是真的：

*   功能覆盖率不是 100％。
*   测试单元中有一个未使用的代码，可以删除它。

可以测量代码覆盖，但功能覆盖范围合理不能。 工具和 IDE 支持代码覆盖率测量。 这些测量被集成到编辑器中，因此您不仅会获得覆盖范围的百分比，但编辑器将究竟暗示覆盖范围暗示哪条线（例如，在 Eclipse）或左边的排水室内显示哪些行 编辑窗口的一侧（Intellij）。 以下屏幕截图显示，在 Intellij 中，测试涵盖了在沟槽上的绿色指示的线条（在打印版中，这只是一个灰度矩形）：

![](img/fa86348e-53d3-4375-a989-902a07ae18cb.png)

# 重构测试

现在我们已经讨论了一个好的单元测试是什么，让我们改善我们的测试。 第一件事是将支持类移动到单独的文件。 我们将创建`ArrayListSortable`：

```
package packt.java189fundamentals.ch03.main.bubble.simple;

import packt.java189fundamentals.ch03.Sortable;

import java.util.ArrayList;

public class ArrayListSortable implements Sortable {
    final private ArrayList actualNames;

    ArrayListSortable(ArrayList actualNames) {
        this.actualNames = actualNames;
    }

    @Override
    public Object get(int i) {
        return actualNames.get(i);
    }

    @Override
    public int size() {
        return actualNames.size();
    }
}
```

此类封装`ArrayList`，然后实现`gets`和`size`方法到`ArrayList`访问。 `ArrayList`本身被声明为`final`。 回想一下，必须通过构造函数结束的时间来定义`final`字段。 这保证了当我们开始使用该对象时存在该字段，并且它在对象生命周期中不会更改。 但是，注意，对象的内容，在这种情况下，可以改变`ArrayList`的元素。 如果不是这种情况，我们将无法对其进行排序。

下一个类是`StringComparator`。 这是如此简单，我不会在这里列出; 我会将其留给您实现可以比较两个`Strings`的`java.util.Comparator`界面。 它不应该困难，特别是因为这个课程已经已经是`BubbleSortTest`类的前一个版本的一部分（提示 - 它是我们存储在命名为`stringCompare`的变量中的匿名类。

我们也必须实施`ArrayListSwapper`，这也不应该是一个大惊小怪：

```
package packt.java189fundamentals.ch03.main.bubble.simple;

import packt.java189fundamentals.ch03.Swapper;

import java.util.ArrayList;

public class ArrayListSwapper implements Swapper {
    final private ArrayList actualNames;

    ArrayListSwapper(ArrayList actualNames) {
        this.actualNames = actualNames;
    }

    @Override
    public void swap(int i, int j) {
        Object tmp = actualNames.get(i);
        actualNames.set(i, actualNames.get(j));
        actualNames.set(j, tmp);
    }
}
```

最后，我们的测试会看这个：

```
@Test
public void canSortStrings2() {
    var actualNames = new ArrayList(List.of(
        "Johnson", "Wilson",
        "Wilkinson", "Abraham", "Dagobert"
    ));
    var expectedResult = List.of(
        "Abraham", "Dagobert",
        "Johnson", "Wilkinson", "Wilson"
    );
    var names = new ArrayListSortable(actualNames);
    var sort = new BubbleSort();
    sort.setComparator(new StringComparator());
    sort.setSwapper(new ArrayListSwapper(actualNames));
    sort.sort(names);
    Assert.assertEquals(expectedResult, actualNames);
}
```

现在，这已经是一个可以在 15 秒内理解的测试。 它如何使用我们定义的一种实现方式。 它仍然运行，到目前为止没有透露任何错误。

# 收藏品错误

一个错误不是微不足道的，并且像往常一样，这不是在实现算法的实现中，而是在定义中或缺少它。 如果我们排序的集合中不仅有字符串，程序应该做什么？

如果我创建一个以下行开头的新测试，它将抛出`ClassCastException`：

```
@Test(expected = ClassCastException.class)
public void canNotSortMixedElements() {
    var actualNames = new ArrayList(Arrays.asList(
        42, "Wilson",
        "Wilkinson", "Abraham", "Dagobert"
    ));
    //... the rest of the code is the same as the previous test
```

这里的问题在于 Java 集合可以包含任何类型的元素。 您不能确保一个集合（例如`ArrayList`）仅包含您期望的类型。 即使您使用泛型（我们将在本章中了解），这种错误的机会较小，但它仍然存在。 不要问我如何; 我不能告诉你。 这是错误的性质 - 你不能告诉他们如何工作，直到你 zap 它们。 事情是你必须为这种特殊情况做好准备。

# 处理例外

应使用异常在 Java 中处理特殊情况。 存在`ClassCastException`，并且当排序尝试使用`StringComparator`将`String`与`Integer`进行比较，并执行此操作，它试图将`Integer`施加到`String`。

当程序使用`throw`命令或通过 java 运行时抛出异常时，程序的执行在该点处停止，而不是执行下一个命令，而不是执行异常捕获的位置。 它可以是相同的方法，或者在呼叫链中的一些调用方法。 要捕获异常，则抛出异常的代码应该在`try`块中，而`try`块后面的 catch 语句应指定与抛出异常兼容的异常。

如果未捕获异常，则 Java 运行时将打印出异常的消息以及将包含在异常时调用堆栈上的所有类，方法和行号的堆栈跟踪。 在我们的情况下，如果我们删除`@Test`注释的`(expected = ClassCastException.class)`参数，则测试执行将在输出中产生以下跟踪：

```
packt.java189fundamentals.ch03.main.bubble.simple.NonStringElementInCollectionException: There are mixed elements in the collection.

        at packt.java189fundamentals.ch03.main.bubble.simple.StringComparator.compare(StringComparator.java:13)
        at packt.java189fundamentals.ch03.main.bubble.BubbleSort.sort(BubbleSort.java:17)
        at packt.java189fundamentals.ch03.main.bubble.simple.BubbleSortTest.canNotSortMixedElements(BubbleSortTest.java:108)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:564)
        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
        at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
        at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
        at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
        at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
        at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
Caused by: java.lang.ClassCastException: java.base/java.lang.Integer cannot be cast to java.base/java.lang.String
        at packt.java189fundamentals.ch03.main.bubble.simple.StringComparator.compare(StringComparator.java:9)
        ... 24 more
```

这个堆栈迹线并不是很长的。 在生产环境中，在运行在应用程序服务器上的应用程序中，堆栈跟踪可能包含几百个元素。 在这条迹象中，您可以看到 Intellij 正在启动测试执行涉及 JUnit Runner，直到我们通过测试到比较器，其中抛出实际异常。

这种方法的问题是真正的问题不是类铸造失败。 实际问题是该集合包含混合元素。 它只通过 Java 运行时实现了试图施放两个不兼容的类时。 我们的代码可能更聪明。 我们可以修改比较者：

```
public class StringComparator implements Comparator {

    @Override
    public int compare(Object first, Object second) {
        try {
            final String f = (String) first;
            final String s = (String) second;
            return f.compareTo(s);
        } catch (ClassCastException cce) {
            throw new NonStringElementInCollectionException(
                "There are mixed elements in the collection.", cce);
        }
    }
}
```

此代码捕获`ClassCastException`并抛出一个新的。 抛出新例外的优势在于您可以确定从比较器抛出此异常，并且问题确实是收集中有混合元素。 课堂铸造问题可能会在代码的其他地方发生。 某些应用程序代码可能希望捕获异常并希望处理案例; 例如，发送特定于应用程序特定的错误消息，而不是仅向用户转储堆栈跟踪。 此代码也可以捕获`ClassCastException`，但无法确定异常的真正原因是什么。 另一方面，`NonStringElementInCollectionException`是明确的。

`NonStringElementInCollectionException`是 JDK 中不存在的异常。 我们必须创建它。 例外是 Java 类，我们的异常如下所示：

```
package packt.java189fundamentals.ch03.main.bubble.simple;

public class NonStringElementInCollectionException extends RuntimeException {
    public NonStringElementInCollectionException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

Java 有检查异常的概念。 这意味着应该在方法定义中声明任何未扩展`RuntimeException`（直接或间接）的任何异常。 假设我们的例外被宣布如下：

```
package packt.java189fundamentals.ch03.main.bubble.simple;

public class NonStringElementInCollectionException extends Exception {
    public NonStringElementInCollectionException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

然后，我们可以如下声明`compare`方法：

```
public int compare(Object first, Object second) throws NonStringElementInCollectionException
```

问题是，方法抛出的例外是方法签名的一部分，这种方式，`compare`不会覆盖接口的`compare`方法，那样，该类将无法实现`Comparator`接口。 因此，我们的例外必须是运行时异常。

应用程序中可以存在例外异常，通常，新手程序员创建了巨大的层次结构。 如果有的东西可以做到，这并不意味着你应该这样做。 等级结构应尽可能平整，但例外情况尤其如此。 如果 jdk 中有一个例外描述了您的例外情况，请使用现成的异常。 这有效以及任何其他类 - 如果它已准备就绪，请勿再次实现。

同样重要的是要注意抛出异常，只能在特殊情况下完成。 它不是为了发出一些正常的运行条件。 这样做妨碍了代码的可读性，也可以消耗 CPU。 抛出异常对 JVM 来说不是一件简单的任务。

它不仅是可以抛出的例外。 `throw`命令可以抛出，并且`catch`命令可以捕获扩展`Throwable`类的任何东西。 `Throwable` - `Error`和`Exception`有两个子类。 如果在执行 Java 代码期间发生了某些错误，则抛出`Error`。 最臭名昭着的错误是`OutOfMemoryError`和`StackOverflowError`。 如果发生其中任何一个，您不能可靠地执行任何操作以捕捉它们。

在 JVM 中还有`InternalError`和`UnknownError`，但由于 JVM 相当稳定，因此您几乎不会达到这些错误。

这样，我们在某些程序员在名称中不小心写入 42 时，我们处理了这个特例，但如果在编译时识别出错误，它会更好吗？ 为此，我们将介绍泛型。

在我们去那里之前只是最后的想法。 我们使用`canNotSortMixedElements`单元测试测试哪种类行为？ 测试在`BubbleSortTest`测试类内，但功能在比较器实现中，`StringComparator`。 此测试检查单位测试类范围的内容。 我可以用它来用于演示目的，但这不是一个单元测试。 排序实现的实际功能可以通过这种方式正式化 - 无论比较器抛出的异常都被排序实现抛出。 您可以尝试编写本机测试或读取; 我们将在下一节中拥有它。

`StringComparator`类没有测试类，因为`StringComparator`是测试的一部分，我们永远不会为测试写测试。 否则，我们将沉入一个无尽的兔子洞。

# 仿制

将泛型功能引入 Versies 5 中的 Java。要以示例开始，我们的`Sortable`界面到现在是如此：

```
public interface Sortable {
    Object get(int i);
    int size();
}
```

介绍泛型后，它将如下：

```
package packt.java189fundamentals.ch03.generic;

public interface Sortable<E> {
    E get(int i);
    int size();
}
```

`E`标识符表示类型。 它可以是任何类型。 它说，如果它实现接口，则一个类是一个可排序的集合，即两个方法 - `size`和`get`。 `get`方法应该返回类型`E`的东西，无论`E`是什么。 直到现在，这可能不会过多意识，但你很快就会得到这一点。 毕竟，仿古是一个困难的话题。

`Sort`界面将成为以下内容：

```
package packt.java189fundamentals.ch03.generic;

public interface Sort<E> {
    void sort(Sortable<E> collection);
}
```

`SortSupport`成为以下内容：

```
package packt.java189fundamentals.ch03.generic;

import packt.java189fundamentals.ch03.Swapper;

import java.util.Comparator;

public interface SortSupport<E> {
    void setSwapper(Swapper swap);

    void setComparator(Comparator<E> compare);
}
```

这仍然没有比以前的版本更加澄清，而不是泛型，但至少它确实做了一些事情。 在实现`Sort`界面的实际类中，`Comparator`应接受相同类型的`Sortable`使用。 `Sortable`无法在`Strings`上工作，我们注入`Integers`的比较器。

`BubbleSort`的实现如下：

```
package packt.java189fundamentals.ch03.main.bubble.generic;

// ... imports were removed from printout ...

public class BubbleSort<E> implements Sort<E>, SortSupport<E> {
    private Comparator<E> comparator = null;
    private Swapper swapper = null;

    @Override
    public void sort(Sortable<E> collection) {
        var n = collection.size();
        while (n > 1) {
            for (int j = 0; j < n - 1; j++) {
                if (comparator.compare(collection.get(j),
                        collection.get(j + 1)) > 0) {
                    swapper.swap(j, j + 1);
                }
            }
            n--;
        }
    }

    @Override
    public void setComparator(Comparator<E> comparator) {
        this.comparator = comparator;
    }

    @Override
    public void setSwapper(Swapper swapper) {
        this.swapper = swapper;
    }
}
```

当我们编写测试时，仿古的真正能力将会来。 第一个测试不会改变太多，虽然与泛型有关，它更明确：

```
    @Test
    public void canSortStrings() {
        var actualNames = new ArrayList<>(List.of(
            "Johnson", "Wilson",
            "Wilkinson", "Abraham", "Dagobert"
        ));
        var expectedResult = List.of(
            "Abraham", "Dagobert",
            "Johnson", "Wilkinson", "Wilson"
        );
        Sortable<String> names =
            new ArrayListSortable<>(actualNames);
        var sort = new BubbleSort<String>();
        sort.setComparator(String::compareTo);
        sort.setSwapper(new ArrayListSwapper<>
        (actualNames));
        sort.sort(names);
        Assert.assertEquals(expectedResult, 
        actualNames);
    }
```

当我们定义`ArrayList`时，我们还将声明列表的元素将是字符串。 当我们分配新的`ArrayList`时，不需要再次指定元素是字符串，因为它来自那里的实际元素。 他们每个人都是一个字符串; 因此，编译器知道`<`和`<`字符之间唯一可以介绍的是`String`。

两个字符`<`和`<`，没有类型的定义，被称为**菱形操作员**。 该类型被推断出来。 如果您习惯了泛型，则此代码为您提供有关集合工作的类型的更多信息，并且代码变得更加可读。 可读性和额外信息不是唯一的点。

如我们所知，`Comparator`参数现在是`Comparator<String>`，我们可以使用 Java 8 以来可用的 Java 的高级功能，并可以通过`String::compareTo`方法参考比较器 Setter。

第二个测试现在是我们的重要人物。 这是测试可确保`Sort`不会干扰比较器抛出的例外：

```
 1\. @Test
 2\. public void throwsWhateverComparatorDoes() {
 3\.     final ArrayList<String> actualNames =
 4\.         new ArrayList<>(List.of(
 5\.             42, "Wilson"
 6\.         ));
 7\.     final var names = new ArrayListSortable<>
        (actualNames);
 8\.     final var sort = new BubbleSort<>();
 9\.     final var exception = new RuntimeException();
10\.     sort.setComparator((a, b) -> {
11\.         throw exception;
12\.     });
13\.     final Swapper neverInvoked = null;
14\.     sort.setSwapper(neverInvoked);
15\.     try {
16\.         sort.sort(names);
17\.     } catch (Exception e) {
18\.         Assert.assertSame(exception, e);
19\.         return;
20\.     }
21\.     Assert.fail();
22\. }
```

事情是，它甚至没有编译。 编译器表明它无法推断第四行上的`ArrayList<>`的类型。 当`asList`方法的所有参数是字符串时，该方法返回了`String`元素的列表，因此已知新操作员生成`ArrayList<String>`。 这次，有一个整数，因此，编译器无法推断`ArrayList<>`是针对`String`元素。

要将`ArrayList<>`更改为`ArrayList<String>`的类型定义不是 cure。 在这种情况下，编译器将抱怨值`42`。 这是泛型的力量。 使用具有类型参数的类时，编译器可以检测到提​​供错误类型的值。 要将值置于`ArrayList`中以检查实现是否真的抛出异常，我们必须将值召集到其中。 我们可以尝试用空`String`替换值`42`，然后添加以下行，仍然无法编译：

```
actualNames.set(0,42);
```

编译器仍然会知道您要在`ArrayList`中设置的值应该是`String`。 要使用`Integer`元素获取阵列，您必须明确解锁安全柄并拉动触发，射击自己：

```
((ArrayList)actualNames).set(0,42);
```

即使是测试，我们也不会这样做。 我们不想测试它识别出`Integer`无法投射到`String`的 JVM。 该测试由不同的 Java 实现完成。 我们真正测试的是，无论比较器抛出的异常抛出这些排序都会抛出相同的例外。

现在，测试看起来像这样：

```
@Test
public void throwsWhateverComparatorDoes() {
    final var actualNames =
        new ArrayList<>(List.of(
            "", "Wilson"
        ));
    final var names = new ArrayListSortable<>(actualNames);
    final var sort = new BubbleSort<>();
    final var exception = new RuntimeException();
    sort.setComparator((a, b) -> {
        throw exception;
    });
    final Swapper neverInvoked = null;
    sort.setSwapper(neverInvoked);
    try {
        sort.sort(names);
    } catch (Exception e) {
        Assert.assertSame(exception, e);
        return;
    }
    Assert.fail();
}
```

现在，我们将变量`actualNames`的声明更改为`var`，以便从右侧表达式推断出类型。 在这种情况下，它是`ArrayList<String>`，并且从创建调用`List.of()`的列表中推断出通用`String`参数。 此方法还具有通用参数，因此我们可以写入`List.<String>of()`。 但是，在此调用中，从参数推断出此泛型参数。 所有参数都是字符串，因此返回的列表是`List<String>`。 在未编译的前一个示例中，创建的列表具有类型`List<Object>`。 这与左侧的声明不兼容，编译器抱怨它。 如果我们为变量声明使用`var`，则编译器在此时无法检测到此错误，我们将有一个`List<Object>`变量而不是`List<String>`。

我们将 swapper 设置为`null`，因为它永远不会被调用。 当我第一次写这个代码时，这对我来说是明显的。 几天后，我读了代码，我停了下来。 *为什么 swapper null？* 然后我记得在第二个或两个。 但随时随地，在阅读和理解代码的时候，我倾向于考虑重构。 我可以向该行添加评论说明`//never invoked`，但即使功能发生变化，注释趋于仍然存在。 我在 2006 年学到了它的艰难方式，当时错误的评论阻止了我看代码是如何执行的。 在调试时，我正在阅读评论，而不是代码，而系统下降时，错误修复需要两天。 而不是评论，我倾向于使用构造，使代码表达发生的事情。 额外的变量可能会使类文件更大，但它由 JIT 编译器优化，因此最终代码不会运行较慢。

将例外投掷异常的比较器作为λ表达。 在使用只使用一个简单方法的匿名类或命名类的情况下可以使用 lambda 表达式。 Lambda 表达式是存储在变量中的匿名方法，或者以参数传递以供稍后调用。 我们将讨论[第 8 章](8.html)，*延长我们的电子商务应用程序*的 Lambda 表达式的详细信息。

目前，我们将继续实施`QuickSort`，并这样做，我们将使用 TDD 方法。

# 测试驱动的发展

TDD 是一种代码编写方法，开发人员首先根据规范写入测试，然后写代码。 这与开发人员社区已被习惯的相反。 我们遵循的传统方法是编写代码，然后为它写测试。 要诚实地，真实的实践是编写代码并用 Adhoc 测试测试它，根本没有单位测试。 作为一名专业人士，你永远不会这样做。 你总是写测试。 （现在，将其写下来百次 - 我将始终写测试。）

TDD 的一个优点是测试不依赖于代码。 由于代码不存在于创建测试时，开发人员不能依赖于设备的实现，因此，它无法影响测试创建过程。 这通常很好。 单元测试应尽可能多地进行黑盒测试。

黑匣子测试是一个未考虑测试系统的实现的测试。 如果系统重构，以不同的方式实现，但它提供给外部世界的接口是相同的，那么黑匣子测试应该很好。 白盒测试取决于测试的系统内部工作。 当代码更改白盒测试时，代码也可能需要调整以遵循更改。 白盒测试的优势可以是更简单的测试代码。 不总是。 灰度盒测试是两者的混合物。

单位测试应该是黑盒式测试，但多次，写一个黑匣子测试并不简单。 开发人员将写一个测试，他们认为是黑匣子，但很多次，这种信念被证明是假的。 当实现更改时，重构某事物，测试不再工作，并且需要纠正。 它刚刚发生了这种实现，开发人员，特别是那些写入该装置的人，将写一个取决于代码的内部工作的测试。 在代码之前编写测试是一个防止此的工具。 如果没有代码，则无法依赖于它。

TDD 还表示，发展应该是一种迭代的方法。 您在开始时只写一个测试。 如果您运行，则会失败。 当然，它失败了！ 因为还没有代码，它必须失败。 然后，您将编写满足此测试的代码。 没有更多，只有使这个测试通过的代码。 然后，您将继续为该规范的另一部分进行新测试。 你会运行它，它失败了。 这证明了新的测试测试了尚未开发的东西。 然后，您将开发代码以满足新测试，并且可能还将修改已在前一个迭代中写入的代码块。 当代码准备就绪时，测试将通过。

多次，开发人员不愿意修改代码。 这是因为他们害怕破坏已经工作的东西。 当你关注 TDD 时，你不应该，同时，你不需要害怕这个。 有测试已经开发的所有功能。 如果某些代码修改中断某些功能，则测试将立即发出错误。 关键是在修改代码时，您可以经常运行测试。

# 实施 Quicksort.

Quicksort，正如我们已经讨论的那样，是由两个主要部分制成的。 一个是分区，另一个是递归地进行分区，直到整个阵列被排序。 要使我们的代码模块化并准备好演示 JPMS 模块处理功能，我们将开发分区和递归排序到单独的类别和单独的包中。 代码的复杂性不会证明这种分离。

# 分区类

分区类应提供一种方法，该方法基于枢轴元件移动集合的元素，并且我们需要在方法完成后知道枢轴元件的位置。 该方法的签名应该看起来像这样：

```
public int partition(Sortable<E> sortable, int start, int end, E pivot);
```

该类还应访问`Swapper`和`Comparator`。 在这种情况下，我们定义了一个类而不是界面; 因此，我们将使用构造函数注入。

这些构造，如 Setder 和 Constructor 注射器，如此常见的并且经常发生，但 IDES 支持这一点。 您需要在代码中创建`final`字段，并使用*代码生成*菜单来创建构造函数。

分区类将如下所示：

```
public class Partitioner<E> {

    private final Comparator<E> comparator;
    private final Swapper swapper;

    public Partitioner(Comparator<E> comparator, Swapper swapper) {
        this.comparator = comparator;
        this.swapper = swapper;
    }

    public int partition(Sortable<E> sortable, int start, int end, E pivot) {
        return 0;
    }
}
```

此代码没有，但这就是 TDD 如何开始。 我们将创建提供代码的骨架和调用它的测试的要求的定义。 为此，我们需要我们可以分区的东西。 最简单的选择是`Integer`数组。 `partition`方法需要类型`Sortable<E>`的对象，我们需要一些包裹数组并实现此接口的内容。 我们姓名`ArrayWrapper`。 这是一个通用类。 它不仅适用于测试。 因此，我们创建它作为生产代码，因此，我们将其放在`main`目录中，而不是在`test`目录中。 由于此包装器与`Sort`的实现无关，因此此类的正确位置是在新的`SortSupportClasses`模块中。 我们将创建新模块，因为它不是界面的一部分。 实现取决于接口，但不在支持类上。 还可以有一些应用程序使用我们的库，并且可能需要接口模块和一些实现，但仍然不需要支持类别，当它们提供包装功能本身时。 毕竟，我们无法实现所有可能的包装功能。 SRP 也适用于模块。

Java 库往往包含不相关的功能实现。 这并不好。 对于短期，它使图书馆更简单。 您只需在 POM 文件中指定一个依赖项，您将拥有所需的所有类和 API。 从长远来看，应用程序变得更大，携带很多都是一些库的一部分，但应用程序永远不会使用它们。

要添加新模块，必须与源目录和 POM 文件一起创建模块目录。 该模块具有被添加到父 POM 并且它也必须被添加到`dependencyManagement`部分，以使`QuickSort`模块的测试代码可以使用它，而不指定的版本。 新模块取决于接口模块，因此必须将此依赖添加到支持类的 POM 中。

`ArrayWrapper`课程简单且一般：

```
package packt.java189fundamentals.ch03.support;

import packt.java189fundamentals.ch03.generic.Sortable;

public class ArrayWrapper<E> implements Sortable<E> {
    private final E[] array;

    public ArrayWrapper(E[] array) {
        this.array = array;
    }

    public E[] getArray() {
        return array;
    }

    @Override
    public E get(int i) {
        return array[i];
    }

    @Override
    public int size() {
        return array.length;
    }
}
```

我们还需要的`ArraySwapper`类进入了同一模块。 它与包装纸一样简单：

```
package packt.java189fundamentals.ch03.support;

import packt.java189fundamentals.ch03.Swapper;

public class ArraySwapper<E> implements Swapper {
    private final E[] array;

    public ArraySwapper(E[] array) {
        this.array = array;
    }

    @Override
    public void swap(int k, int r) {
        final E tmp = array[k];
        array[k] = array[r];
        array[r] = tmp;
    }
}
```

拥有这些课程，我们可以创建我们的第一次测试：

```
package packt.java189fundamentals.ch03.qsort.phase1;

// ... imports deleted from print ...

public class PartitionerTest {
```

在创建`@Test`方法之前，我们需要两个使断言的帮助方法。 断言并不总是简单，在某些情况下，它们可能涉及一些编码。 一般规则是测试和断言应该尽可能简单; 否则，它们只是一个可能的编程错误来源。 此外，我们创建了它们以避免编程错误，而不是创建新的。

`assertSmallElements`方法断言`cutIndex `之前的所有元素小于`pivot`：

```
private void assertSmallElements(Integer[] array, int cutIndex, Integer pivot) {
    for (int i = 0; i < cutIndex; i++) {
        Assert.assertTrue(array[i] < pivot);
    }
}
```

`assertLargeElements`方法确保`cutIndex`之后的所有元素至少与`pivot`一样大：

```
private void assertLargeElements(Integer[] array, int cutIndex, Integer pivot) {
    for (int i = cutIndex; i < array.length; i++) {
        Assert.assertTrue(pivot <= array[i]);
    }
}
```

该测试使用常数`Integers`数组并将其包装成`ArrayWrapper`类：

```
@Test
public void partitionsIntArray() {
    final var partitionThis = new Integer[]{0, 7, 6};
    final var swapper = new ArraySwapper<> \   
    (partitionThis);
    final var partitioner =
            new Partitioner<Integer>(
                  (a, b) -> a < b ? -1 : a > b ? +1 : 0,
                    swapper);
    final Integer pivot = 6;
    final int cutIndex = partitioner.partition(
       new ArrayWrapper<>(partitionThis), 0, 2, pivot);
    Assert.assertEquals(1, cutIndex);
    assertSmallElements(partitionThis, cutIndex, pivot);
    assertLargeElements(partitionThis, cutIndex, pivot);
}
```

JDK 中`Integer`类型没有`Comparator`，但很容易将一个作为 Lambda 函数定义。 现在，我们可以编写`partition`方法，如下所示：

```
 1\. public int partition(Sortable<E> sortable,
 2\.                      int start,
 3\.                      int end,
 4\.                      E pivot) {
 5\.     var small = start;
 6\.     var large = end;
 7\.     while (large > small) {
 8\.         while(comparator.compare(sortable.get(small), pivot) < 0
 9\.                 && small < large) {
10\.             small++;
11\.         }
12\.         while(comparator.compare(sortable.get(large), pivot) >= 0
13\.                 && small < large) {
14\.             large--;
15\.         }
16\.         if (small < large) {
17\.             swapper.swap(small, large);
18\.         }
19\.     }
20\.     return large;
21\. }
```

![](img/97faa5a5-07f1-4524-b339-36a4bb2c0d5c.png)

如果我们运行测试，它会罚款。 但是，如果我们用覆盖率运行测试，那么 IDE 告诉我们，覆盖范围仅为 92％。 测试仅覆盖了`partition`方法的 14 行中的 13 个。

在 Line **17** 的排水沟上有一个红色矩形。 这是因为测试数组已经分区。 当枢轴值为`6`时，无需在其中交换任何元素。 这意味着我们的测试是好的，但不够好。 如果该行有错误怎么办？

要修改此问题，我们将延长测试，将测试数组从`{0, 7, 6 }`更改为`{0, 7, 6, 2}`。 运行测试，它将失败。 为什么？ 在一些调试之后，我们将意识到我们使用固定参数`2`作为阵列的最后一个索引来调用方法`partition`。 但是，我们让阵列更长。 为什么我们首先在那里写一个常数？ 这是一个糟糕的做法。 让我们用`partitionThis.length-1`替换它。 现在，它说`cutIndex`是​​`2`，但我们期待`1`。 我们忘了将断言调整到新阵列。 让我们修复它。 现在它有效。

最后一件事是重新思考断言。 代码越多越好。 断言方法非常一般，我们将使用它为一个测试阵列。 断言方法如此复杂，以至于他们应得自己的测试。 但是，我们没有写代码来测试测试。 相反，我们可以简单地删除方法并具有最终版本的测试，如下所示：

```
@Test
public void partitionsIntArray() {
    final var partitionThis = new Integer[]{0, 7, 6, 2};
    final var swapper = new ArraySwapper<>(partitionThis);
    final var partitioner =
            new Partitioner<Integer>(
        (a, b) -> a < b ? -1 : a > b ? +1 : 0, swapper);
    final var pivot = 6;
    final var cutIndex = partitioner.partition(
            new ArrayWrapper<>(partitionThis),
            0,
            partitionThis.length - 1,
            pivot);
    Assert.assertEquals(2, cutIndex);
    final var expected = new Integer[]{0, 2, 6, 7};
    Assert.assertArrayEquals(expected, partitionThis);
}
```

那么，这是一个黑盒式测试吗？ 如果划分返回`{2, 1, 7, 6}`何种何种？ 它适合定义。 我们可以创建更复杂的测试以涵盖此类案例。 但是更复杂的测试也可能在测试本身中具有错误。 作为一种不同的方法，我们可以创建可能更简单但依赖于实现的内部结构的测试。 这些不是黑匣子测试，因此不是理想的单位测试。 我会去第二个，但如果有人选择另一个，我不会争辩。

# 递归排序

我们将使用额外的类实现 Quicksort，该类与分区类一起在`qsort`封装中，如下所示：

```
package packt.java189fundamentals.ch03.qsort;

// ... imports are deleted from print ...
public class Qsort<E> {
    final private Comparator<E> comparator;
    final private Swapper swapper;
// ... constructor setting fields deleted from print ...
    public void qsort(Sortable<E> sortable, int start, int end) {
        if (start < end) {
            final var pivot = sortable.get(start);
            final var partitioner = new Partitioner<E>(comparator, swapper);
            var cutIndex = partitioner.partition(sortable, start, end, pivot);
            if (cutIndex == start) {
                cutIndex++;
            }
            qsort(sortable, start, cutIndex - 1);
            qsort(sortable, cutIndex, end);
        }
    }
}
```

该方法获取`Sortable<E>`和两个索引参数。 它没有整理整个集合; 它只对`start`和`end`索引之间的元素进行排序。

与索引非常精确，总是很重要。 通常，Java 中的启动索引没有问题，但是来自如何解释`end`索引的许多错误来源。 在此方法中，`end`的值可以意味着索引已经不是待排序间隔的一部分。 在这种情况下，应该用`end-1`调用`partition`方法，以及与`end-1`作为最后一个参数的第一个递归调用。 这是一个味道。 重要的是要精确并定义索引参数的解释。

如果只有一个`(start == end)`元素，那么没有什么可排序并且方法返回。 这是递归的最终标准。 该方法还假定`end`索引永远不会小于`start`索引。 由于此方法仅在我们现在正在开发的库内使用，因此这种假设不会太冒险。

如果有一些要排序的东西，则该方法将采用待排序间隔的第一个元素，并将其用作枢轴并调用`partition`方法。 完成分区时，该方法递归地称为两半的自身。

该算法是递归的。 这意味着该方法称为自身。 当执行方法调用时，处理器在一个名为**堆栈**的区域中分配一些内存，并且它将局部变量存储在那里。 该区域属于堆栈中的方法称为**堆栈帧**。 当方法返回时，释放此区域并恢复堆栈，只需将堆栈指针移动到呼叫之前。 这样，一种方法可以在调用另一种方法后继续执行; 局部变量在那里。

当方法调用自身时，它并不不同。 本地变量是本地呼叫的本地呼叫。 当方法调用自身时，它会在堆栈上再次分配局部变量的空间。 换句话说，这些是局部变量的新*实例*。

我们在 Java 中使用递归方法，并在算法的定义是递归时，在其他编程语言中，了解处理器代码运行时非常重要; 它不再递归了。 在该级别上，有指令，寄存器和内存负载和跳转。 没有什么比函数或方法类似，因此在该级别上，没有像递归一样。

如果您得到的话，很容易理解任何递归都可以编码为循环。

事实上，它也是如此，另一个循环可以编码为递归，但在开始功能规划之前，这并不是很有趣。

java 中递归和许多其他编程语言的问题是它可能会耗尽堆栈空间。 对于 Quicksort，这不是这种情况。 您可以安全地假设用于在 Java 中调用的方法的堆栈是几百个级别。 QuickSort 需要一个近似 *log <sub>2</sub> n* 深的堆栈，其中 *n* 是​​要排序的元素数。 在十亿元素的情况下，这是 30，应该适合。

为什么堆栈没有移动或调整大小？ 这是因为堆栈空间中运行的代码通常是糟糕的风格。 它们可以以更可读形式的形式表达，以某种环路。 更强大的堆栈实现只会引诱新手程序员做一些不太可读的递归编码。

有一个特殊的递归递归命名尾递归。 尾递归方法称为该方法的最后一个指令。 当递归调用返回代码时，调用方法不再赘述，但释放用于此方法调用的堆栈帧。 换句话说，我们将在递归调用期间保留堆栈框架，只是以后立即抛出它。 为什么不在电话前扔掉它？ 在这种情况下，实际帧将被重新分配，因为这与保留的方法相同，并且递归调用被转换为跳转指令。 这是 Java 不做的优化。 功能语言正在进行它，但 Java 并不是一种功能语言，因此应该避免尾部递归函数并将其转换为 Java 源电平的循环。

# 非递归排序

为了证明即使是非尾递归方法也可以以非递归方式表达，这里是 Quicksort 的方式：

```
 1\. public class NonRecursiveQuickSort<E> {
 2\. // ... same fields and constructor as in Qsort are  
    deleted from print ...
 3\. 
 4\.     private static class StackElement {
 5\.         final int begin;
 6\.         final int fin;
 7\. 
 8\.         public StackElement(int begin, int fin) {
 9\.             this.begin = begin;
10\.             this.fin = fin;
11\.         }
12\.     }
13\. 
14\.     public void qsort(Sortable<E> sortable, int  
        start, int end) {
15\.         final var stack = new  
        LinkedList<StackElement>();
16\.         final var partitioner = new Partitioner<E> 
            (comparator, swapper);
17\.         stack.add(new StackElement(start, end));
18\.         var i = 1;
19\.         while (!stack.isEmpty()) {
20\.             var it = stack.remove(0);
21\.             if (it.begin < it.fin) {
22\.                 final E pivot =  
                    sortable.get(it.begin);
23\.                 var cutIndex = 
              partitioner.partition(sortable, it.begin, 
              it.fin, pivot);
24\.                 if( cutIndex == it.begin ){
25\.                     cutIndex++;
26\.                 }
27\.                 stack.add(new StackElement(it.begin, 
                     cutIndex - 1));
28\.                 stack.add(new StackElement(cutIndex, 
                     it.fin));
29\.             }
30\.         }
31\.     }
32\. }
```

此代码在 Java 级别实现堆栈。 虽然似乎仍然计划在`stack`中排序，但它从堆栈中获取它并进行排序分区，并调度两个部分进行排序。

此代码比上一个代码更复杂，您必须了解`StackElement`类的角色以及它的工作原理。 另一方面，该程序仅使用`Partitioner`类的一个实例，也可以使用线程池来安排后续排序而不是在单个过程中处理任务。 当在多 CPU 机器上执行时，这可能会加快排序。 但是，这有点复杂任务，本章包含很多没有多任务处理的新事物; 因此，我们将仅在两章中查看多线程代码。

在这类的第一个版本中，我正在编写它，没有三行比较`cutIndex`与间隔开始并递增它在`if`分支中（第 24-26 行）。 它需要很多。 但是，如果我们错过了这些行，我们在本书中创建的单元测试不会发现错误。 我建议您删除这些行并尝试编写一些失败的单元测试。 然后，尝试了解这些线路的特例是什么时候，这些行为重要并尝试修改您的单元测试，以便最简单的可能仍然发现该错误。 （最后，将四行返回并查看代码是否有效。）另外，找到一些架构原因为什么不将此修改放入方法`partition`。 该方法可以在`large == start`的情况下返回`large+1`。

# 实现 API 类

完成了这一切，我们需要的最后一件事就是用`QuickSort`作为一个简单的课程（所有真正的工作都在不同的类中完成）：

```
public class QuickSort<E> extends AbstractSort<E> {
    public void sort(Sortable<E> sortable) {
        final var n = sortable.size();
        final var qsort = new Qsort<E>(comparator,swapper);
        qsort.qsort(sortable, 0, n-1);
    }
}
```

不要忘记我们也需要测试！ 但是，在这种情况下，与`BubbleSort`的不同之处不大：

```
    @Test
    public void canSortStrings() {
        final var actualNames = new String[]{
                "Johnson", "Wilson",
                "Wilkinson", "Abraham", "Dagobert"
        };
        final var expected = new String[]{"Abraham",
                "Dagobert", "Johnson", "Wilkinson", "Wilson"};
        var sort = new QuickSort<String>();
        sort.setComparator(String::compareTo);
        sort.setSwapper(new ArraySwapper<>(actualNames));
        sort.sort(new ArrayWrapper<>(actualNames));
        Assert.assertArrayEquals(expected, actualNames);
    }
```

这次，我们使用`String`数组而不是`ArrayList`。 这使得这次测试更简单，并且这次我们已经拥有了支持类。

您可以认识到这不是单位测试。 在`BubbleSort`的情况下，该算法在单个类中实现。 测试单级是单位测试。 在`QuickSort`的情况下，我们将功能分成单独的类，甚至分成单独的包。 `QuickSort`类的真实单元测试将披露该类对其他类的依赖性。 当此测试运行时，它涉及执行`Partitioner`，也涉及`Qsort`; 因此，它不是一个单位测试。

我们应该打扰这一点吗？ 并不真地。 我们希望创建一个涉及单个单元的单元测试，以知道问题是单位测试失败的位置。 如果只有集成测试，则失败的测试用例在问题所在的位置时，无法帮助很多。 所有它所说的是，在测试中涉及的类中存在一些问题。 在这种情况下，只有有限数量的涉及该测试的类（三个），它们被捆绑在一起。 它们实际上与彼此相互联系，如此密切相关，在真实的生产代码中，我将在一个模块中实现它们。 我将它们分开在这里展示如何测试单个单元，也可以演示 Java 模块支持，该支持需要 jar 文件中的单个类。

# 创建模块

模块处理，也称为 Project **拼图，**或 **JPMS** ，是仅在 Java 9 中可用的功能。它是一个长计划的功能。 首先，计划为 Java 7 计划，但它被推迟到 Java 8 然后 java 9.最后，JPMS 包含在 Java 的第 9 版中。 同时 oracle 介绍了长期的概念，也是短期支持版本。 仅支持短期版本，直到发布了下一个语言。 另一方面，长期发布支持较长的时间，在新版本甚至新的长期支持版本之后多次甚至多次被释放。 在 Java 9 之前，所有版本都是长期支持版本。 如果存在影响稳定性或应用程序的安全性，则 Oracle 正在创建新的小版本。 java 1.8 可用时，甚至为 Java 1.6 创建了新版本。

那时候 Oracle 声明了 Java 9 和 10 不会是长期支持的版本。 但是，Java 11 或 Java 18.9 根据新版本控制方案编号，是一个长期支持版本，因此，它是具有 **JPMS** 实现的第一个长期支持的版本。

# 为什么需要模块

我们已经看到 Java 有四个级别的访问权限。 当没有修改器在类内提供时，方法或字段可以是`private`，`protected`，`public`或`default`（也称为包私有）。 当您在多个项目中使用要使用的复杂库时，库本身将包含许多软件包中的许多类。 当然会有类和方法，在那些中，应该是由不同包中的其他类单独使用的那些字段。 库中的代码不使用这些类。 使它们比`public`更不可见，将在库中呈现不可用。 使它们`public`将使它们从外面看。 这是不好的。

在我们的代码中，只有在方法排序可以调用`qsort`时才能使用编译成 JAR 中的 Maven Module `quick`。 但是，我们不希望直接从外部使用`qsort`。 在下一个版本中，我们可能希望从`NonRecursiveQuickSort`类中使用`qsort`的排序版本，并且我们不希望由于较小的库升级，其代码不编译或工作的抱怨客户。 我们可以记录内部方法和类，这些方法是公开的不适合使用，而是徒劳无功。 使用我们库的开发人员不会读取文档。 这也是为什么我们没有写过多的评论。 没有人会阅读它，甚至没有执行代码的处理器。

# 什么是 Java 模块？

Java 模块是 jam 中的类集合，也可以包含一个名为`module-info`的特殊类的目录中的集合。 如果 jar 或目录中存在此文件，则它是一个模块，否则，它只是`classpath`（或不）上的类集合。 Java 8，早期版本将忽略那个类，因为它永远不会被用作代码。 这样，使用较旧的 Java，不会导致伤害，并保持向后兼容性。

创造这样的罐子有点棘手。 `module-info.class`文件应具有符合 Java 9 字节码或更高版本的字节码，但其他类应包含旧版本字节码。

模块信息定义模块导出和它所需的内容。 它具有特殊格式。 例如，我们可以在我们的`SortInterface` Maven 模块中放置`module-info.java`：

```
module packt.java189fundamentals.SortInterface{
    exports packt.java189fundamentals.ch03;
    exports packt.java189fundamentals.ch03.generic;
}
```

这意味着可以从外部使用`public`和`packt.java189fundamentals.ch03`封装内部的任何类。 此软件包从模块导出，但即使它们是`public`，也不会从模块的外部可见其他软件包的其他类。 命名要求与包中的情况相同 - 应该有一个名称不太可能与其他模块名称碰撞。 反向域名是一个不错的选择，但它不是必须的，就像你在本书中看到的那样。 还没有顶级域`packt`。

我们还应该修改父 POM 以确保我们使用的编译器是 Java 9 或更高版本在`project/build/plugins/`的 Maven Compiler 插件：

```
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.7.0</version>
    <configuration>
        <source>1.10</source>
        <target>1.10</target>
    </configuration>
    <dependencies>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm</artifactId>
            <version>6.1.1</version> 
        </dependency>
    </dependencies>
</plugin>
```

旧版本将与`module-info.java`文件混淆。 （顺便说一下，即使是我用于本书的第一版的 Java 9 的早期访问版本，有时候会给我很难过。）

我们还在 Maven 模块中创建一个`module-info.java`文件`quick`，如下所示：

```
module packt.java189fundamentals.quick {
    exports packt.java189fundamentals.ch03.quick;
    requires packt.java189fundamentals.SortInterface;
    }
```

此模块导出另一个包，并需要我们刚刚创建的`packt.java189fundamentals.SortInterface`模块。 现在，我们可以编译模块和`./quick/target`和`./SortInterface/target`目录中的创建 jar，现在是 Java 模块。

要测试模块支持的功能，我们将创建一个名为`Main`的 Maven 模块。 它只有一个类，称为`Main`，具有`public static void main`方法：

```
package packt.java189fundamentals.ch03.main;

// ... imports are deleted from print ...

public class Main {
    public static void main(String[] args) throws IOException {
        final var fileName = args[0];
        BufferedReader br = null;
        try {
            br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(fileName))));
            final var lines = new LinkedList<String>();
            String line;
            while ((line = br.readLine()) != null) {
                lines.add(line);
            }
            String[] lineArray = lines.toArray(new String[0]);
            var sort = new FQuickSort<String>();
            sort.setComparator((a, b) -> ((String) a).compareTo((String) b));
            sort.setSwapper(new ArraySwapper<>(lineArray));
            sort.sort(new ArrayWrapper<>(lineArray));
            for (final String outLine : lineArray) {
                System.out.println(outLine);
            }
        } finally {
            if (br != null) {
                br.close();
            }
        }
    }
}
```

它采用第一个参数（如果没有检查有一个，我们不应该在生产代码中使用）并将其用作文件名。 然后，它将文件的行读入`String`数组，对其进行排序，并将其打印到标准输出。

由于模块支持仅适用于模块，此 Maven 模块也必须是 Java 模块，并且具有`module-info.java`文件：

```
module packt.java189fundamentals.Main{
    requires packt.java189fundamentals.quick;
    requires packt.java189fundamentals.SortInterface;
    requires packt.java189fundamentals.SortSupportClasses;
}
```

此外，我们必须为支持模块创建`module-info.java`文件; 否则，我们将无法从模块中使用它。

使用`mvn install`编译模块后，我们可以运行它以打印排序的文件的行。 例如，我们可以打印出父 POM 的行排序，这没有效果，但它很有趣。 以下是启动 Java 代码的 Windows 命令文件：

```
set MODULE_PATH=Main/target/Main-1.0.0-SNAPSHOT.jar;
set MODULE_PATH=%MODULE_PATH%SortInterface/target/SortInterface-1.0.0-SNAPSHOT.jar;
set MODULE_PATH=%MODULE_PATH%quick/target/quick-1.0.0-SNAPSHOT.jar;
set MODULE_PATH=%MODULE_PATH%SortSupportClasses/target/SortSupportClasses-1.0.0-SNAPSHOT.jar
java -p %MODULE_PATH% -m packt.java189fundamentals.Main/packt.java189fundamentals.ch03.main.Main pom.xml
```

jar 文件在模块路径上获取，使用命令行选项`-p`给出给 java 执行。 要启动在模块中的类的`public static void main()`方法，还不够重新指定类的完全限定名称。 我们必须使用`-m`选项，然后使用模块和类的`module/class`格式化规范。

现在，如果我们尝试直接插入以下行的`Qsort`，`Qsort<String> qsort = new Qsort<>(String::compareTo,new ArraySwapper<>(lineArray));`进入`main`方法，Maven 将抱怨，因为模块系统隐藏了我们的`Main`类。

模块系统还支持`java.util.ServiceLoader` - 基于类加载机制，我们不会在本书中讨论。 这是一种旧技术，即在使用弹簧，GUICE 或一些其他依赖注入框架时很少在企业环境中使用。 如果看到包含`uses`和`provides`关键字的`module-info.java`文件，那么首先会在 [http://docs.oracle.com/javase/8 上有关`ServiceLoader`类的 Java 文档 /docs/api/java/util/serviceloader.html](http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html) ，然后是模块支持的 Java 9 语言文档（ [http://openjdk.java.net/projects/jigsaw/quick-start](http://openjdk.java.net/projects/jigsaw/quick-start) ）。

# 概括

在本章中，我们开发了一种实现 Quicksort 的一般排序算法。 我们将项目修改为多模块 Maven 项目，也可以使用 Java 模块定义。 我们正在使用 JUnit 来开发单位测试，我们使用 TDD 开发了代码。 我们将代码从旧式 Java 转换为新使用泛型，我们使用异常处理。 这些是即将到来的章节所需的基本工具，我们将开发猜测游戏。 首先，我们将开发更简单的版本，并且在后续章节中，我们将开发一个使用并行计算和多个处理器的版本。