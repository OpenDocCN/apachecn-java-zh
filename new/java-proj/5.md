# 扩展游戏 - 运行并行，运行更快

在本章中，我们将扩展 MasterMind 游戏。 因为它是现在，它可以猜测，被隐藏的秘密，它也可以隐藏钉。 测试代码甚至可以同时进行两者。 它可以对自己进行播放，只借助编程的乐趣。 什么不能做的是利用所有的处理器，我们在今天的笔记本电脑和服务器。 代码运行同步并仅利用单个处理器核心。

我们将改变扩展猜测算法的代码，以便将猜测切入子任务并并行执行代码。 在这样做时，我们会熟悉 Java 并发编程。 这将是一个巨大的主题，许多微妙的曲折，在阴影中延伸。 我们将进入那些最重要的细节，并将在需要并发计划时进行进一步研究的公司基础。

由于游戏的结果与它相同，只有更快，我们必须评估更快的是。 为此，我们将利用 Java 9 中引入的新功能 - 微基准线束。

在本章中，我们将涵盖以下主题：

*   过程，线程和纤维的含义
*   java 的多线程
*   多线程编程问题以及如何避免它们
*   锁定，同步和阻塞队列
*   MicroBenchmarking.

# 如何使 MasterMind 并行

旧算法是通过所有变体，并尝试找到与表的当前状态匹配的猜测。 假设目前审查的猜测是秘密，我们会在表格上获得相同的答案作为实际在表中的答案吗？ 如果是，那么当前的猜测可能是秘密，它就像任何其他猜测一样猜到。

一种更复杂的方法可以实现 min-max 算法（ [https://en.wikipedia.org/wiki/minimax](https://en.wikipedia.org/wiki/Minimax) ）。 此算法并不简单地获得下一个可能的猜测，而且还可以查看所有可能的猜测，并选择最缩短游戏结果的猜测。 如果有猜测可以在最坏的情况下猜测三个猜测，并且还有另一个这个数字只有两个，然后 min-max 将选择后者。 为那些感兴趣的读者实施 MIN-MAX 算法是一个很好的练习。 在六种颜色和四列的 PEG 的情况下，MIN-MAX 算法在不超过五个步骤中解决了游戏。 我们实施的简单算法也以五个步骤解决了游戏。 但是，我们不朝着那个方向走。

相反，我们希望拥有利用多个处理器的游戏版本。 如何将算法转换为平行的算法？ 这没有简单的答案。 当您有算法时，可以分析算法的计算和部分，您可以尝试查找依赖项。 如果有一个计算， *b，*需要数据，这是另一个计算的结果， *a* ，那么很明显 *a* 只能是 当 *b* 准备好时执行。 如果存在的部分算法不依赖于其他算法，则它们可以并行执行。

例如，快速排序有两个主要任务，用于分区，然后对这两个部分进行排序。 在我们开始对两个分区部分进行排序之前，分区必须完成，这是相当明显的。 但是，两部分的分拣任务不依赖于彼此; 他们可以独立完成。 您可以将它们提供给两个不同的处理器。 一个人会愉快地对包含较小元素的部分排序，而另一个将携带更大的部分。

如果我们调用非递归快速排序实现，您可以看到我们将排序任务安排到堆栈中，然后通过从`while`循环中的堆栈中的元素来执行排序：

```
public class NonRecursiveQuickSort<E> {
// ... same fields and constructor as in Qsort are deleted from print ...

    private static class StackElement {
        final int begin;
        final int fin;

        public StackElement(int begin, int fin) {
            this.begin = begin;
            this.fin = fin;
        }
    }

    public void qsort(Sortable<E> sortable, int start, int end) {
        final var stack = new LinkedList<StackElement>();
        final var partitioner = new Partitioner<E>(comparator, swapper);
        stack.add(new StackElement(start, end));
        var i = 1;
        while (!stack.isEmpty()) {
            var it = stack.remove(0);
            if (it.begin < it.fin) {
                final E pivot = sortable.get(it.begin);
                var cutIndex = partitioner.partition(sortable, it.begin, it.fin, pivot);
                if( cutIndex == it.begin ){
                    cutIndex++;
                }
                stack.add(new StackElement(it.begin, cutIndex - 1));
                stack.add(new StackElement(cutIndex, it.fin));
            }
        }
    }
}
```

我们可以将任务传递给异步线程来执行它并返回下一个等待任务的任务，而不是在那里执行排序。 我们只是不知道如何。 然而。 这就是我们在本章中的原因。

处理器，线程和流程是复杂的和抽象的东西，它们很难想象。 不同的程序员具有不同的技术来想象并行处理和算法。 我可以告诉你我是怎么做到的。 无法保证这将为您工作。 其他人可能会有不同的技术。 事实上，我刚才意识到，就像我写这一点一样，我以前从未向任何人讲过这个。 无论如何，它可能看起来很幼稚。

当我想象算法时，我想象的是人。 一个处理器是一个人。 这有助于让我克服处理器可以在第二秒钟内执行数十亿计算的怪异事实。 我实际上想象一个穿着棕色西装并进行计算的官僚。 当我为并行算法创建代码时，我想象他们中的许多人在他们的办公桌后面工作。 他们独自工作，他们不说话。 重要的是他们不互相交谈。 他们非常正式。 当需要有关信息交换时，他们站在他们写过东西的一张纸上，他们把它互相带来了。 有时，他们需要一张纸来工作。 然后，他们站起来，去纸张的地方，带它，把它带回他们的办公桌，继续工作。 当他们准备好了，他们回去了，把纸带回来了。 如果纸张不需要它，他们排队等待，直到有纸张带来的人。

这对 MasterMind 游戏有何帮助？

我想象一个负责猜测的老板。 墙上有一张桌子在办公室里有一个猜测和每行的结果。 老板懒得想出新的猜测，所以他把这项任务归到下属。 当一个从属猜测猜测时，BOSS 检查猜测是否有效。 他不相信下属，如果猜测是好的，他就会让它成为一个官方的猜测，并将其放在桌面上。

下属提供猜测在小篇文章中写的猜测，他们将它们放在老板桌上的盒子里。 老板不时看着盒子，如果有一个纸条，老板就会拿走它。 如果盒子已满，并且从那里有一个纸张，从属停止并等待，直到老板至少有一个音符，以便盒子里有一些空间用于新的音符。 如果下属队列队到禁用箱子存款，他们都等待轮到他们。

下属应该协调; 否则，他们会拿出同样的猜测。 每个人都应该有猜测间隔。 例如，第一个应该从 1234 到 2134 检查猜测，第二个应该从 2134 到 3124 检查，等等，如果我们表示具有数字的颜色。

这项结构是否有效？ 常识说它会。 然而，在这种情况下，官僚是隐喻，隐喻并不准确。 官僚是人类的，即使他们似乎没有，不仅仅是线程或处理器。 他们有时会表现得非常奇怪，做正常人类的事情并没有经常做的事情。 但是，如果有助于我们想象平行算法如何工作，我们仍然可以使用这种隐喻。

我们可以想象老板去度假，并没有触摸堆上纸上的纸上。 我们可以想象，一些工人正在生产结果比其他工人要快得多。 因为这只是想象力，加速可以是 1,000 次（想想一个时间流逝视频）。 想象解决这些情况可能有助于我们发现很少发生的特殊行为，但可能导致问题。 随着线程并行工作，大量微妙差异可能会大大影响一般行为。

在早期版本中，正如我编写了并行主机算法的那样，官僚开始工作并在老板可以将其中任何一个放在桌子上之前猜测老板的盒子。 由于桌面上没有猜测，官僚机构只是在可能构成好猜测的间隔内发现所有可能的变化。 并行助手的帮助，老板没有任何东西; 老板必须从各种可能的猜测中选择正确的猜测，而猜测者则只是空闲。

另一个时候，官僚们正在检查猜测，而老板猜测它是猜测。 坚持我们的隐喻，一些官僚吓坏了，说如果有人改变它，就无法检查猜测。 更确切地说，在修改表的`List`时，在官僚线程中抛出`ConcurrentModificationException`。

另一个时候，我试图避免官僚的过快的工作，我限制了他们可以把他们的论文含有猜测的盒子的大小。 当老板终于发现了秘密时，比赛结束了，老板告诉官僚，他们可以回家。 老板通过创建一个带有指令的小纸张来做到这一点 - 你可以回家并把它放在官僚主义的桌子上。 官僚们做了什么？ 他们一直在等待盒子的空间，因为在那里等着，他们没有阅读表格的任何变化！ （直到进程被杀死。这是在麦斯科斯队和 Linux 上的等同物，因为从 Windows 上的任务管理器结束过程。）

这种编码错误发生了，要尽可能多地避免，我们必须至少做两件事。 首先，我们必须了解 Java 多线程如何工作，其次，将代码与尽可能干净。 对于第二个，我们将更多地清理代码，然后我们将研究如何在 Java 中实现先前描述的并行算法，在 JVM 上运行而不是利用官僚。

# 重构

完成上一章时，我们拥有汉语游戏的课程，以一种良好而完美的对象导向的方式设计并编码，没有破坏任何 *oo* 原则。 我们了吗？ 荒诞。 没有代码，除了几个琐碎的例子，不能看起来更好或更好。 通常，当我们开发代码并完成编码时，它看起来很棒。 它工作，所有运行的测试，以及记录准备好了。 从专业角度来看，它真的很完美。 好吧，它足够好。 我们尚未测试的大问题是可维护性。 改变代码的成本是多少？

这不是一个简单的问题，特别是因为它不是明确的问题。 改变什么？ 我们想要制作的修改是什么？ 我们不知道当我们首先创建代码时。 如果修改是解决一个错误，那么很明显我们事先不知道。 如果我们知道，我们将没有首先介绍这个错误。 如果这是一个新功能，那么就有可能预见了该功能。 但是，通常情况下，这不是这种情况。 当开发人员试图预测未来的功能，并将来需要哪些功能，他们通常会失败。 客户知道这项业务是客户的任务。 在专业软件开发的情况下，所需的功能是由业务的驱动。 毕竟，这就是专业意义的意义。

即使我们不完全了解稍后在代码中需要更改的内容，也有某些可能为经验丰富的软件开发人员提供提示。 通常， *OO* 代码比 *ad hoc* 代码更容易维护，并且有一个代码香气可以检测。 例如，查看以下代码行：

```
while (guesser.guess() != Row.none) {
. . .
while (guesser.nextGuess() != Guesser.none) {
. . .
public void addNewGuess(Row row) {
. . .
Color[] guess = super.nextGuess();
```

我们可能会感觉到奇怪的东西。 （这些行中的每一个都在应用程序的代码中，因为我们在 [](4.html) ， *mastermind - 创建游戏*。）比较`guess()`方法的返回值 到`Row.none`，这是一个`Row`。 在下一个示例行中，我们将`nextGuess()`方法的返回值与`Guesser.none`进行比较，这应该是猜测而不是`Guesser`。 当我们在下一个示例行中添加新的猜测时，我们实际上添加了`Row`。 最后，我们可以意识到该方法`nextGuess()`返回一个不是*对象*的猜测，其中包含了自己声明的类。 猜测只是`Colors`的数组。 这些东西很乱。 我们如何提高代码的质量？

我们应该介绍另一层抽象创建`Guess`类？ 它会使代码更加可维护吗？ 或者它只会使代码更加复杂吗？ 我们通常的代码行通常是如此，我们对错误的可能性越少。 但是，有时，缺乏抽象将使代码复杂并纠结。 这种情况是什么？ 什么是一般的决定方法？

您拥有的经验越多，您可以通过查看代码并严格知道您想要制作的修改来讲述更容易。 很多次，你不会打扰更多抽象的代码，还有很多其他时间，你将毫不犹豫地创造新的课程。 如有疑问，创建新课程，看看出了什么。 重要的是不要毁了现有的功能。 只有在您有足够的单位测试时，您只能这样做。

当您想介绍一些新功能或修复错误时，但代码不合适，您将必须先修改它。 当您修改代码以使功能不会更改时，该进程名为**重构**。 在有限的时间内更改代码的一小部分，然后您构建它。 如果它编译和所有单元测试运行，那么您可以继续。 提示是经常运行构建。 这就像在现有的一条附近建造一条新道路。 每一英里一次，你应该遇到旧线路。 没有这样做，你将在沙漠中间的某个地方结束完全错误的方向，你所能做的就是返回起点 - 你的旧的待重构代码。 努力浪费了。

不仅是迫使我们经常运行构建的安全性; 这也是时间限制。 重构不直接提供收入。 该计划的功能直接与收入捆绑在一起。 没有人会为我们支付无限重构的工作。 重构必须停止某个时候，通常不是没有什么可以重构的时间了。 代码永远不会是完美的，但是当你足够好的时候可能会停止。 并且，多次，程序员对代码的质量不满意，并且当他们被迫停止某些外部因素时（通常被称为项目管理器），代码应该编译和测试应该运行，以便新功能和错误 可以在实际代码库上执行修复。

重构是一个巨大的主题，并且在这样的活动期间可以遵循许多技术。 这是如此复杂的是，马丁福勒有一本关于它的全书（ [http://martinfowler.com/books/refactoring.html](http://martinfowler.com/books/refactoring.html) ），这将很快就有第二版。

在我们的情况下，我们想要应用于我们代码的修改是实施并行算法。 我们将修改的第一件事是`ColorManager`。 当我们想在终端上打印猜测和行时，我们用一些糟糕的技巧实现了它。 为什么没有可以打印的颜色实现？ 我们可以具有扩展原始`Color`类的类，并具有返回表示该颜色的内容的方法。 你有该方法的候选名称吗？ 它是`toString()`方法。 它在`Object`类中实现，任何类都可以自由地覆盖它。 当您将对象连接到字符串时，自动类型转换将调用此方法将对象转换为`String`。 顺便说一下，它是一个使用`""+object`而不是`object.toString()`的旧技巧，以避免`null`指针异常。 不用说，我们不使用技巧。

当 Debugger 想要显示某些对象的值时，也会通过 IDE 调用`toString()`方法，因此通常建议以其他原因实现`toString()`，然后暂时轻松开发。 如果我们有一个`Color`类实现`toString()`，那么`PrettyPrintRow`课程变得相当简单，并且欺骗性不那么欺骗：

```
public class PrettyPrintRow {

    public static String pprint(Row row) {
        var string = "";
        var pRow = new PrintableRow(row);
        for (int i = 0; i < pRow.nrOfColumns(); i++) {
            string += pRow.pos(i);
        }
        string += " ";
        string += pRow.full();
        string += "/";
        string += pRow.partial();
        return string;
    }
}
```

我们从打印类中删除了问题，但您可能会争辩说出问题仍在那里，而且你是对的。 很多时候，当类设计中存在问题时，解决方案的方式是将问题从类移动到另一个。 如果那里仍然存在问题，那么你可能会越来越拆分设计，并且在最后阶段，你会意识到你有什么问题，而不是问题。

实现`LetteredColor`类也很简单：

```
package packt.java189fundamentals.mastermind.lettered;

import packt.java189fundamentals.mastermind.Color;

public class LetteredColor extends Color {

    private final String letter;
    public LetteredColor(String letter){
        this.letter = letter;
    }

    @Override
    public String toString(){
        return letter;
    }
}
```

同样，问题被推动了。 但是，实际上，这不是一个问题。 这是一个 *OO* 设计。 打印不负责将`String`分配给颜色以获取其表示。 颜色实现本身也不负责。 必须执行在所做颜色的位置进行分配，然后将`String`传递给`LetteredColor`类的构造函数。 `color`实例在`ColorManager`中创建，因此我们必须在`ColorManager`类中实现这一点。 或不？ `ColorManager`做什么？ 它创造了颜色和......

当您来解释或描述列出功能的类时，您可以立即看到**单责任原则**被侵犯。 `ColorManager`应该管理颜色。 管理是提供一种方法来以明确的顺序获取颜色，并在我们知道一种颜色时获得第一个和下一个。 我们应该实施其他责任 - 在单独的类中创建颜色。

具有创建另一个类别的唯一功能的类被称为`factory`。 与使用`new`操作员几乎相同，但是，与`new`不同，工厂可以以更灵活的方式使用。 我们会立即看到。 `ColorFactory`接口包含单个方法，如下所示：

```
package packt.java189fundamentals.mastermind;

public interface ColorFactory {
    Color newColor();
}
```

定义一个方法的接口是名为的功能接口，因为它们的实现可以作为 Lambda 表达式提供，或者在您将使用作为实现功能界面的类实例的位置的位置处的方法引用。 例如，`SimpleColorFactory`实现创建以下`Color`对象：

```
package packt.java189fundamentals.mastermind;

public class SimpleColorFactory implements ColorFactory {
    @Override
    public Color newColor() {
        return new Color();
    }
}
```

在我们的代码中使用`new SimpleColorFactory()`，我们可以写入`Color::new`或`() -> new Color()`。

非常类似于我们如何创建界面，然后是一个实现，而不是仅在`ColorManager`中的代码中写入`new Color()`。 `LetteredColorFactory`有点有趣：

```
package packt.java189fundamentals.mastermind.lettered;

import packt.java189fundamentals.mastermind.Color;
import packt.java189fundamentals.mastermind.ColorFactory;

public class LetteredColorFactory implements ColorFactory {

    private static final String letters = "0123456789ABCDEFGHIJKLMNOPQRSTVWXYZabcdefghijklmnopqrstvwxzy";
    private int counter = 0;

    @Override
    public Color newColor() {
        Color color = new LetteredColor(letters.substring(counter, counter + 1));
        counter++;
        return color;
    }
}
```

现在，在这里，我们的功能在创建时为`Color`对象分配`String`对象。 保持追踪已创建的颜色的`counter`变量非常重要，而不是`static`。 在前面的章节类似的变量是`static`，这意味着它可以随时更新`ColorManager`对象创建太多的颜色的字符用完。 当每个测试创建`ColorManager`对象和新的`Color`实例时，它实际上确实发生在单元测试执行期间。 打印代码试图为新颜色分配新字母。 该测试在同一类加载器下的相同 JVM 中运行，不幸的`static`变量没有任何线索，即它可以从零开始计算新测试时。

另一方面，这个工厂解决方案的缺点是某人，某个地方必须实例化工厂，而不是`ColorManager`。 `ColorManager`已经有责任，它不是创建一个颜色的工厂。 `ColorManager`必须在其构造函数中获取`ColorFactory`：

```
package packt.java189fundamentals.mastermind;

import java.util.HashMap;
import java.util.Map;

public class ColorManager {
    protected final int nrColors;
    protected final Map<Color, Color> successor = new HashMap<>();
    private final ColorFactory factory;
    private Color first;

    public ColorManager(int nrColors, ColorFactory factory) {
        this.nrColors = nrColors;
        this.factory = factory;
        createOrdering();
    }

    private Color[] createColors() {
        var colors = new Color[nrColors];
        for (int i = 0; i < colors.length; i++) {
            colors[i] = factory.newColor();
        }
        return colors;
    }

    private void createOrdering() {
        var colors = createColors();
        first = colors[0];
        for (int i = 0; i < nrColors - 1; i++) {
            successor.put(colors[i], colors[i + 1]);
        }
    }

    public Color firstColor() {
        return first;
    }

    public boolean thereIsNextColor(Color color) {
        return successor.containsKey(color);
    }

    public Color nextColor(Color color) {
        return successor.get(color);
    }

    public int getNrColors() {
        return nrColors;
    }
}
```

您还可能会注意到我无法将`createColors`方法重构为两种方法，以遵循单一责任原则。

现在，创建`ColorManager`的代码必须创建一个工厂并将其传递给构造函数。 例如，单元测试的`ColorManagerTest`类将包含以下方法：

```
@Test
public void thereIsAFirstColor() {
    var manager = new ColorManager(NR_COLORS, Color::new);
    Assert.assertNotNull(manager.firstColor());
}
```

这是实现由功能界面定义的工厂的最简单的方式。 只需命名类并引用`new`运算符，就好像它是通过创建方法引用的方法。

我们将重构的下一件事是`Guess`课程，实际上，我们没有到目前为止。 a `Guess`类包含猜测的挂钩，并且可以计算完整（颜色和位置）的数量和部分（颜色存在，但在错误的位置）匹配。 它还可以计算此猜测后的下一个`Guess`。 此功能是在`Guesser`类来实现，到目前为止，但是这是不是真的检查桌子上已经作出的猜测时，我们如何选择猜测的功能。 如果我们按照我们为颜色设置的模式，我们可以在命名为`GuessManager`的单独类中实现此功能，但是，截至目前，不需要。 再次，所需的抽象水平主要是品味的问题; 这件事不是黑色或白色。

值得注意的是，只能立即进行`Guess`对象。 如果它位于桌面上，则不允许播放器更改它。 如果我们有一个尚未在桌子上的`Guess`，它仍然只是由 PEG 的颜色和订单标识的`Guess`。 A `Guess`对象在创建后永远不会更改。 这些对象易于在多线程程序中使用，并且称为不可变的对象。 因为这是一个相对较长的课程，我们将在本书中检查几个片段中的代码：

```
package packt.java189fundamentals.mastermind;

import java.util.Arrays;
import java.util.HashSet;

public class Guess {
    public final static Guess none = new Guess(new Color[0]);
    private final Color[] colors;
    private boolean uniquenessWasNotCalculated = true;
    private boolean unique;

    public Guess(Color[] colors) {
        this.colors = Arrays.copyOf(colors, colors.length);
    }
```

构造函数正在创建作为参数传递的颜色数组的副本。 因为`Guess`是不可变的，这是非常重要的。 如果我们只是保留原始数组，则`Guess`类之外的任何代码可以更改数组的元素，基本上更改不应该更改的`Guess`的内容。

代码的下一部分是两个简单的 getters：

```
public Color getColor(int i) {
    return colors[i];
}

public int nrOfColumns() {
    return colors.length;
}
```

下一个方法是计算`nextGuess`的方法：

```
public Guess nextGuess(ColorManager manager) {
    final var colors = Arrays.copyOf(this.colors, nrOfColumns());

    int i = 0;
    var guessFound = false;
    while (i < colors.length && !guessFound) {
        if (manager.thereIsNextColor(getColor(i))) {
            colors[i] = manager.nextColor(colors[i]);
            guessFound = true;
        } else {
            colors[i] = manager.firstColor();
            i++;
        }
    }
    if (guessFound) {
        return new Guess(colors);
    } else {
        return Guess.none;
    }
}
```

在此方法中，我们开始计算`nextGuess`，从包含在实际对象中的颜色阵列开始。 我们需要一个修改的工作数组，所以我们将复制原件。 此时，最终的新对象可以使用我们在计算过程中使用的数组。 要允许，我们需要一个单独的构造函数，不会创建`Color`数组的副本。 这是一个可能的额外代码。 只有我们看到代码中的瓶颈，我们应该考虑创造它，我们对实际性能不满意。 在这个应用程序中，它不是瓶颈，我们对性能感到满意，因为当我们讨论基准时，您会看到后面。

下一个方法只需检查传递的`Guess`是否具有与实际颜色相同的颜色：

```
private void assertCompatibility(Guess guess) {
    if (nrOfColumns() != guess.nrOfColumns()) {
        throw new IllegalArgumentException("Can not compare different length guesses");
    }
}
```

这只是计算匹配的下两种方法使用的安全检查：

```
public int nrOfPartialMatches(Guess guess) {
    assertCompatibility(guess);
    int count = 0;
    for (int i = 0; i < nrOfColumns(); i++) {
        for (int j = 0; j < nrOfColumns(); j++) {
            if (i != j &&
                    guess.getColor(i) == this.getColor(j)) {
                count++;
            }
        }
    }
    return count;
}

public int nrOfFullMatches(Guess guess) {
    assertCompatibility(guess);
    int count = 0;
    for (int i = 0; i < nrOfColumns(); i++) {
        if (guess.getColor(i) == this.getColor(i)) {
            count++;
        }
    }
    return count;
}
```

下一个`isUnique()`方法检查`Guess`中是否若有多次颜色。 随着`Guess`是不可变的，可能不会发生`Guess`在一次唯一的情况下是独特的，而不是另一个时间独特。 每当调用特定对象时，此方法应返回相同的结果。 因此，可以缓存结果。 此方法执行此操作，将返回值保存到实例变量。

您可以说这是过早的优化。 是的。 我决定是为了一个原因而做的。 它是一个本地保存结果的演示，基于此，您可以尝试修改`nextGuess()`方法来执行相同的方法。 `isUnique()`方法如下：

```
public boolean isUnique() {
    if (uniquenessWasNotCalculated) {
        final var alreadyPresent = new HashSet<Color>();
        unique = true;
        for (final var color : colors) {
            if (alreadyPresent.contains(color)) {
                unique = false;
                break;
            }
            alreadyPresent.add(color);
        }
        uniquenessWasNotCalculated = false;
    }
    return unique;
}
```

返回相同参数的相同结果的方法称为 idempotent。 如果该方法调用多次并且计算使用大量资源，则缓存此类方法的返回值可能非常重要。 当该方法具有参数时，缓存结果并不简单。 `object`方法必须记住已计算的所有参数的结果，并且此存储必须有效。 如果需要更多资源来查找存储的结果而不是计算所存储的结果，那么使用缓存不仅使用更多内存，而且还慢下来。 如果在对象的生命周期内调用该方法的几个参数，则存储存储器可能刚刚变得太大。 必须清除不再需要的元素。 但是，我们无法知道稍后不需要缓存的哪些元素。 我们不是幸运的人，所以我们必须猜测。 （就像幸运的柜员一样。）

正如您所看到的，缓存可以变得复杂。 要做到这一专业，几乎总是最好使用一些可用的缓存实现。 这里使用的缓存只是冰山一角。 或者，即使只是阳光瞥见它。

班级的其余部分是相当标准的，我们在详细讨论的内容 - 良好的检查是您的知识，了解如何通过这种方式实现`equals()`，`hashCode()`和`toString()`方法。 我实现了`toString()`方法来帮助我调试，但它也用于很快遵循的示例输出。 以下是以下方法：

```
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || !(o instanceof Guess)) return false;
    var guess = (Guess) o;
    return Arrays.equals(colors, guess.colors);
}

@Override
public int hashCode() {
    return Arrays.hashCode(colors);
}

@Override
public String toString() {
    if (this == none) {
        return "none";
    } else {
        String s = "";
        for (int i = colors.length - 1; i >= 0; i--) {
            s += colors[i];
        }
        return s;
    }
}
```

主要是，这是我开发并行算法时所需的所有修改。 在这些更改之后，代码看起来更好，很好地描述了功能，以便我们可以专注于本章的主题 - 如何并行执行 Java 中的代码。

Java 中代码的并行执行在线程中完成。 您可能知道 Java 运行时中有一个`Thread`对象，但不了解计算机中的线程是什么，它没有意义。 在以下小节中，我们将学习这些线程是什么，如何启动一个新线程，如何同步线程之间的数据交换，最后将所有这一切放在一起并实现 MasterMind 游戏并行猜测算法。

# 流程

启动计算机时，启动的程序是操作系统（OS）。 操作系统控制机器硬件和可以在机器上运行的程序。 启动程序时，操作系统会创建一个新进程。 这意味着 OS 在表（阵列）中分配一个新条目，其中它管理进程并填写它所知的参数，并且需要了解该过程。 例如，它注册了允许进程使用的内存段，该过程的 ID 是哪个用户启动的内容，以及使用哪些进程来启动它。 你无法从薄空气中开始一个进程。 双击 EXE 文件时，您实际上告诉文件资源管理器，该文件资源管理器是运行作为进程的程序，以将 EXE 文件作为单独的进程启动。 Explorer 通过 API 调用系统，并请询问操作系统。 操作系统将注册资源管理器进程作为新进程的父级。 操作系统实际上并不在这一点开始该过程，但是在此时创建它需要随后开始它的所有数据，并且当有一些免费的 CPU 资源时，进程开始，并且在此之后，它很快就会暂停 重新启动，然后暂停，等等。 您不会注意到它，因为操作系统将一次又一次地启动它，并且始终反复暂停进程。 它需要这样做，为所有流程提供运行可能性。 这样，我们经历了同时运行的所有进程。 实际上，流程在单个处理器上没有同时运行，但它们会频繁地运行时隙，以便我们觉得他们一直在运行。

如果计算机中有多个 CPU，则进程实际上可以在与 CPU 的同时运行时运行。 随着当今集成更高级的，桌面计算机具有包含多个函数，几乎与单独的 CPU 一样。 在我的机器上，我有四个核心，每个核心都能够同时执行两个线程; 所以，我的麦克斯几乎就像一个 8 个 CPU 机器。 当我开始工作时，8 亿计算机是一百万美元的机器。

流程有单独的回忆。 他们被允许使用内存的一部分，如果进程尝试使用不属于它的部分，则处理器将停止执行此操作。 操作系统将杀死该过程。

想象一下，原始 UNIX 的开发人员必须一定是他们命名为程序来阻止作为`kill`的过程。 停止一个过程称为杀戮。 当他们切掉重型手时，就像中世纪的时代。 你触摸了内存的错误部分并被杀死。 我不想成为一个过程。

除了将过程彼此分离外，操作系统的内存处理非常复杂。 当内存没有足够的内存时，OS 将部分内存写入磁盘，释放内存并在再次需要时重新加载该部分。 这是特殊硬件操作支持的非常复杂，低级别的实现和高度优化的算法。 这是操作系统的责任。

# 线程

当我说操作系统在时隙中执行流程时，我简化了如何真正发生。 每个进程都有一个或多个线程，并且执行线程。 线程是由*外部*调度程序管理的最小执行。 较旧的 oise 没有线程的概念并执行进程。 事实上，第一个线程实现是分享内存的进程的简单重复。

如果您读取了旧的话，您可以听到第*轻量级过程*。 它意味着一个线程。

重要的是线程没有自己的记忆。 他们使用该过程的记忆。 换句话说，在同一过程中运行的线程具有对同一内存段的无法区分的访问。

实现并行算法的可能性，使得在机器中使用多个核心非常强大，但同时可能导致错误：

![](img/c051a9af-b577-4087-8b0e-e3138e17a710.png)

想象一下，两个线程递增相同的长变量。 增量首先计算较低 32 位的递增值，然后是较高的，如果存在任何溢出比特。 这些是 OS 中可能中断的两个或更多个步骤。 可能发生一个线程递增较低的 32 位，它记得到上 32 位有什么东西，开始计算，但没有时间在它被中断之前存储结果。 然后，另一个线程递增较低的 32 位，上部 32 位，然后第一线程刚刚节省了所计算的较高 32 位。 结果乱码了。 在较旧的 32 位 Java 实现中，展示这种效果非常容易。 在 64 位 Java 实现中，所有 64 位都将加载到寄存器中并在一步中保存回内存，因此展示这种多线程并不是那么容易，但这并不意味着没有。

当线程暂停并且另一个线程启动时，操作系统必须执行上下文切换。 它意味着，除此之外，还必须保存 CPU 寄存器，然后设置为其应该具有其他线程的值。 上下文切换始终保存线程的状态并加载要启动的线程的先前保存状态。 这是 CPU 寄存器级别。 这种上下文切换是耗时的; 因此，存在的上下文切换越多，越多的 CPU 资源用于线程管理而不是让它们运行。 另一方面，如果没有足够的交换机，某些线程可能无法获得足够的时间槽以执行，并且程序挂起。

# 纤维

Java 版本 11 没有光纤，但有一些支持有限的光纤处理，也有一个 JDK 项目（ [http://openjdk.java.net/projects/loom/](http://openjdk.java.net/projects/loom/) ），其目标 有一个支持光纤的稍后 JVM 版本。 因此，迟早，我们将在 Java 中有纤维，因此，了解并知道它们是重要的。

纤维是比螺纹更精细的单位。 在线程中执行的程序代码可能决定放弃执行并告诉光纤管理器只需执行其他一些光纤。 什么是什么，为什么比使用另一个线程更好？ 原因在于，这种方式，光纤可以避免上下文切换的一部分。 不能完全避免上下文切换，因为开始执行它的代码的不同部分可以以完全不同的方式使用 CPU 寄存器。 由于它是相同的线程，因此上下文切换不是操作系统的任务，而是应用程序。

操作系统不知道是否使用寄存器的值。 寄存器中有位，并且没有人可以告诉，仅看到处理器状态，这些比特是否与当前代码执行相关，或者只是以这种方式发生在那里。 由编译器生成的程序确实知道哪些寄存器很重要，哪些寄存器是那些可以忽略的寄存器。 此信息从一个地方更改为代码，但是当需要一个开关时，光纤通过该点到切换的代码所需的信息。

编译器计算此信息，但 Java 不支持当前版本中的光纤。 在编译阶段之后，在 Java 中实现 java 中的光纤分析和修改类的字节码。

Golang 的 Goroutines 是纤维的类型，这就是为什么你可以轻松地开始大量的大峡谷，但建议您将 Java 中的线程数限制为较低的数字。 它们不是同一件事。

即使术语*轻质过程*慢慢消失，并且被较少且较少地使用，纤维通常仍被称为轻质线程。

# java.lang.thread.

Java 中的一切（差不多）是一个对象。 如果我们想启动一个新的线程，我们将需要一个对象，因此，一个代表线程的类。 此类是`java.lang.Thread`，它内置于 JDK 中。 当您启动 Java 代码时，JVM 会自动创建一些`Thread`对象，并使用它们来运行它所需的不同任务。 如果启动 **VisualVM** ，您可以选择任何 JVM 进程的线程选项卡，并查看 JVM 中的实际线程。 例如，我开始的 VisualVM 有 29 个直线线程。 其中一个是名为`main`的线程。 这是开始执行`main`方法的那个（惊喜！）。 `main`线程启动了大多数其他线程。 当我们想编写多线程应用程序时，我们将必须创建新的`Thread`对象并启动它们。 最简单的方法是启动`new Thread()`，然后在线程上调用`start()`方法。 它将开始一个新的`Thread`，只要我们没有给它任何事情即可立即完成。 `Thread`类，因为它在 JDK 中，不做我们的业务逻辑。 以下是指定业务逻辑的两种方式：

*   创建实现`Runnable`界面的类并将其实例传递给`Thread`对象
*   创建扩展`Thread`类的类并覆盖`run`方法

以下代码块是一个非常简单的演示程序：

```
package packt.java189fundamentals.thread;

public class SimpleThreadIntermingling {
    public static void main(String[] args) {
        Thread t1 = new MyThread("t1");
        Thread t2 = new MyThread("t2");
        t1.start();
        t2.start();
        System.out.print("started ");

    }

    static class MyThread extends Thread {
        private final String name;

        MyThread(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            for (int i = 1; i < 1000; i++) {
                System.out.print(name + " " + i + ", ");
            }
        }
    }
}
```

前面的代码创建两个线程，并在另一个之后启动它们。 调用 start 方法时，它会调度要执行的线程对象，然后返回。 因此，新线程很快就会在调用线程继续执行时异步地执行。 两个线程和`main`线程在以下示例中并行运行，并创建一个看起来像这样的输出：

```
started t2 1, t2 2, t2 3, t2 4, t2 5, t2 6, t2 7, t2 8, t1 1, t2 9, t2 10, t2 11, t2 12,...
```

实际输出从运行运行时更改。 执行的无明确顺序，或者线程如何访问单个屏幕输出。 甚至没有保证在每次和每次执行中，在任何线程消息之前都会打印消息`started`。

为了更好地了解这一点，我们看看线程的状态图。 Java 线程可以是以下状态之一：

*   `NEW`
*   `RUNNABLE`
*   `BLOCKED`
*   `WAITING`
*   `TIMED_WAITING`
*   `TERMINATED`

这些状态在`enumThread.State`中定义。 创建新的线程对象时，它位于`NEW`状态。 此时，线程没什么特别的，它只是一个对象，但操作系统的执行调度不知道它。 在某种意义上，它只是 JVM 分配的一段内存。

调用启动方法时，将关于线程的信息传递给 OS，OS 调度线程，以便在存在适当的时隙时它可以由它执行。 这样做是一个有智慧的动作，这就是为什么我们不创建的原因，特别是在必需时才能启动新的`Thread`对象。 即使目前不需要，我们将保留现有线程，而不是创建新的`Threads`，而不是创建新的`Threads`，并且如果存在一个合适的情况，即使在此时不需要它们。

操作系统中的一个线程也可以处于运行状态，以及 OS 调度并执行它的运行状态。 目前，Java JDK API 没有区分两者以获得充分原因。 这将是无用的。 当一个线程在`RUNNABLE`状态中时，如果它实际上正在运行，则询问线程本身将导致显而易见的答案 - 如果从`Thread`类中实现的`getState()`方法返回的代码，那么它 运行。 如果它没有运行，则它将首先从呼叫中返回。 更进一步，在非运行`Thread`内也不可能调用方法`getState()`。 如果从另一个线程调用`getState()`方法，那么通过方法返回的时间有关另一个线程的结果将毫无意义。 操作系统可能已停止或启动，返回 Quered 线程几次。

当在线程中执行的代码尝试访问当前可用的资源时，线程在`BLOCKED`状态中。 为避免持续轮询资源，操作系统提供了有效的通知机制，以便在所需的资源可用时，线程返回`RUNNABLE`状态。

当它等待一些其他线程或锁定时，一个线程在`WAIT`或`TIMED_WAITING`状态。 `TIMED_WAITING`是等待启动的状态，调用一个具有超时的方法的版本。

最后，当线程完成其执行时达到`TERMINATED`状态。 如果将以下行追加到我们上一个示例的末尾，那么您将获得`TERMINATED`打印输出，并将异常抛出到抱怨非法线程状态的屏幕，这是因为无法启动已终止的线程：

```
System.out.println(); 
System.out.println(t1.getState()); 
System.out.println(); 
t1.start();
```

而不是扩展`Thread`类来定义异步执行的内容，我们可以创建一个实现`Runnable`界面的类。 做这一点与 *oo* 编程方法更加连贯。 我们在类中实现的东西不是线程的功能。 它更像是可以执行的东西。 这是可以刚刚运行的东西。

如果执行在不同的线程中异步，或者如果在调用 RUN 方法的同一线程中执行，则这是要分开的不同问题。 如果我们这样做，我们可以将类传递给`Thread`对象作为构造函数参数。 在`Thread`对象上调用`start`将启动我们传递的对象的运行方法。 这不是增益。 增益是我们也可以将`Runnable`对象传递给`Executor`（可怕的名字，呵呵！）。 `Executor`是​​一个接口，实现以有效的方式执行`Runnable`（以及`Callable`，参见稍后的）对象。 执行者通常具有编写的`Thread`对象的池，并在`BLOCKED`状态中。 当`Executor`有一个新任务来执行时，它会给它一个`Thread`对象之一，并释放阻止线程的锁定。 `Thread`进入`RUNNABLE`状态，执行`Runnable`，再次被阻止。 它不会终止，因此可以重复使用以稍后执行另一`Runnable`。 这样，`Executor`实现避免了 OS 中的线程注册的资源消耗过程。

专业的应用程序代码永远不会创建一个新的`Thread`。 应用程序代码使用框架来处理代码的并行执行或使用由某些`ExecutorService`提供的`Executor`实现来启动`Runnable`或`Callable`对象。

# 陷阱

我们已经讨论了在开发并行计划时可能面临的许多问题。 在本节中，我们将通过用于问题的通常术语来总结它们。 术语不仅有趣，而且当你与同事交谈时也很重要，以便你彼此了解。

# 死锁

死锁是最臭名昭着的并行编程陷阱，因此，我们将从这个开始。 要描述这种情况，我们将遵循官僚的隐喻。

官僚必须盖章。 为此，他需要邮票和论文。 首先，他去了邮票所在的抽屉和接受它。 然后，他走到抽屉里，其中纸张并采取纸。 他墨水墨水，并按下纸张。 然后，他把邮票和纸张归还给他们的地方。 一切都是桃子; 我们在云 9。

如果另一个官僚首先拿到这篇文章，那么邮票第二次会发生什么？ 他们可能很快结束了一个官僚与邮票在手上等待纸张，另一个在手中等待邮票。 而且，他们可能只是留在那里，永远冻结，然后越来越多的开始等待这些锁，而且纸张从未被盖章，整个系统陷入了冰冻的无政府状态。

为了避免这种情况，必须订购锁，并且始终以相同的顺序获取锁。 在前面的示例中，首先获得墨水垫的简单协议和邮票第二解决问题。 谁收购了邮票可以确定墨水垫是免费的，或者很快就会免费。

# 种族条件

当计算结果可以基于不同并行运行线程的速度和 CPU 访问时，我们讨论竞争条件。 让我们看一下以下两种方法：

```
   void method1(){
1       a = b; 
2       b = a+1; 
        } 
    void method2(){ 
3       c = b; 
4       b = c+2; 
        }
```

线的顺序可以是 1234,1324,1342,3412,3142 或 3142.可能发生四条线的任何执行顺序，以确保 **1 **2** 和 **3** 在 **4** 之前运行，但没有其他限制。 假设`b`的值在开始时为零，在段执行结束时`b`的值是 1 或`2£`。 这几乎绝不是我们想要的。 如果我们程序的行为不是随机的，除了实现随机发生器时，我们更喜欢它。**

请注意，并行 MasterMind 游戏的实施也面临着一种种族条件的东西。 实际猜测非常依赖于不同线程的速度，但是从最终结果的角度来看，这是无关紧要的。 我们可能在不同的运行中有不同的猜测，这样，算法不是确定性的。 保证是什么，我们找到了最终解决方案。

# 过度使用的锁

在许多情况下，可能会发生线程在锁上等待锁，这保护资源并经常访问。 如果可以同时由多个线程使用资源，并且有更多的线程，则线程旨在删除。 然而，在许多情况下，可以以一种方式组织资源，使得线程可以访问资源提供的一些服务，并且锁定结构可能不太限制。 在这种情况下，锁定过度使用，并且可以修复情况而不为线程分配更多资源。 可以使用多个锁来控制对资源的不同功能的访问。

# 饥饿

饥饿是几个线程在等待尝试获取锁的资源的情况的情况，并且某些线程只在非常长的时间之后就可以访问锁定，或者永远不会访问锁定。 当锁定锁定并且有线程等待它时，那么其中一个线程可以锁定。 通常无法保证如果它等于足够长，则线程会得到锁定。 这样的机制需要密集的线程管理，将它们排序在等待队列中。 由于锁定应该是低延迟和高性能动作，即使是几个 CPU 时钟周期也很重要; 因此，锁定不提供此类公平访问默认情况下。 在线程调度方面的公平不浪费时间是一种很好的方法，以防锁只有一个螺纹等待。 锁的主要目标不是安排等待线程，而是防止并行访问资源。

它就像一家商店。 如果收银员有人，你会等。 这是一个锁定的锁，它是隐含的。 如果人们没有排队收银员，这不是一个问题，只要几乎总是一个免费。 然而，当有几个人在收银员前等待时，那么没有队列和等待命令当然会导致很长的等待时间，让人慢进入收银员。 通常，公平性和创建等待线程（客户）的队列的解决方案不是一个好的解决方案。 良好的解决方案是消除导致等待队列的情况。 您可以使用更多的收银员，或者您可以做一些完全不同的东西，使得峰值负荷更小。 在一家商店，您可以享受折扣，以驱动距离峰值时间的客户。 在编程中，通常可以应用几种技术，具体取决于我们代码的实际业务，并且锁的公平计划通常是解决方法。

# Executorservice.

`ExecutorService`是 JDK 中的接口。 接口的实现可以以异步方式执行`Runnable`或`Callable`类。 该接口仅定义实现的 API，并且不需要调用是异步的。 实际上，这就是我们使用这种服务的原因。 用同步方式调用`run`接口的`run`方法只是调用方法。 我们不需要一个特殊的课程。

`Runnable`接口定义一个`run`方法。 它没有参数，返回任何值，并且不会抛出异常。 `Callable`界面是参数化的，它定义的唯一方法`call`没有参数，但返回通用值，也可以抛出`Exception`。 在一个代码中，如果我们只想运行东西，我们就可以实现`Runnable`，以及我们想要返回一些东西时的`Callable`。 这两种接口都是功能界面; 因此，它们是使用λ实现的好候选人。

要具有`ExecutorService`的实现实例，我们可以使用实用程序类`Executors`。 通常，当 JDK 中存在`XYZ`接口时，可以有一个`XYZs`（多个）实用程序类，为接口实现提供工厂。 如果我们想多次启动`t1`任务，我们可以在不创建新的`Thread`的情况下这样做。 我们应该使用以下执行程序服务：

```
public class ThreadIntermingling {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        final var es = Executors.newFixedThreadPool(2);
        final var t1 = new MyRunnable("t1");
        final var t2 = new MyRunnable("t2");
        final Future<?> f1 = es.submit(t1);
        final Future<?> f2 = es.submit(t2);
        System.out.print("started ");
        var o = f1.get();
        System.out.println("object returned " + o);
        f2.get();
        System.out.println();
        es.submit(t1);
        es.shutdown();
    }

    static class MyRunnable implements Runnable {
        private final String name;

        MyRunnable(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            for (int i = 1; i < 10; i++) {
                System.out.print(name + " " + i + ", ");
            }
        }
    }
}
```

这次，当我们第二次提交任务`t1`时，我们不会出现异常。 在此示例中，我们使用具有两个`Thread`插槽的固定大小的线程池。 我们希望同时启动两个线程，就足够了。 有实现的实现和动态地增长池的大小。 当我们希望限制线程数或我们知道从其他信息来源时，应使用固定大小的池源使用线程数*先验*。 在这种情况下，将池的大小改变为一个是一个很好的实验，并看到第二个任务在这种情况下不会开始，直到第一个完成。 该服务将没有另一个线程`t2`，并且必须等到池中的一个且唯一的`Thread`可用。

当我们将任务提交给服务时，即使当前无法执行任务，它也会返回。 在队列中放入任务，并将在有足够的资源启动它们时立即开始执行。 `submit`方法返回一个`Future<?>`对象，因为我们可以在上面的示例中看到。

它就像一张服务票。 你把你的车带到维修机械师上，你买一张票。 您不需要留在那里，直到汽车固定，但在任何时候，您都可以询问汽车是否准备好了。 你所需要的只是票。 您也可以决定等到汽车准备好。 一个`Future`对象是类似的东西。 您没有得到您需要的价值。 它将是异步计算的。 但是，存在一个`Future`承诺，它将在那里和您的票证访问您需要的对象是`Future`对象。

当您有一个`Future`对象时，可以调用`isDone()`方法来查看它是否已准备就绪。 您可以开始等待它来调用`get()`，或没有超时。 您还可以取消执行它的任务，但在这种情况下，结果可能是值得怀疑的。 就像你的车一样，如果你决定取消任务，你可以用电机拆卸你的车。 同样，取消未准备的任务可能导致资源丢失，打开和无法访问的数据库连接（即使在 10 年之后也是我的痛苦记忆），或者只是一个乱码的无法使用的对象。 准备您的任务被取消或不要取消它们。

在前面的示例中，由于我们提交了`Runnable`对象而不是`Callable`，因此没有返回值。 在这种情况下，不使用传递给`Future`的值。 它通常是`null`，但这无关紧要。

许多开发人员未命中的最终最重要的事情，即使是我，在不使用代码编写多数 java api 之后，正在关闭`ExecutorService`。 创建`ExecutorService`，它具有`Thread`元素。 所有非守护程序线程停止时，JVM 会停止。 “直到胖子的唱歌，这还没有结束。”

如果它被设置为守护程序（在启动之前调用`setDaemon(true)`），则线程是守护程序线程。 一个自动启动它的守护程序线程的线程也是一个守护程序线程。 当所有其他线程完成时，JVM 停止守护程序线程，并且 JVM 想要完成。 JVM 执行本身的一些线程是守护程序线程，但可能无法实际使用在应用程序中创建守护程序线程。

未关闭服务只是防止 JVM 停止。 代码将在`main`方法完成后挂起。 要告诉`ExecutorService`，没有必要的线程，我们将需要`shutdown`服务。 呼叫只会立即开始关机并立即返回。 在这种情况下，我们不想等待。 无论如何，JVM 确实如此。 如果我们需要等待，我们将不得不打电话给`awaitTermination`。

# 完善的未来

Java 版本 1.8 介绍了接口`Future` - `CompletableFuture`的新实现。 `java.util.concurrent.CompletableFuture`类可用于异步执行定义回调以处理结果的程序。 由于 Java 1.8 还引入了 Lambda 表达式，可以使用它们来描述回调：

```
public static void main(String[] args) throws ExecutionException, InterruptedException {
    var future = CompletableFuture.supplyAsync(() ->
            {
                var negative = true;
                var pi = 0.0;
                for (int i = 3; i < 100000; i += 2) {
                    if (negative)
                        pi -= (1.0 / i);
                    else
                        pi += (1.0 / i);
                    negative = !negative;
                }
                pi += 1.0;
                pi *= 4.0;
                return pi;
            }
    ).thenAcceptAsync(piCalculated -> System.out.println("pi is " + piCalculated));
    System.out.println("All is scheduled");
    future.get();
}
```

完整的未来类实现了`Future`界面，但它还提供了当我们需要描述异步代码执行时友好的方法。 额外的方法是在`CompletionStage`界面中定义的，这首先是有点奇怪的名称，但我们将理解它的真正意味着什么。

我们已经看到了此接口中定义的许多方法之一 - `thenAcceptAsync()`。 前面的代码创建由 Lambda 表达式定义的完整的未来。 静态方法`supplyAsync()`接受`Supplier`作为参数。 Java 的线程系统将稍后调用此供应商。 此方法的返回值是`CompletableFuture`，它用于使用方法`thenAcceptAsync()`创建另一个`CompletableFuture`。 第二`CompletableFuture`附加到第一个`CompletableFuture`。 只有在第一个完成时才开始。 `thenAcceptAsync()`的论点是消费者，它将消耗`Supplier`提供的第一个`CompletableFuture`的结果。 可以使用以下伪代码描述代码的结构：

```
CompletableFuture.supplyAsync( supply_value ).thenAcceptAsync( consume_the_value )
```

它说要启动由`supply_value`表示的`Supplier`，并且在完成时，将此值馈送到由`consume_the_value`表示的消费者。 示例代码计算 PI 的值并提供此值。 `consume_the_value`部分将值打印到输出。 当我们运行代码时，文本`All is scheduled`可能会在首先打印到输出和 PI 之后的计算值。

班级有许多其他方法。 当完成的未来没有产生任何值或我们只是不需要消耗值，然后我们应该使用`thenRunAsync(Runnable r)`方法。

如果我们想消耗该值并且还希望从中创建一个新值，那么我们应该使用`thenApplyAsync()`方法。 该方法的参数是一个`Function`是可以获得 completable 未来的结果是运行后，其结果是为未来 completable `thenApplyAsync()`返回该值。

在完成完成后，还有许多其他方法执行代码。 这些都是在第一个完整的未来完成后指定一些回调的目的。 执行完成的未来代码可能会抛出异常。 在这种情况下，完成了完成的未来; 它不会抛出异常。 异常被捕获并存储在完整的未来对象中，只有在我们想要访问`get()`方法时才会抛出它。 方法`get()`抛出封装原始异常的`ExecutionException`。 `join()`方法抛出原始异常。

诸如`thenAcceptAsync()`的方法具有它们的同步对，例如`thenAccept()`。 如果调用这一点，则传递的代码将被执行：

*   使用相同的线程，用于在此代码依赖的未来尚未完成的完整的未来，以执行原始的完整的未来; 或者
*   如果已完成的未来已经完成，请使用普通的来电方式线程

换句话说，如果我们再次查看伪代码：

```
var cf = CompletableFuture.supplyAsync( supply_value );
cf.thenAccept( consume_the_value )
```

但这时间它是`thenAccept()`而不是`thenAcceptAsync()`，因此在用`supply_value`完成后，执行由`supply_value`呈现的代码的线程继续执行`consume_the_value`，或者如果执行`supply_value`是 在调用方法`thenAccept()`时已经完成，然后它将简单执行如下：

```
consume_the_value( cf.get() )
```

在这种情况下，代码`consume_the_value`简单地同步执行。 （请注意，如果发生异常，它将存储而不直接抛出。）

使用`CompletableFuture`的最佳用例是我们有异步计算，我们需要处理结果的回调方法。

# forkjoinpool.

`ForkJoinPool`是一个特殊的`ExecutorService`，具有执行`ForkJoinTask`对象的方法。 当我们想要执行的任务可以分成许多小型任务时，这些类非常方便，然后在结果时，可以使用，聚合。 使用此执行程序，我们不需要关心线程池的大小并关闭执行程序。 将线程池的大小调整为给定计算机上的处理器数量，以具有最佳性能。 正如`ForkJoinPool`是一个专用的`ExecutorService`，它专为短期运行任务而设计，它不会期望在不再运行任务时越来越长或正在需要任何任务。 因此，它被作为守护程序线程执行; 当 JVM 关闭时，`ForkJoinPool`会自动停止。

要创建任务，程序员应扩展`java.util.concurrent.RecursiveTask`或`java.util.concurrent.RecursiveAction`。 第一个在任务中有一些返回值时要使用，而第二次没有计算值返回。 它们被称为递归，因为多次，这些任务拆分了它们必须解决较小问题的问题，并通过 Fork / Join API 异步调用这些任务。

使用此 API 解决的典型问题是 Quicksort。 在[第 3 章](3.html)，*优化排序代码专业人员*，我们创建了两个版本的 Quicksort 算法，一个使用递归调用和一个没有。 我们还可以创建一个新的，而不是递归地调用自己，调度要执行的任务，也许是由另一个处理器执行。 调度是`ForkJoinPool`的`ExecutorService`的执行任务。

您可以重新审视[第 3 章](3.html)，*优化排序代码专业人员*中的`Qsort.java`代码。 以下是使用`ForkJoinPool`的版本，而没有一些明显的代码，包括构造函数和`final`字段定义：

```
public void qsort(Sortable<E> sortable, int start, int end) {
    ForkJoinPool pool = new ForkJoinPool();
    pool.invoke(new RASort(sortable, start, end));
}

private class RASort extends RecursiveAction {

    final Sortable<E> sortable;
    final int start, end;

    public RASort(Sortable<E> sortable, int start, int end) {
        this.sortable = sortable;
        this.start = start;
        this.end = end;
    }

    public void compute() {
        if (start < end) {
            final E pivot = sortable.get(start);
            int cutIndex = partitioner.partition(sortable, start, end, pivot);
            if (cutIndex == start) {
                cutIndex++;
            }
            RecursiveAction left = new RASort(sortable, start, cutIndex - 1);
            RecursiveAction right = new RASort(sortable, cutIndex, end);
            invokeAll(left, right);
            left.join();
            right.join();
        }
    }
}
```

阵列由枢轴元素拆分之后，将创建两个`RecursiveAction`对象。 它们存储对左手和阵列的右侧进行排序所需的所有信息。 当调用`invokeAll()`时，这些操作会定时。 `invokeAll()`方法由前面的代码继承来自`ForkJoinClass` class 通过`RecursiveAction`，它本身在此代码中延长。

API 上有良好的阅读材料，以及 Oracle 的 Javadoc 文档的应用。

# 可变访问

现在我们可以启动线程并创建运行并行的代码，是时候谈谈这些线程如何在彼此之间交换数据。 乍一看，似乎相当简单。 线程使用相同的共享内存; 因此，他们可以读取和写入 Java Access Protection 允许它们的所有变量。 除了一些线程可能只是决定不读取内存之外，这是真的。 毕竟，如果它们刚刚读取特定变量的值，为什么如果没有修改，为什么再次从内存中读取到寄存器？ 谁会修改它？ 让我们看看以下简短示例：

```
package packt.java189fundamentals.thread;

public class VolatileDemonstration implements Runnable {
    private final Object o;
    private static final Object NON_NULL = new Object();
    @Override
    public void run() {
        while( o == null );
        System.out.println("o is not null");
    }

    public VolatileDemonstration() throws InterruptedException {
        new Thread(this).start();
        Thread.sleep(1000);
        this.o = NON_NULL;
    }

    public static void main(String[] args) throws InterruptedException {
        VolatileDemonstration me = new VolatileDemonstration();
    }
}
```

会发生什么？ 您可能希望代码启动，启动新线程，然后，当`main`线程将对象设置为不是`null`的东西时，会停止吗？ 它不会。

它可能会在一些 Java 实现上停止，但是，在大多数情况下，它只继续旋转。 原因是 JIT 编译器优化代码。 它看到循环没有什么，并且变量也永远不会是非空的。 允许假设由于未声明为`volatile`的变量不受不同的线程修改，因此 JIT 有资格优化。 如果我们声明`Object o`变量为`volatile`，则代码将停止。 您还必须删除`final`关键字，因为变量不能同时是`final`和`volatile`。

如果您尝试删除睡眠呼叫，则代码也将停止。 但是，这不解决问题。 原因是只有在代码执行的大约 5,000 个循环之后，才会才能获得 JIT 优化踢。 在此之前，代码在优化之前运行 Naive 并停止将消除额外的，并且定期不需要访问非易失性变量。

如果这是如此令人难以置疑，那么为什么我们不声明所有变量都是不稳定的？ 为什么 Java 不这样做？ 答案是速度。 要更深入地理解，我们将与办公室和官僚使用我们的隐喻。

# CPU 心跳

这些天，CPU 在 2 到 4 GHz 频率处理器上运行。 这意味着处理器获得 2 到 4 倍 10 <sup>9</sup> 时钟信号，每秒做点什么。 处理器不能更快地执行任何原子操作，而且没有理由创建比处理器遵循的速度更快的时钟。 这意味着 CPU 执行简单的操作，例如纳入纳秒的一半或四分之一的寄存器。 这是处理器的心跳，如果我们认为官僚作为人类，他们是谁，那么它相当于一秒钟，大约是他们的心跳。 在我们的想象中，这会使计算机的操作减慢了解可理解的速度。

处理器在芯片上有不同级别的芯片寄存器和高速缓存; L1，L2，有时 L3; 检索数据可能需要内存，SSD，磁盘，磁盘，网络和磁带。

访问 L1 缓存中的数据需要大约 0.5 ns。 你可以抓住你的桌子上的一张纸。 访问 L2 缓存中的数据需要 7 ns。 这是抽屉里的纸。 你必须把椅子推回一点，将它弯曲在坐姿，拉出抽屉，拿纸，推抽屉背部，抬起并将纸张放在桌子上; 需要 10 秒钟，给予或采取。

主内存读数是 100 ns。 官僚站起来，通过墙上的共享文件存储，等待其他官僚拉动他们的论文或将他们的背部放回，选择抽屉，将其拉出，拿到纸张，然后走回桌子。 这需要两分钟。 每次在文档上写一个单词时，这是易失性的可变访问，它必须完成两次，一旦阅读，然后写作，即使你碰巧知道你要做的下一件事就是填写另一件事 同样纸张上表格的领域。

现代架构，没有多个 CPU，而是具有多个核心的单个 CPU，有点快。 一个核心可以检查其他核心的高速缓存，以查看同一变量是否存在任何修改。 这加速了挥发性访问到 20 ns 等，这仍然比非挥发性慢幅度慢。

虽然其余的重点是多线程编程，但这里值得一提的是，因为它给出了对不同时间量大的良好理解。

从 SSD 读取块（通常）需要 150,000 个 NS。 以人的速度，这有点超过 5 天。 在 GB 本地以太网上的网络上读取或向服务器发送某些东西是 0.5 毫秒，这就像等待近一个月的隐喻官僚。 如果网络上的数据位于旋转磁盘上，则寻找时间增加（磁盘旋转的时间，使得磁表面的一部分在读取头下方）到 20 毫秒。 它大约是人类术语的一年，为我们的计算环境上下运行的想象的小官僚。

如果我们在互联网上的大西洋上发送网络数据包，则需要大约 150 毫秒。 这就像 14 年，这只是一个包装; 如果我们想在海洋上发送数据，这将在历史时代构成数千年。 如果我们计算一分钟让机器启动，则相当于我们整体文明的时间跨度。

当我们想要了解 CPU 大部分时间都在做什么时，我们应该考虑这些数字。 它等待。 此外，当您考虑真实官僚的速度时，这种隐喻还有助于让您的神经保持紧张。 如果我们考虑他们的心跳，它们毕竟它们并不是那么慢，这意味着他们有一颗心。 但是，让我们回到现实生活，CPU，L1 和 L2 缓存和挥发性变量。

# 挥发性变量

让我们在我们的示例代码中修改`o`变量的声明，如下所示：

```
private volatile Object o = null;
```

前面的代码运行正常并在秒左右后停止。 任何 Java 实现都必须保证多个线程可以访问`volatile`字段，并且始终如一更新字段的值。 这并不意味着挥发声明将解决所有同步问题，而是保证不同的变量及其价值变更关系是一致的。 例如，让我们考虑在方法中递增以下两个字段：

```
private int i=0,j=0; 

 public void method(){ 
     i++; j++; 
 }
```

在前面的代码中，在不同的线程中读取`i`和`j`可能永远不会导致`i>j`。 如果没有`volatile`声明，编译器可以自由重新组织递增操作的执行，因此，它不会保证异步线程读取一致的值。

# 同步块

声明变量不是唯一可确保线程之间一致性的工具。 Java 语言中还有其他工具，其中一个是同步块。 `synchronized`关键字是语言的一部分，它可以在方法前面或程序块前面使用，该程序块在方法，构造函数或初始化程序块内。

Java 程序中的每个对象都有一个监视器，可以由任何正在运行的线程锁定和解锁。 当线程锁定监视器时，据说线程保持锁定，并且没有两个线程可以一次保持监视器的锁定。 如果线程尝试锁定已锁定的监视器，则会获取`BLOCKED`，直到释放显示器。 同步块以`synchronized`关键字以`synchronized`关键字开头，然后在括号之间指定的对象实例，然后进行阻止。 以下小程序演示了`synchronized`块：

```
package packt.java189fundamentals.thread;

public class SynchronizedDemo implements Runnable {
    public static final int N = 1000;
    public static final int MAX_TRY = 1_000_000;

    private final char threadChar;
    private final StringBuffer sb;

    public SynchronizedDemo(char threadChar, StringBuffer sb) {
        this.threadChar = threadChar;
        this.sb = sb;
    }

    @Override
    public void run() {
        for (int i = 0; i < N; i++) {
            synchronized (sb) {
                sb.append(threadChar);
                sleep();
                sb.append(threadChar);
            }
        }
    }

    private void sleep() {
        try {
            Thread.sleep(1);
        } catch (InterruptedException ignored) {
        }
    }

    public static void main(String[] args) {
        boolean failed = false;
        int tries = 0;
        while (!failed && tries < MAX_TRY) {
            tries++;
            StringBuffer sb = new StringBuffer(4 * N);
            new Thread(new SynchronizedDemo('a', sb)).start();
            new Thread(new SynchronizedDemo('b', sb)).start();
            failed = sb.indexOf("aba") != -1 || sb.indexOf("bab") != -1;
        }
        System.out.println(failed ? "failed after " + tries + " tries" : "not failed");
    }
}
```

代码启动了两个不同的线程。 其中一个线程将`aa`附加到名为`sb`的`StringBuffer`。 另一个附加`bb`。 这种附加在两个单独的阶段完成，睡眠之间。 需要睡眠以避免 JIT 将两个单独的步骤优化为一个。 每个线程执行`append` 1,000 次，每次都附在`a`或`b`两次。 作为另一个之后的两个`append`，它们在`synchronized`块内，它不能发生`aba`或`bab`序列进入`StringBuffer`。 虽然一个线程执行同步块，但另一个线程无法执行它。

如果我删除同步块，那么 JVM i 用于测试 Java Hotspot（TM）64 位服务器 VM（构建 9-EA + 121，混合模式和 18.3 构建 10 + 46，混合模式为第二版 书籍）尝试左右的速度打印出故障。 （看看 Packt 中可用的代码库中的`SynchronizedDemoFailing`类。）

它清楚地证明了同步手段，但它也引起了对另一个重要现象的关注。 仅在每十万个执行中发生错误。 即使这个例子被装修展示这样的事故，这是极其罕见的。 如果一个错误似乎很少出现，它非常困难，并且更加难以调试和修复。 大多数同步错误以神秘的方式清算并修复它们通常是细致代码审查的结果而不是调试。 因此，在开始商业多线程应用之前，清楚地了解 Java 多线程行为的真实性质是非常重要的。

`synchronized`关键字也可以在方法前使用。 在这种情况下，用于获取锁的物体是`this`对象。 在`static`方法的情况下，在整个类上执行同步。

# 等待和通知

`Object`类中有五种方法可以用于获得进一步同步功能 - `wait`，其中三个不同的超时参数签名，`notify`和`notifyAll`。 要调用`wait`，调用线程应具有`Object`的锁，在该锁定在其中调用`wait`。 这意味着您只能从同步块内部调用`wait`，并且当调用时，线程获取`BLOCKED`并释放锁定。 当另一个线程在同一个`notifyAll`上调用`notifyAll`时，线程进入`RUNNABLE`状态。 它无法立即继续执行，因为它无法在对象上获取锁定。 锁定在那一刻被刚刚称为`notifyAll`的线程。 但是，在其他线程之后的某个时间释放锁，换句话说，它从`synchronized`块中取出，等待线程可以获取它并继续执行。

如果在对象上等待更多的线程，则它们都将从`BLOCKED`状态下出来。 `notify`方法只唤醒其中一个等待线程。 无法唤醒哪个线程。

`wait`，`notify`和`notifyAll`的典型用途是当一个或多个线程正在创建由另一个线程或线程消耗的对象时。 线程之间行驶的存储器是一种队列。 消费者等待，直到有一些东西可以从队列中读取，而制作人之后将这些物体放入队列中。 当它在队列中放置某些东西时，生产者会通知消费者。 如果队列中没有剩余空间，则生产商必须停止并等到队列有一些空间。 在这种情况下，生产者调用`wait`方法。 为了唤醒生产者，消费者在读取某些东西时调用`notifyAll`。

消费者在循环中从队列中消耗对象，只有从队列中没有什么可读取的信息，才会调用`wait`。 当生产者调用`notifyAll`时，没有消费者等待，通知只是忽略。 它飞走了，但这不是问题; 消费者不等待。 当消费者消耗一个物体并呼叫`notifyAll`时，并且没有生产者等待，情况是一样的。 这不成问题。

它不能发生消费者消耗，调用`notifyAll`，并且在空中通知后，无法找到等待的生产者，因此生产者开始等待。 这不能发生，因为整个代码在`synchronized`块中，它确保在关键部分中没有生产者。 这是`wait`，`notify`和`notifyAll`只能在获取`Object`类的锁定时才能调用的原因。

如果有许多消费者执行相同的代码，它们同样擅长消耗对象，那么它是调用`notify`而不是`notifyAll`的优化。 在这种情况下，`notifyAll`只会唤醒所有消费者线程。 但是，只有幸运的人会认识到他们被唤醒了; 其他人会看到其他人已经遇到了诱饵。

我建议您至少练习一次以实现可用于传递线程之间的对象的阻塞队列。 仅作为练习执行，从未在生产中使用练习码。 从 Java 1.5 开始，有`BlockingQueue`接口的实现。 使用适合您需求的人。 在我们的示例代码中，我们也会这样做。

幸运的是，您可以在 Java 11 中代码。我在 1.4 的时候专业地使用 Java，一时，我必须实施一个阻塞队列。 java 一直在变得越来越好，更容易。

在专业代码中，我们通常避免使用`synchronized`方法或块和`volatile`字段以及`wait`和`notify`方法，以及`notifyAll`，如果可能，也是如此。 我们可以在线程之间使用异步通信或将整个多线程传递给处理框架。 在某些特殊情况下，在某些特殊情况下，在代码的性能很重要的情况下，无法避免`synchronized`关键字，或者我们找不到更好的构造。 有时，特定代码和数据结构的直接同步比 JDK 类传递的方法更有效。 然而，应该指出的是，这些类也使用这些低级同步构造，因此它们是不是魔法。 要从专业代码中学习，您可以在想要实现自己的版本之前查看 JDK 类的代码。 你将意识到实施这些队列并不简单; 没有充分原因，类的代码并不复杂。 如果您发现代码简单，这意味着您的高级足以知道不予重新实现的内容。 或者，也许，您甚至没有意识到您阅读的代码。

# 锁

锁定在 Java 中包含; 每一个`Object`有一个锁定线程可以在进入`synchronized`块时获取线程。 我们已经讨论过了。 在一些编程代码中，存在这种结构不是最佳的情况。

在某些情况下，锁的结构可能被排列，以避免僵局。 可能需要在 *B* 之前获取锁定 *A* ，并在 *C* 之前获取 *B* 。 但是，*应该尽快释放*，以允许访问受锁 *D* 保护的资源，还需要锁定 *A* 。 在复杂且高度平行的结构中，锁定经常构造为树木。 一个线程应该沿着树爬到树上代表资源以获取锁的叶子。 在攀登行为中，线程在节点上持有锁，然后在它下面的节点上锁定，然后释放上面的锁定，就像一个真正的登山者下降（如果你想象树，那么 叶在顶部，这更现实;尽管如此，图形通常会颠倒树木）。

您不能在第一个内部留下一个`synchronized`块。 同步块嵌套。 `java.util.concurrent.Lock` interface 定义了处理该情况的方法，并且在我们的代码中使用 JDK 中的实施方式也存在实现。 当您有锁时，可以调用`lock()`和`unlock()`方法。 实际顺序位于您的手中，您可以编写以下代码行以获取锁定序列：

```
a.lock(); b.lock(); a.unlock(); c.lock()
```

然而，凭借巨大的自由，是责任。 锁和解锁没有与代码的执行序列相关联，与同步块的情况不同，并且可能很容易创建代码，在某些情况下，在某些情况下丢失锁，而不会解锁它，呈现一些资源 不可用。 情况类似于内存泄漏。 您将分配（锁定）某些东西并忘记释放（解锁）它。 经过一段时间，程序将用完资源。

我的个人推荐是避免使用锁，如果可能，而是在线程之间使用更高级别的构造和异步通信，例如阻塞队列。

# 状况

`java.util.concurrent.Condition`界面类似于内置的`wait()`，`notify()`和`notifyAll()`对象。 `Lock`的任何实现都应创建新的`Condition`对象并将其返回它们，以便调用`newCondition()`方法。 当线程具有`Condition`时，当线程具有创建条件对象的锁时，它可以调用`await()`，`signal()`和`signalAll()`。

该功能与提到的`Object`方法非常相似。 大区别是您可以为单个`Lock`创建许多`Condition`对象，它们将彼此独立地工作，但不与`Lock`无关。

# 雷丁锁

`ReentrantLock`是 JDK 中`Lock`接口的最简单实现。 有两种方法可以创建这种类型的锁和没有公平政策。 如果用`true`调用`ReentrantLock(Boolean fair)`构造函数作为参数，则锁将分配给等待锁定的线程，以防许多线程等待。 这将避免一个线程等待过多的时间和饥饿。 另一方面，处理锁定这种方式需要更多管理从`ReentrantLock`代码，并运行一点较慢。 （永远不要害怕慢速代码，直到你测量它。）

# ReentrantreadWriteLock.

此类是`ReadWriteLock`的实现。 `ReadWriteLock`是一种可用于并行读取访问和独占写访问的锁。 这意味着几个线程可以读取受锁保护的资源，但是当线程写入资源时，没有其他线程可以访问它，甚至在该时段期间甚至没有阅读它。 A `ReadWriteLock`是`readLock()`和`writeLock()`方法返回的两个`Lock`对象。 要在`ReadWriteLock`上获取读取访问，则代码必须调用`myLock.readLock().lock()`，并访问写入锁定`myLock.writeLock().lock()`。 获取其中一个锁并在实现中释放它与另一个锁相耦合。 要获取写入锁，则没有主题应具有活动读锁。

使用不同的锁定有几种复杂的杂志。 例如，您可以获得读锁，但只要有读锁，就无法获得写入锁定。 首先，您必须先释放读取锁定锁定。 这只是一个简单的细节之一，但这是新手程序员多次遇到麻烦的一个。 为什么它以这种方式实现？ 为什么程序应该得到一个写锁，这更昂贵 - 在锁定其他线程的较高概率的意义上 - 当它仍然不确定它想要编写资源时？ 代码想要阅读它，并根据内容来读取它，稍后可以决定它想要编写它。

这个问题没有实施。 图书馆的开发人员决定了这一规则，而不是因为他们只是喜欢这种方式，或者因为他们意识到并行算法和死锁可能性。 当两个线程具有`readLock`时，每个线程决定将锁升级到`writeLock`，那么他们本质上会创建一个僵局。 每个都会在等待`writeLock`的同时持有`readLock`，没有一个人会得到它。

另一方面，您可以将`writeLock`降级为`readLock`而不冒险，同时，有人获取`writeLock`并修改资源。

# 原子变量

原子类将原始值括成对象并提供对象的原子操作。 我们讨论了竞争条件和挥发性变量。 例如，如果我们有一个`int`变量要用作计数器，我们希望为我们使用的对象分配唯一值，我们可以将值递增并使用结果作为唯一 ID。 但是，当多个线程使用相同的代码时，我们无法确定递增后我们读取的值。 可能发生在另一个线程中也递增了该值。 为避免这种情况，我们将必须括起来并将递增值分配给`synchronized`块中的对象。 这也可以使用`AtomicInteger`完成。

如果我们有一个`AtomicInteger`的变量，则调用`incrementAndGet`递增`int`中括在类中的值，并返回递增值。 为什么它代替使用同步块？ 第一个答案是，如果在 JDK 中有功能，那么使用它会导致更少的代码行，而不是再次实现它。 预计维护您创建的代码的开发人员会知道 JDK 库。 另一方面，研究你的代码需要时间，时间是金钱。

另一个原因是，这些类是高度优化的，并且通常，它们通常使用特定于平台的本机代码来实现特征，这些原始代码大大优于我们可以使用 Synchronized 块实现的版本。 担心性能太早并不好，但是在性能至关重要时通常使用平行算法和线程之间的同步; 因此，使用原子类的代码性能存在很大的机会很重要。 据说这一切，主要原因是可读性和简单性。

在`java.util.concurrent.atomic`包中，其中有几个类，`AtomicInteger`，`AtomicLong`，`AtomicLong`和`AtomicReference`。 它们都提供了特定于封装值的方法。

`compareAndSet()`方法由每个原子类实现。 这是一个有条件的值设置操作，具有以下格式：

```
boolean compareAndSet(expectedValue, updateValue);
```

当它应用于原子类时，它将实际值与一个`expectedValue`进行比较，如果它们是相同的，则将值设置为`updateValue`。 如果更新值，则该方法返回`true`，并在原子操作中完成所有这些。 不用说，如果不持有条件并没有执行更新，则返回值为`false`。

您可能会询问问题，如果此方法在所有这些类中，为什么没有`Interface`定义此方法？ 原因是基于封装类型的参数类型不同，这些类型是基元。 由于原语不能用作通用类型，但无法定义接口。

在`AtomicXXXArray`的情况下，该方法具有额外的第一个参数，这是呼叫中处理的数组元素的索引。

封装的变量与易失性相同的方式处理，就像在不同处理器内核上运行的多个线程的重新排序和访问一样。 原子类的实际实现可以使用特殊的硬件代码，这些代码可以提供比 Java 中的天真的实现更好的性能，因此原子类可能具有比使用挥发变量和同步块在 vanilla Java 代码中实现的相同功能的性能。

如果有一个可用的话，常规建议是考虑使用原子类，并且您将发现自己创建用于校验和设置，原子增量或加法操作的同步块。

# blockingqueue.

`BlockingQueue`是一种延伸标准`Queue`接口的接口，该方法适用于多线程应用程序的方法。 此接口的任何实现提供了允许不同线程将元素放入队列中的方法，从队列中提取元素，并等待队列中的元素。

当有一个要存储在队列中的新元素时，可以`add()`它，`offer()`它，或`put()`它。 这些是存储元素的方法的名称，并且他们做同样的事情，只是有点不同。 如果队列已满，则`add()`方法抛出异常，并且元素没有空间。 `offer()`方法不抛出异常，但取决于操作是否成功，返回`true`或`false`。 如果它可以将元素存储在队列中，则返回`true`。 还有一个`offer()`的版本，它指定超时。 该方法的版本仅等待并返回`false`如果它在此期间无法存储队列中的值。 `put()`方法是最简单的版本; 它等待直到它可以做到这一点。

在谈论队列中的可用房间时，请勿疑惑并将其与常规 Java 内存管理混淆。 如果没有更多的内存，并且垃圾收集器也无法释放任何内存，你肯定会得到一个`OutOfMemoryError`。 `add()`抛出异常，并且在达到队列限制时`offer()`返回`false`值。 一些`BlockingQueue`实现可以限制可以同时存储在队列中的元素的数量。 如果达到该限制，则队列已满，并且无法接受更多元素。

从`BlockingQueue`实现中有四种不同的提取元素。 在此方向上，特殊情况是队列是空的。 在这种情况下，`remove()`方法抛出异常而不是返回元素，如果没有元素，`poll()`方法返回`null`，并且`take()`方法只等待它可以返回一个元素。

最后，有两种方法继承了从队列中的`Queues`接口继承的方法，但只是*看*它。 `element()`方法返回队列的头部，或者如果队列为空，则抛出异常。 如果队列中没有元素，则`peek()`方法返回`null`。 下表总结了从界面的文档中借用的操作：

|  | **抛出异常** | **特殊值** | **块** | **超时** |
| **插入** | `add(e)` | `offer(e)` | `put(e)` | `offer(e, time, unit)` |
| **删除** | `remove()` | `poll()` | `take()` | `poll(time, unit)` |
| **检查** | `element()` | `peek()` | `not applicable` | `not applicable` |

# linkedblockingqueue.

这是`BlockingQueue`接口的实现，由链接列表备份。 Queue 的大小不受默认限制（要精确，它是`Integer.MAX_VALUE`），但它可以可选地在构造函数参数中受到限制。 限制此实现中尺寸的原因是帮助使用有限大小队列更好地执行时使用。 实施本身对除`Integer.MAX_VALUE`以外的大小没有任何限制，这是相当大的。

# linkedblockingdeque

这是`BlockingQueue`的最简单实现以及其`BlockingDeque`子接口。 正如我们在上一章中所讨论的那样，A `Deque`是一种双端队列，其具有`add`，`remove`和`offer`方法类型，其中包括`xxxFirst`和`xxxLast`的形式 执行队列的一个或另一端的行为。 `Deque`接口定义`getFirst`和`getLast`，而不是一致命名`elementFirst`和`elementLast`，因此这是您应该习惯的。 毕竟，IDES 帮助自动代码完成，所以这不应该是一个大问题。

# ArrayBlockingQueue.

`ArrayBlockingQueue`实现`BlockingQueue`界面，因此`Queue`接口。 此实现管理具有固定大小元素的队列。 实现中的存储是数组，元素在 *FIFO* 的方式首先，首先。 这是我们还将在 MasterMind 的平行实施中使用的课程，以便在 BOSS 和从属官僚之间的沟通。

# 联系转让纽扣

`TransferQueue`界面正在扩展`BlockingQueue`，JDK 中唯一的实现是`LinkedTransferQueue`。 当一个线程想要向另一个线程交出某些数据时，`TransferQueue`派上派上友好，并且需要确保另一个线程需要元素。 这一个`TransferQueue`有一个`transfer()`方法，将元素放在队列上，但不会返回，直到一些其他线程调用`remove()`，从而去除它（或调用`poll()`，从而轮询它）。 这样，生产线程可以确定放在队列上的对象是另一个处理线程的手中，不在队列中等待。 `transfer()`方法还具有`tryTransfer()`格式`tryTransfer()`，您可以在其中指定超时值。 如果方法超出，则元素不会放入队列中。

# intervalGuesser.

我们讨论了不同于实现并行算法的不同 Java 语言元素和 JDK 类。 现在，我们将看到如何使用这些方法来实现 MasterMind 游戏的并行猜测。

在我们开始之前，我必须承认这项任务不是典型的并行，并行编程教程任务。 谈论并发编程技术的教程倾向于为其示例选择问题，这些示例易于使用并行代码和该比例良好解决。 如果在 *N* 处理器上运行的并行算法实际上运行的并行算法比非并行解决方案更快地运行 *n* 倍。 我的个人观点是这些例子在没有暴风雨的云层的情况下涂上天空蓝色。 然而，当你在现实生活中面对并发编程时，那些云在那里，你会看到雷声和闪电，如果你没有经历过，你会弄湿你的脚。

现实生活中的问题经常不理想地扩展。 我们已经访问了一个衡量良好的示例，但不是理想的 - Quicksort。 这次，我们将开发一个并行算法，以便更紧密地类似于现实生活问题。 解决 N 处理器上的 MasterMind 游戏不会加速解决方案 *n* 次，并且代码不是微不足道的。 这个例子将向您展示真实的问题看起来像什么，即使它不会教你所有可能的问题，当您在商业环境中第一次看到其中一个时，您不会震惊。

该解决方案中最重要的类别是`IntervalGuesser`。 这是影响猜测的课程。 它在开始和最终猜测之间创建猜测，并将它们发送到`BlockingQueue`。 类实现`Runnable`，因此它可以在单独的`Thread`中运行。 纯粹的实现将从间隔猜测中分离`Runnable`功能，但是，随着整个类几乎超过 50 行，它是一个可原形的 SIN，实现单个类中的两个功能：

```
public class IntervalGuesser extends UniqueGuesser implements Runnable {
    private final Guess start;

    private final Guess end;
    private Guess lastGuess;
    private final BlockingQueue<Guess> guessQueue;

    public IntervalGuesser(Table table,
                           Guess start,
                           Guess end,
                           BlockingQueue<Guess> guessQueue) {
        super(table);
        this.start = start;
        this.end = end;
        this.lastGuess = start;
        this.guessQueue = guessQueue;
        nextGuess = start;
    }

    @Override
    public void run() {
        Thread.currentThread()
            .setName("guesser [" + start + "," + end + "]");
        var guess = guess();
        try {
            while (guess != Guess.none) {
                guessQueue.put(guess);
                guess = guess();
            }
        } catch (InterruptedException ignored) {
        }
    }

    @Override
    protected Guess nextGuess() {
        var guess = super.nextGuess();
        if (guess.equals(end)) {
            guess = Guess.none;
        }
        lastGuess = guess;
        return guess;
    }

    public String toString() {
        return "[" + start + "," + end + "]";
    }
}
```

实现非常简单，因为大多数功能都已经在 Abstract `Guesser`类中实现了。 更有趣的代码是调用`IntervalGuesser`的代码。

# ParallyGamePlayer.

`ParallelGamePlayer`类实现定义`play`方法的`Player`界面：

```
@Override
public void play() {
    final var table = new Table(NR_COLUMNS, colorManager);
    final var secret = new RandomSecret(colorManager);
    final var secretGuess = secret.createSecret(NR_COLUMNS);
    final var game = new Game(table, secretGuess);
    final var guessers = createGuessers(table);
    final var finalCheckGuesser = new UniqueGuesser(table);
    startAsynchronousGuessers(guessers);
    try {
        while (!game.isFinished()) {
            final var guess = guessQueue.take();
            if (finalCheckGuesser.guessMatch(guess)) {
                game.addNewGuess(guess);
            }
        }
    } catch (InterruptedException ie) {

    } finally {
        stopAsynchronousGuessers(guessers);
    }
}
```

该方法创建一个`Table`，一个`RandomSecret`，以随机方式创建猜测用作秘密的猜测，A `Game`对象`IntervalGuesser`对象和`UniqueGuesser`。

`IntervalGuesser`对象是官僚; `UniqueGuesser`是交叉检查`IntervalGuesser`对象创建的猜测的老板。 我们在单独的方法中创建间隔猜测，`createGuessers()`：

```
private IntervalGuesser[] createGuessers(Table table) {
    final var colors = new Color[NR_COLUMNS];
    var start = firstIntervalStart(colors);
    final IntervalGuesser[] guessers = new IntervalGuesser[nrThreads];
    for (int i = 0; i < nrThreads - 1; i++) {
        Guess end = nextIntervalStart(colors);
        guessers[i] = new IntervalGuesser(table, start, end, guessQueue);
        start = end;
    }
    guessers[nrThreads - 1] = new IntervalGuesser(table, start, Guess.none, guessQueue);
    return guessers;
}

private Guess firstIntervalStart(Color[] colors) {
    for (int i = 0; i < colors.length; i++) {
        colors[i] = colorManager.firstColor();
    }
    return new Guess(colors);
}

private Guess nextIntervalStart(Color[] colors) {
    final int index = colors.length - 1;
    int step = NR_COLORS / nrThreads;
    if (step == 0) {
        step = 1;
    }
    while (step > 0) {
        if (colorManager.thereIsNextColor(colors[index])) {
            colors[index] = colorManager.nextColor(colors[index]);
            step--;
        } else {
            return Guess.none;
        }
    }
    Guess guess = new Guess(colors);
    while (!guess.isUnique()) {
        guess = guess.nextGuess(colorManager);
    }
    return guess;
}
```

间隔猜测员以每个将具有其独特的颜色变化范围的方式创建，使得它们在一起，它们涵盖了所有可能的颜色猜测。 `firstIntervalStart()`方法返回包含在所有位置的*颜色的猜测。 `nextIntervalStart()`方法返回启动下一个范围的颜色集，推进颜色，使每个猜测器具有相同数量的猜测来检查结束（加上或减 1）。*

`startAsynchronousGuessers()`方法从异步猜测器开始，然后从它们中读取循环中的猜测，然后将它们放在表上，直到游戏完成。 在该方法结束时，在`finally`块中，异步猜测器被停止。

异步猜测器的开始和停止方法采用`ExecutorService`：

```
private void startAsynchronousGuessers(IntervalGuesser[] guessers) {
    executorService = Executors.newFixedThreadPool(nrThreads);
    for (IntervalGuesser guesser : guessers) {
        executorService.execute(guesser);
    }
}

private void stopAsynchronousGuessers(IntervalGuesser[] guessers) {
    executorService.shutdown();
    guessQueue.drainTo(new LinkedList<>());
}
```

代码非常简单。 需要一些解释的唯一需要的是`drainTo()`呼叫。 此方法排出未使用的猜测，即工作线程仍然进入我们立即抛弃的链接列表（我们不会对其进行任何引用）。 这是必需的，以帮助任何`IntervalGuesser`，这可能在手中等待建议的猜测，试图将其放入队列中。 当我们排除队列时，猜测线程从`guessQueue.put(guess);`中的`put()`方法返回`IntervalGuesser`中的`put()`方法，并可以捕获中断。 其余代码不包含任何与我们已经看到的东西无关的东西。

我们仍然想在本章中讨论的最后一个问题是，我们通过制作代码并行获得了多少时间？

# MicroBenchmarking.

MicroBenchmarking 正在测量小型代码片段的性能。 当我们想优化我们的代码时，我们将不得不衡量它。 没有测量，代码优化就像被击落的射击。 你不会击中目标，但你可能会射击别人。

拍摄是一个很好的比喻，因为你通常不应该这样做，但是当你真的需要的时候，那么你别无选择。 如果没有表现问题，软件符合要求，那么任何优化，包括速度测量都是浪费金钱。 这并不意味着您被鼓励写入缓慢和邋 and 的代码。 当我们测量性能时，我们将其与要求进行比较，并且要求通常在用户级别，类似于“应用程序的响应时间应小于 2 秒”的内容。 为进行这样的测量，我们通常在测试环境中创建负载测试，并使用不同的分析工具，以防测量性能并不令人满意，告诉我们最多的时间以及我们应该优化的地方消耗了什么。 很多次，它不仅是 Java 代码，而是配置优化，使用较大的数据库连接池，更多内存和类似的东西。

Microbenchmarking 是一个不同的故事。 它是关于一个小型 Java 代码片段的性能，因此越靠近 Java 编程。

它很少使用，并且在开始为实际商业环境执行微调标记之前，我们将不得不三思而后行。 Microbenchmark 是一种诱发的工具，可以在不知道它是否值得优化那些代码的情况下优化小的东西。 当我们有一个在多个服务器上运行的多个模块的巨大应用程序时，我们如何确定提高应用程序的特殊部分大大提高了性能？ 它会在收入增加，产生如此多的利润，涵盖了绩效测试和开发所产生的费用吗？ 统计上，您几乎可以确定，如此优化，包括微生物标记，不会得到回报。

我曾经保留过高级同事的代码。 他创建了一个高度优化的代码，以识别文件中存在的配置关键字。 他创建了一个基于密钥字符串中的字符表示决策树的程序结构。 如果在配置文件中有一个拼写错误的关键字，则代码在最初的字符下抛出异常，可以决定关键字无法正确。 要插入新关键字，需要通过代码结构来查找新关键字最初与现有的代码中的机会，并扩展了深度嵌套的[​​HTG0]结构。 要从列出他没有忘记文档的所有关键字的评论中读取可以处理的关键字列表。 代码非常快速地工作，可能会保存一些 servlet 应用程序的启动时间。 应用程序仅在每隔几个月后系统维护后启动。您感到讽刺，不是吗？ 资历并不总是多年。 那些更幸运的人可以拯救他们的内在孩子。

那么，应该使用微磁发布何时？ 我可以看到两个地区：

*   您已识别使用应用程序中的大多数资源的代码段，并且可以通过微磁发布测试改进
*   您无法识别将消耗应用程序中大多数资源的代码段，但您怀疑它

第一个是通常的案例。 第二个是开发库时，您只是不知道将使用它的所有应用程序。 在这种情况下，您将尝试优化您认为大多数想象的疑似应用程序最重要的部分。 即使在这种情况下，最好使用库的用户创建的一些示例应用程序，并收集有关使用的一些统计信息。

我们为什么要详细谈论微磁发布？ 什么是陷阱？ 基准是一个实验。 我写的第一个程序是 TI 计算器代码，我可以只计算程序所做的程序的步骤数量两个大（10 位数大的时间）素数。 即使是那个时候，我也在使用旧的机械俄罗斯秒表来测量时间，懒惰计算步数。 试验和测量更容易。

今天，您无法手动计算 CPU 所做的步骤数，即使您想要。 有这么多的小因素可能会改变超出程序员控制的应用程序的性能，这使得计算步骤是不可能的。 我们对我们留下了测量，我们将获得与测量相关的所有问题。

什么是最大的问题？ 我们对某事感兴趣，例如 *x* ，我们通常无法衡量它。 因此，我们将测量 *Y* ，并希望 *Y* 和 *X* 的值耦合在一起。 我们希望测量房间的长度，但是，我们测量激光束从一端到另一端行进所需的时间。 在这种情况下，长度， *x，*和时间， *y，*是强烈耦合的。 许多次， *x* 和 *y* 只关联或多或少。 大多数情况下，当一个人进行测量时， *x* 和 *y* 值根本没有彼此相对。 尽管如此，人们仍然赌他们的房屋，更多，在这些测量后支持的决定。

Microbenchmarking 没有什么不同。 第一个问题是，我们如何测量执行时间？ 小码短次运行，`System.currentTimeMillis()`可以在测量开始时返回相同的值，而且它结束时，因为我们仍然处于同一毫秒。 即使执行是 10 毫秒，测量的误差仍然至少为 10％，纯粹是因为我们测量时的量化。 幸运的是，有`System.nanoTime()`。 但是吗？ 仅仅因为这个名字说它从特定的开始时间返回纳秒的数量并不一定意味着它真的可以。

非常依赖于硬件和 JDK 中的方法的实现。 它被称为 nano，因为这是我们肯定无法达到的精确度。 如果它是微秒，那么一些实现可能受到定义的限制，即使在特定硬件上，也有更精确的时钟。 然而，这不仅仅是关于可用硬件时钟的准确性的水平; 它是关于硬件的精度。

让我们记住官僚的心跳，以及从记忆中阅读一些东西所需的时间。 调用一种方法，例如`System.nanoTime(),`就像在酒店询问酒店，从二楼到大厅跑下来，偷看路上的另一面塔上的时钟，回来，回来 准确讲述我们问的时候。 废话。 我们应该了解塔上时钟的精度以及从地板到大厅和背部的钟线的速度。 这比呼叫`System.nanoTime()`更多。 这是微磁头带的线束为我们所做的。

**java microbenchmarking harness** （ **JMH** ）可用作为库的一段时间。 它由 Oracle 开发，用于调整多个核心 JDK 类的性能。 这是为那些谁开发新的硬件 Java 平台的好消息，同时也为开发者，因为这意味着江铃控股是，并且将通过 Oracle 支持。

“ *jmh 是一个 java 线束，用于构建，运行和分析用 Java 和针对 JVM 的其他语言编写的纳米/微/毫米/宏基准测试。*”

（报价 JMH 的官方网站 [http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/) ）。

您可以运行`jmh`作为单独的项目，独立于您测量的实际项目，或者您只能将测量代码存储在单独的目录中。 线束将根据生产类文件编译，并将执行基准。 就像我看到它一样，最简单的方法是使用 Gradle 插件来执行 JMH。 您可以将基准代码存储在一个名为`jmh`的目录中（与`main`和`test`相同的级别），并创建一个可以启动基准测试的`main`类。

Gradle Build 脚本扩展为包括以下行：

```
buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath "me.champeau.gradle:jmh-gradle-plugin:0.2.0"
    }
}
apply plugin: "me.champeau.gradle.jmh"

jmh {
    jmhVersion = '1.13'
    includeTests = true
}
```

而`MicroBenchmark`课程如下：

```
public class MicroBenchmark {

    public static void main(String... args)
        throws RunnerException {
        var opt = new OptionsBuilder()
            .include(MicroBenchmark.class.getSimpleName())
            .forks(1)
            .build();

        new Runner(opt).run();
    }

    @Benchmark
    @Fork(1)
    public void playParallel(ThreadsAndQueueSizes t3qs) {
        int nrThreads = Integer.valueOf(t3qs.nrThreads);
        int queueSize = Integer.valueOf(t3qs.queueSize);
        new ParallelGamePlayer(nrThreads, queueSize).play();
    }

    @Benchmark
    @Fork(1)
    public void playSimple() {
        new SimpleGamePlayer().play();
    }

    @State(Scope.Benchmark)
    public static class ThreadsAndQueueSizes {
        @Param(value = {"1", "4", "8"})
        String nrThreads;
        @Param(value = {"-1", "1", "10", "100", "1000000"})
        String queueSize;
    }
}
```

创建`ParallelGamePlayer`以与-1,1,4 和 8 `IntervalGuesser`线程一起播放游戏，并且在每种情况下，在长度 1,10,100 和 100 万的队列中存在测试。 这些是 16 个测试执行。 当线程数为负时，构造函数使用`LinkedBlockingDeque`。 还有另一个单独的测量来测量非平行播放器。 测试是用独特的猜测和秘密（无多次使用的秘密）执行，10 种颜色和六列。

当线束开始时，它会自动完成所有校准并运行测试，以便许多迭代以让 JVM 启动。 您可以调用刚刚从未停止的代码，除非我们在用于信号停止的变量上使用`volatile`修饰符，否则 发生了，因为 JIT 编译器优化了代码。 仅当代码已经运行几千倍时才完成。 线束使得这些执行是为了使代码加热并确保在 JVM 处于全速时进行测量。

运行此基准测试在我的机器上大约需要 15 分钟。 在执行过程中，建议停止所有其他进程，并让基准使用所有可用的资源。 如果在测量过程中有任何使用资源，那么它将反映出：

```
Benchmark      (nrThreads) (queueSize)  Score    Error
playParallel            1         -1   15,636  ± 1,905
playParallel            1          1   15,316  ± 1,237
playParallel            1         10   15,425  ± 1,673
playParallel            1        100   16,580  ± 1,133
playParallel            1    1000000   15,035  ± 1,148
playParallel            4         -1   25,945  ± 0,939
playParallel            4          1   25,559  ± 1,250
playParallel            4         10   25,034  ± 1,414
playParallel            4        100   24,971  ± 1,010
playParallel            4    1000000   20,584  ± 0,655
playParallel            8         -1   24,713  ± 0,687
playParallel            8          1   24,265  ± 1,022
playParallel            8         10   24,475  ± 1,137
playParallel            8        100   24,514  ± 0,836
playParallel            8    1000000   16,595  ± 0,739
playSimple            N/A       N/A   18,613   ± 2,040
```

程序的实际输出有点冗长; 它被编辑用于打印目的。 `Score`列显示了基准测试中可以在秒中运行的次数。 `Error`列表明测量散射散射小于 10％。

我们拥有的最快性能是算法在八个线程上运行，这是处理器可以在我的机器上独立处理的线程数。 有趣的是，限制队列的大小没有帮助性能。 我实际上预计它会有所不同。 使用一百万个长度数组作为阻塞队列具有巨大的开销，并且不是一个惊喜，在这种情况下，执行速度慢，我们在队列中只有 100 个元素。 另一方面，使用无限链路的列出基于列表的队列处理相当快速，并清楚地表明 100 个元素有限队列的额外速度并不来自限制阻止`IntervalThreads`运行太远的事实。

当我们启动一个线程时，我们期望在我们运行串行算法时相似的结果。 串行算法在一个线程上击败运行的并行算法的事实并不令人意外。 线程创建和主线程与额外单线之间的通信具有开销。 开销是显着的，特别是当队列不必要的大时。

# 概括

在本章中，我们学到了很多事情。 首先，我们改进了代码准备好进一步开发，以便使用并行猜测。 我们熟悉流程和线程，我们甚至提到了纤维。 之后，我们研究了 Java 如何实现线程以及如何创建在多个线程上运行的代码。 此外，我们看到了不同的意味着 Java 向需要并行程序，启动线程或仅在现有线程中启动任务的程序员提供程序员。

也许你应该记住这一章中最重要的部分是官僚和不同速度的隐喻。 当您想要了解并发应用程序的性能时，这非常重要。 我希望这是一个吸引人的画面，一个很容易记住。

有关不同同步的巨大主题意味着 Java 提供，并且您还了解了程序员在编程并发应用程序时陷入的陷阱。

最后，但绝不是最少的，我们创建了 MasterMind 猜测程序的并发版本，并且还测量它确实比仅使用一个处理器的版本更快（至少在我的机器上）。 我们使用 Java Microbenchmark Larness 与 Gradle 构建工具，并谈到了如何执行微磁盘标记。

这是一个很长一篇，而不是一个简单的篇章。 我可能倾向于认为这是最复杂和最理论的章节。 如果你最初阅读一半的阅读，你就可以自豪。 另一方面，请注意，这只是一个坚实的基础，从中开始尝试并发编程，并且在该地区的经验丰富和专业人士之前有很长的路要走。 而且，这一章不是一个容易的。 但是，首先，在本章的最后，为自己感到骄傲。

在以下章节中，我们将了解有关 Web 和 Web 编程的更多信息。 在下一章中，我们将开发我们的小游戏，以便它可以在服务器上运行，并且播放器可以使用 Web 浏览器播放它。 这将建立网络编程的基本知识。 稍后，我们将在此构建，开发基于 Web 的服务应用程序，无功编程以及将为您提供专业 Java 开发人员的所有工具和区域。