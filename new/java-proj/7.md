# 使用 REST 构建商业 Web 应用程序

我们到目前为止，我们在玩耍，但 Java 不是玩具。 我们希望为真实，严肃，商业和专业的东西使用 Java。 在本章中，我们会这样做。 我们将看的例子不是唯一有趣的东西，例如汉语，我们在前三章中看了，而是真正的商业应用。 实际上，这不是真实的应用程序。 你不应该想到一本书中的任何东西。 这将是太长而不是教育。 但是，我们将在本章中开发的应用程序可以扩展，可以用作真实应用程序的核心，以防您决定这样做。

在上一章中，我们创建了 servlet。 为此，我们使用 Servlet 规范，我们手工实施的 servlet。 这是你很少这些日子都很重要的事情。 在本章中，我们将使用易于提供的框架。 这次，我们将使用 Spring，这是 Java 商业应用最广泛使用的框架，我敢说这是事实上的标准。 我们必须做的所有繁琐工作（至少要理解并了解 Servlet 工作）在上一章中的所有繁琐工作。 我们还将使用 Spring 进行依赖注入（为什么当一个人完成所有框架时使用两个框架？）和 Tomcat。

在上一章中，我们使用 Guice 作为 Servlet 容器的 DI 框架和码头。 这些项目可能是完全良好的选择。 对于其他项目，其他框架确实更好。 有机会在本书中查看不同的工具，我们将使用不同的框架，即使我们将显示您的所有示例，也可以通过仅使用 Tomcat 和 Spring 专门来创建。

我们将开发的商业应用程序将是一个针对经销商的订购系统。 我们将提供给用户的界面不会是 Web 浏览器消耗品 HTML / JavaScript / CSS 接口。 相反，它将是一个休息界面。 用户将自己开发与我们的系统通信的应用程序，并为不同产品下订单。 除标准 Chrome 开发人员工具功能外，应用程序的结构将是微服务架构，我们将使用 SOAPUI 测试应用程序。

# MyBusiness 网上商店

想象一下，我们有一个巨大的贸易和物流公司。 货架上有成千上万的不同产品; 百卢比来到我们的仓库带来了新的商品，数百个货车向我们的客户提供货物。 为了管理这些信息，我们有一个库存系统，每天每小时都会追踪每分钟的商品，所以我们知道我们在仓库中的实际拥有了什么。 我们为我们的客户提供服务，没有人类管理仓库信息。 以前，有手机，传真机，甚至电传。 今天，我们使用的只是互联网和 Web 服务。 我们不为客户提供网站。 我们从未直接向其想象的业务提供最终用户，但这些日子，我们有一个子公司，我们作为一个单独的公司开始做到这一点。 他们有一个网站，它完全独立于我们。 它们只是我们数百名注册合作伙伴之一，每个注册合作伙伴都使用 Web 服务界面来查看我们拥有的产品，订购产品，并跟踪订单的状态。

# 示例业务架构

我们的合作伙伴也是有自动管理的大公司，有几台机器运行的课程。 我们对其建筑和他们使用的技术没有兴趣，但我们希望整合到他们的运营。 我们希望以一种不需要任何人类互动的方式为各方面订购货物的方式为他们服务。 为此，提供了一个可以使用的 Web 服务接口，无论它们使用的基础架构是什么。

在我们身边，正如我们想象的一个例子，我们最近用微服务架构替换了我们的单片应用程序，尽管系统中仍有一些基于 SOAP 的解决方案，但大多数后端模块都使用 HTTPS 和 REST 协议进行通信。 一些模块仍然依赖于使用 FTP 在每天完成的异步文件传输，这是从 UNIX `cron`作业开始的。 总帐系统在 COBOL 中编程。 幸运的是，我们不需要处理这些恐龙。

这种结构是一个虚构的设置，而是一个现实的设置。 我弥补了这些部分，为您提供如何在大型企业中看到混合技术的照片。 我在这里描述的是一个非常简单的设置。 使用不同的技术和完全不同的接口，系统中有一个以上的软件模块在其系统中拥有超过一千个软件模块，全部互相连接。 这不是因为他们喜欢混乱，但这是它在连续 30 年后成为的方式。 新技术来源，旧技术淡出。 如果您想保持竞争力，业务更改，您无法坚持旧技术。 与此同时，您无法瞬间更换整个基础架构。 结果是，我们看到仍然跑步的旧技术，并且主要是新技术。 旧技术及时推出。 当恐龙在我们面前出来时，他们仍然不会永远留下来，仍然感到惊讶。

我们必须处理我们将开发的两个前端组件。 这些如下：

*   **产品信息**
*   **订单放置和跟踪**

在下图中，您可以看到我们将查看的结构的架构 UML 图表。 我们只会与前端组件进行互动，但如果我们有更大的图片，它有助于了解它们的功能及其角色：

![](img/6b6b271c-bbbd-4792-a49e-1911d61f150f.png)

**产品信息**提供有关单一产品的信息，但它还可以根据查询标准提供产品列表。 **命令放置** **和跟踪**提供功能，以便客户可以下订单，并允许我们的客户查询过去订单的状态。

为了提供产品信息，我们需要访问**产品目录**模块，该模块保存实际的产品详细信息。

**产品目录**可以存在很多其他任务，这是它是单独模块的原因。 例如，它可以具有工作流程和批准引擎，可让产品管理员输入产品数据和管理者来检查和批准数据。 批准通常是一个复杂的过程，考虑错字和法律问题（我们不想贸易未经许可的药物，爆炸物等），并检查货物来源的质量和批准状态。 许多复杂的任务使其成为后端模块。 在大型企业应用程序中，前端系统很少做其他任何其他方式，而不是服务外方的基本功能。 但这对我们有好处; 我们可以专注于我们必须提供的服务。 这对架构也有益。 与面向对象的编程单一责任相同的原则。

**产品信息**模块还必须与**访问控制**模块进行咨询，看看是否可以将某些产品提供给实际客户，并使用库存看出有任何产品 离开，这样我们就没有提供缺货的产品。

**订单放置和跟踪**模块还需要访问**产品库存**和 **Access Control** 模块，以检查是否可以满足订单。 与此同时，它还需要从**定价**模块的服务，该模块可以计算订单的价格，以及从**物流**模块，这触发了来自库存的货物收集 地点和装运给客户。 **物流**也有与发票的连接，它与**将军**连接，但这些只是在图片上显示信息的旅行不会结束那里。 还有许多其他模块运行公司，所有这些模块目前都对我们感兴趣。

# 微服务

上一章中描述的架构不是清洁的微服务架构。 您永远不会在任何企业中以其纯粹的形式达到一个。 它更像是我们在一家真正的公司中遇到的东西，从单片到微服务。

当应用程序以许多小型服务的形式开发时，我们将讨论 MicroService 架构，这些架构使用一些简单的 API 互相通信，通常通过 HTTP 和 REST 进行通信。 服务实现业务功能，可以独立部署。 在大多数情况下，希望服务部署是自动化的。

可以使用不同的编程语言开发各个服务，可以使用不同的数据存储，并可以在不同的操作系统上运行; 因此，它们彼此高度独立。 它们可以是，通常由不同的团队制定。 重要要求是他们合作; 因此，API 一个服务实现可由构建在其上的其他服务中使用。

微服务架构不是所有架构的圣杯。 它为单片架构的某些问题提供了不同的答案，在大多数情况下，这些答案在使用现代工具时更好地工作。 仍然必须测试和调试应用程序。 必须管理的性能，并且必须解决错误和问题。 不同之处在于各个组件不强烈耦合，这样，开发，部署和测试可以沿不同的技术分开。 由于实践中的微服务架构沿网络协议将模块分开，调试可能需要更多网络相关的工作。 这可能是好的，坏的，或两者都同时。 然而，对于开发人员来说，优势很清楚。 他们可以独立地在较小的单位上工作，可以更快地看到工作结果。

在开发单片应用程序的单个模块时，只能在部署整个应用程序时看到结果。 在大应用的情况下，这可能是罕见的。 在大公司开发单片的典型部署周期每隔几个月，说三个，但看到释放只有两次甚至每年一次都不罕见。 开发微服务器，可以在准备好并测试后立即部署新模块，只要它不会破坏网络接口，它就会为我们提供和使用其他模块。

如果您想了解更多关于微服务，第一个和最真实的来源是 Martin Fowler 的文章（ [http://www.martinfowler.com/articles/microservices.html](http://www.martinfowler.com/articles/microservices.html) ）。 请注意，此页面指的是微服务资源指南，列出了许多微服务信息资源。

# 服务界面设计

在本节中，我们将设计我们将实施的两个界面。 当我们设计接口时，我们首先关注功能。 格式化和协议稍后。 界面通常，应该简单，同时，适应未来的变化。 这是一个难题，因为我们无法看到未来。 业务，物流和所有其他专家可能会看到未来的某些部分 - 世界将如何变化以及它将对公司的运作产生什么，特别是我们为合作伙伴提供的界面。

界面的稳定性至关重要，因为合作伙伴在外部实体。 我们无法重构他们使用的代码。 当我们在代码中更改 Java 接口时，编译器将抱怨应遵循更改的所有代码位置。 如果在我们的领域以外使用的接口，那不是这种情况。 即使它只是我们在 *github* 上作为开源发布的 Java 接口，我们应该准备好，如果我们以不兼容的方式更改库，我们的用户将面临问题。 在这种情况下，他们的软件不会编译和与我们的图书馆合作。 在订购系统的情况下，这意味着它们不会从我们订购，我们将很快脱离业务。

这是接口应该简单的原因之一。 虽然这一般对生活中大多数事情都是如此，但对于接口来说非常重要。 为合作伙伴提供便利功能很诱人，因为它们很容易实现。 然而，从长远来看，这些功能可能会在需要维护时变得非常昂贵; 他们应该保持向后兼容。 从长远来看，他们可能不会像成本一样获得。

要访问产品信息，我们需要两个功能。 其中一个列出了某些产品，另一个产品返回特定产品的详细信息。 如果是 Java API，它将如下所示：

```
List<ProductId> query(String query);
ProductInformation byId(ProductId id);
```

同样，订单放置可能看起来像以下代码中所示的内容：

```
OrderId placeOrder(Order order);
```

我们通过 Web 服务界面在我们的应用程序中提供这些功能; 更具体地，使用 JSON 休息。 我们将以更详细的详细讨论这些技术，以及 Spring 框架和模型视图控制器设计模式，但首先，让我们来看看产品信息控制器以了解我们的程序的样子：

```
package packt.java11.mybusiness.productinformation;
import ...
@RestController
public class ProductInformationController {
    private final ProductLookup lookup;

    public ProductInformationController(
            @Autowired ProductLookup lookup) {
        this.lookup = lookup;
    }

    @RequestMapping("/pi/{productId}")
    public ProductInformation getProductInformation(
            @PathVariable String productId) {
        return lookup.byId(productId);
    }

    @RequestMapping("/query/{query}")
    public List<String> lookupProductByTitle(
            @PathVariable String query,
            HttpServletRequest request) {
        return lookup.byQuery(query)
                .stream().map(s -> "/pi/" + s)
                .collect(Collectors.toList());
    }
}
```

如果将 servlet 的代码与前面的代码进行比较，则可以看到这更简单。 我们不需要处理`HttpServletRequest`对象，调用 API 来获取参数，或创建 HTML 输出并将其写入响应。 框架是这样做的。 我们注释了`@RestController`类，告诉 Spring 这是一个使用 REST Web 服务的控制器; 因此，它将创建一个 **JSON** 响应默认返回的对象。 我们不需要关心对象的转换为 *json* ，尽管我们可以真的需要。 使用类中使用的字段名称和我们返回的实例的字段值，该对象将自动转换为 *JSON* 。 如果对象包含比仅仅是 Plain `String`，`int`和`double`值更复杂的结构，那么转换器是为嵌套结构和最常见的数据类型做好准备。

要在 servlet 上具有不同的代码处理和不同的 URL，我们需要做的就是用`@RequestMapping`向方法注释，提供 URL 的路径一部分。 映射字符串内的`{productId}`表示法是可读且易于维护的。 Spring 刚刚从那里削减了值，并根据`@PathVariable`注释所要求的，将其放入`productId`变量中。

产品的实际查找尚未在控制器中实现。 这不是控制器的功能。 控制器只决定调用哪些业务逻辑以及要使用的视图。 业务逻辑在服务类中实现。 将此服务类的实例注入`lookup`字段。 这种注射也通过弹簧完成。 我们要做的实际工作是调用这次业务逻辑，这次是因为我们只有一个，相当容易。

这些事情中的大多数似乎是关于框架为我们所做的内容的更多细节。 因此，在继续之前，我们将看一下建筑块 - JSON，REST，MVC 和 Spring 框架的一点。

# 杰森

**JSON** 代表 **JavaScript 对象表示法**。 它在官方 JSON 网站上定义（ [http://www.json.org/](http://www.json.org/) ）。 这是一种文本表示法，与在 JavaScript 中定义的对象文字相同。 对象表示以`{`字符开头，并以`}`字符结尾。 介于之间的文本定义了表单中的对象的字段`string : value`。 字符串是字段的名称，因为 JSON 想要成为语言不可知论之后，它允许任何字符成为字段名称的一部分，因此此字符串（以及 JSON 中的任何字符串）应开始和结束 使用`"`字符。

这似乎很奇怪，在大多数情况下，当您开始使用 JSON 时，很容易忘记和写`{ myObject : "has a string"}`而不是正确的`{ "myObject" : "has a string" }`表示法。

逗号分隔字段。 您也可以在 JSON 中有数组。 它们分别从`[`和`]`字符启动和结束，它们包含逗号分隔值。 对象字段或阵列中的值可以是字符串，数字，对象，阵列或常量`true`，`false`和`null`之一。

一般来说，JSON 是一个非常简单的符号，用于描述可以存储在对象中的数据。 使用文本编辑器和易于阅读易于编写，因此更容易调试使用 JSON 的通信而不是使用复杂格式的东西。 将 JSON 转换为 Java 对象的方法以及其他方式，在本章中使用的库中随时可用。 描述了来自我们示例代码的产品的示例 JSON 对象也可以在程序的源代码中提供，如下所示：

```
{"id":"125","title":"Bar Stool",
 "description":"another furniture",
 "size":[20.0,2.0,18.0],"weight":300.0}
```

请注意，JSON 的格式不需要新行，但同时，这也是可能的。 程序生成的 JSON 对象通常是紧凑且不格式化的。 当我们使用文本编辑器编辑对象时，我们倾向于以与 Java 编程通常所做的方式格式化字段的缩进。

# 休息

**REST** 协议没有完全定义。 它代表**代表状态转移**，这可能对从未听说过的人对任何人都不意味着什么。 当我们编写 REST API 时，我们使用 HTTP（S）协议。 我们向服务器发送简单的请求，我们会得到我们编程的简单答案。 这样，Web 服务器的客户端也是一个程序（顺便说一下，浏览器也是一个程序），它消耗来自服务器的响应。 因此，响应的格式不是使用 CSS 格式化的 HTML，并由 **JavaScript** 通过客户端函数来丰富，但是一些数据描述性格式，例如 JSON。 REST 未对实际格式设置限制，但这些日子，JSON 是最广泛使用的格式。

描述 REST 的 Wiki 页面在 [https://en.wikipedia.org/wiki/representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer) 可用。

REST 接口通常很简单。 HTTP 请求几乎始终始终使用`GET`方法。 它还使 REST 服务的测试简单，因为没有什么比从浏览器发出`GET`请求更容易。 幼儿可以这样做。 `POST`仅在服务执行某些事务或更改服务器时执行请求，并且该请求将数据发送到服务器而不是获取一些数据。

在我们的应用程序中，我们将使用`GET`方法查询产品列表并获取有关产品的信息，我们只会使用`POST`来订购产品。 服务于这些请求的应用程序将在 servlet 容器中运行。 您已经学会了如何在不使用框架的情况下创建裸体服务器。 在本章中，我们将使用 Spring Framework，从而卸载来自开发人员的许多任务。 servlet 编程中有许多程序构造，大部分时间都是相同的。 它们被称为 Boilerplate 代码。 Spring 框架利用模型视图控制器设计模式来开发 Web 应用程序; 因此，我们将简要介绍一下，在春季讨论春季之前。

# 模型视图控制器

**模型视图控制器**（ **MVC** ）是一种设计模式。 设计模式是编程构造 - 简单结构，可以提示如何解决特定问题。 术语设计模式被创造并在书中进行了正式描述的*设计模式，可重复使用的面向对象软件的元素*，由 Erich Gamma，Richard Helm，Ralph Johnson 和 John Vlissides 编写。 本书将设计模式定义为具有*名称*的结构，A *问题*和*解决方案*。 *名称*描述了模式，并给出了开发人员社区的词汇，在谈论这些模式时使用。 重要的是，不同的开发人员使用相同的语言术语来互相理解。 *问题*描述了这种情况，即可以应用模式的设计问题。 *解决方案*描述了类和对象以及它们之间的关系，这有助于良好的设计。

其中一个是 MVC，适用于编程 Web 应用程序，但可以一般用于具有用户界面的任何应用程序。 在我们的情况下，我们没有经典的用户界面，因为客户也是一个程序; 尽管如此，MVC 可能是一个很好的选择：

![](img/394a6111-5277-4b1d-93c0-c1334912bd78.png)

作为名称的 MVC 模式也表示，具有三个部分 - 模型，视图和控制器。 这种分离遵循单一责任原则，需要一个部分的不同责任。 控制器负责处理系统的输入，并决定使用什么模型和视图。 它控制执行，但通常不会做任何业务逻辑。 该模型是业务逻辑并包含数据。 View 将模型数据转换为客户端消耗的表示。

MVC 是一种众所周知的和广泛使用的设计模式，它是由弹簧直接支撑的。 创建 Web 应用程序时，使用注释将控制器进行编程内置框架中。 基本上是配置它。 您可以编程视图，但更有可能使用内置于框架中的一个。 您希望将数据发送到客户端在 **xml** ， **json** 或 **html** 中。 如果您是非常异国情调，您可能希望发送 **YAML** ，但通常，这就是它。 您不希望实现需要在服务器上编程的新格式，并且在客户端上也是新的。

我们创建了模型，这次，我们也会编程。 毕竟，这是业务逻辑。 框架可以为我们做很多事情，主要是大多数应用程序的东西，但不是业务逻辑。 业务逻辑是从其他程序区分代码的代码。 这就是我们必须编程的。

另一方面，这就是我们喜欢专注于商业代码的东西，避免框架提供的所有样板。

既然我们知道什么 **JSON** ， **REST** ，以及一般模型视图控制器的设计模式，让我们看看这些如何由春天管理，以及我们如何将这些技术融入行动。

# 春天框架

Spring 框架是一个具有多个模块的巨大框架。 框架的第一个版本于 2003 年发布，从那时起，已经有四个主要版本提供了新的和增强的功能。 目前，Spring 是使用的事实上的企业框架，也许比 De Jure Standard **EJB 3.0** 更广泛。

Spring 支持依赖注入，**面向宽面的编程**（ **AOP** ），并以常规方式持久地用于 **SQL** 和 **NOSQL** 数据库 对象关系映射方式。 它具有交易支持，消息传递，网络编程以及许多其他功能。 您可以使用 **XML** 配置文件，注释或使用 Java 类配置。

# 春天的建筑

春天不是单片。 您可以使用其中的一部分，或者只使用一些功能。 您可以包含您需要的春天的一些模块，并留出其他春天。 有些模块依赖于其他一些，以及 Gradle，Maven 或其他构建工具处理依赖项。

下图显示了版本 4 的 Spring 框架的模块：

![](img/26140f41-bd71-4b94-9c60-624ad141a68a.png)

自首次发布以来，春天一直在发展，它仍然被认为是现代框架。 框架的核心是一个类似于我们在上一章中看到的依赖注入容器。 随着框架的开发，它还支持 AOP 和许多其他企业功能，例如以邮件为导向的模式和 Web 编程，使用模型视图控制器的实现，不仅支持 servlet，还支持 portlet 和 websockets。 由于 Spring 针对企业应用程序竞技场，它还支持多种不同方式的数据库处理。 它支持使用模板的 JDBC，**对象关系映射**（ **orm** ）和事务管理。

在此示例程序中，我们将使用一个相当近期的模块 - 春季启动。 此模块使得开始编写和运行应用程序非常容易，假设许多程序通常相同的配置通常相同。 它包含一个嵌入式 servlet 容器，它配置为默认设置并在任何地方配置弹簧，以便我们可以专注于编程方面而不是在弹簧配置上。

# 春心核心

核心模块的中心元素是上下文。 当 Spring 应用程序启动时，容器需要一个上下文，其中容器可以创建不同的 bean。 这对于任何依赖注入容器都是非常普遍的并且是真实的。 如果我们以编程方式创建两个不同的上下文，它们可以在相同的 **JVM** 中彼此独立地生活。 如果有一个 bean 声明为单例，那么应该只有一个单个实例，那么容器将在需要时创建一个上下文的实例。 表示上下文的对象具有引用我们已创建的对象。 但是，如果有多个上下文，则它们不知道 JVM 中有另一个上下文已经具有实例，并且容器将为其他上下文创建单例 bean 的新实例。

通常，我们在程序中不使用多个上下文，但是在单个 JVM 中存在许多上下文的许多示例。 当不同的 servlet 在同一 servlet 容器中运行时，它们在由类加载器分隔的同一 JVM 中运行，并且每个都可以使用弹簧。 在这种情况下，上下文将属于 servlet，每个上下文都有新上下文。

在上一章中，我们使用了 Guice。 弹簧上下文类似于 ugice 喷射器。 在上一章中，我正在作弊，因为我是编程 Guice，为每个请求创建一个新的注射器。 这远非最佳，并且 Guice 提供可以处理 Servlet 环境的注射器实现。 作弊的原因是我想更多地关注 DI 架构必需品，我不想通过引入注射器的复杂（井，更复杂）的实现来使代码复杂化。

Spring 上下文行为由接口`ApplicationContext`定义。 此接口有两个扩展和许多实现。 `ConfigurableApplicationContext`扩展`ApplicationContext`，定义稳定器，`ConfigurableWebApplicationContext`定义了 Web 环境中所需的方法。 当我们编程 Web 应用程序时，我们通常不需要直接与上下文进行干扰。 该框架以编程方式配置 servlet 容器，它包含创建上下文并调用我们的方法的 servlet。 这是为我们创建的所有样板代码。

上下文会跟踪已创建的 bean，但它不会创建它们。 要创建豆类，我们需要豆造工厂或至少一个工厂。 春天的豆类工厂是一种实现接口`BeanFactory`的类。 这是 Spring 中 Bean Factory 类型层次结构的最顶层接口。 bean 只是一个对象，因此 bean factore 只需创建一个类的新实例。 但是，它也必须将此新对象注册到上下文中，而 Bean 也应该具有名称，这是一个`String`。 这样，程序中的程序和春天可以通过它的名称引用 bean。

可以在春天以几种不同的方式配置不同的豆。 最古老的方法是创建一个描述不同 bean 的 XML 文件，指定名称，必须实例化以创建 bean 的类，而字段，则为 bean 需要为其创建注入其他 bean。

这种方法背后的动机是这种方式，豆布线和配置可以完全独立于应用程序代码。 它成为一个可以单独维护的配置文件。

例如，我们可能有一个在几个不同环境中工作的大型应用程序。 在我们的示例中以众多方式获得库存数据的访问。 在一个环境中，通过调用 SOAP 服务可用库存。 在另一个环境中，可以在 SQL 数据库中访问数据。 在第三种环境中，它可以在一些 NoSQL 商店提供。 这些访问中的每一个都实现为单独的类，实现公共库存访问接口。 应用程序代码仅取决于接口，它是提供一个实现或另一个实现的容器。

当 Bean 接线的配置处于 XML 时，只需编辑此 XML 文件，并且可以使用适合于特定环境的接口的实现启动代码。

下一个可能性是使用注释配置 bean。 在大多数情况下，使用 Spring 的原因是将对象创建与功能分开。 在这种情况下，可能只有一个豆类的实现。 仍然使用春天，使用为依赖项注入提供的框架，实际代码是更清洁的。 另一方面，外部 XML 将从需要配置配置的代码移动配置。 在这种情况下，可以控制 bean 创建和注入的注释作为代码中的声明。

的情况下的 XML 配置时，只有一个单一的实现是多余的。 为什么我要以 XML 配置指定我希望由我的程序的单个类别的接口实例实现该接口？ 它相当明显，不能以任何其他方式，因此这是实现界面的唯一类。 我们不喜欢键入不呈现新信息的东西。

要发出一个类可以用作 bean，并且可能提供名称，我们可以使用`@Component` annotation。 我们不需要提供名称作为论据。 在这种情况下，名称将是一个空字符串，但为什么要有一个名称，如果我们不提及它？ Spring 扫描了类路径上的所有类，并识别已注释的类，并且它知道它们是用于 Bean 创建的候选者。 当组件需要注入另一个豆时，该字段可以用`@Autowired`或`@Inject`注释。 `@Autowired`注释是弹簧注释，并在`@Inject`注释标准化之前存在。 如果您打算在 Spring 容器之外使用您的代码，建议您使用标准注释。 在功能上，它们是等同的。

在我们的代码中，当 Spring 创建`ProductInformationController`组件的实例时，似乎它需要`ProductLookup`的实例。 这是一个接口，因此，Spring 开始查找实现此接口的类，然后它创建了一个实例，可能首先创建其他 bean，然后将容器注入，设置字段。 您可以决定向字段的 Setter 注释，而不是字段本身。 在这种情况下，即使 Setter 是`private`，Spring 也会调用 Setter。 您可以通过构造函数参数注入依赖项。 设定器，现场注射和构造函数注入之间的主要区别是您无法在使用构造函数注入的情况下没有依赖性的情况下无法创建豆子。 当实例化 bean 时，它应该并且将具有注入的所有其他 bean，以便它取决于使用构造函数注入。 同时，需要通过 Setter 注入或直接进入场的依赖性，或者可以在稍后由在实例化类和装备 bean 之间的某个时间来实例化。

在构造函数代码变得比简单依赖项设置更复杂或直到依赖关系变得复杂之前，这种略有差异可能看起来不太有趣或重要。 在复杂的构造函数的情况下，代码应注意未完全创建对象的事实。 这通常是任何构造函数代码，但在由依赖注入容器创建的 Bean 的情况下，通过直接现场访问或通过 Setter 注入注入依赖性，更重要。 可以建议使用构造函数注入以确保依赖关系。 如果程序员犯了错误，忘记了该对象未完全初始化，并且在构造函数中使用它或从构造函数调用本身的方法，依赖于那里。 此外，它是清洁和结构良好的，用于使用构造函数初始化依赖项，并具有声明的这些字段`final`。

另一方面，构造函数注射有其缺点。

如果不同的对象彼此相互依赖，并且在依赖图中有一个环，则如果使用构造函数依赖项，弹簧将具有困难的时间。 当类 *a* 需要类 *b* 和另一个方式，作为最简单的圆圈，那么都没有创建和 *b* 没有 如果依赖项注入是构造函数依赖性，则另一个。 在这样的情况下，不能使用构造函数喷射，并且圆圈应至少分成单个依赖性。 在这样的情况下，Setter 注入是不可避免的。

当存在可选依赖性时，Setter 注入也可能更好。 在大多数情况下，类可能不需要同时需要所有的依赖项。 某些类可以使用数据库连接或 NoSQL 数据库句柄，但不同时使用数据库连接。 虽然它也可能是代码闻起来，可能是糟糕的 OO 设计的标志，可能会发生。 这可能是一个刻意的决定，因为纯 OO 设计将导致对象层次太大和太多类，超出可维护的限制。 如果是这种情况，可以使用 Setter 注入更好地处理可选的依赖项。 有些是配置和设置的，有些是留下默认值，通常是`null`。

最后但并非最不重要的是，我们可以使用 Java 类配置容器，以防注释是不够的。 例如，`ProductLookup`接口有多种实现，因为它在我们的代码库中。 （不要担心，如果你不认识到那样;我还没有告诉过你。）有一个`ResourceBasedProductLookup`类，可以从包中读取属性文件，主要用于测试应用程序，并且存在`RestClientProductLookup`，这是界面的类似生产的实现。 如果除了用`@Autowired`注释`lookup`字段的情况下没有其他配置，则 Spring 将不知道要使用哪个实现，并且将在启动期间奖励用户的错误消息：

```
Error starting ApplicationContext. To display the auto-configuration report re-run your application with 'debug' enabled.
2023-11-03 07:25:01.217 ERROR 51907 --- [  restartedMain] o.s.b.d.LoggingFailureAnalysisReporter   :  

***************************
APPLICATION FAILED TO START
***************************

Description:

Parameter 0 of constructor in packt.java9.by.example.mybusiness.productinformation.ProductInformationController required a single bean, but 2 were found:
        - resourceBasedProductLookup: defined in file [/.../sources/ch07/productinformation/build/classes/main/packt/java9/by/example/mybusiness/productinformation/lookup/ResourceBasedProductLookup.class]
        - restClientProductLookup: defined in file [/.../sources/ch07/productinformation/build/classes/main/packt/java9/by/example/mybusiness/productinformation/lookup/RestClientProductLookup.class]

Action:

Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed
```

这是一个相当自我解释的错误信息; 它告诉我们很多。 现在，现在是我们可以在 XML 中配置 Bean 的时候，但同时，我们还可以使用 Java 配置它。

许多开发人员第一次没有得到该点。 我也没有得到它。 整个 XML 配置是将配置与代码分开。 它是创建系统管理员更改配置的可能性，并且可以自由选择某些接口的一个或其他实现，将应用程序连接在一起。 现在，春天告诉我，最好返回编程方式？

与此同时，我可以听到多年的担忧，XML 不是比 Java 代码更好。 XML 写作基本上是编程的，除了工具和 IDE 支持并不适用于 XML，因为它是用于 Java 代码的 XML（近年来的后者发达了很多，但这是因为这是弹簧 XML 配置）。

要了解从 XML 返回 Java 代码的概念，我们必须恢复纯粹的原因和 XML 配置方式的目标。

XML Spring 配置的主要优点不是格式不是编程的，而是与应用程序代码分开的配置代码。 如果我们在 Java 中编写配置并将这些配置类保留到最低限度，并且它们应尽可能地保持，然后应用程序与配置代码的分离仍然存在。 它只是我们从 XML 到 Java 的配置的格式。 优点很多。 一个是，在我们编辑时，IDE 识别类的名称，我们可以在 Java 中自动完成（请注意，在某些 IDE 中使用 XML 时，这也可以使用其中一些插件的 IDE）。 在 Java 的情况下，IDE 支持普遍存在。 Java 比 XML 更可读。 好吧，这是一种味道，但我们大多数人都像 Java 一样多于 XML。

系统管理员还可以编辑 Java 代码。 当他们编辑 XML 配置时，它们通常必须从 jar 或 War 文件中提取它，编辑它，然后再次打包存档。 在 Java 编辑的情况下，它们也必须发出`gradle war`命令或类似的东西。 这不应该是一个在服务器上运行 Java 应用程序的系统管理器的 Showstopper。 而且，它不是 Java 编程。 它只是编辑一些 Java 代码文件并替换某些类名称文字和字符串常量。

我们在我们的示例应用程序代码中遵循此方法。 我们在应用程序中有两个配置文件：一个用于本地部署和测试，另一个用于生产。 `@Profile`注释指定配置应该使用的配置文件。 配置文件在执行代码时，可以在命令行中指定为系统属性，如下所示：

```
$ gradle -Dspring.profiles.active=local bootRun
```

配置类用`@Configuration`注释。 Bean Factories 的方法用`@Bean`注释：

```
package packt.java11.mybusiness.productinformation;

import ...

@Configuration
@Profile("local")
public class SpringConfigurationLocal {

    @Bean
    @Primary
    public ProductLookup productLookup() {
        return new ResourceBasedProductLookup();
    }

    @Bean
    public ProductInformationServiceUrlBuilder urlBuilder() {
        return null;
    }
}
```

Bean Factory 只是返回实现`ProductLookup`接口的`ResourceBasedProductLookup`类的新实例。 当没有外部服务依赖于外部服务时，此实现可用于运行本地测试的应用程序。 此实现从打包到 JAR 应用程序中的本地资源文件中读取产品数据。

配置的生产版本并不大得多，但可以预期，有几件事要配置：

```
package packt.java11.mybusiness.productinformation;
import ...
@Configuration
@Profile("production")
public class SpringConfiguration {

    @Bean
    @Primary
    public ProductLookup productLookup() {
        return new RestClientProductLookup(urlBuilder());
    }

    @Bean
    public ProductInformationServiceUrlBuilder urlBuilder() {
        return new ProductInformationServiceUrlBuilder("http://localhost");
    }
}
```

此版本的`ProductLookup`服务类使用外部 REST 服务来检索它将其呈现给客户端的数据。 为此，它需要这些服务的 URL。 通常应配置此类 URL。 在我们的示例中，我们实现了一个解决方案，可以在飞行中计算这些 URL。 我试图弥补现实生活中可能需要的情况，但所有的推理都扭曲了，我放弃了。 真正的原因是，这样，我们可以看到包含要注入另一个 bean 的 bean 的代码。 目前，请注意，`ProductInformationServiceUrlBuilder`实例 bean 以与`ProductLookup` bean 相同的方式定义，并且当必须注入`ProductLookup` bean 的构造函数时，它使用它的定义 bean 方法而不是 直接表达式：

```
new ProductInformationServiceUrlBuilder("http://localhost");
```

后者可以工作，但不在所有情况下，我们不应该使用它。 出于这些原因，我们将在随后的部分讨论 AOP 时返回。

此外，请注意，无需定义一个接口以定义一个 bean。 Bean 方法返回的类型也可以是类。 上下文将使用适合所需类型的方法，如果有多个合适的类型并且配置不足以足够精确，则随着我们所看到的，容器将记录错误并无法正常工作。

在服务本地配置文件的配置中，我们将为`ProductInformationServiceBuilder`为`null`值创建一个`null`值。 这是因为当我们使用本地测试时我们不需要它。 此外，如果调用此类的任何方法，则会是错误的。 应尽快检测错误; 因此，`null`值是一个简单合理的选择。 如果曾经调用的任何方法，则更好的选择是抛出特定异常的 bean。 这样，您可以看到特定的异常，也可以看到测试代码想要调用的方法而不是 null 指针异常。

`ProductInformationServiceUrlBuilder`类非常简单：

```
package packt.java11.mybusiness.productinformation;

public class ProductInformationServiceUrlBuilder {
    private final String baseUrl;

    public ProductInformationServiceUrlBuilder(String baseUrl) {
        this.baseUrl = baseUrl;
    }

    public String url(String service) {
        final String serviceUrl;
        switch (service) {
            case "pi":
                serviceUrl = baseUrl + ":8081/product/{id}";
                break;
            case "query":
                serviceUrl = baseUrl + ":8081/query/{query}";
                break;
            case "inventory":
                serviceUrl = baseUrl + ":8083/inventory/{id}";
                break;
            default:
                serviceUrl = null;
                break;
        }
        return serviceUrl;
    }
}
```

此 bean 还需要构造函数参数，并且我们在配置中使用字符串常量。 这清楚地向我们展示了可以使用一个简单的对象来初始化一些依赖项（什么会阻止我们？它毕竟是纯粹的 Java），但它可以*可能*阻碍了一些弹簧特征的工作。

# 服务课程

我们有两个服务课程。 这些类为控制器提供数据并实现业务逻辑，无论它们多么简单。 其中一个服务类实现了对基于 REST 的服务的调用，而另一个则读取来自属性文件的数据。 后者可用于在离线时测试应用程序。 调用 REST 服务的产品在生产环境中使用。 两者都实现了`ProductLookup`界面：

```
package packt.java11.mybusiness.productinformation;
import java.util.List;
public interface ProductLookup {
    ProductInformation byId(String id);
    List<String> byQuery(String query);
}
```

`ResourceBasedProductLookup`将整个数据库存储在名为产品的地图中。 当调用其中一个服务方法时，它填充了属性文件。 当它们开始时，从每个服务方法调用`private`方法`loadProducts`，但如果它没有加载，则只会加载数据：

```
package packt.java11.mybusiness.productinformation.lookup;
import ...

@Service
public class ResourceBasedProductLookup implements ProductLookup {
```

该类使用`@Service`注释。 该注释实际上等同于`@Component`注释。 这只是相同注释的替代名称。 Spring 还处理`@Component`注释，以便如果使用`@Component`注释注释注释接口，则注释也可用于发信号通知类是弹簧组件。 如果要为更好的可读性发出信号，您可以编写自己的注释接口，指出一个类不是一个简单的组件，而是其他特殊类型。

例如，启动您的 IDE 并导航到`ResourceBasedProductLookup`类中的`fromProperties()`方法：

```
private ProductInformation fromProperties(Properties properties) {
    final ProductInformation pi = new ProductInformation();
    pi.setTitle(properties.getProperty("title"));
    pi.setDescription(properties.getProperty("description"));
    pi.setWeight(Double.parseDouble(properties.getProperty("weight")));
    pi.getSize()[0] = Double.parseDouble(properties.getProperty("width"));
    pi.getSize()[1] = Double.parseDouble(properties.getProperty("height"));
    pi.getSize()[2] = Double.parseDouble(properties.getProperty("depth"));
    return pi;
}
```

`fromProperties()`方法创建`ProductInformation`的实例，并将其填充在`Properties`对象中给出的参数。

`Properties`类是一种旧的和广泛使用的类型。 虽然有更多现代格式和课程，但仍然广泛使用，并且很可能会遇到这个课程。 这是我们在这里使用它的原因。

`ProductInformation` is a simple **Data Transfer Object** (**DTO**) that contains no logic—only fields, setters, and getters. It also contains a constant, `emptyProductInformation`, which holds a reference to an instance of the class with empty values.

`Properties`对象类似于`Map`对象。 它包含分配给`String`键的`String`值。 有些方法，正如我们在我们的示例中看到的那样，这有助于程序员从所谓的属性文件加载`Properties`对象。 这样的文件通常具有`.properties`扩展，它包含以下格式的键值对：

```
key=value
```

例如，`123.properties`文件包含以下内容：

```
id=123
title=Fundamentals of Java 18.9
description=a new book to learn Java 11
weight=300
width=20
height=2
depth=18
```

`properties`文件用于存储简单的配置值，并且几乎完全用于包含特定语言常量。 这是一个非常扭曲的使用，因为`properties`文件是 **iso latin-1** 编码文件，在需要使用一些特殊的 UTF-8 字符时，必须使用`uXXXX`键入它们 格式或使用 Native2Ascii Converter 程序。 您无法将它们保存为 UTF-8。 然而，这是文件用于程序国际化的语言特定字符串的文件（也缩写为 I18N，因为在 International 化的 Word In International 化中的启动 I 和 Last N 之间有 18 个字符）。

要获取`Properties`对象，我们必须读取项目中的文件，并将它们打包到 JAR 文件中。 Spring 类[Htg1]帮助我们这样做。

天哪，是的，我知道！ 当我们使用春天时，我们必须习惯这些长名称。 无论如何，如此长而描述的名称广泛用于企业环境，需要解释类的功能。

我们声明一个地图，它将在测试期间包含所有产品：

```
final private Map<String, ProductInformation> products = new HashMap<>();
```

关键是产品 ID，这是我们示例中的字符串。 使用`fromProperties`方法，值为`ProductInformation`对象。

未加载产品的下一个字段信号：

```
private boolean productsAreNotLoaded = true;
```

新手程序员通常使用名称`productsAreLoaded`的相反值，默认设置为`false`。 在这种情况下，我们将读取值的唯一位置将否定值，或`if`命令的主分支成为无数零件。 也不是最好的做法。

```
private void loadProducts() {
    if (productsAreNotLoaded) {
        try {
            Resource[] resources =
                new PathMatchingResourcePatternResolver()
                    .getResources("classpath:products/*.properties");
            for (Resource resource : resources) {
                loadResource(resource);
            }
            productsAreNotLoaded = false;
        } catch (IOException ex) {
            log.error("Test resources can not be read", ex);
        }
    }
}
```

`getResources()`方法返回具有`products`扩展的`products`目录下的类路径上的所有资源（文件）：

```
private void loadResource(Resource resource) throws IOException {
    final int dotPos = resource.getFilename().lastIndexOf('.');
    final String id = resource.getFilename().substring(0, dotPos);
    Properties properties = new Properties();
    properties.load(resource.getInputStream());
    final ProductInformation pi = fromProperties(properties);
    pi.setId(id);
    products.put(id, pi);
}
```

产品 ID 由文件的名称给出。 这是使用简单的字符串操作来计算的，切断扩展。 `Resource`还可以提供`Properties`类`load`方法可以用于一次加载所有属性的输入流。 最后，我们在地图中保存新的`ProductInformation`对象。

我们还有一个空的`noProduct`列表。 如果我们想要搜索产品时，如果查询没有产品，则会返回此操作：

```
private static final List<String> noProducts = new LinkedList<>();
```

产品查找服务只需从`Map`中获取产品并返回它，或者如果不存在，则返回一个空产品：

```
@Override
public ProductInformation byId(String id) {
    loadProducts();
    if (products.containsKey(id)) {
        return products.get(id);
    } else {
        return ProductInformation.emptyProductInformation;
    }
}
```

查询有点复杂。 它通过标题进行搜索产品。 现实生活实现可以实现更复杂的逻辑，但此版本仅用于本地测试; 因此，按标题的搜索足够：

```
@Override
public List<String> byQuery(String query) {
    loadProducts();
    List<String> pis = new LinkedList<>();
    StringTokenizer st = new StringTokenizer(query, "&=");
    while (st.hasMoreTokens()) {
        final String key = st.nextToken();
        if (st.hasMoreTokens()) {
            final String value = st.nextToken();
            log.debug("processing {}={} query", key, value);
            if (!"title".equals(key)) {
                log.error("Search by title is allowed only");
                return noProducts;
            }
            for (String id : products.keySet()) {
                log.error("key: {} value:{} id:{}", key, value, id);
                ProductInformation pi = products.get(id);
                if (pi.getTitle().startsWith(value)) {
                    pis.add(id);
                }
            }
        }
    }
    return pis;
}
```

实现生产功能的服务类更简单。 奇怪，但在大多数情况下，测试代码比生产代码更复杂：

```
package packt.java11.mybusiness.productinformation.lookup;

import ...
@Component
public class RestClientProductLookup implements ProductLookup {
    private static Logger log = LoggerFactory.getLogger(RestClientProductLookup.class);

    final private ProductInformationServiceUrlBuilder piSUBuilder;

    public RestClientProductLookup(ProductInformationServiceUrlBuilder piSUBuilder) {
        this.piSUBuilder = piSUBuilder;
    }
```

构造函数用于注入 URL Builder Bean，这是类的所有辅助代码。 其余的是`byId()`和`byQuery()`的两种服务方法。 首先，我们查看`byId()`方法：

```
@Override
public ProductInformation byId(String id) {
    var uriParameters = new HashMap<String, String>();
    uriParameters.put("id", id);
    var rest = new RestTemplate();
    var amount =
        rest.getForObject(piSUBuilder.url("inventory"),
            InventoryItemAmount.class,
            uriParameters);
    log.info("amount {}.", amount);
    if (amount.getAmount() > 0) {
        log.info("There items from {}. We are offering", id);
        return rest.getForObject(piSUBuilder.url("pi"),
            ProductInformation.class,
            uriParameters);
    } else {
        log.info("There are no items from {}. Amount is {}", id, amount);
        return ProductInformation.emptyProductInformation;
    }
}
```

`byId()`方法首先调用库存服务，看看库存中是否有任何产品。 此 REST 服务返回具有格式`{ amount : nnn }`的 JSON; 因此，我们需要一个类（如此简单，我们在这里没有列出它），具有`int amount`字段，Setter 和 Getter。

Spring `RestTemplate`提供了一种访问 REST 服务的简单方法。 所有它所需的是 URL 模板，一种用于转换结果的类型，以及具有参数的`Map`对象。 URL 模板字符串可以包含与弹簧控制器中的请求映射相同的参数，参数的名称在`{`和`}`字符之间。 模板类提供了访问 REST 服务的简单方法。 它自动执行拼标，发送参数和未编组，接收响应。 在`GET`请求的情况下，不需要元帅。 数据位于请求 URL 中，并且`{xxx}`占位符被从地图中的值替换为第三个参数。 大部分格式都可以随时使用 Un-Marshaling。 在我们的应用程序中，REST 服务发送 JSON 数据，并在响应`Content-Type` HTTP 标头中指示。 `RestTemplate`将 JSON 转换为作为参数提供的类型。 如果服务器决定在 XML 中发送响应，则它也将在 HTTP 标头`RestTemplate`中指示，这将自动处理情况。 事实上，查看代码，我们无法讲述响应的编码方式。 这也很好，因为它使客户端灵活，同时，我们不需要处理此类技术细节。 我们可以专注于业务逻辑。

与此同时，该类还提供了套间或其他一些功能的配置参数，以便自动需要它。 例如，您可以提供元帅方法，但我建议您使用默认提供的任何可用性。 在大多数情况下，当开发人员认为需要需要任何这些功能的特殊版本时，其代码的原始设计缺陷。

业务逻辑非常简单。 如果有一定的产品，我们首先询问库存。 如果（超过零），则我们查询产品信息服务并返回详细信息。 如果没有，那么我们返回空记录。

其他服务甚至更简单。 它只是调用了下林服务并返回结果：

```
@Override
public List<String> byQuery(String query) {
    var uriParameters = new HashMap<String, String>();
    uriParameters.put("query", query);
    var rest = new RestTemplate();
    return rest.getForObject(piSUBuilder.url("query"), List.class, uriParameters);
}
```

# 编译和运行应用程序

我们使用`gradle`编译并运行应用程序。 由于应用程序没有任何未出现在大多数相似的应用程序中的任何特定配置，因此使用 Spring 启动是明智的。 Spring Boot 使创建和运行 Web 应用程序非常简单。 我们需要一个 Java 标准`public static void main`方法，通过 Spring 启动应用程序：

```
package packt.java11.mybusiness.productinformation;

import ...

@SpringBootApplication(scanBasePackageClasses = SpringScanBase.class)
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

此方法除了启动`StringApplication`类`run`方法之外不会做任何事情。 它通过原始参数，也可以是应用程序所在的类。Spring 使用此类来读取注释。 此类是 Spring Boot 应用程序的`@SpringBootApplication`注释信号，并提供配置包含应用程序的包的参数。 为此，您可以提供包含类的包的名称，但您也可以在基本包中提供包含春天必须注意的所有类的类。 您可能无法使用 Annotation 参数的类版本，因为根包可能不包含任何类，只有子包。 同时，提供根包的名称作为`String`不会在编译时透露任何拼写错误或未对流。 一些 *IDE* 可以认识到该参数应该是包名称，或者它可以在重构或重命名包时扫描包名称的程序字符串，并为您提供支持，但这是 只有启发式更多。 在那里没有课程的情况下，创建一个占位符班级的普通实践是创建一个占位符。 此类可用于将`scanBasePackageClasses`指定为注释参数而不是需要`String`的`scanBasePackages`。 在我们的示例中，我们有一个空界面`SpringScanBase`，作为占位符。

Spring 扫描类路径上的所有类，识别它可以解释的组件和字段注释，并在需要时使用此知识创建 Bean 而无需配置。

请注意，JDK 中包含的抽象类`ClassLoader`不提供任何类扫描方法。 由于 Java 环境和框架可以实现自己的`ClassLoaders`，因此某些实现不可能提供`URLClassLoader`提供的扫描功能。 `URLClassLoader`是类加载功能的非抽象实现，是 *jdk* 的一部分，也是`ClassLoader`。 我们将讨论随后章节中课堂加载机制的复杂性。

`gradle`构建文件包含通常的内容。 它指定存储库，Java 的插件以及 Spring 启动的 IDE。 它还指定在构建期间生成的 jar 文件的名称。 最重要的部分是依赖项列表：

```
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.4.1.RELEASE")
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'spring-boot'

jar {
    baseName = 'packt-ch07-microservice'
    version =  '1.0.0'
}

repositories {
    mavenCentral()
}

bootRun {
    systemProperties System.properties
}

sourceCompatibility = 1.10
targetCompatibility = 1.10

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web")
    compile("org.springframework.boot:spring-boot-devtools")
    compile("org.springframework:spring-aop")
    compile("org.springframework:spring-aspects")
    testCompile("org.springframework.boot:spring-boot-starter-test")
}
```

我们依赖于 Spring Boot 软件包，一些测试包，AOP 支持（我们很快就会查看），也是在 Spring Boot DevTools 上。

Spring Boot DevTools 可以在重新编译时重新启动 Web 应用程序，而无需重新启动内置 Tomcat 服务器。 假设，我们使用以下命令行启动应用程序：

```
gradle -Dspring.profiles.active=production bootRun
```

Gradle 启动了应用程序。 每当它看到它运行的类被修改时，它会重新加载它们，我们可以在几秒钟内测试修改的应用程序。

`-Dspring.profiles.active=production`参数指定生产配置文件应该是活动的。 为了能够使用此命令行参数，我们还需要在构建文件中关闭`bootRun{}`配置。

# 测试应用程序

应用程序应为每个且每个类的单元测试，除了包含无功能的 DTO 类别之外，每个类别都有。 Setter 和 Getters 由 IDE 创建，程序员未键入，因此不太可能会有任何错误。 如果与这些类有关的一些错误，则更有可能是通过使用单元测试无法发现的集成问题。 由于我们详细讨论了先前章节中的单元测试，我们将更多地关注在此处的集成测试和应用测试。

# 整合测试

集成测试与单元测试非常相似，并且在大多数情况下，新手程序员声称它们在实际执行集成测试时执行单元测试。

集成测试驱动代码，但不在隔离中测试单个类（单位），嘲笑类可以使用的所有内容。 相反，他们测试执行测试所需的大多数类的功能。 这样，集成试验确实测试了这些类能够一起工作，不仅满足自己的规格，而且还可以确保这些规格在一起工作。

在集成测试中，外部世界（如外部服务）和对数据库的访问是嘲笑的。 这是因为集成测试应该在集成服务器上运行，在执行单元测试的同一环境中，并且这些外部接口可能无法使用。 在大多数情况下，数据库使用内存中的 SQL 模拟，并且使用一些模拟类模拟外部服务。

Spring 提供了一个很好的环境来执行这种集成测试。 在我们的项目中，我们有一个样本集成测试：

```
package packt.java11.mybusiness.productinformation;

import ...

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
@AutoConfigureMockMvc
@ActiveProfiles("local")
public class ProductInformationControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void noParamGreetingShouldReturnDefaultMessage() throws Exception {

        this.mockMvc.perform(get("/pi")).andDo(print())
            .andExpect(status().isNotFound());
    }

    @Test
    public void paramGreetingShouldReturnTailoredMessage() throws Exception {

        this.mockMvc.perform(get("/pi/123"))
            .andDo(print()).andExpect(status().isOk())
            .andExpect(jsonPath("$.title").value("Book Java 9 by Example"));
    }

}
```

这远未成为一个完整而全面的集成测试。 有许多情况下尚未测试，但这里，它是良好的。 要拥有对春天环境的所有支持，我们必须使用`SpringRunner`类。 `@RunWith`注释由 JUnit 框架处理; 所有其他注释都适用于春季。 当 JUnit 框架看到有一个`@RunWith`注释和指定的 runner 类时，它将启动该类而不是标准赛道。 `SpringRunner`为测试设置一个弹簧上下文并处理注释。

`@SpringBootTest`指定我们需要测试的应用程序。 这有助于 Spring 读取该类上的课程和注释，标识要扫描的包。

`@AutoConfigureMockMvc`告诉 Spring 以配置模型视图控制器框架的模型版本，可以在没有 Servlet 容器和 Web 协议的情况下执行。 使用此，我们可以测试我们的 REST 服务而无需真正进入网络。

`@ActiveProfiles`告诉春天，活动配置文件是本地的，该春天必须使用注释，`@Profile("local")`表示的配置。 这是一个使用`.properties`文件而不是外部 HTTP 服务的版本; 因此，这适用于集成测试。

该测试在嘲笑框架内执行`GET`请求，在控制器中执行代码，并以非常可读的方式使用模拟框架和流利 API 测试返回的值。

请注意，使用属性文件并基于属性文件具有服务实现是跨危机的一点。 我创建了这一点，以便可以在没有任何实际备用服务的情况下以交互方式启动应用程序。 考虑以下命令-`gradle -Dspring.profiles.active=local bootRun`。 如果我们发出前述命令，则服务器使用此本地实现启动。 如果我们只瞄准集成测试，那么服务类的本地实现应该在`test`目录下，应该更简单，主要只是返回任何预期请求的任何预期请求和抛出错误的持续响应。

# 应用测试

请考虑以下命令：

```
gradle -Dspring.profiles.active=production bootRun
```

如果我们启动应用程序，发出前面的命令并将浏览器射击到 URL `http://localhost:8080/pi/123`，我们将在浏览器屏幕上获得胖错误消息。 哎哟...

它说`Internal Server Error, status=500`或类似的东西。 这是因为我们的代码想要连接到备份服务，但我们还没有任何内容。 要在此级别上进行一些测试，我们应该创建支持服务或至少用于模拟它们的内容。 最简单的方法是使用 SOAPUI 程序。

SOAPUI 是一种可从 [https://www.soapui.org/](https://www.soapui.org/) 可用的 Java 程序。 有一个开源版本和免费版本，并且有一个商业版本。 出于我们的目的，免费版本就足够了。 我们可以以最简单的点击前进方式安装它，因为它具有设置向导。 之后，我们可以启动它并使用图形用户界面。

我们将创建一个新的测试项目，目录和库存，并在 IT，目录和清单中设置两个 REST 模拟服务，如以下屏幕截图所示：

![](img/b22c4714-a394-43ff-85bd-1691e0f356ff.png)

对于每个模拟服务，我们设置要匹配的请求以及响应。 响应的内容是文本，可以在用户界面上键入文本字段。 重要的是，我们忘记将媒体类型设置为`application/json`（默认为 xml）：

![](img/6855ce94-37aa-4059-be2a-0a5666ceaad0.png)

在开始服务之前，我们必须设置端口号（通过单击齿轮）到服务器上可用的东西。 由于 Tomcat 服务器使用 8080 并由 Gradle 执行，并且 SOAPUI 使用 8082 来列出当前正在运行的模拟服务，我将设置目录以侦听端口 8081 和库存以收听端口 8083。您 还可以在`ProductInformationServiceUrlBuilder`类的列表中看到这些端口号。

SOAPUI 将项目保存在 XML 文件中，并且在`project`目录中的 github 上可用。

启动模拟服务后，当我们按刷新时，错误消息会从浏览器屏幕中消失：

![](img/9685b294-4d1e-4a29-be6b-728d3b021bb2.png)

我们看到的是我们输入的东西。

现在，如果我更改库存模拟服务以返回 0 而不是 100，就像原始版本一样，我得到的是以下空记录：

```
{"id":"","title":"","description":"","size":[0.0,0.0,0.0],"weight":0.0}
```

即使在这个级别，测试也可以自动化。 现在，我们正在使用浏览器玩耍，这是一个很好的东西。 不知何故，我觉得当有一个真正做某事的程序时，我觉得我正在制作一些东西，而且我可以看到浏览器窗口中有一些响应。 然而，经过一段时间，这变得无聊，并且手动测试应用程序仍在工作是麻烦的。 对于那些没有改变的功能，它特别乏味。 事实是，即使我们不触摸影响它们的代码，它们也会多次变化。 我们实际上触摸了影响功能的代码，但我们不知道它。 糟糕的设计，编码差，或者我们刚刚忘了，但它发生了。 回归测试是不可避免的。

虽然浏览器测试用户界面也可以自动化，但是我们使用的是我们可以测试的休息服务 - 这就是索拉普伊的。 我们已经安装了该工具，我们已经开始它了，我们有一些模拟服务在其中运行。 下一件事是将新的 REST 服务从 URI 添加到项目并指定 URL `http://localhost:8080/pi/{id}`，与我们为 Spring 的方式完全相同：

![](img/c7c80404-b7bd-4eeb-86ab-4a4ae09c562d.png)

当我们在项目中定义的 REST 服务时，我们可以在套件内创建新的测试套件和测试用例。 然后，我们可以将步骤添加到测试用例，该测试用例将使用参数`123`调用 REST 服务，如果我们修改默认值，则与参数的名称相同，在这种情况下，`id`。 我们可以在窗口的左上角上使用绿色三角形运行测试步骤，并且由于我们拥有经过测试的应用程序和苏拉普模型运行，我们应该在 JSON 中获得答案。 我们必须在响应方面选择 JSON; 否则，SOAPUI 试图将响应解释为 XML，并且由于我们有一个 JSON 响应，它不会太丰硕。 我们看到的是以下窗口：

![](img/b5eca71b-76b5-4757-afb6-a001dee1b1a0.png)

它是我们在浏览器中看到的相同的回应。 我们编程计算机时没有奇迹。 有时，我们不明白会发生什么，有些事情是如此复杂，他们似乎是一个奇迹，但它们实际上不是。 对一切都有解释 - 它可能只是我们所知。 在这种情况下，我们肯定知道正在发生的事情，但为什么要在浏览器上看到 Soapui 屏幕上的 JSON 是更好的？ 原因是 SOAPUI 可以执行断言，并且在某些情况下，基于 REST 调用的结果进一步测试步骤，最终结果是简单的是或否。 测试是可以的，或者它失败。

要添加断言，请单击窗口左下角的断言文本。 正如您在上面的屏幕截图中看到的，我已经添加了一个比较返回的 JSON 的`"title"`字段与 text `"Bar Stool"`。 当我们添加断言时，它建议的默认值是实际返回的默认值，这只是一个非常方便的功能。

在此之后，再次运行整个测试套件将运行所有测试用例（我们只有一个），以及所有的测试步骤，一个之后另一个（再次，我们只有一个），最后它将显示一个绿色成品栏 在 UI 上，如下屏幕截图所示：

![](img/75473ec9-e153-482c-9be7-f96cddd0486b.png)

这不是苏帕努利可以做的一切。 这是一款已在市场上的良好的测试工具多年来。 SOAPUI 可以测试 SOAP 服务和 REST 服务，可以处理 JMS 消息。 您可以使用这些呼叫，循环和断言或在单独的测试中创建许多步骤的测试，并且在所有其他 else 失败的情况下，您可以通过创建 Groovy 语言的编程步骤或通过在 Java 中创建扩展来执行任何内容。

# servlet 筛选器

到目前为止，服务应该正常工作，任何人都可以查询我们产品的详细信息。 这可能是一个问题。 产品的详细信息不一定是公共信息。 我们必须确保我们只向有资格看到它的合作伙伴提供数据。

为了确保，我们需要一些请求证明请求来自合作伙伴的请求。 此信息通常是密码或其他秘密。 它可以放入`GET`请求参数或 HTTP 请求标题中。 最好把它放入标题，因为信息是秘密而不是由任何人看到的。

获取参数是 URL 的一部分，浏览器历史记录记得。 在浏览器位置窗口中输入此信息也很容易，复制/粘贴它，并通过聊天通道或通过电子邮件发送。 这样，不那么教育和关注安全的应用程序的用户可以透露秘密信息。 虽然与在 HTTP 标头中发送的信息并非不可能这样做，但它不太可能发生。 如果信息在标题中，有人在电子邮件中发送此信息，他们可能知道他们在做什么; 他们自愿地越过安全边境而不是简单的疏忽。

要沿 HTTP 请求发送身份验证信息，Spring 提供了一种安全模块，可以轻松地配置注释和配置 XML 和/或类。 这次，我们将对介绍 Servlet 滤波​​器进行不同的方式。

我们将要求供应商将`X-PartnerSecret`标题插入请求中。 这是一个非标准标题，因此它必须具有`X-`前缀。 以下此方法也是一个额外的安全功能。 这样，我们可以使用简单的浏览器阻止用户到达服务。 至少有一个需要一个额外的插件，可以插入自定义标题或其他诸如 SOAPUI 的其他程序。 这样，它将确保我们的合作伙伴以编程方式使用该界面，或者他们需要测试接口 ad hoc，只有具有特定技术级别的用户可以这样做。 这对于保持支持成本控制非常重要。

由于必须在每个和每个服务的情况下检查此秘密，因此我们最好不会将检查代码插入每个服务控制器。 即使我们正确地创建代码并将秘密的检查分解为单独的类，也可以调用断言秘密在那里并且是正确的，必须插入每个控制器中。 控制器执行服务; 检查客户端的真实性是一个基础架构问题。 它们是不同的担忧，因此它们必须分开。

servlet 标准为我们提供此提供的最佳方式是通过 servlet 滤波​​器。 Servlet 过滤器是 Servlet 容器在 servlet 本身之前调用的类，如果已配置过滤器，则为 servlet 本身。 滤波器可以在 servlet 容器的`web.xml`配置文件中配置，或者在使用 Spring Boot 时使用注释。 过滤器不仅可以将请求和响应作为参数获取，而且将用于调用链条中的 servlet 或下一个过滤器的`FilterChain`类型的第三个参数。

定义了多个过滤器，它们被锁定。 过滤器可以自行决定拨打电话或不调用链中的下一个：

![](img/2210c89d-4730-403a-bc2c-593cc1f85534.png)

我们将 Servlet 过滤器放入应用程序的`auth`子包中：

```
package packt.java11.mybusiness.productinformation.auth;

import ...

@Component
public class AuthFilter implements Filter {
    public static final int NOT_AUTHORIZED = 401;
    private static Logger log = LoggerFactory.getLogger(AuthFilter.class);

    @Override
    public void init(FilterConfig filterConfig)
        throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest request,
                         ServletResponse response,
                         FilterChain chain)
        throws IOException, ServletException {

        HttpServletRequest httpRequest = (HttpServletRequest) request;
        final String secret = httpRequest.getHeader("X-PartnerSecret");
        log.info("Partner secret is {}", secret);
        if (true || "packt".equals(secret)) {
            chain.doFilter(request, response);
        } else {
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            httpResponse.sendError(NOT_AUTHORIZED);
        }
    }

    @Override
    public void destroy() {
    }
}
```

过滤器实现了`Filter`界面，它定义了三种方法。 在我们的情况下，我们没有在过滤器中考虑的任何参数，并且我们不会分配任何资源来释放; 因此，`init`和`destroy`方法都是空的。 过滤器的主要工作是`doFilter`方法。 它有三个参数; 其中两个与 servlet 的参数相同，第三个是`FilterChain`。

该请求被转换为`HttpServletRequest`，以便我们可以通过`getHeader`方法访问`X-PartnerSecret`标题。 如果在此标题字段中发送的值很好，我们将在链中调用下一个。 在我们的应用程序中，未配置过滤器; 因此，链中的接下来是 servlet。 如果秘密是不可接受的，那么我们不会在链中致电下一个。 相反，我们返回 *401 未授权* HTTP 错误给客户端。

在这个应用程序中，秘密非常简单。 这是常量字符串`packt`。 这不是一个真正的秘密，特别是现在它在本书中发表。 真实的应用程序需要更多隐秘和较少的知名度。 每个伙伴都会使用不同的秘密，并且秘密必须不时改变。

当 Servlet 中存在错误条件时，我们的程序句柄，使用 HTTP 错误处理机制是一个很好的做法。 而不是通过状态代码 *200 确定*并解释认证不成功的 json 格式，而不是发送回复消息，我们必须寄回 *401 代码*。 这由标准定义，不需要任何进一步的解释或文件。

我们的程序中还有一件事，这是审计日志记录。

# 审计日志记录和 AOP

我们已登录我们的示例代码，并且我们使用了 SLF4J，我们在上一章中介绍。 日志记录或多或少是开发人员的决定并支持操作的技术水平。 在那里，我们还涉及几句审计记录。 这种类型的日志记录通常在功能要求中明确要求。

通常，AOP 正在将代码功能的不同方面分成单独的代码片段，并且正在彼此独立地实现它们。 这是单一责任原则。 这一次，它以不同的方式实现的方式在一起，但我们可以将它们连接在一起的地方。 这是单独定义的。 在其他部件分别编码之前和之后执行的内容并进入弹簧配置？ 我们已经看到了类似的东西。 类需要正确操作的依赖项在单独的段（XML 或 Java 代码）中定义。 在 AOP 的情况下，它并不令人惊讶，使用春天完成相同的事情。 方面配置在配置文件或类中。

典型方面是审计日志记录，我们将用它用作示例。 有许多主题可以使用方面实现，其中一些甚至值得这种方式实现。

我们不希望在需要它的每个业务方法或类中实现审计日志记录代码。 相反，我们实现了一般方面并配置了接线，以便每当调用需要审核日志记录的 Bean 方法时，Spring 会调用审计日志记录。

我们应该了解 AOP 的其他重要术语，特别是如何在春季配置 AOP。

第一个也是最重要的是方面。 这是我们想要实现的功能，在我们的示例中是审计日志记录。

加入点是调用方面时执行的点。 在修改生成类的字节码的 Java 中使用全尺寸方向解决方案时，连接点几乎可以是任何东西。 它可以访问一个字段，读写; 它可以调用方法或异常投掷。 在弹簧的情况下，不修改类别的字节码; 因此，Spring 无法识别字段的访问或被抛出的异常。 使用 Spring，当调用方法时，始终使用连接点。

一条建议是如何在加入点调用方面。 它可以在建议之前，建议或咨询附近。 在之前提出建议时，在调用方法之前调用该方面。 当建议之后，在调用方法后调用该方面。 围绕意味着在方法调用之前调用该方面，并且该方面也有一个参数来调用该方法，并且在调用方法后仍会执行一些操作。 这样，周围的建议与 servlet 滤波​​器非常相似。

在方法调用之前调用之前的建议，返回后，框架将调用该方法。 方面无法防止调用原始方法。 唯一的例外是当方面，嘛，抛出异常。

建议后也受例外的影响。 在方法返回时可以存在返回后的建议。 如果该方法抛出异常，则只能调用抛出后。 最后，在例外或返回的情况下调用之后。

Pointcut 是一个特殊的字符串表达式，标识加入点。 Pointcut 表达式可以匹配零，一个或多个连接点。 当方面与点表达式相关联时，框架将知道加入点以及何时何地调用该方面。 换句话说，切入点是字符串，用于告诉您何时何种方法来调用该方面。

即使 AOP 的 Spring 实现不使用 AspectJ，也不会修改为类创建的字节码，它支持 PointCut 表达式语言。 虽然此表达语言提供了比春季实现的更多功能，但它是一个完整的和广泛使用和接受的表达语言来描述切点，而且没有意义对创造新的东西。

*简介*将方法或字段添加到已存在的类型，并在运行时在运行时执行此操作。 Spring 允许此 AOP 功能将接口添加到现有类型，并以建议类的形式添加接口的实现。 在我们的示例中，我们不使用此功能。

*目标对象*是该方面所建议的对象。 这是包含围绕该方面的方法的 bean，即在调用方面之前或之后。

这只是一套浓缩的定义，几乎就像在数学书中一样。 如果你没有读到这一点，不要担心。 当我第一次读它时，我不明白它。 这就是为什么我们拥有以下示例，之后我们刚刚所涵盖的所有榜样会更有意义：

```
package packt.java11.mybusiness.productinformation;

import ...
@Configuration
@Aspect
public class SpringConfigurationAspect {
    private static Logger log = LoggerFactory.getLogger("AUDIT_LOG");

    @Around("execution(* byId(..))")
    public ProductInformation byIdQueryLogging(ProceedingJoinPoint jp) throws Throwable {
        log.info("byId query is about to run");
        ProductInformation pi = (ProductInformation) jp.proceed(jp.getArgs());
        log.info("byId query was executed");
        return pi;
    }

    @Around("execution(* url(..))")
    public String urlCreationLogging(ProceedingJoinPoint jp) throws Throwable {
        log.info("url is to be created");
        var url = (String) jp.proceed(jp.getArgs());
        log.info("url created was " + url);
        return url;
    }
}
```

该类用`@Configuration`注释注释，因此 Spring 知道此类包含配置。 `@Aspect`注释表示该配置还可以包含方面定义。 方法上的`@Around`注释给出了建议的类型，并且注释的参数字符串是点表达式表达式。 如果建议类型不同，应使用其中一个注释，`@Before`，`@After`，`@AfterReturning`或`@AfterThrowing`。

在我们的示例中，我们使用`@Around`方面来展示最复杂的情​​景。 我们在执行方法之前和之后的目标方法的执行，我们还通过`ProceedingJoinPoint`对象称为原始方法。 因为这两个对象返回了不同类型，我们想要以不同的方式登录，所以我们定义了两个方面方法。

建议注释的参数是 Pointcut 字符串。 在这种情况下，这是一个简单的。 第一个`execution(* byId(..))`说，应该调用该方面，以便任何具有名称的方法的任何执行，并具有任何参数。 第二个是非常相似的，除了方法的名称是不同的。 这些是简单的 Pointcut 表达式，但在大量使用 AOP 的大型应用程序中，它们可以非常复杂。

Spring 中的 Pointcut 表达式语法主要遵循 AspectJ 使用的语法。 该表达使用**点切割指示符**（ **PCD** ）的概念，这通常是执行。 它之后是定义拦截的方法的模式。 常规格式如下：

```
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
```

除了返回类型部分，所有其他部分都是可选的。 例如，我们可以写下列：

```
execution(public * *(..))
```

这将拦截所有`public`方法。 以下表达式拦截具有以`set`字符开头的所有方法：

```
execution(* set*(..))
```

我们可以以与我们可以在 Windows 中的命令行或 UNIX shell 上使用它的方式使用`*`字符作为 Joker。 参数匹配定义有点复杂。 `(..)`表示任何参数，`()`意味着没有参数，而`(*)`意味着任何类型的一个参数。 当有更多参数时，还可以使用最后一个; 例如，`(*,Integer)`意味着有两个参数，第二个是`Integer`，我们只是不关心第一个是什么类型。

Pointcut 表达式可以更复杂，将匹配表达式与`&&`（和）和`||`（或）逻辑运算符一起加入匹配表达式，或使用`!`（否定）一元操作员。

使用`@Pointcut()`注释，配置可以定义切点，将注释放在方法上。 例如，考虑以下内容：

```
@Pointcut("execution(* packt.java.9.by.example.service.*.*(..))")  
public void businessService() {}
```

它将为任何在`packt.java.9.by.example.service`包中的任何类中实现的方法定义连接点。 这只是定义切点表达式并将其分配给名称`businessService`，由方法的名称给出。 稍后，我们可以在方面注释中引用此表达式，例如：

```
@After("businessService()")
```

请注意，使用此方法纯粹是为了其名称。 Spring 不会调用此方法。 它仅用于通过使用`@Pointcut`注释来借用它在它上定义的表达式的名称。 需要一些东西，如方法，把这个注释放在上面，而且由于方法有名字，为什么不使用它？ 春天做到了。 当它扫描配置类并查看注释时，它将其内部结构分配给方法的名称，并且当使用该名称（以及括号中的括号中困惑 MIMICING 方法调用）时，它看起来 向该名称的表达式。

AspectJ 定义其他指示符。 Spring AOP 识别它们中的一些，但它抛出`IllegalArgumentException`，因为 Spring 仅实现方法执行点切点。 另一方面，AspectJ 还可以作为示例拦截 PCD 初始化的对象创建。 除执行外，还有一些其他 PCD 可以限制执行 PCD。 例如，PCD `within`可用于限制属于某些软件包内的类的连接点，或者可以使用`@target` PCD 来限制与具有介于给出注释的对象中的方法的匹配 `(`和`)`在 Pointcut 表达式中的关键字`@target`之后。

有一个 PCD，Spring 使用不存在于 AspectJ 中。 这是一个 bean。 您可以定义包含`bean(name pattern)`的切割点表达式，以限制命名 bean 中的方法执行。 模式可以是整个名称，或者它可以是几乎所有匹配的 pcd 表达式，`*`，作为一个小丑字符。

# 动态代理的 AOP

春天 AOP，第一次呈现给 Java 程序员，似乎是魔术。 我们如何具有`classX`的变量，我们调用该对象的方法？ 相反，它在方法执行之前或之后执行某些方面，甚至在其周围拦截呼叫。

Spring 使用的技术称为动态代理。 当我们有一个实现接口的对象时，我们可以创建另一个对象 - 代理对象 - 还实现该接口，但每个方法实现都调用了一个名为 Handler 的不同对象，实现 JDK 接口`InvocationHandler`。 当在代理对象上调用接口的方法时，它将在 Handler 对象上调用以下方法：

```
public Object invoke(Object target, Method m, Object[] args)
```

此方法可以自由地执行任何操作，甚至用原始或修改的参数调用目标对象上的原始方法：

![](img/c4e38441-1a7a-4ad1-870b-07e36fec3902.png)

当我们手中没有界面时，待代理的类实现，我们不能使用 JDK 方法。 幸运的是，有广泛使用的库，例如`cglib`，它们也可以由弹簧使用，可以做类似的东西。 `Cglib`可以创建一个代理对象，该对象扩展原始类并实现其方法，以类似于 JDK 版本为接口方法的方式调用处理程序对象的调用方法。

这些技术在运行时在 Java 内存中创建和加载类，它们是非常深的技术工具。 他们是先进的主题。 在作为新手 Java 程序员时，我不说不要和他们一起玩。 毕竟，会发生什么？ Java 不是装载的枪。 然而，当您不了解某些细节或某些东西时，您不会失去兴趣的重要事项。 或第二。 或第三...继续游泳。

AOP 在 Spring 中实现通过为目标对象生成代理对象，并且处理程序调用我们在 Spring 配置中定义的方面。 这就是您无法在`final`类或`final`方法上的方面的原因。 此外，您无法在`private`或`protected`方法上配置方面。 `protected`方法原则上可以代理，但这不是一个很好的做法，因此 Spring Aop 不支持它。 同样，您无法在不是春豆的类上放置方面。 它们是由代码直接创建的，而不是通过春天创建，并且在创建对象时，没有机会返回代理而不是原始对象。 简单地，如果没有要求春天创建对象，它无法创建自定义。 我们要做的最后一件事是执行程序，并查看方面的表现如何。 我们的审核日志记录的实施非常简单。 我们使用标准日志记录，这不是真正足以实现审计日志的真实应用。 我们所做的唯一特别的事情是我们使用名称`AUDIT_LOG`标识的记录器而不是由类的名称。 这是对大多数记录框架中的记录器使用的合法使用。 尽管我们通常使用该类来识别记录器，但绝对可能使用字符串来标识记录器。 在我们的日志记录的情况下，此字符串也将在 Log 行中的控制台上打印，它将视觉上脱颖而出。

请考虑以下命令：

```
gradle -Dspring.profiles.active=production bootRun
```

如果我们使用前面的命令启动应用程序，请启动 SOAPUI 为项目开始，启动模拟服务，并执行测试，我们将看到以下日志行，即在控制台上打印的方面打印：

```
2023-10-07 23:42:07.559  INFO 74643 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2023-10-07 23:42:07.567  INFO 74643 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2023-10-07 23:42:07.626  INFO 74643 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 59 ms
2023-10-07 23:42:07.629  INFO 74643 --- [nio-8080-exec-1] p.j.b.e.m.p.auth.AuthFilter              : Partner secret is packt
2023-10-07 23:42:07.655  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : byId query is about to run
2023-10-07 23:42:07.666  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : url is to be created
2023-10-07 23:42:07.691  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : url created was http://localhost:8083/inventory/{id}
2023-10-07 23:42:07.715  INFO 74643 --- [nio-8080-exec-1] p.j.b.e.m.p.l.RestClientProductLookup    : amount {id: 123, amount: 100}.
2023-10-07 23:42:07.716  INFO 74643 --- [nio-8080-exec-1] p.j.b.e.m.p.l.RestClientProductLookup    : There items from 123\. We are offering
2023-10-07 23:42:07.716  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : url is to be created
2023-10-07 23:42:07.716  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : url created was http://localhost:8081/product/{id}
2023-10-07 23:42:07.725  INFO 74643 --- [nio-8080-exec-1] AUDIT_LOG                                : byId query was executed
```

# 概括

在本章中，我们构建了一个简单的业务应用程序，支持业务到业务交易。 我们使用 De Facto 标准企业框架-Spring 提供的功能在微服务（差不多）架构中实现了 REST 服务。 回顾这一章，这是惊人的，我们写的代码短多数才能实现所有功能，这是好的。 我们需要开发我们想要的代码越少。 这证明了框架的力量。

我们讨论了 MicroServices，HTTP，REST，JSON，以及如何使用 MVC 设计模式使用它们。 我们了解了春天的建立，有哪些模块，春天的依赖性注射如何工作，我们甚至触及了一点。 这是非常重要的，因为以及与 AOP 一起发现 Spring 如何使用动态代理对象，这是您需要调试 Spring 或使用类似解决方案的其他一些框架时非常有价值（并且有一些情况 经常使用）。

我们开始使用一个简单的浏览器测试我们的代码，但之后，我们意识到使用专业测试工具更好地测试 REST 服务，为此，我们使用 Soapui 并建立了一个简单的 REST 测试套件，并与 REST 测试步骤和嘲笑 服务。

已经了解到所有这些，没有任何东西可以使用非常现代和高级的 Java 技术（例如，当我们讨论 JDK 动态代理），Java Streams，Lambda 表达式和脚本时，这一切都不会阻止我们扩展这个应用程序 服务器端。