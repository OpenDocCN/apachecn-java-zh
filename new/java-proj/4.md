# mastermind - 创建一个游戏

在本章中，我们将开始开发一个简单的游戏。 这场比赛是 MasterMind，两个玩家。 玩家人们选择四种不同的彩色别针，其中六种不同的颜色，并将它们排列在另一个播放器中隐藏的行中。 另一个玩家试图猜测引脚的颜色及其位置。 在每次猜测中，播放器猜测匹配颜色的数量和匹配颜色和位置的引脚。 该计划将充当玩家一个和玩家二。 我们的代码将单独播放。 但是，我们仍然可以玩的是最重要的 - 代码。

这个例子足够复杂，可以加深**面向对象的**（ **OO** ）原理以及我们设计类别和模型现实世界。 我们已经使用了 Java 运行时中提供的类。 这次，我们将使用收藏品并讨论这个重要的领域。 这些类和接口广泛使用和可在 JDK 中使用，并且对专业 Java 开发人员视为语言本身并对专业的 Java 开发人员来说很重要。

这次构建工具是 Gradle。

在本章中，我们将涵盖以下内容：

*   Java 系列
*   依赖注入
*   如何评论我们的代码并创建 Javadoc 文档
*   如何创建集成测试

# 游戏

mastermind（ [https://en.wikipedia.org/wiki/mastermind_（board_game）](https://en.wikipedia.org/wiki/Mastermind_(board_game))）是一款旧游戏。 在 1970 年，每栋房屋都享用塑料版本。我在 1980 年左右发明了一个董事会作为圣诞礼物，并在基本语言中解决游戏拼图的计划是我在 1984 年左右创建的第一个节目之一 。

游戏板包含四列中几行的孔。 有六种不同颜色的塑料销可以插入孔中。 每个引脚都有一种颜色。 它们通常是红色，绿色，蓝色，黄色，黑色和白色。 有一个特殊的行，隐藏了一个玩家（猜测者）。

为了玩游戏，其中一个球员（垃圾箱）必须从一组引脚中选择四个引脚。 所选引脚应具有不同的颜色。 将引脚放置在隐藏的行中，一个接一个地放置在一个位置。

猜测者试图找出哪些颜色的位置，猜测。 每次猜测都选择四个引脚并将其排成一行。 汉德告诉猜测者处于正确位置有多少个引脚以及桌子上有多少颜色，但不是在正确的位置：

![](img/491c2b6a-34cb-49d3-88ca-fd98d2a67a51.png)

样本播放可能像这样：

1.  汉德隐藏着四个别针，颜色蓝色，黄色，白色和黑色。
2.  猜测猜测黄色，蓝色，绿色和红色。

3.  汉德告诉猜测器有两种颜色匹配，但它们都不是隐藏行中的正确位置。 汉德说这是因为黄色和蓝色是隐藏的行，但没有猜测猜测的位置。 它们实际上是交换的，但这些信息隐藏着秘密。 他们所说的就是有两种颜色匹配，没有正确的位置。
4.  下一个猜测是......

当猜测器以正确的顺序找到正确的颜色时，游戏完成。 也可以用文本符号 - `B`为蓝色，`Y`为绿色，`G`为绿色，`W`为红色，`R`为红色，以及黑色的`R`的蓝色，`R`为黑色，而且 我们在计算机上有大写和小写字母）：

```
RGBY 0/0

GRWb 0/2
YBbW 0/2
BYGR 0/4
RGYB 2/2
RGBY 4/0
```

你猜怎么着！ 这是我们将在本章中开发的程序的实际输出。

我们还播放了游戏，允许一个职位是空的。 这基本上与具有第七颜色相同。 当我们发现游戏太简单时，即使有七种颜色，我们也改变了规则，以允许颜色出现在不同的位置。 这些都是游戏的所有有效变化。

在本章中，我们将在隐藏行中使用六种颜色而无颜色重复。 其他版本的游戏对程序有点复杂，但它们基本相同，解决这些变化不会增加我们的学习体验。

# 游戏的模型

当我们使用 OO Mindset 开发一段代码时，我们尝试将现实世界建模并将真实世界对象映射到程序中的对象。 您当然具有听到的对象方向，以典型的几何物体或汽车和电机来解释组成。 就个人而言，我认为这些例子太简单，无法了解良好的理解。 他们可能对初学者有利，但我们已经在本书的第四章中。 MasterMind 游戏更好。 它比仅仅是矩形和三角形，但与电信计费应用或原子发电厂控制不一样复杂。

我们在这场比赛中的真实物体是什么？ 我们有一张桌子，我们有不同颜色的别针。 有两个 java 类，我们肯定需要。 什么是桌子？ 有四个位置的行。 也许我们将需要一排。 表将有行。 我们还需要一些隐藏秘密的东西。 这也可以是一行，并且每行也可以保存关于匹配数量的信息和多种颜色的信息。 在秘密行的情况下，此信息是显而易见的-4 和 0。

什么是别针？ 每个引脚都有颜色，通常是那样的。 销没有其他特征，除了它可以插入桌子上的孔中，但这是我们不会模拟的真实功能。 基本上，PIN 是一种颜色，没有别的。 这样，我们可以尽早消除我们的模型中的 PIN 类，甚至在我们在 Java 中创建它之前。 相反，我们有颜色。

什么是颜色？ 这是第一次难以沉浸的东西。 我们都知道颜色是什么。 由于我们的眼睛感知，它是不同频率的混合。 我们可以用不同颜色的涂料和打印等等。 在这个程序中我们没有模拟许多事情。 真的很难讲述我们代码中颜色模型的模型，因为这些功能如此明显，我们将其视为在现实生活中理所当然; 我们可以判断两种颜色是不同的。 这是我们需要的唯一功能。 为此，可以使用最简单的 Java：

```
public class Color {
}
```

如果您有两个类型的`Color`变量，则可以判断它们是否相同。 您可以使用对象标识使用表达式`a == b`比较`a`和`b`，或者您可以使用从`Object`类，`a.equals(b)`继承的`equals()`方法。 用字母编码颜色或使用`String`常量是诱人的诱人表示它们。 首先可能更容易，但后面有严重的缺点。 当代码变得复杂时，它会导致错误; 它将容易通过一些也被编码为`String`而不是颜色，而且只有单元测试可以节省一天。 当您输入错误的参数时，这比在 IDE 中抱怨的编译器更好。

当我们玩游戏时，别针在小盒子里。 我们将别针拉出盒子。 我们如何获得程序中的颜色？ 我们需要我们可以在哪里取颜色的东西。 或者以另一种方式看待它，我们需要一些可以给我们颜色的东西。 我们会称之为`ColorManager`。 现在，`ColorManager`知道我们有多少种不同的颜色，以及我们需要颜色的任何时候，我们都可以要求它。

同样，设计了设计`ColorManager`的诱惑，以便它可以通过其序列号服务。 如果我们有四种颜色，我们可以询问颜色数字 0,1,2 或 3.但是再次，它只将颜色视为整数数字，我们同意我们不会做。 我们应该找到我们需要建模游戏所需的最低功能。

要描述类的结构，专业开发人员通常使用**统一建模语言**（ **UML** ）类图。 UML 是标准化的图表，几乎完全用于可视化软件架构。 UML 中有许多图表类型来描述静态结构和程序的动态行为。 这次，我们会看一个非常简化的类图：

![](img/181e84d0-fc07-4a7d-bdb9-07ace7116fe2.png)

我们没有空间进入 UML 类图的细节。 矩形表示类，普通箭头表示当类具有另一个类类型的字段时的关系，而三角形箭头表示类别扩展另一个类。 箭头指向正在扩展的类的方向。

**game** 类包含一个秘密**行**类和**表**类。 **表**有一个 **colormanager** 类和**行**类的`List<>`。 **Colormanager** 具有第一颜色，具有**颜色**类的`Map<>`。 我们尚未讨论为什么这是设计; 我们将到达那里，图表有助于我们这样做。 **行**类基本上是**颜色**类的数组。

玩家有一个功能 - 他们必须多次猜测，直到他们找到隐藏的秘密。 要到达 **colormanager** 的模型，我们必须设计**猜测器**的算法。

当玩家发出第一猜时，任何颜色的组合就像任何其他颜色一样好。 后来，猜测应该考虑以前猜测给出的答复。 这是一种合理的方法，只尝试成为实际秘密的颜色变化。 假设所选变化是秘密，玩家选择一个变体并看起来看起来所有先前的猜测。 如果对游戏中未知秘密的这种变化的响应是相同的，那么尝试这种变化是合理的。 如果响应有任何差异，则此变更肯定不是隐藏的变化。

该游戏有更复杂的方法，具有选择与符合答案的可能猜测集中的颜色变化之一的特殊策略。 我们在此不讨论这些算法。 当我们找到可能是解决方案的颜色变化时，我们将使用那个。

要遵循这种方法，猜测程序必须生成所有可能的颜色变化，一个接一个地，并将它们与表进行比较。 猜测代码不会创建和存储前方的所有可能变化。 它必须知道它在哪里，必须能够计算下一个变异。 这假设变化的顺序。 一小段时间，让我们忘记在变体中没有颜色也可能出现两次。 简单的顺序可以与我们分类十进制数相同。 如果我们有三位数字，那么第一个是 000，下一个是 001，等等，直到 009，始终为最后位置获取下一个数字。 之后，010 来了。 我们在最后一个旁边增加了一位数字，我们再次将最后一个到 0 设置为 0。 现在，我们有 011,012 等。 你知道，我们如何计算数字。 现在，用颜色替换数字，我们只有六个，而不是十。 或者，当我们实例化`ColorManager`对象时，我们有多种。

这导致`ColorManager`的功能。 它必须执行以下两件事：

*   给呼叫者提供第一种颜色
*   给出给定颜色的下一个颜色（我们将命名方法`nextColor`）

后一个功能也应该在没有下一个颜色时发出信号。 这将使用另一个命名为`thereIsNextColor`的方法来实现。

它是启动与`is`返回布尔值的方法名称的惯例。 这将导致本次契约之后的名称 - `isThereNextColor`; 或者这个一个`isNextColor`。 这些名称中的任何一个都解释了方法的功能。 如果我问问题`isThereNextColor`，该方法将回答我`true`或`false`。 但是，这不是我们将如何使用该方法。 我们将以简单的句子说话。 我们将使用短句。 我们将避免不必要的，痛苦的表达。 我们还将以这种方式编程。 最可能，调用者将在`if`语句中使用此方法。 他们会写下列：

```
 if( thereIsNextColor(currentColor)){...}
```

They will not write this:

```
 if( isThereNextColor(currentColor)){...}
```

我认为第一个版本更具可读性，可读性首先是。 最后，但并非最不重要的是，如果你遵循旧的公约，没有人会责怪你，如果这是公司标准，那么你必须无论如何。

为此，`ColorManager`还必须创建颜色对象，并应将它们存储在有助于执行操作的结构中：

```
 1\. package packt.java189fundamentals.example.mastermind;
 2\. 
 3\. import java.util.HashMap;
 4\. import java.util.Map;
 5\. 
 6\. public class ColorManager {
 7\.     final protected int nrColors;
 8\.     final protected Map<Color, Color> successor = new HashMap<>();
 9\.     private Color first;
10\. 
11\.     public ColorManager(int nrColors) {
12\.         this.nrColors = nrColors;
13\.         createOrdering();
14\.     }
15\. 
16\.     protected Color newColor(){
17\.         return new Color();
18\.     }
19\. 
20\.     private Color[] createColors() {
21\.         Color[] colors = new Color[nrColors];
22\.         for (int i = 0; i < colors.length; i++) {
23\.             colors[i] = newColor();
24\.         }
25\.         return colors;
26\.     }
27\. 
28\.     private void createOrdering() {
29\.         Color[] colors = createColors();
30\.         first = colors[0];
31\.         for (int i = 0; i < nrColors - 1; i++) {
32\.             successor.put(colors[i], colors[i + 1]);
33\.         }
34\.     }
35\.     public Color firstColor() {
36\.         return first;
37\.     }
38\. 
39\.     boolean thereIsNextColor(Color color) {
40\.         return successor.containsKey(color);
41\.     }
42\. 
43\.     public Color nextColor(Color color) {
44\.         return successor.get(color);
45\.     }
46\. }
```

我们使用的结构是`Map`。 现在，`Map`是 Java 运行时中定义的接口，并且自从 Java 的早期版本以来已经获得。 `Map`具有键和值，以及任何键，可以轻松检索分配给键的值。

您可以在线上看到，其中`successor`变量定义（第 8 行），我们将变量的类型定义为接口，但该值是类的实例。 显然，该值不能形是界面的实例，因为这种野兽不存在。 但是，为什么我们将变量定义为一个接口？ 原因是抽象和编码实践。 如果我们需要改变我们使用的实现，因此变量类型可能仍然存在相同，并且无需在其他地方更改代码。 将变量声明为一个界面也是一个很好的做法，以便我们将没有诱惑使用在方便的界面中不可用的实现的一些特殊 API。 当真的需要时，我们可以更改变量的类型并使用特殊的 API。 毕竟，有一个原因在那里，但只是诱惑使用一些特殊的东西，因为它是受阻的。 这有助于编写更简单和更清晰的程序。

`Map`只是属于 Java 集合的 Java 运行时中定义的接口之一。 还有许多其他接口和课程。 虽然 JDK 和所有课程很多，但几乎没有人知道那里的所有课程，集合是专业开发人员应该了解的特殊区域。 在进行详细信息之前，在此代码中使用了`HashMap`，我们将概述集合类和接口。 这将帮助我们了解本程序中使用的其他集合。

# Java 系列

集合是接口和类，帮助我们存储多个对象。 我们已经看到了阵列，可以这样做。 我们在前一章中也有`ArrayList`。 我们没有详细讨论 JDK 中的其他可能性。 在这里，我们将更详细地进行更详细但留下河流和稍后章节的功能方法，我们也将避免详细信息。 这是参考书的任务。

使用集合类和接口的实现减少了编程工作。 首先，您不需要对已经存在的东西进行编程。 其次，这些类是在实现和特征中的高度优化的。 它们具有非常精心设计的 API，代码快速，使用小的内存占用。 但是，他们的代码很久以前写了很好的风格，很难阅读和理解。

当您使用 JDK 中的集合时，您更有可能与某些库互操作。 如果您可以烹饪自己的链接列表版本，则您不太可能会找到一个将对列表进行排序的现成解决方案。 如果在 JDK 标准类库中使用`LinkedList`类，则您将从 JDK 中获取从`Collections`类的现成解决方案。 值得一提的是，Java 语言本身支持这些类。 例如，您可以通过`Collection`的元素轻松迭代`for`命令的特殊语法。

JDK 中的集合包含用于定义执行某些操作（例如排序）的不同收集类型，实现类和算法的行为的接口。 多次，这些算法在不同的实现版本上工作，获得相同的结果，但为实现特定的类进行了优化。

您可以使用界面给出的 API，如果更改代码中的实现，则会获得拟合实现的优化版本。

下图显示了不同`Collection`接口之间的关系：

![](img/4b14cf4f-4c4d-4700-ba33-2fa58845876c.png)

`Collection`接口可以分为两个袋子。 一个袋子包含扩展`Collection`接口的接口，另一个袋子包含`Map`，以及延伸`SortedMap`。 这样一来，`Map`是不是一个真正的收藏，因为它不只是包含其他对象，但对作为值和键。

# 接口集合

`Collection`是界面层次结构的顶部。 此接口定义了所有实现应提供的方法，无论它们是直接实现`Set`，`SortedSet`，`Queue`，`Queue`，`Queue`或`Deque`界面。 作为`Collection`简单地说，一个实现`Collection`界面的对象只是一个对象，它定义的方法是将新对象添加到集合，从那里清除所有元素，检查一个对象 已经是集合的成员，并通过元素迭代。

有关接口的最新定义，请参阅 Java API 文档（ [https://download.java.net/java/early_access/jdk11/docs/api/](https://download.java.net/java/early_access/jdk11/docs/api/) ）。 您可以随时咨询在线 API，建议您这样做。

Java 语言本身直接支持接口。 您可以使用增强型`for`循环语法迭代`Collection`的元素，与您可以迭代的数组元素相同，其中集合应该是导致实现[htg2 的对象的表达式 ] 界面：

```
for( E element : collection ){...}
```

在前面的代码中，`E`是一个对象或`Collection`元素的通用类型。

`Collection`接口不直接在 JDK 中实现。 类实现`Collection`的子接口之一。

# 放

`Set`是一个专用集合，不能包含重复元素。 当您希望将对象添加到已经具有该对象的集合或等于实际的集合时，然后`add`方法不会添加实际对象。 `add`方法将返回`false`，表示故障。

您可以在程序中使用`Set`在您只需要检查一个唯一想要检查元素是否是集合的成员时，对象是否属于某个组。

正如我们将返回我们的程序代码，我们将看到`UniqueGuesser`类必须实现一种算法，该算法检查猜测中的颜色仅存在一次。 该算法是用于`Set`的理想候选者：

```
    private boolean isNotUnique(Color[] guess) {
        final var alreadyPresent = new HashSet<Color>();
        for (final var color : guess) {
            if (alreadyPresent.contains(color)) {
                return true;
            }
            alreadyPresent.add(color);
        }
        return false;
    }
```

代码创建一个集合，当方法启动时为空。 之后，如果之前存在，它会检查每种颜色（注意数组元素上的增强型`for`循环）。 为此，代码检查`color`是否已在集合中。 如果是在那里，猜测并不唯一，因为我们发现了至少两次的颜色。 如果`color`没有设置，那么猜测仍然可以是唯一的颜色。 为了能够检测到稍后，代码将颜色放入集合中。

我们使用的`Set`的实际实现是`HashSet`。 在 JDK 中，有许多类实现`Set`接口。 最广泛使用的是`HashSet`。 它也值得一提`EnumSet`，`LinkedHashSet`和`TreeSet`。 最后一个也实现了`SortedSet`界面，因此我们将在那里详细说明。

要了解哪些`HashSet`（及以后，`HashMap`）是以及它们的工作方式，我们将不得不讨论哈希。 它们在许多应用中发挥着非常重要和中央角色。 他们在 JDK 的引擎盖下做了工作，但程序员必须遵循一些非常重要的限制，或者真正奇怪，非常难以找到错误会使他们的生活变得悲惨。 我敢说，违反`HashSet`和`HashMap`的哈希合约是第二次最难以找到多线程问题旁边的错误的原因。

因此，在继续使用不同的收集实现之前，我们将访问此主题。 我们已经从我们的替代品中讨论了收藏品中的一个级别，现在我们甚至更深入。 我保证这是绕道的最后一个深入的水平。

# 哈希函数

哈希是将数字分配给元素的数学函数。 听起来很糟糕，不是吗？ 假设您作为大学管理员工作，您必须判断 Wilkinson 是否是您班上的学生。 您可以将名称存储在信封中的小纸上，一个用于每个起始字母。 而不是搜索 10,000 名学生，你可以看出标题为 W 的信封中的论文。这个非常简单的哈希函数将名称的第一个字母分配给名称（或信件的序号，因为我们所说的哈希 功能结果一个数字）。 这不是一个很好的哈希函数，因为它只会将一些元素（如果有的话）放入信封中表示 x，并且许多人进入 a。

良好的哈希函数返回具有类似概率的每个可能的序号。 在哈希表中，我们通常有更多的桶（前面示例中的信封）而不是要存储的元素数。 因此，当搜索元素时，很可能在那里只有一个元素。 至少这就是我们想要的。 如果单个桶中有多个元素，则称为碰撞。 良好的哈希函数尽可能少一些。

为向后兼容，JDK 中存在一个`Hashtable`类。 这是第一个版本中 Java 中的第一个哈希表实现之一，因为 Java 向后兼容，它没有被抛弃。 `Map`界面仅在 1.2 版中引入。 `Hashtable`有许多缺点，不建议使用它的使用。 （甚至名称违反了 Java 命名约定。）我们不会在本书中讨论此类。 每当我们谈论哈希表时，我们都会指的是在实现`HashSet`，`HashMap`或使用一些哈希索引表的任何其他集合中的实际阵列。

哈希表是使用散列函数的结果来索引数组的阵列。 数组元素称为桶。 哈希表实现尝试避免在同一桶中有多个元素的情况。 为此，当铲斗在一定限制上满足时，表将从时间调整大小。 当超过 70％的铲斗已经包含一个元素时，表大小加倍。 即使具有这样的阈值和阵列的调整大小，也不能保证在单个桶中将永远不会超过一个元素。 因此，实现通常不会在桶中存储单个元素，而是一个链接的元素列表。 大多数情况下，列表只包含一个元素，但是当存在碰撞时，两个或多个元素具有相同的哈希值，然后列表可以存储元素。

当调整桶阵列大小时，必须再次放置每个元件。 该操作可能需要相当长的时间，并且在此期间，各个元件在铲斗之间移动。

在此操作期间，哈希表不能可靠地使用，这可能是多线程环境中的一些问题源。 在单线程代码中，您不符合此问题。 调用`add()`方法时，哈希表（set 或 map）决定必须调整表。 `add()`方法调用调整大小方法，直到完成直到它就不会返回。 单线程代码无可能在此期间使用哈希表 - 一个和单个线程正在执行调整大小。 在多线程环境中，可能会发生一个线程调用`add()`，该线程启动调整大小，另一个线程还会在重组哈希表时调用`add()`。 在这种情况下，JDK 中的哈希表实现将抛出`ConcurrentModificationException`。

`HashSet`和`HashMap`使用存储在集合中的`Object`提供的散列函数。 `Object`类实现`hashCode()`和`equals()`方法。 您可以覆盖它们，如果您这样做，您应该以一致的方式覆盖两者。 首先，我们将看到它们是什么，然后如何持续覆盖它们。

# 等于方法

`Set`的文档说，设置不包含一对元素`e1`和`e2`，因此`e1.equals`（`e2`）。 如果`e1`和`e2`以某种方式返回`equals()`方法返回`true`。 它可能与两个相同的对象不同。 可以有两个等于的不同对象。 例如，我们可以具有颜色实现，该颜色实现具有颜色的名称，作为属性，两个颜色对象可能会返回`true`，调用其中一个方法并将参数传递在两个字符串时作为另一个。 是平等的。 `equals()`方法的默认实现是`Object`类的代码，并且如果`e1`和`e2`才能完全相同和单个对象，则返回`Object`类的代码。

它似乎是显而易见的，但我的经验表明它不能被强调，以至于对象中的`equals()`的实施必须如下：

*   **反身**：这意味着物体始终等于自身
*   **对称**（换向）：这意味着如果`e1.equals(e2)`是`true`，那么`e2.equals(e1)`也应该是`true`
*   **传递**：这意味着如果`e1.equals(e2)`和`e2.equals(e3)`，那么`e1.equals(e3)`
*   **一致**：这意味着如果对象在调用之间没有更改，则返回值不应更改

# 哈希码方法

`hashCode()`方法返回`int`。 该文档说重新定义此方法的任何类都应提供以下实现：

*   如果未修改对象，则始终返回相同的值
*   结果两个等对象的相同`int`值（`equals()`方法返回`true`）

该文档还提到了这不是一个要求导致不等于的对象的对象的不同`int`值的要求，但是可以支持散列实现集合的性能。

如果您违反了`equals()`和`hashCode()`的执行情况下的任何规则，那么使用它们可能会失败。 您可以确定`HashSet`，`HashMap`和类似的类完全调试，从而看到您将一个对象添加到一个集合，然后将其添加到集合报告中，如果它不存在，则将是一种令人眼花缭乱的体验。 但是，只有在您发现在集合中的两个对象具有不同的`hashCode()`值时，才会才有不同的`hashCode()`值，`HashSet`和`HashMap`将仅在由`hashCode()`值索引的桶中查找对象 。

将对象存储在`HashSet`或`HashMap`中也是一个常见的错误，然后修改它。 该对象在集合中，但您无法找到它，因为`hashCode()`返回不同的值，因为它被修改。 除非您知道您在做什么，否则不应修改存储在集合中的对象。

很多次，对象包含从平等的角度来看不趣的字段。 `hashCode()`和`equals()`方法应该是 idemotent 对这些字段，即使在`HashSet`中的对象或`HashMap`中也可以更改这些字段。 （IDEMPotent 意味着您可以更改所需这些字段的值，并且方法的结果不会更改。）

作为示例，您可以在维护顶点的坐标和三角形颜色的对象中管理三角形。 但是，您不关心平等的颜色，只有两个三角形位于空间中的完全相同的位置。 在这种情况下，`equals()`和`hashCode()`方法不应考虑野外颜色。 这样，我们可以画出我们的三角形; 无论颜色字段是什么，它们仍将在`HashSet`或`HashMap`中找到。

# 实现等于和哈希码

实施这些方法很简单。 由于这是一个非常常见的任务，但 IDE 支持这方法的生成。 这些方法如此捆绑在一起，即 IDE 中的菜单项并不分开; 它们允许您立即生成这些方法。

询问 IDE 生成`equals()`方法将导致类似于以下代码的内容：

```
@Override 
public boolean equals(Object o) { 
  if (this == o) return true; 
  if (o == null || getClass() != o.getClass()) return false;   
  MyObjectJava7 that = (MyObjectJava7) o;
  return Objects.equals(field1, that.field1) && 
  Objects.equals(field2, that.field2) && 
  Objects.equals(field3, that.field3); 
}
```

对于此示例，我们有三个`Object`字段名为`field1`，`field2`和`field3`。 具有任何其他类型和字段的代码看起来非常相似。

首先，方法检查对象标识。 一个`Object`始终`equals()`本身。 如果作为参数传递的引用是`null`而不是对象，或者它们是不同的类，那么此生成的方法将返回`false`。 在其他情况下，将使用`Objects`类的静态方法（注意复数）来比较每个字段。

在 Java 7 中引入了`Objects`实用类。静态方法`equals()`和`hash()`支持`Object equals`和`hashCode()`方法的覆盖。 `hashCode()`在 Java 7 之前创建相当复杂，需要使用一些难以解释代码的魔术数字来实现模数算术，而不知道它背后的数学。

这种复杂性现在隐藏在下`Objects.hash`方法后面：

```
@Override 
 public int hashCode() { 
     return Objects.hash(field1, field2, field3); 
 }
```

生成的方法只需调用`Objects::hash`方法，将重要字段传递为参数。

# hashset.

现在，我们本质上讲很多关于哈希的东西，所以我们可以勇敢地讨论`HashSet`课程。 `HashSet`是在内部使用哈希表的`Set`接口的实现。 一般来说，即它。 您将对象存储在那里，您可以查看对象是否已存在。 当需要一个`Set`实现时，几乎总是`HashSet`是选择。 几乎...

# enumset.

`EnumSet`可以包含某个枚举的元素。 回想一下，枚举是固定在`enum`本身内部声明的许多实例的类。 由于这限制了不同对象实例的数量，并且在编译期间已知该号码，因此`EnumSet`代码的实现相当优化。 在内部，`EnumSet`实现为位字段，是一个很好的选择，其中位现场操纵是选择的选择是以低级语言编程。

# linkedhashset.

`LinkedHashSet`是一个`HashSet`，也保持了它保持的元素的双链接列表。 当我们迭代`HashSet`时，元素没有保证顺序。 当修改`HashSet`时，将新元素插入其中一个桶中，并且可能是哈希表被调整大小。 这意味着元素重新排列并进入完全不同的桶。 迭代在`HashSet`中的元素中刚刚采用桶和其中的元素，因为它们是从来电者的角度任意的任意的顺序。

但是，`LinkedHashSet`使用它维护的链接列表迭代元素，并且保证迭代以在插入元素的顺序中发生。 这样，`LinkedHashSet`是一种同时是`HashSet`和`LinkedList`的复合数据结构。

# 排序集

`SortedSet`是一种界面，可保证实现它的类将以排序顺序迭代集合。 如果对象实现`Comparable`接口，则订单可以是对象的自然排序，或者`Comparator`对象可以驱动它。 当创建`SortedSet`的类实例时，此对象应可用; 换句话说，它必须是一个构造函数的参数。

# Navipableset.

`NavigableSet`将`SortedSet`接口扩展到允许您在集合中进行近距离搜索的方法。 这主要允许您搜索搜索中的元素，并且是以下任何一种：

*   少于搜索对象
*   小于或等于搜索的元素
*   大于或等于搜索的对象

# 树瓣

`TreeSet`是`NavigableSet`的实现，也是一个`SortedSet`，并且事实上，它也是一个`Set`，因为`SortableSet`文档意味着有两种类型的构造函数 有多个版本。 一个需要一些`Comparator`，而另一个需要依赖于元素的自然排序。

# 列表

`List`是一个需要实现类以跟踪元素的顺序的接口。 还有方法通过索引和迭代访问元素，由`Collection`接口定义，可保证元素的顺序。 该接口还定义了返回`Iterator`的`listIterator`方法，也实现了`ListIterator`接口。 此接口提供了让来电者在迭代并在迭代中来回迭代的同时将元素插入列表的方法。 还可以在`List`中搜索某个元素，但是接口的大多数实现提供了不良的性能，而搜索只能通过所有元素，直到找到用于搜索的元素。 有许多在 JDK 中实现此接口的类。 在这里，我们将提到两个。

# linkedlist.

这是`List`接口的双链接列表实现，它具有引用上一个和每个元素列表中的下一个元素。 该类还实现了`Deque`界面。 从列表中插入或删除元素是相当便宜的，因为它只需要调整少数参考。 另一方面，按索引对元素的访问将需要从列表的开始或从列表的末尾开始迭代; 以较靠近指定的索引元素的方式。

# 数组列表

此类是`List`接口的实现，可将引用与数组中的元素保存在一起。 这样，通过索引访问元素是相当快的。 另一方面，将元素插入`ArrayList`可能是昂贵的。 它需要将上方的插入元件上方的所有引用移动到一个索引上方，并且在原始网格中没有空间来存储新元件的情况下，它也可能需要调整背衬阵列的大小。 基本上，这意味着分配新的数组并复制所有引用。

如果我们知道阵列的成长有多大并且调用`ensureCapacity()`方法，可以优化数组的重新定位。 即使当前使用的插槽较少编号，这将调整将数组调整为作为参数提供的大小。

我的经验是，新手程序员在未考虑不同实现的算法性能的情况下使用列表时使用`ArrayList`。 我实际上并没有知道为什么`ArrayList`的普及。 程序中使用的实际实现应基于正确的决策而不是习惯。

# 队列

A `Queue`是通常存储元素以供以后使用的集合。 您可以将元素放入队列中，您可以将它们拉出。 实现可以指定给定的顺序，这可以是**首先在首先**（ **fifo** ）或**最后一次**（ **lifo** ） 或基于优先级的排序。

在队列中，您可以调用`add()`方法添加元素`remove()`以删除头部元素，以及`element()`方法访问头部元素而不从队列中删除它。 当存在容量问题时，`add()`方法将抛出异常，并且无法将元素添加到队列中。 当队列为空时，没有头部元素，`element()`和`remove()`方法抛出异常。

由于例外只能用于特殊情况，并且调用程序可以在代码的正常过程中处理这些情况，所有这些方法都有一个刚刚返回某些特殊值信令情况的版本。 代码代替`add()`，呼叫者可以调用`offer()`以提供用于存储的元素。 如果队列无法存储元素，则会返回`false`。 同样，`peek()`将尝试访问头部元素或返回`null`如果没有，并且`poll()`将删除并返回头部元素或者如果没有，则返回`null`。

请注意，这些方法返回`null`只是使情况模糊，例如`LinkedList`，允许`null`元素。 切勿将`null`元素存储在队列中，否则您将无法判断队列是否为空，或者只是第一个元素是`null`。

# 和

`Deque`是一个是双重队列的接口。 它将`Queue`接口扩展到允许访问队列的两端以添加，查看和从两端删除元素的方法。

对于`Queue`界面，我们需要六种方法。 `Dequeue`具有两个可管理的端部，需要 12 种方法。 而不是`add()`，我们有`addFirst()`和`addLast()`。 同样，我们可以使用`offerFirst()`和`offerLast()`，`peekFirst()`和`peekLast()`和`pollFirst()`和`pollLast()`。 出于某种原因，在`Queue`接口中实现`element()`方法的功能的方法是`Dequeue`接口中的`getFirst()`和`getLast()`。

由于此接口扩展了`Queue`界面，因此可以使用定义的方法来访问队列的头部。 除此之外，此接口还定义了`removeFirstOccurrence()`和`removeLastOccurrence()`方法，可用于删除队列内的特定元素。 我们无法指定要删除的元素的索引，我们也无法访问基于索引的元素。 `removeFirst()` / `LastOccurrence()`的参数是要删除的对象。 如果我们需要此功能，我们也可以使用`Deque`即使我们从队列的一端添加和删除元素。

为什么`Deque`中有这些方法，而不是`Queue`？ 这些方法与`Deque`的双向相比无关。 原因是在释放后无法将方法添加到界面。 如果我们向接口添加方法，我们会打破向后兼容性，因为实现该界面的所有类都必须实现新方法。 Java 8 引入了缓解此约束的默认方法，但`Queue`接口在 Java 1.5 中定义，并且在 Java 1.6 中定义了`Deque`接口。 当时没有办法将新方法添加到已存在的接口。

# 地图

a `Map`对键和值。 如果我们从`Collection`的角度来接近`Map`，那么`Map`是键/值对的集合。 您可以将键/值对放入`Map`，您可以根据密钥获取值。 密钥以与`Set`中的元素相同的方式是唯一的。 如果查看`Set`界面的不同实现的源代码，则可能会看到它们中的一些是在`Map`实现周围的包装器，其中值只是丢弃的值。

该接口定义了很多方法。 两个最重要的方法是`put()`和`get()`。 `put(key,value)`方法可用于在地图中存储键/值对。 如果有一对具有`equals()`的关键字我们要在该对中设置的键，则旧值将被替换。 在这种情况下，`put()`的返回值是旧对象，否则，它返回`null`。 请注意，返回的`null`值还可以指示与密钥相关联的值是`null`。

`get(key)`方法返回使用指定键存储的值。 同样，该方法`equals()`用于检查所提供的密钥的平等和地图中使用的键的平等。 如果映射没有提供作为参数的密钥的任何关联值，则此方法返回`null`。 这也可能意味着与密钥相关联的实际值是`null`参考。

为了区分两种情况，当没有存储给定键的值并且存储的值`null`时，还有另一个命名的方法`contains()`。 如果此映射包含指定键的映射，则此方法返回`true`。

`Map`接口中有许多其他方法可以在 JDK 的 Javadoc 文档中找到。

使用`Map`简单诱人。 许多语言，例如 Python，Go，JavaScript 和 Perl，支持语言级别的此数据结构。 但是，当阵列足够时，使用`Map`是我多次看到的不良练习，尤其是脚本语言。 Java 不容易发生那个新手程序员错误，但你可能仍然在你想使用`Map`的情况下，仍然有更好的解决方案。 这是一种总体规则，即应该使用最简单的数据结构，这足以实现算法。

# Hashmap.

`HashMap`是`Map`接口的基于哈希表的实现。 由于实现使用哈希表，因此`get()`和`put()`方法通常与地图中的实际元素数一起执行非常快速，常数和时间。 如果地图大小的增长和表元素的数量不足以将元素符合符合人体工程的，将新元素置于此类地图中可能强制实现调整底层数组的大小。 在这种情况下，必须在新的尺寸阵列中再次放置在数组中的每个元素。 在这些情况下，`put()`操作可能会消耗大量时间，与地图中的元素数成比例。

当要存储在此映射中的元素时，则在密钥对象上调用`hashCode()`方法，返回值用于确定底层哈希表的桶应存储新元素。 桶包含一个简单的二叉树结构。 如果桶为空，则存储此结构中的元素就像将元素直接存储在桶中一样简单。 另一方面，当两个或更多个元素具有相同的`hashCode()`值时，它们也可以存储在同一桶中的地图中，但效率是有点劣化。

由于`hashCode()`值的可能碰撞，`get()`或`put()`方法呼叫所需的时间可以是比其他方式长的 WEE 位。

此实现`Map`界面是 Java 程序中最常使用的; 实现是微调的，可以配置使用。 最简单的方法是创建一个`HashMap`调用默认构造函数。 如果我们碰巧知道地图上有多少元素，那么我们可以指定它，将`int`传递给构造函数。 在这种情况下，构造函数将分配一个阵列，该阵列具有不小于我们所需的容量的尺寸，并且尺寸是两个的功率。

有一个第三构造函数，我们可以定义`float`负载因子。 负载因子的默认值为`0.75`。 当地图中的元素数量大于散列表大小的大小乘以负载因子时，则下一个`put()`呼叫将加倍底层哈希表的大小。 这种早期调整大小试图避免碰撞变得过于频繁。 如果我们将某些特殊类的实例存储在我们确信`hashCode()`非常好的情况下，那么我们可以将负载系数设置为更近的`1.0`。 如果我们不在乎速度太多，我们不希望底层哈希表会增加太多，我们甚至可以使用大于`1.0`的值。 但是，在这种情况下，我会考虑使用一些不同的数据结构。

在大多数情况下，我们需要`Map`时的选择是`HashMap`。 通常，我们不应该真正担心这些实施细节。 但在一些罕见的情况下，当内存使用或性能降级时，我们应该了解我们使用的地图的实施复杂性。

# IdentityHashMap.

`IdentityHashMap`是一个特殊的`Map`，它实现了`Map`接口本身，但事实上，该实施违反了文档定义的`Map`接口的合同。 它是为了充分理由。 该实现使用哈希表作为`HashMap`，但是要决定桶中找到的键的平等与作为 GET 方法的参数提供的关键元素进行比较，但它使用`Object`参考（`==`运算符） 而不是方法`equals()`，这是通过`Map`界面的文档所必需的。

当我们希望将不同的`Object`实例区分为彼此等于彼此的键时，使用此实现是合理的。 使用此实施的性能原因几乎是一个错误的决定。 此外，请注意，JDK 中没有`IdentityHashSet`实现。 可能，这样的收藏很少使用它在 JDK 中的存在会造成更大的伤害，诱人的新手程序员滥用。

# 依赖注入

在上一章中，我们简要讨论过 **Depe** **Ndency 注射**（ **DI** ）。 在继续我们的示例之前，我们将更详细地挖掘它。 我们将这样做，因为编程结构我们将在这一原则上创造大量建立。

对象通常不像自己工作。 大多数时候，实现取决于其他类的服务。 例如，当我们想向控制台写一些东西时，我们使用`System`类，我们通过该对象使用`final`字段`final`和`println()`方法。 另一个例子是，当我们管理猜测表时，我们需要`Color`对象和`ColorManager`。

写入控制台时，我们可能无法实现依赖性，因为类是 jdk 类库的一部分，一直在提供，我们需要做的就是写`System.out.println()`。 它可能是很明显的，因为我们有腿。 无论这看起来多么简单，我们都依赖于我们的腿走路，同样，当我们想写到控制台时，我们依靠`System`课程。

当我们刚写`System.out.println()`时，依赖关系已连接到代码中。 除非更改代码，否则我们无法在其他地方发送输出。 这不是非常灵活，并且在许多情况下，我们需要一个可以使用不同的输出，不同的颜色管理器或不同类型的任何服务的解决方案所取决于所取得的。

第一个步骤要做，具有一个字段，该字段具有对提供我们类服务的对象的引用。 在输出的情况下，该字段的类型可以是`OutputStream`类型。 如果我们在代码中使用此字段而不是直接连接到代码的内容，那么我们有可能使用不同的依赖项。 例如，我们可以将输出发送到文件中而不是控制台。 我们不需要更改写作发生的代码。 我们要做的就是为在对象创建期间为引用`OutputStream`的字段分配不同的值。

这已经是下一步，即，此字段如何获得该值。

其中一个解决方案是使用 DI。 在这种方法中，一些外部代码准备了依赖关系并将它们注入对象。 当发出第一次调用该类的方法时，所有依赖项都已填充并准备好使用。

在这种结构中，我们有四个不同的演员：

*   `client`对象是在此过程中获取注入的`service`对象的对象
*   `service`对象或对象被注入`client`对象
*   注射器是执行注入的代码
*   接口定义客户端需要的服务

如果从客户端代码移动`service`对象的创建逻辑，则代码变短且更清晰。 `client`类的实际竞争力难以涵盖`service`对象的创建。 例如，a `Game`类包含`Table`实例，但游戏不对创建`Table`负责。 它被赋予它与它一起工作，就像我们模型的现实生活中一样。

创建`service`对象有时像发出`new`运算符一样简单。 有时，`service`对象还取决于其他`service`对象，也取决于 DI 的过程中的客户端。 在这种情况下，`service`对象的创建可能是大量线条。 依赖关系的结构可以以声明方式表达，所述声明方式表达了哪个`service`对象需要其他`service`对象，以及还要使用服务接口的实现。 DI 注射器与此类声明性描述合作。 当需要一个需要`service`对象的对象本身需要其他`service`对象时，注射器使用符合声明性描述的实现以适当的顺序创建服务实例。 喷射器传输所有依赖关系，并创建依赖性的传递闭合图。

所需依赖项的声明性描述可以是 XML，或者甚至可以使用特殊设计的 FLUENT API（ [HTTPS://blog.jooq.org/2012/甚至可以是 Java 本身而开发的特殊语言。 01/05 / the-java-fluent-api-designer-crash-course /](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/) ）。 XML 首先用于 DI 注射器。 以后， **groovy-**基于域的**特定语言**（ [https://martinfowler.com/books/dsl.html](https://martinfowler.com/books/dsl.html) ）作为 java- 流利的 API 方法。 我们只使用最后一个，它是最现代化的，我们将使用 **spring** 和 **guice** **di** 容器，因为它们是最良好的 已知的注射器实现。

# 实施游戏

没有例子的收藏很无聊。 幸运的是，我们有我们的游戏，我们使用一些集合类以及我们将在本章中审查的其他方面。

# COLORMANAGER.

我们跳进池中，汇集了从`ColorManager`类的实现中填充了集合类。 让我们用现在对我们有趣的课程刷新我们的内存 - 构造函数：

```
package packt.java189fundamentals.example.mastermind;

import java.util.HashMap;
import java.util.Map;

public class ColorManager {
    final protected int nrColors;
    final protected Map<Color, Color> successor = new HashMap<>();
    private Color first;

    public ColorManager(int nrColors) {
        this.nrColors = nrColors;
        createOrdering();
    }

    protected Color newColor(){
        return new Color();
    }

    private Color[] createColors() {
        Color[] colors = new Color[nrColors];
        for (int i = 0; i < colors.length; i++) {
            colors[i] = newColor();
        }
        return colors;
    }

    private void createOrdering() {
        Color[] colors = createColors();
        first = colors[0];
        for (int i = 0; i < nrColors - 1; i++) {
            successor.put(colors[i], colors[i + 1]);
        }
    }
    // ...
}
```

我们使用`HashMap`将颜色保持在有序列表中。 起初，`HashMap`的选择似乎很奇怪。 非常真实的是，在编码`ColorManager`期间，我也考虑了`List`，这似乎是一个更明显的选择。 如果我们有一个`List<Color> colors`变量，那么`nextColor`方法将是这样的：

```
public Color nextColor(Color color) { 
     if (color == Color.none) 
         return null; 
     else 
         return colors.get(colors.indexOf(color) + 1); 
 }
```

构造函数将更简单，如以下代码所示：

```
final List<Color> colors = new ArrayList<>(); 

     public ColorManager(int nrColors) { 
         this.nrColors = nrColors; 
         for (int i = 0; i < nrColors; i++) { 
             colors.add(new Color()); 
         } 
         colors.add(Color.none); 
     } 

     public Color firstColor() { 
         return colors.get(0); 
     }
```

为什么我选择更复杂的解决方案和更复杂的数据结构？ 原因是表现。 当调用`nextColor()`方法时，列表实现首先查找检查列表中的所有元素的元素，然后获取下一个元素。 时间与颜色的数量成比例。 当我们的颜色数量增加时，时间也会增加，只需获得一个有一个。

同时，如果我们专注于我们想要实施的实际方法，而不是我们想要解决的任务的口头表达（以排序的顺序获取颜色），那么我们将轻松来 结论`Map`更合理。 我们需要的是一个`Map` - 一个元素，我们想要另一个与我们拥有的元素相关。 键和值也是`Color`。 使用`HashMap`，获取下一个元素实际上是恒定的时间。 此实现可能比基于`ArrayList`更快。

问题是它只是更快的问题。 当您考虑重构代码具有更好的性能时，应始终基于测量值。 如果您实现只有思考的代码更快，练习显示，则会失败。 在最佳情况下，您将优化在应用程序服务器设置期间快速快速窃取的代码并运行。 同时，优化的代码通常不太可读。 某事的东西。 优化永远不应该过早完成。 首先是可读性的代码。 然后，评估性能，如果表现性能，配置文件的问题，并优化了整体性能最多的代码。 微优化不会有所帮助。 我是否进行过早优化选择`HashMap`实现而不是`List`？ 如果我实际使用`List`实际实现了代码，然后重新转换，则是。 如果我正在考虑`List`解决方案，然后它来找我，`Map`解决方案更好而没有先前的编码，那么我没有。 随着收集更多的经验，这种考虑将变得更容易。

# 班上的颜色

我们已经查看了类代码的代码，它是世界上最简单的类。 实际上，正如它在 Packt 代码存储库中，代码有点复杂：

```
/**
 * Represents a color in the MasterMind table.
 */
public class Color {
    /**
     * A special object that represents a
     * value that is not a valid color.
     */
    public static final Color none = new Color();
}
```

我们的特殊颜色常量命名为`none`，我们使用它来发出类型`Color`的引用，但不是有效的`Color`。 在专业开发中，我们使用了很长时间的`null`值来发出无效的参考，而且因为我们向后兼容，我们仍然使用它。 但是，建议尽可能避免`null`参考。

Tony Hoare（ [https://en.wikipedia.org/wiki/tony_hoare](https://en.wikipedia.org/wiki/Tony_Hoare) ），他们在 1965 年发明了`null`参考资料，一旦这是一个错误，这是 IT 行业成本数十亿美元的错误 。

`null`值的问题是它需要远离类的控制，因此打开封装。 如果方法在某些情况下返回`null`，则严格要求呼叫者检查无效并按照该呼叫者。 例如，您无法在`null`引用上调用方法（至少在 java 中，您不能在 java 中执行此操作），并且无法访问任何字段。 如果方法返回，则对象的特殊实例这些问题不太严重。 如果呼叫者忘记检查特殊返回值并在特殊实例上调用方法，则调用的方法仍然有可能实现某些例外或错误处理。 该类具有封装的控件，可以抛出一个特殊的例外，可能会通过呼叫者提供有关由呼叫者未检查特殊值的程序性错误引起的错误的更多信息。

# javadoc 和代码评论

我们在此之前呈现的其他区别在此之前和列表之间。 这是评论代码。 代码注释是程序的一部分，它被忽略，并由编译器过滤。 这些评论仅适用于维护或使用代码的人。

在 Java 中，有两种不同的评论。 括在`/*`和`*/`之间的代码是注释。 评论的开始和结尾不需要在同一条线上。 其他类型的注释以`//`字符开头，并在行的末尾结束。

要记录代码，可以使用 Javadoc 工具。 javadoc 是 JDK 的一部分，它是一个特殊的工具，它读取源代码，并提取关于与`/**`字符开头的类别，方法，字段和其他实体的 HTML 文档。 文档将以格式化的方式包含 Javadoc 注释，以及从程序代码中提取的信息。

当您通过方法调用或类名将鼠标移动或类名将鼠标移动时，文档也显示为 IDE 中的在线帮助。 javadoc 评论可以包含 HTML 代码，但通常不应该。 如果真的需要，您可以使用`<p>`启动新段落或`<pre>`标记，以将一些预格式化的代码样本包含在文档中，但没有任何东西给出了真正的好处。 文档应尽可能短，并包含尽可能少的格式。

有些标签可以出现在 javadoc 文档中。 当您开始键入 Javadoc 作为`/**`时，这些是预先填写的，然后按*输入*。 这些都在评论中，并以`@`字符为开头。 有一个预定义的标签 - `@author`，`@version`，`@param`，`@return`，`@exception`，`@see`，`@see`，`@serial`和`@deprecated`。 最重要的标签是`@param`和`@return`。 它们用于描述方法参数和返回值。 虽然我们不在那里，让我们从`Guesser`课程中偷看`guessMatch`方法：

```
/**
 * A guess matches if all rows in the table matches the guess.
 *
 * @param guess to match against the rows
 * @return true if all rows match
 */
private boolean guessMatch(Color[] guess) {
    for (Row row : table.rows) {
        if (!row.guessMatches(guess)) {
            return false;
        }
    }
    return true;
}
```

参数的名称是由 IDE 自动生成的。 当您创建文档时，写入有意义的内容而不是 Tautology。 很多次，新手程序员都感受到写 Javadoc 的冲动，并且必须撰写关于参数的东西。 他们创建了这样的文档：

```
* @param guess is the guess
```

真的吗？ 我永远不会猜到。 如果您不知道该写入什么以记录参数; 可能会发生，您正在选择优秀参数的名称。

我们前面示例的文档将如下所示：

![](img/702fd60b-15cf-4d7c-a4fd-dd4b2b6add2d.png)

专注于方法，类和界面以及如何使用 javadoc。 不要解释它在内部工作原理。 javadoc 不是算法或编码解释的地方。 它的目标是帮助使用代码。 但是，如果有人恰好解释方法如何工作，那就不是灾难。 可以轻松删除评论。

但是，存在的注释比没有差：无效的过时的文档不再有效。 当元素的合同发生了变化时，但文件不遵循更改，并且误导想要调用方法，界面或类的用户，它将面临严重的错误，并且将是无能的。

从现在起，JavaDoc 注释将不被打印上市拯救树木，电子在电子书版本，但他们在那里的资源库，可以参考一下。

# 排

现在，当我们需要`ColorManager`时，我们有一个`Color`甚至是实例。 这是在`Row`对象中存储`Color`对象的时间。 `Row`类有点更长，但不是太复杂。 我们在本节中查看小片段中的代码，其中包含以下内容：

```
package packt.java189fundamentals.example.mastermind;

public class Row {
    final Color[] positions;
    protected int matchedPositions;
    protected int matchedColors;
```

`Row`包含三个字段。 一个是`positions`阵列。 阵列的每个元素是`Color`。 `matchedPositions`是匹配的位置数，而`matchedColors`是匹配隐藏行中颜色但在隐藏行中的相同位置匹配的颜色数：

```
public static final Row none = new Row(Guesser.none);
```

`none`是包含一个特殊的`Row`实例的常量，我们将在我们使用的任何地方使用`null`。 构造函数获取应在行中的数组中的颜色：

```
public Row(Color[] positions) {
    this.positions = Arrays.copyOf(positions, positions.length);
}
```

构造函数使原始数组的副本。 这是我们将检查一点点的重要代码。 让我们重新开始，Java 通过价值传递参数。 这意味着当您将数组传递给方法时，您将传递包含阵列的变量的值。 但是，Java 中的数组是一个对象以及其他任何东西（除了`int`之类的基元除外）。 因此，变量包含的是对往往是阵列的对象的引用。 如果更改数组的元素，则实际上更改原始数组的元素。 数组引用在参数传递时复制，但数组本身和元素不是。

`java.util.Arrays`实用程序类提供了很多有用的工具。 我们可以轻松编码 Java 中的阵列复制，但为什么重新发明轮子？ 除此之外，阵列是一个连续的存储器区域，可以使用低级机器代码从一个地方与一个地方进行非常有效地复制。 我们调用的`copyOf`方法调用`System.arraycopy`方法，它是一种本机方法，因此执行本机代码。

请注意，在大阵列的情况下，无法保证`Arrays.copyOf`调用本机实现，并且这将是非常快的。 我正在测试和调试的非常版本正在这样做，我们可以假设一个好的 JDK 做一些类似，有效的东西和快速。

在我们复制数组后，如果调用者修改传递给构造函数的数组，则这不是问题。 该类将引用将包含相同元素的副本。 但是，如果调用者更改存储在阵列中的任何对象（而不是阵列中的引用，而且由数组元素引用的对象本身），则修改相同的对象。 `Arrays.copyOf`不复制数组引用的对象，只有数组元素。 在我们的情况下，我们有`Color`阵列中的实例，因为此类根本没有字段，它本质上是不可变的，没有任何实例可以更改。

该行与颜色一起创建，因此我们使用了`Color`数组的`final`字段命名为`positions`。 但是，当创建行时，匹配可能无法知道; 因此，它们不能是`final`。 其中一个玩家创建了`Row`，然后，之后，其他玩家将稍后讲述两个`int`值。 我们需要一个设置这些字段。 但是，我们不会为两个值创建两个定居者，因为它们始终在游戏中的同时定义：

```
public void setMatch(int matchedPositions, int matchedColors) {
    if (matchedColors + matchedPositions > positions.length) {
        throw new IllegalArgumentException(
                "Number of matches can not be more that the position.");
    }
    this.matchedColors = matchedColors;
    this.matchedPositions = matchedPositions;
}
```

`setMatch`方法不仅设置值，还可以检查值是否一致。 两个值的总和不能超过列的数量。 此检查可确保使用`Row`类的 API 的来电者不使用它不一致。 如果此 API 仅从我们的代码中使用，则此断言不应成为代码的一部分。 在这种情况下，一个良好的编码风格将确保使用单元测试不一致地呼吸该方法。 当我们创建要在我们的控制中使用 API​​时，我们应该检查使用是否一致。 未能这样做，当使用不一致时，我们的代码可能表现得很奇怪。 当呼叫者设置与不匹配任何可能猜测的值的匹配时，游戏可能永远不会完成，并且呼叫者可能很难弄清楚发生了什么。 这可能需要我们代码的调试执行。 这不是库的用户的任务。 始终尝试创建不需要从 API 的消费者调试的代码。

如果我们在这种情况下抛出异常，则程序停止错误的位置。 无需调试库。

以下方法决定猜测作为参数的猜测匹配实际行：

```
public boolean guessMatches(Color[] guess) {
    return nrMatchingColors(guess) == matchedColors &&
            nrMatchingPositions(guess) == matchedPositions;
}
```

此方法检查行中猜测的答案如果当前猜测是隐藏的行中，则可以有效。 实施相当简单，简单。 如果颜色匹配的数量和匹配的位置匹配的数量与行中的数字相同，则猜测符合行。 当然，在实现`nrMatchingColors()`和`nrMatchingPositions()`方法的情况下，有一些额外的代码，但这种方法确实很简单。 不要害羞地写简短的方法！ 不要认为一个基本上包含一个陈述的单行方法是无用的。 无论我们使用此方法，我们还可以编写表达式，它是在返回声明之后的表达式，但我们没有两个原因。 第一和最重要的原因是该算法决定行与猜测相匹配，属于类`Row`的实现。 如果实现更改，则在此处更改代码的唯一位置。 另一个原因也很重要，这是可读性。 在我们的代码库中，我们从`abstract class Guesser`调用此方法。 它包含一个`if`语句，具有以下表达式：

```
if (!row.guessMatches(guess)) {
```

是否以下列方式更可读？

```
if( !(nrMatchingColors(guess) == matchedColors && nrMatchingPositions(guess) ==
matchedPositions)) {
```

我肯定的是大多数程序员都了解第一个版本的意图更容易。 我甚至建议实施`doesNotMatchGuess`方法来提高代码的可读性：

```
public int nrMatchingColors(Color[] guess) {
    int count = 0;
    for (int i = 0; i < guess.length; i++) {
        for (int j = 0; j < positions.length; j++) {
            if (i != j && guess[i] == positions[j]) {
                count++;
            }
        }
    }
    return count;
}
```

匹配颜色的数量是在行中和猜测中出现的颜色的数量，但不在同一位置。 如果没有颜色在隐藏行中出现两次，则定义以及我们如何计算它，这是相当简单和明确的。 如果颜色可能在隐藏行中多次出现，则此实现将在隐藏行中显示的猜测中的猜测中的所有颜色的所有发生。 例如，如果我们有一个隐藏的`RRGB`行和猜测是`bYRR`，则计算会说 4.玩家之间的协议是如何计算在这种情况下。 重要方面是他们使用相同的算法，这在我们的情况下应该是真的，因为我们会要求该程序扮演两个玩家，而且因为我们在章节开始时没有颜色可以出现不止一次的章节 隐藏的行。

因为我们将自己编制代码，我们可以相信它不会作弊。

计算可以的颜色，也可以在它们应该是它们的位置，甚至更简单：

```
public int nrMatchingPositions(Color[] guess) {
    int count = 0;
    for (int i = 0; i < guess.length; i++) {
        if (guess[i] == positions[i]) {
            count++;
        }
    }
    return count;
}
```

此类中的最后一个方法是返回列数的方法：

```
public int nrOfColumns() {
    return positions.length;
}
```

此方法讲述`Row`中的列数。 在控制整个游戏流程的`Game`类中需要此方法。 由于此类与`Row`相同的包，它可以访问现场位置。 我创建了代码以获取列为`row.positions.length`的列数。 但后来，我在第二天读了代码并告诉自己 - 这是丑陋和不可读的！ 我对此感兴趣的不是一些神秘的位置; 这是列数。 并且列数是`Row`课程的责任，而不是任何其他类的业务。 如果我开始将位置存储在`List`中，它没有`length`（它有方法`size()`），它是`Row`的唯一责任，不应影响任何其他代码。 因此，我创建了`nrOfColumns()`方法来改进代码并具有正确的封装。

`Row`类具有另一个构造函数，可从另一个克隆一行：

```
protected Row(Row cloneFrom) {
    this(cloneFrom.positions);
    setMatch(cloneFrom.matchedPositions, cloneFrom.matchedColors);
}
```

这是通过扩展`PrintableRow`类来使用的。 此类使得在测试过程中可能会打印出表，猜测，以及游戏的方式。

`PrintableRow`类看起来像这样：

```
package packt.java189fundamentals.example.mastermind;

public class PrintableRow extends Row {
    public PrintableRow(Row row) {
        super(row);
    }

    public Color position(int i) {
        return positions[i];
    }

    public int matchedPositions() {
        return matchedPositions;
    }

    public int matchedColors() {
        return matchedColors;
    }
}
```

这些方法的第一个版本在`Row`类中，然后移动到新的`PrintableRow`类。 在重构期间，我曾经剪切和粘贴了 IDE 的功能。 我也可以使用重构支持，可以直接从一个类移动到另一个类的方法。 有一个 IDE 功能，不应使用 - 复制和粘贴。

当您编写代码时，请不要使用副本和粘贴。 您可以使用剪切和粘贴来移动码片段。 危险在于复制粘贴使用。 许多开发人员声称他们使用实际拷贝和粘贴不是复制粘贴编程。 他们的推理是它们如此改变粘贴的代码，以至于它与原始代码几乎没有任何关系。 真的吗？ 在这种情况下，为什么您开始修改时需要复制的代码？ 为什么不从头开始？ 这是因为如果您使用 IDE 的副本和粘贴功能，那么，无论如何，您都可以复制粘贴编程。 面对它，不要试图欺骗自己。

`PrintableRow`非常整洁，并将产出问题与核心功能分开。 当您需要一个实例时，它不是一个问题，你有一个`Row`实例已经在手中。 构造函数基本上将克隆原始类并返回可打印版本，调用父类中定义的克隆构造函数。 在此类的开发过程中，我在`PrintableRow`类中创建了克隆代码。 但是，此功能放置违反封装。 即使`PrintableRow`扩展了`Row`类，也不是知道父类的内部工作不是一个永恒的罪，如果可能的话，最好不要依赖它。 因此，新`protected`构造函数在父类中创建并从孩子中调用。

一段代码从未完成，永远不会完美。 在专业环境中，程序员往往在足够好时倾向于抛光代码。 没有代码不能更好，但有截止日期。 该软件必须传递给测试人员和用户，并且必须用于帮助经济。 毕竟，这是专业开发人员的最终目标 - 有一个支持业务的代码。 从不运行的代码都不值得。 我不希望你认为这里为这里提供的例子是完美的上面创造了完美的。 我甚至不敢说他们现在在这本书的第二版中完美。 原因是（你仔细阅读了吗？）因为它们并不完美。 正如我所说，代码永远不会完美。 当我第一次创建`Row`时，它包含在内部类中的打印方法。 我不喜欢它。 代码臭。 所以，我决定将功能移动到`Row`类。 但是，我仍然不喜欢解决方案。 然后，我上床睡觉，睡觉，工作，几天后回到了它。 我无法创建的那一天似乎显而易见 - 这些方法必须转移到子类。 现在是另一个困境。 我应该介绍这个最终解决方案，还是应该在这里有不同的版本？ 在某些情况下，我只会介绍最终版本。 在其他情况下，如此，有些东西可以从发展步骤中学到。 在这些情况下，我不仅提出了代码，而且还存在其对创建的一部分。 我承认，有时候，我创造了一天后让我为自己肢解的代码。 谁没有？

# 桌子

MasterMind 表是一个简单的类，只有一个非常简单的功能：

```
public class Table {
    final ColorManager manager;
    final int nrColumns;
    final List<Row> rows;
    public Table(int nrColumns, ColorManager manager) {
        this.nrColumns = nrColumns;
        this.rows = new LinkedList<>();
        this.manager = manager;
    }
    public void addRow(Row row) {
        rows.add(row);
    }
}
```

有一件事要提到，这没什么好的，而是值得重复。 `rows`变量被声明为`final`，它获得了构造函数中的值。 这是一个`List<Row>`变量。 它是`final`的事实意味着它在寿命期间将持有相同的列表对象。 列表的长度，成员和其他功能可能并将更改。 我们将为此列表添加新行。 最终对象变量引用一个对象，但它不保证对象本身是不可变的。 它只是不改变的变量。

当您对代码审查并向您的同事解释为什么课程时，并且您发现自己开始解释*这个类很多很简单*多次，这意味着代码很好。 嗯，在其他方面，这可能似乎是错误的，但至少课堂的粒度似乎是好的。

# 猜测

`Guesser`抽象类和`UniqueGuesser`和`GeneralGuesser`子类是程序中最有趣的类。 他们实际上执行了比赛核心的任务。 鉴于一个`Table`用一个隐藏的行，猜测程序必须创建新的猜测。

为此，`Guesser`需要在创建时获取`Table`。 这被作为构造函数参数传递。 它应该实现的唯一方法是`guess`，它基于表格和实际状态返回新的猜测。

我们希望实现一个猜测，假设隐藏行中的所有颜色都不同，也是一个没有提出这种假设的颜色; 我们将实施三个课程来执行此操作。 `Guesser`是一个抽象类，只实现独立于假设的逻辑。 这些方法将由实际实现（HTG1]和`GeneralGuesser`继承，该方法分别实现猜测功能，如果每种颜色分别在行中或不是唯一的行。

让我们完成课程的实际代码：

```
package packt.java189fundamentals.example.mastermind;

public abstract class Guesser {
    protected final Table table;
    private final ColorManager manager;
    protected final Color[] lastGuess;
    public static final Color[] none = new Color[]{Color.none};

    public Guesser(Table table) {
        this.table = table;
        this.lastGuess = new Color[table.nrColumns];
        this.manager = table.manager;
    }
```

猜测者的状态是它的最后一个猜测。 虽然这是在表的最后一行中，但它更像是猜测者的内部问题。 猜测者拥有所有可能的猜测，一个接一个地; `lastGuess`是最后一次离开的地方，它应该在再次调用它时从那里继续。

在此类中的`none`只是我们尝试使用而不是`null`的对象，每当我们需要返回对`Guess`的引用但不是真的猜测的东西。

设置第一猜测非常取决于颜色唯一性的假设：

```
abstract protected void setFirstGuess();
```

在不允许隐藏行包含任何内容的情况下，第一次猜测不应包含重复的颜色，因此此类中的方法是抽象的。

下一个方法是在具体类中覆盖的内部：

```
protected Color[] nextGuess() {
    if (lastGuess[0] == null) {
        setFirstGuess();
        return lastGuess;
    } else {
        return nextNonFirstGuess();
    }
}
```

`nextGuess`方法是一个内部的内部，它刚刚猜测，只要我们订购可能的猜测。 它没有检查`Table`的任何东西; 它只在没有思考的情况下产生下一个猜测。 关于我们如何执行第一次猜测以及我们如何进行连续猜测的执行情况。 因此，我们以不同的方法实现这些算法并从此处调用它们。

`nextNonFirstGuess`方法表示特殊情况下的下一个猜测，当猜测不是第一个时：

```
private Color[] nextNonFirstGuess() {
    int i = 0;
    boolean guessFound = false;
    while (i < table.nrColumns && !guessFound) {
        if (manager.thereIsNextColor(lastGuess[i])) {
            lastGuess[i] = manager.nextColor(lastGuess[i]);
            guessFound = true;
        } else {
            lastGuess[i] = manager.firstColor();
            i++;
        }
    }
    if (guessFound) {
        return lastGuess;
    } else {
        return none;
    }
}
```

回顾几页，我们详细介绍了算法如何工作。 我们陈述了这种工作方式非常像我们用十进制数字的方式。 到目前为止，您有足够的 Java 知识和编程技巧，以了解方法所做的。 知道为什么要这样做法是更有趣的。

提示 - 一如既往地是可读的。

有诱惑消除`guessFound`变量。 当我们找到祝福的猜测时，从方法的中间返回它是否不会更简单？ 如果我们这样做，在返回`none`值之前，不需要检查`guessFound`值。 如果我们从循环中间返回，则代码不会到达那里。

是的，写的是更简单的。 但是，我们创建代码是可读且不可写的。 您可以说*是的，但较少的代码更可读*。 在这种情况下！ 从循环返回降低可读性。 更不用说，`return`语句在不同的执行阶段分散在方法中。

此外，从循环返回返回表示循环的隐式结束条件。 在我们的情况下，循环的头部清楚地说明我们在循环中迭代的时间 - 直到我们达到计数表的总宽度或我们猜测。

当有人用这种方式写入代码时，它类似于蹒跚学步的蹒跚学步，他们制作他/她的第一步，然后在他/她的母亲骄傲地看起来。 好的，男孩/女孩，你很棒。 现在，继续走路。 当你是邮递员时，走路将很无聊。 这将是你的职业。 所以，滑移骄傲并写入钻孔代码。 专业人士编写乏味代码。 不会慢？

不！ 它不会很慢。 首先，在探查器证明代码不符合业务需求之前，它并不慢。 如果它，它足够快，无论它有多慢。 只要这是对业务来说，慢是好的。 毕竟，正常在时间编译器（JIT）应该有一些任务优化要运行的代码。

以下方法检查猜测是否与`Table`上的先前猜测及其结果匹配：

```
private boolean guessMatch(Color[] guess) {
    for (Row row : table.rows) {
        if (!row.guessMatches(guess)) {
            return false;
        }
    }
    return true;
}
```

正如我们在类`Row`中已经实现的猜测匹配，我们要做的就是调用表中每行的方法。 如果所有行匹配，那么猜测可能对表有利。 如果任何前猜测不匹配，那么这猜测就会消失。

当我们检查匹配的否定表达时，我们创建了一个否定方法的英文版。

在这样的情况下，它可能足以创建方法的`guessDoesNotMatch`版本。 但是，如果该方法没有否定，则代码的逻辑执行更可读。 因此，单独写入`guessDoesNotMatch`方法更容易出错。 相反，我们将实现原始，可读的版本，以及 AUX 方法只不过是一个否定。

在所有 AUX 方法之后，我们实施的下一个和最终方法是公共一个，`guess()`：

```
public Row guess() {
    Color[] guess = nextGuess();
    while (guess != none && guessDoesNotMatch(guess)) {
        guess = nextGuess();
    }
    if (guess == none) {
        return Row.none;
    } else {
        return new Row(guess);
    }
}
```

它一次又一次地调用`nextGuess()`，直到它发现匹配隐藏行的猜测，或者没有更多的猜测。 如果它发现正确的猜测，它将其封装到`Row`对象，它返回它，以便稍后通过`Game`类添加到`Table`。 这种算法在两种情况下都是相同的，连续具有唯一和非唯一的颜色。

# uniquequesser.

`UniqueGuesser`类必须实现`setFirstGuess`（扩展抽象类的所有具体类别都应实现父母的抽象方法），它可以并将覆盖受保护的`nextGuess`方法：

```
package packt.java189fundamentals.example.mastermind;

import java.util.HashSet;

public class UniqueGuesser extends Guesser {

    public UniqueGuesser(Table table) {
        super(table);
    }

    @Override
    protected void setFirstGuess() {
        int i = lastGuess.length - 1;
        for (var color = table.manager.firstColor();
             i >= 0;
             color = table.manager.nextColor(color)) {
            lastGuess[i--] = color;
        }
    }
```

`setFirstGuess`方法以这样的方式选择第一猜测，即在第一算法之后第一个创建猜测的任何可能的颜色变化，如果我们遵循算法。

AUX `isNotUnique`方法如果猜测包含重复颜色，则返回 true。 看到多少是有趣的。 如果所有颜色相同，或者只有一种颜色出现两次，则无关紧要。 猜测不是唯一的，不适合我们的猜测。 这种方法告诉我们。

请注意，我们讨论了`Set` JDK 接口时已列出此方法：

```
private boolean isNotUnique(Color[] guess) {
    final var alreadyPresent = new HashSet<Color>();
    for (final var color : guess) {
        if (alreadyPresent.contains(color)) {
            return true;
        }
        alreadyPresent.add(color);
    }
    return false;
}
```

为此，它使用`Set`，随时在`guess`阵列中找到新颜色，颜色存储在该组中。 如果设置在阵列中发现它时，该组包含颜色，则表示之前已使用颜色; 猜测不是唯一的。

此外，请注意，在这种情况下，我以从循环中间返回的方式编码循环。 *不要从循环/方法*规则中间返回，未设置在石头中。 在这种情况下，我觉得从循环的中间返回更好的可读性，而不是引入新的`boolean`。 循环短暂，读取代码可以轻松地发现`return`只需两行循环头。

我们必须在此混凝土类中实现的最后一种方法是`nextGuess()`：

```
@Override
protected Color[] nextGuess() {
    Color[] guess = super.nextGuess();
    while (isNotUnique(guess)) {
        guess = super.nextGuess();
    }
    return guess;
}
```

覆盖`nextGuess()`方法很简单。 它询问超级`nextGuess()`实现来猜测，但抛出它不喜欢的那些。

# GeneralGuesser.

`GeneralGuesser`类也必须实现构造函数和`setFirstGuess`，但通常是它。 它不需要做任何其他事情：

```
package packt.java189fundamentals.example.mastermind;

public class GeneralGuesser extends Guesser {

    public GeneralGuesser(Table table) {
        super(table);
    }

    @Override
    protected void setFirstGuess() {
        int i = 0;
        for (Color color = table.manager.firstColor();
             i < lastGuess.length;
            ) {
            lastGuess[i++] = color;
        }
    }
}
```

算法非常简单。 它只是将第一种颜色放入`lastGuess`阵列的每列中。 `Guess`不能更简单。 其他一切都是从`abstract class Guesser`继承的。

# 游戏类

`Game`类的实例包含一个`Row`，保持秘密颜色值，并包含`Table`。 当有一个新的猜测时，`Game`实例将猜测存储到`Table`中，并设置匹配秘密行的位置和颜色的数量：

```
package packt.java189fundamentals.example.mastermind;

public class Game {

    final Table table;
    final private Row secretRow;
    boolean finished = false;
    final int nrOfColumns;

    public Game(Table table, Color[] secret) {
        this.table = table;
        this.secretRow = new Row(secret);
        this.nrOfColumns = secretRow.nrOfColumns();
    }

    public void addNewGuess(Row row) {
        if (isFinished()) {
            throw new IllegalArgumentException(
                "You can not guess on a finished game.");
        }
        final int positionMatch =
            secretRow.nrMatchingPositions(row.positions);
        final int colorMatch =
            secretRow.nrMatchingColors(row.positions);
        row.setMatch(positionMatch, colorMatch);
        table.addRow(row);
        if (positionMatch == nrOfColumns) {
            finished = true;
        }
    }

    public boolean isFinished() {
        return finished;
    }
}
```

想想我早些时候写的简短方法。 从 packt 存储库下载代码以播放它，尝试使其看起来更可读。 您可以，也许，创建和使用命名为`boolean itWasAWinningGuess(int positionMatch)`的方法。

# 创建集成测试

我们在上一章中创建了单元测试，并且还有本章类中实现的功能的单元测试。 我们将在此处不会打印这些单元测试，但您可以在 Packt 代码存储库中找到它们。 我们将查看集成测试，而不是列出单元测试。

集成测试需要调用许多课程一起工作。 他们检查功能是否可以通过整个应用程序或应用程序的至少一部分来传递功能，并且不关注单个单元。 它们称为集成测试，因为它们测试了类之间的集成。 单独的课程都可以。 它们不应该有任何问题，因为它已经被单位测试验证了。 集成侧重于他们如何共同努力。

如果我们想测试`Game`类，我们要么必须创建模拟模拟其他`Game`类的行为，或者我们只需编写集成测试。 从技术上讲，集成测试与单元测试非常相似。 在大多数情况下，相同的 JUnit 框架用于执行集成测试。 这是该游戏的集成测试的情况。

但是，构建工具需要配置为仅在需要时执行集成测试。 通常，集成测试执行需要更多时间，有时资源，例如可能在每个开发人员桌面上不可用的外部数据库。 每次编译应用程序都会运行单元测试，因此它们必须快速。 要分隔单位和集成测试，还有不同的技术和配置选项，但没有这样或更少的遗传标准，例如 Maven 引入的目录结构（稍后由 Gradle 适应）。

在我们的情况下，集成测试不需要任何额外的资源，并且不需要运行巨大的时间。 它从开始到最后玩游戏，并扮演玩家的角色。 非常像有棋子一样的人，迈出一步，然后转动桌子。 这是一个有趣的问题在那些赢得的游戏中。

这段代码的目的是双重的。 一方面，我们希望看到代码运行并播放整个游戏。 如果游戏完成，那么它就没问题了。 这是一个非常弱的断言，并且实际的集成测试执行大量断言（但是一项测试测试只有一个断言）。 我们将专注于其他旨在提供一些快乐，并以文本格式在控制台上可视化游戏，以便读者没有厌倦。

为此，我们将创建一个 Utility 类，它打印出颜色，并在飞行中为`Color`实例分配字母。

警告：在我们查看代码后我们必须谈论这一类的若干限制。 我会说这个代码只是为了演示什么*不做*，为下一章建立一些推理，以及我们需要重构我们在这个中创建的代码。 小心阅读！

这是`PrettyPrintRow`类：

```
package packt.java189fundamentals.example.mastermind;

import java.util.HashMap;
import java.util.Map;

public class PrettyPrintRow {

    private static final Map<Color, Character>
            letterMapping = new HashMap<>();
    private static final String letters = "RGBYWb";
    private static int counter = 0;

    private static char colorToChar(Color color) {
        if (!letterMapping.containsKey(color)) {
            letterMapping.put(color, letters.charAt(counter));
            counter++;

        }
        return letterMapping.get(color);
    }
```

这是这个课堂的核心。 当要打印颜色时，除非它已经有一个，否则它会获得一封信。 作为在 JVM 中运行的每个游戏中的`Map`包含在 JVM 中的每个游戏中使用相同的映射，启动了一个新的`Game`。 它分配了新的`Color`对象，很快就会出现在`String`常量中分配的六个字符。

如果`Game`实例并行运行，那么我们更麻烦。 班级根本不是线程安全。 如果两个线程同时调用相同 着名的最后一句话在墓碑上引用），然后两个线程都可能看到没有同时分配给颜色的字母，两者都将分配信函（基于运气的相同字母或两条不同的字母）并增加计数器 一次或两次。 至少，我们可以说的是执行是不确定的。

您可能会记得，我说违反哈希合约是第二次最难在多线程问题后找到一个错误。 这样一个非确定的代码正是 - 一个多线程问题。 找不到最困难的错误。 当应用程序没有运行时，一个错误会影响生产系统的数小时或几天，没有商业人员会很开心，并且在找到错误后，他们不会惊讶。 它可能是一种智力挑战，许多程序员经历了这样的事情，但实际值不是在第一位置创建错误。

作为摘要，此代码只能通过单个线程在 JVM（在同一个类加载器下）中使用一次。 对于这一章，它就没问题，但虽然是一个臭臭和可耻的代码。 稍后，它将是下一章的一个很好的例子，其中我们将看到如何重构应用程序，以便它不需要这样的黑客打印颜色。

根据 Martin Fowler（ [http://martinfowler.com/bliki/codesmell.html](http://martinfowler.com/bliki/CodeSmell.html) ），代码气味是由肯特回来创造的术语。 这意味着一些代码看起来不好，也不是糟糕的，但有些构造使开发商感到可能不好。 在网页上定义时，*代码气味是一种表面指示，其通常对应于系统中的更深问题。* 该术语被广泛接受，并已在过去 10 年中用于软件开发。

其余的代码是简单的简单：

```
    public static String pprint(Row row) {
        var string = "";
        final var pRow = new PrintableRow(row);
        for (int i = 0; i < pRow.nrOfColumns(); i++) {
            string += colorToChar(pRow.position(i));
        }
        string += " ";
        string += pRow.matchedPositions();
        string += "/";
        string += pRow.matchedColors();
        return string;
    }
}
```

集成测试，或者而不是演示码（因为它不包含除了不含异常的任何断言），定义了六种颜色和四列。 这是原始游戏的大小。 它创建了一个彩色管理器，然后它创建了一个桌子和一个秘密。 秘诀可能只是从可用的六种颜色中选择的任何随机颜色（在 Packt 代码存储库中获得的`UniqueGuesserTest`单元测试中有 360 个不同的可能性）。 正如我们所知，`Guesser`实现从颜色集的一端开始并系统地创建新的猜测，我们想设置它将猜测的秘密。 这不是因为我们是邪恶的，而是因为我们希望看到我们的代码真的有效。

代码的目录结构与我们在 Maven 构建工具的情况下使用的目录结构非常相似，可以在 Windows 计算机上创建的以下屏幕截图上看到：

![](img/1ad2d114-82f2-4124-aa93-b3ff3944c806.png)

源代码位于`src`目录下，`main`和`test`源代码文件分为两个子目录结构。 当我们使用 Gradle 时，将在`build`目录中生成编译的文件。

集成测试类的代码如下：

```
package packt.java189fundamentals.example.mastermind.integration;

import org.junit.Assert;
import org.junit.Test;
import packt.java189fundamentals.example.mastermind.*;

public class IntegrationTest {

    final int nrColors = 6;
    final int nrColumns = 4;
    final ColorManager manager = new ColorManager(nrColors);

    private Color[] createSecret() {
        Color[] secret = new Color[nrColumns];
        int count = 0;
        Color color = manager.firstColor();
        while (count < nrColors - nrColumns) {
            color = manager.nextColor(color);
            count++;
        }
        for (int i = 0; i < nrColumns; i++) {
            secret[i] = color;
            color = manager.nextColor(color);
        }
        return secret;
    }

    @Test
    public void testSimpleGame() {
        Table table = new Table(nrColumns, manager);
        Color[] secret = createSecret();
        System.out.println(PrettyPrintRow.pprint(new Row(secret)));
        System.out.println();
        Game game = new Game(table, secret);

        Guesser guesser = new UniqueGuesser(table);
        while (!game.isFinished()) {
            Row guess = guesser.guess();
            if (guess == Row.none) {
                Assert.fail();
            }
            game.addNewGuess(guess);
            System.out.println(PrettyPrintRow.pprint(guess));
        }
    }
}
```

运行测试的最简单方法是从 IDE 内部启动它。 当 IDE 基于构建文件导入项目时，将是 Maven `pom.xml`或 Gradle `build.gradle`，IDE 通常提供运行按钮或菜单以启动代码。 运行游戏将打印出我们在本章中努力工作的以下代码：

```
RGBY 0/0

GRWb 0/2
YBbW 0/2
BYGR 0/4
RGYB 2/2
RGBY 4/0
```

# 概括

在本章中，我们编写了一个表游戏 - MasterMind。 我们不仅编程了游戏的模型，还创建了一种可以猜到的算法。 我们重新审视了一些原则，并讨论了为什么模型是创造的方式。 我们创建了游戏的型号，同时我们了解了 Java 集合，集成测试和 javadoc。 在下一章中，我们将建立在此知识上，我们将加强游戏以在多个处理器上运行。