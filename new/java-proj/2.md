# 第一个真正的 Java 程序 - 排序名称

在上一章中，我们熟悉 Java，尤其是使用 Repl 工具和交互方式执行一些简单的代码。 这是一个很好的开始，但我们需要更多。 在本章中，我们将开发一个简单的程序。 使用此代码作为示例，我们将查看不同的构建工具，这些工具经常用于 Java 项目，并学习 Java 语言的基本功能。

本章将涵盖以下主题：

*   分拣问题
*   项目结构和构建工具
*   make，ant，maven 和 gradle 构建工具
*   Java 语言功能与代码示例相关

# 入门排序

排序问题是工程师遵守的最旧的编程任务之一。 我们有一系列记录，我们知道我们希望很快找到特定的一个。 要找到它，我们以特定顺序对记录进行排序，帮助我们快速找到我们想要的记录。

作为一个例子，我们有一些牌上的学生的名字。 当学生来到院长的小屋询问他们的结果时，我们将在另一个纸上看一下，找到询问学生的名称。 但是，如果我们按字母顺序排列学生的名称，更好。 当学生进行询问时，我们可以更快地搜索附加到名称的标记。

我们可以看看中间卡; 如果它显示学生的名称，那么我们很高兴找到了名称和标记。 如果该卡在按字母顺序上前进学生的名称，那么我们将继续在下半场搜索; 否则，我们将检查上半场。

通过这种方法，我们可以在几步中找到学生的名称。 步骤的数量不能超过多次卡片可以减半的数量。 如果我们有两张牌，那么它最多是两个步骤。 如果是四个，那么我们最多需要三步。 如果有八张牌，那么我们可能需要四个步骤，但不再需要。 如果有 1,000 张牌，那么我们可能需要最多 11 个步骤，而原始的不排他的集合需要 1000 个步骤，作为最坏的情况。 即，它大致，它将搜索速度加快了 100 次，因此这值得对卡进行排序，除非排序本身需要太多时间。 在我们刚刚描述的已经描述的已经排序集中找到元素的算法称为**二进制搜索**（ [https://en.wikipedia.org/wiki/binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm) ）。

在许多情况下，值得对数据集进行排序，并且有许多排序算法要做。 有更简单，更复杂的算法，并且如在许多情况下，更复杂的算法是运行速度更快的算法。

正如我们专注于 Java 编程部件，而不是算法伪造，在本章中，我们将开发一个实现简单而不是那种快速算法的 Java 代码。

# 泡沫排序

我们将在本章中实施的算法是众所周知的**泡沫排序**。 这种方法很简单。 从卡的开始开始并比较第一和第二卡。 如果第一张牌稍后以词典顺序而不是第二个，则交换两张牌。 然后，重复现在第二名的卡，然后是第三个，等等。 威尔逊说，有一张被释放的卡片的卡片。 当我们收到这张卡并开始将其与下一个比较时，我们将始终交换它们; 这样，威尔逊的卡将前往最后一个地方，在那里的最后一个地方。 我们所要做的就是重复从一开始就重复行驶，并再次偶尔转换卡，但这一次只到最后但一个元素。 这一次，第二个最新元素将到达其地方 - 说，威尔金森将在威尔逊之前。 如果我们有 *n* 卡片，我们重复这个 *n-1* 次，所有卡片将到达他们的位置。

在即将到来的部分中，我们将创建一个实现此算法的 Java 项目。

# 项目结构和构建工具入门

当项目比单个类更复杂时，通常是，定义项目结构是明智的。 我们必须决定在哪里存储源文件，其中资源文件（包含该程序的某些资源但不是 Java 源）的资源文件，其中应该由编译器写入`.class`，等等 。 通常，该结构主要是目录设置和执行构建的工具的配置。

复杂程序的编译不能使用命令行发出`javac`命令可公开完成。 如果我们有 100 个 Java 源文件，则编译将要求发出许多`javac`命令。 可以使用通配符缩短，例如`javac *.java`，或者我们可以编写一个简单的 bash 脚本或蝙蝠命令文件。 首先，它只需 100 行，每个源将一个源 Java 文件编译为类文件。 然后，我们将意识到，CPU 和电源正在消耗的唯一一次以编译自上次编译以来没有改变的文件，因此我们可以添加一些 Bash 编程，检查源和生成的文件上的时间戳。 最后，我们最终将使用基本上构建工具的工具。 建造工具可提供现成的; 它不值得重新发明轮子。

我们将使用已准备就绪的构建工具而不是创建一个。 其中很少可以在 [https://en.wikipedia.org/wiki/list_of_build_automation_software](https://en.wikipedia.org/wiki/List_of_build_automation_software) 中找到。 在本章中，我们将使用一个被称为 maven; 但是，在跳入此工具的详细信息之前，我们会查看您可能在企业项目中作为 Java 专业人士见面的其他一些工具。

在即将到来的部分中，我们将讨论以下四个构建工具：

*   制作
*   在地上
*   Maven.
*   译

我们将提到简要介绍，因为它这些天不在 Java 环境中使用。 但是，制作是第一个构建工具，而现代 Java 构建工具的许多想法是基于 *Good* `make`。 作为一个专业的 Java 开发人员，也应该熟悉，这样你就不会吓坏，如果你碰巧在一个项目中看到它以出于某种目的，并且可以知道它是什么以及它的详细文档可以在哪里 成立。

Ant 是多年前广泛用于 Java 的第一个构建工具，它仍然在许多项目中使用。

Maven 比 Ant 更新，它使用了不同的方法。 我们会详细看看它。 Maven 也是 Java 项目的 Apache 软件基础的官方构建工具。 我们还将在本章中使用 Maven 作为构建工具。

Gradle 甚至更新，这几天已经开始赶上 Maven。 我们将在本书的后来章节中使用此工具更详细地使用此工具。

# 制作

`make`程序最初于 1976 年 4 月创建，因此这不是一个新工具。 它包含在 UNIX 系统中，因此在 Linux，MacOS X 或基于 UNIX 的任何其他基于 UNIX 的系统上没有任何额外安装，可以使用此工具。 此外，Windows 上有许多此工具的此工具，Visual Studio 编译器工具集中包含一些版本。

制作没有与 Java 相关联。 它是在主要编程语言的 C 时创建的，但它没有与 C 或任何其他语言相关联。 `make`是具有非常简单的语法的依赖性描述语言。 与任何其他构建工具一样，`make`由项目描述文件控制。 在 make 的情况下，此文件包含规则集。 描述文件通常名为`Makefile`，但如果描述文件的名称不同，则可以将其指定为`make`命令的命令行选项。

`Makefile`中的规则互相按照一行或多行组成。 第一行在第一个位置开始（行开始时没有选项卡或空间），并且以下行以标签字符开头。 因此，`Makefile`可能看起来像以下代码：

```
run : hello.jar
    java -cp hello.jar HelloWorld

hello.jar : HelloWorld.class
    jar -cf hello.jar HelloWorld.class

HelloWorld.class : HelloWorld.java
    javac HelloWorld.java
```

此文件定义了三个所谓的目标：`run`，`hello.jar`和`HelloWorld.class`。 要创建`HelloWorld.class`，请在命令提示符下键入以下行：

```
make HelloWorld.class
```

make 将查看规则并了解它取决于`HelloWorld.java`。 如果`HelloWorld.class`文件不存在，或`HelloWorld.java`比 java 类文件更新，`make`将执行写在下一行上的命令，它将编译 Java 源文件。 如果在`HelloWorld.java`的最后修改后创建了类文件，则`make`知道不需要运行该命令。

在创建`HelloWorld.class`的情况下，`make`程序具有简单的任务。 源文件已经存在。 如果发出`make hello.jar`命令，则过程更复杂。 `make`命令看到，为了创建`hello.jar`，它需要`HelloWorld.class`，它也是另一条规则的目标。 因此，我们可能必须创建它。

首先，它以与以前相同的方式启动问题。 如果存在`HelloWorld.class`并且比`hello.jar`较大，我们需要做任何事情。 如果它不存在或更新，则需要执行`jar -cf hello.jar HelloWorld.class`命令，但是当它意识到必须执行它时不一定是必然的。 `make`程序记住，当创建`HelloWorld.class`所需的所有命令已成功执行时，必须在将来执行此命令。 因此，它继续以完全相同的方式创建类文件。

通常，规则可以具有以下格式：

```
target : dependencies
    command
```

`make`命令可以通过首先计算要执行的命令然后逐个执行它们的命令来使用`make target`命令来创建任何目标。 该命令是在不同进程中执行的 shell 命令，并且可能在 Windows 下构成问题，这可能会呈现`Makefile`文件的操作系统依赖于依赖。

请注意，`run`目标不是`make`创建的实际文件。 目标可以是文件名或目标的名称。 在后一种情况下，`make`永远不会考虑易于获得的目标。

由于我们不使用`make`为 Java 项目，没有理由进入更多细节。 此外，我通过使规则的描述更简单，我欺骗了一点。 `make`工具具有本书范围的许多强大功能。 还有几种实现彼此不同。 您将大概会符合自由软件基础 - GNU 制作的。 当然，在任何 Unix 命令行工具的情况下，`man`是您的朋友。 `man make`命令将在屏幕上显示工具的文档。

以下是您应该记住`make`的重要点：

*   它以声明方式定义单个工件（目标）的依赖关系
*   它定义了以必要的方式创建丢失的工件的操作

这个结构是发明的几十年前，并幸存下来，直到现在大多数构建工具，因为你将在接下来的几章中看到。

# 在地上

`ant`构建工具尤其适用于 2000 年左右的 Java 项目。Java 的目标是写入次运行 - 随时随地的语言需要一个可以在不同环境中使用的工具。 虽然`make`在 UNIX 机器上可用，但 Windows 也没有始终兼容。 使用标签字符有一些小问题，即某些编辑器替换为空间，渲染`Makefile`无法使用，但这不是主要原因。 点燃 Ant 的发展的主要问题是命令是 shell 命令。 即使进行了`make`程序的实现兼容，在不同的操作系统上运行，使用的命令也很多次不兼容，这是一个使自己无法改变。 因为`make`发出外部命令来构建目标，因此开发人员可以自由地使用开发机上可用的任何外部工具。 使用相同操作系统的另一台计算机可能没有`make`调用的同一组工具。 这破坏了`make`建立项目的可移植性。

与此同时，Ant 正在遵循`make`的主要原则。 存在可能彼此依赖的目标，并且存在需要以适当的序列执行的命令，以便在依赖顺序之后之后另一个之后地创建目标。 依赖关系和命令的描述是 XML（解决选项卡问题），并在 Java 中实现命令（系统依赖性解决，良好......或多或少）。

由于 ANT 既不是操作系统的一部分，也不是 JDK，如果要使用它，您将不得不单独下载并安装它。

# 安装 Ant.

蚂蚁可以从其官方网站下载（ [http://ant.apache.org](http://ant.apache.org) ）。 您可以下载源或预编译版本。 最简单的方法是在`tar.gz`格式中下载二进制文件。

每当您从 Internet 下载软件时，强烈建议您检查下载文件的完整性。 HTTP 协议不包含错误检查，可能会发生网络错误仍然隐藏或恶意内部代理修改下载的文件。 下载网站通常为可下载文件提供校验和。 这些通常是 MD5，SHA1，SHA512 或其他一些校验和。

当我在`tar.gz`格式中下载 Apache Ant 1.9.7 版本时，我还打开了导致 MD5 校验和的页面。 校验和值为`bc1d9e5fe73eee5c50b26ed411fb0119`：

![](img/5547972d-0d49-4922-a323-964ebb767050.png)

可以使用以下命令行检查下载的文件：`$ md5 apache-ant-1.9.7-bin.tar.gz` `MD5 (apache-ant-1.9.7-bin.tar.gz) = bc1d9e5fe73eee5c50b26ed411fb0119`计算的 MD5 校验和与网站上的一个相同，这表示文件完整性不会受到伤害。 在 Windows 操作系统上，没有工具来计算 MD5 摘要。 Microsoft 提供了一个工具，称为**文件完整性校验和验证验证程序**，可在 [https://support.microsoft.com/en-us/help/841290/availability-和 - 描述-File-Checksum-Integrity-Verifier-Utility](https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility) 的描述。 如果使用 Linux，可能会发生`md5`或`md5sum`实用程序。 在这种情况下，您可以使用`apt-get`命令或 Linux 发行支持的任何安装工具安装。

下载文件后，您可以使用以下命令将其爆炸到子目录中：

```
tar xfz apache-ant-1.9.7-bin.tar.gz
```

创建的子目录是 Ant 的可用二进制分布。 通常，我在`~/bin`下移动它，使其仅适用于我的用户在 OS X 上。在此之后，您应该将环境变量设置为`ANT_HOME`以指向此目录，并添加`bin`目录的安装 到`PATH`。 为此，您应该编辑`~/.bashrc`文件并将以下行添加到其中：

```
export ANT_HOME=~/bin/apache-ant-1.9.7/
export PATH=${ANT_HOME}bin:$PATH
```

然后，重新启动终端应用程序，或者仅键入`. ~/.bashrc`并通过键入以下命令来测试 ANT 的安装：

```
$ ant
Buildfile: build.xml does not exist!
Build failed
```

如果安装正确，则应看到前面的错误消息。

# 使用 Ant.

当您看到由 Ant 构建的项目时，您将看到一个`build.xml`文件。 这是项目构建文件，当您检查安装是否正确时，缺少 Ant 的文件。 它可以有任何其他名称，您可以将文件的名称指定为 ant 的命令行选项，但这是默认文件名，因为`Makefile`为`make`。 a `build.xml`样本如下所示：

```
<project name="HelloWorld" default="jar" basedir=".">
<description>
    This is a sample HelloWorld project build file.
</description>
    <property name="buildDir" value="build"/>
    <property name="srcDir" value="src"/>
    <property name="classesDir" value="${buildDir}/classes"/>
    <property name="jarDir" value="${buildDir}/jar"/>

    <target name="dirs">
        <mkdir dir="${classesDir}"/>
        <mkdir dir="${jarDir}"/>
    </target>

    <target name="compile" depends="dirs">
        <javac srcdir="${srcDir}" destdir="${classesDir}"/>
    </target>

    <target name="jar" depends="dirs,compile">
        <jar destfile="${jarDir}/HelloWorld.jar" basedir="${classesDir}"/>
    </target>
</project>
```

顶级 XML 标记是`project`。 每个构建文件都描述了一个项目，因此名称。 标签有三种可能的属性，如下：

*   `name`：这定义了项目的名称，并由某些 IDE 使用以在左侧识别项目的左侧面板中显示它
*   `default`：此命令在命令行上没有定义目标时使用的目标使用
*   `basedir`：这定义了用于构建文件中的任何其他目录名称计算的初始目录

构建文件可以包含项目的描述，以及属性标记中的属性。 这些属性可以用作`${`和`}`字符之间任务的属性中的变量，并在构建过程中播放重要作用。

目标在目标 XML 标记中定义。 每个标记都应该具有唯一标识构建文件中目标的名称，并且可以具有一个`depends`标记，该标记指定此目标取决于的一个或多个其他目标。 如果存在多个目标，则目标是逗号分隔在属性中。 属于目标的任务以与目标依赖链相同的顺序执行，因为在`make`的情况下，我们看到了非常相似的方式。

您还可以将`description`属性添加到 ant 打印的目标，当使用`-projecthelp`命令行选项时。 这有助于构建文件的用户知道有哪些目标以及哪些是什么。 构建文件往往会随着许多目标而变大，当你有 10 个或更多目标时，很难记住每个目标。

具有`HelloWorld.java`的示例项目现在排列在以下目录中：

*   `build.xml`：这是项目的`root`文件夹中存在
*   `HelloWorld.java`：这是项目的`src`文件夹中存在
*   `build/`：此文件夹不存在; 它将在构建过程中创建
*   `build/classes`和`build/jar`：这些也不存在，并且将在构建过程中创建

第一次启动`HelloWorld`项目的构建时，您将看到以下输出：

```
$ ant
Buildfile: ~/java_11-fundamentalssources/ch02/build.xml

dirs:
    [mkdir] Created dir:
~/java_11-fundamentalssources/ch02/build/classes
    [mkdir] Created dir:
~/java_11-fundamentalssources/ch02/build/jar

compile:
...
    [javac] Compiling 1 source file to
~/java_11-fundamentalssources/ch02/build/classes

jar:
      [jar] Building jar:
~/java_11-fundamentalssources/ch02/build/jar/HelloWorld.jar

BUILD SUCCESSFUL
Total time: 0 seconds
```

一些不重要的线条从实际输出中删除。

蚂蚁意识到，首先，它必须创建目录，然后它必须编译源代码，最后，它可以将`.class`文件包装到`.jar`文件中。 现在，您可以记住执行`HelloWorld`应用程序的命令。 它已在第一章中列出。 请注意，这次，JAR 文件名为`HelloWorld.jar`，它不在当前目录中。 您也可以尝试阅读 Ant 的在线文档，并创建执行编译和打包程序的目标`run`。

Ant 具有名为`java`的内置任务，该任务以终端中的`java`命令在键入`java`命令几乎与您的方式几乎相同的方式执行 Java 类。

# Maven.

由于创建蚂蚁来克服`make`的短缺，因此使用类似的意图来创建 Maven - 克服蚂蚁的短缺。 您可能会记住`make`无法保证构建可移植性，因为命令`make`执行是可以是特定于系统的任意 shell 命令。 一个 Ant 构建，如果类路径上的所有任务都可用，只要 Java 在不同的平台上运行相同的方式，就可以是可移植的。

蚂蚁的问题有点不同。 下载项目的源代码并且您想要构建时，命令将是什么？ 您应该向 Ant 询问所有目标并选择似乎最合适的目标。 任务的名称取决于制作`build.xml`文件的工程师。 有一些公约，但它们不是严格的规则。

您将在哪里找到 Java 源文件？ 它们是否在`src`目录中？ 如果项目是 Polyglot，还会有一些 Groovy 或其他编程语言文件吗？ 那要看。 同样，可能有一些群组或公司文化建议的一些公约，但没有一般性的行业实践。

当您使用 Ant 启动新项目时，您必须创建编译，测试执行和打包的目标。 这是您已经为其他项目做过的事情。 在第二个或第三个项目之后，您将仅将您之前的`build.xml`复制并粘贴到您的新项目中。 那是问题吗？ 是的。 它是复制/粘贴编程，即使它只是一些构建文件。

开发人员意识到利用 Ant 的项目的重大努力致力于项目构建工具配置，包括重复任务。 当新人来到团队时，他们将首先要了解构建的构建方式。 如果启动了一个新项目，则必须创建构建配置。 如果是重复的任务，那么更好地让计算机做到。 这通常是什么节目是关于，不是吗？

Maven 不同地接近构建问题。 我们希望构建 Java 项目。 有时，一些 groovy *或* jython 的东西，但它们也是 JVM 语言; 因此，请说我们想要构建 Java 项目并不是一个非常巨大的限制。 Java Projects 包含 Java 文件，有时是其他一些编程语言的源文件，资源文件，通常，即它。 蚂蚁可以做任何事情，但我们不想用构建工具做任何事情。 我们想要建立项目。

好的，在我们限制自己并接受我们不需要任何可以用于任何内容的构建工具之后，我们可以继续。 我们可以要求源文件位于`src`目录下。 有操作代码所需的文件，并且有些文件包含一些测试代码和数据。 因此，我们将有两个目录`src/test`和`src/main`。 Java 文件位于`src/main/java`以及`src/test/java`中。 资源文件在`src/main/resources`和`src/test/resources`下。

如果您想将源文件放在其他地方，那么请勿。 我是认真的。 有可能，但我甚至不会告诉你。 没有人这样做。 我甚至不知道为什么 Maven 使它成为可能。 每当您看到使用 Maven 作为构建工具的项目时，源都是这样组织的。 无需了解项目构建工程师所设想的目录结构。 它总是相同的。

目标和任务怎么样？ 它们对所有基于 Maven 的项目也是如此。 您还要使用除编译，测试，包或部署之外的 Java 项目以外的项目吗？ Maven 为我们定义了这些项目生命周期。 当您想使用 Maven 作为构建工具编译项目时，您必须输入`$ mvn compile`以编译项目。 即使在理解项目实际是什么之前，你也可以这样做。

随着我们具有相同目录结构和相同的目标，导致目标的实际任务也是一样的。 当我们创建 Maven 项目时，我们不必描述构建过程必须做些什么以及它如何进行。 我们必须描述该项目，只有特定于项目的零件。

Maven 项目的构建配置在 XML 文件中给出。 此文件的名称通常是`pom.xml`，它应该在项目的`root`目录中，这应该是当前工作目录时触发 maven。 **pom** 代表**项目对象模型**，它以分层方式描述了项目。 源目录，包装和其他事物在所谓的超级 POM 中定义。 此 POM 是 Maven 计划的一部分。 POM 定义的任何内容都会覆盖超级 POM 中定义的默认值。 当有多个模块有一个项目时，POMS 被排列成层次结构，并且它们将配置值从父压缩到模块继承到模块。 正如我们将使用 Maven 要开发我们的排序代码，我们稍后会看到更多详细信息。

# 安装 maven.

Maven 既不是操作系统的一部分，也不是 JDK。 它必须以非常相似的方式下载并安装到蚂蚁。 您可以在下载部分下载来自其官方网站（ [https://maven.apache.org/](https://maven.apache.org/) ）的 maven。 目前，最新的稳定版本为 3.5.4。 下载时，实际版本可能不同; 相反，使用最新的稳定版本。 您可以下载源或预编译版本。 最简单的方法是在`tar.gz`格式中下载二进制文件。

我无法跳过注意使用校验和检查下载完整性的重要性。 我详细介绍了在*安装 ant* 的部分中进行的方法。

下载文件后，您可以使用以下命令将其爆炸到子目录中：

```
tar xfz apache-maven-3.5.4-bin.tar.gz
```

创建的子目录是 Maven 的可用二进制分布。 通常，我将它移动到`~/bin`下，仅在 OS X 上为我的用户提供。在此之后，您应该将安装的`bin`目录添加到`PATH`。 为此，您应该编辑`~/.bashrc`文件并将以下行添加到其中：

```
export M2_HOME=~/bin/apache-maven-3.5.4/
export PATH=${M2_HOME}bin:$PATH
```

然后，重新启动终端应用程序，或者只键入`. ~/.bashrc`并测试 Maven 键入的安装，如下所示：

```
$ mvn -v
Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T20:33:14+02:00)
Maven home: /Users/verhasp/bin/apache-maven-3.5.4
Java version: 11-ea, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home
Default locale: en_HU, platform encoding: UTF-8
OS name: "mac os x", version: "10.13.6", arch: "x86_64", family: "mac" 
```

您应该在显示已安装的 Maven 版本和其他信息的屏幕上看到类似的消息。

# 使用 maven.

与 Ant 不同，Maven 可以帮助您创建一个新项目的骨架。 为此，您必须键入以下命令：

```
$ mvn archetype:generate
```

Maven 将首先从网络下载实际的可用项目类型，并提示您选择要使用的项目。 当 Maven 是新的，这种方法似乎是一个好主意。 当我第一次开始 Maven 时，列出的项目数量在 10 到 20 之间。今天，正如我写这本书的那样，它列出了 1,635 个不同的原型。 这个数字似乎更像是一个历史日期（法国科学院的宪法）而不是不同原型的可用大小列表。 但是，不要吓坏了。 Maven 在询问您的选择时提供默认值。 默认值适用于`HelloWorld`，我们去。

```
Choose a number: 817: 
```

安装时，实际数字可能不同。 无论是什么，接受建议，然后按*输入*。 之后，Maven 会向您询问项目版本：

```
Choose version:
1: 1.0-alpha-1
2: 1.0-alpha-2
3: 1.0-alpha-3
4: 1.0-alpha-4
5: 1.0
6: 1.1
Choose a number: 6: 5
```

选择列为 Weale `5`的`1.0`版本。 下一代 Maven 要求是项目的组 ID 和项目的工件 ID。 我们将稍后讨论的依赖管理使用这些。 我选择了基于这本书和发布者的组 ID。 项目的工件是`SortTutorial`，因为我们将在此项目中开始我们的章节示例。

```
Define value for property 'groupId': : packt.java11.example
Define value for property 'artifactId': : SortTutorial
```

下一个问题是项目的当前版本。 我们已经选择了`1.0`和 Maven 提供`1.0-SNAPSHOT`。 在这里，我选择了`1.0.0-SNAPSHOT`，因为我更喜欢语义版本化。

```
Define value for property 'version':  1.0-SNAPSHOT: : 1.0.0-SNAPSHOT
```

语义版本，在 [http://semver.org/](http://semver.org/) 中定义，是一种版本控制方案，它建议三位版本号为 m.m.p. 对于主要*，*次要*和*补丁版本号。 这对图书馆非常有用。 如果自上文版本以来只有错误修复，您将递增最后一个版本号。 当新版本还包含新功能时，您将递增次要数字，但库与以前的版本兼容; 换句话说，使用旧版本的任何程序仍然可以使用较新版本。 当新版本与前一个人显着不同时，主要版本号增加。 在应用程序的情况下，没有使用应用程序 API 的代码; 因此，次要版本号并不重要。 但是，它没有伤害，并且它经常证明在申请的较小变化中有用。 我们将讨论在最后一章中的版本软件。

Maven 处理具有`-SNAPSHOT` Postfix 作为非发行版本的版本。 虽然我们开发代码，我们将有许多版本的代码，所有版本都具有相同的快照版本号。 另一方面，非快照版本号只能用于单个版本：

```
Define value for property 'package':  packt.java11.example: :
```

程序骨架生成中的最后一个问题是 Java 包的名称。 默认值是我们给出的`groupId`的值，我们将使用它。 使用其他东西是一个罕见的例外。

当我们指定所需的所有参数时，最终请求是确认设置：

```
Confirm properties configuration:
groupId: packt.java11.example
artifactId: SortTutorial
version: 1.0.0-SNAPSHOT
package: packt.java11.example
 Y: : Y
```

进入`Y`后，Maven 将生成项目所需的文件并显示该报告：

```
[INFO] -----------------------------------------------------------
[INFO] Using following parameters for creating project from Old (1.x)
Archetype: maven-archetype-quickstart:1.0
[INFO] -----------------------------------------------------------
[INFO] Parameter: basedir, Value: .../mavenHelloWorld
[INFO] Parameter: package, Value: packt.java11.example
[INFO] Parameter: groupId, Value: packt.java11.example
[INFO] Parameter: artifactId, Value: SortTutorial
[INFO] Parameter: packageName, Value: packt.java11.example
[INFO] Parameter: version, Value: 1.0.0-SNAPSHOT
[INFO] *** End of debug info from resources from generated POM ***
[INFO] project created from Old (1.x) Archetype in dir:
.../mavenHelloWorld/SortTutorial
[INFO] -----------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] -----------------------------------------------------------
[INFO] Total time: 01:27 min
[INFO] Finished at: 2016-07-24T14:22:36+02:00
[INFO] Final Memory: 11M/153M
[INFO] -----------------------------------------------------------
```

您可以查看以下生成的目录结构：

![](img/113c68df-9aa6-49f2-8941-60c5b7a8cfa9.png)

您还可以看到它生成了以下三个文件：

*   `SortTutorial/pom.xml`：它包含**项目对象模型**
*   `SortTutorial/src/main/java/packt/java11/example/App.java`：其中包含`HelloWorld`示例应用程序
*   `SortTutorial/src/test/java/packt/java11/example/AppTest.java`：这包含利用`junit4`库的单元测试骨架

我们将在下一章讨论单位测试。 目前，我们将专注于排序应用程序。 由于 Maven 非常善良并为应用程序生成示例类，我们可以在没有实际编码的情况下编译和运行它，只是为了了解我们如何使用 Maven 构建项目。 通过发出`cd SortTutorial`将默认目录更改为`SortTutorial`，并发出以下命令：

```
$ mvn package
```

我们将获得以下输出：

![](img/667bb862-202c-4272-8765-841d8d1a714b.png)

Maven 自动击中，编译和包装项目。 如果没有，请阅读下一个信息框。

当您第一次启动 Maven 时，它会从中央存储库下载很多依赖项。 这些下载需要时间，并且在屏幕上报告时间值，并且对于不同的运行，这些值可能不同。 实际输出可能与您在前面的代码中看到的不同。 Maven 使用 Java 1.5 版的默认设置编译代码。 这意味着生成的类文件与 Java 1.5 版兼容，并且编译器仅接受已在 Java 1.5 中可用的语言构造。 后来 Maven Compiler 插件版本将使用 1.6 作为默认版本更改此行为。 如果我们想使用较新的语言功能，并且在本书中，我们使用很多它们，应编辑`pom.xml`文件来包含以下行：

```
<build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.8.0</version>
        <configuration>
            <source>1.11</source>
            <target>1.11</target>
            <release>11</release>
        </configuration>
      </plugin>
    </plugins>
  </build>
```

使用 Java 11 对 Maven 的默认设置时，它变得更加复杂，因为 Java 9 和稍后不生成类格式，也不会限制比 Java 1.6 早期的源兼容性。 这就是编译器插件更改其默认行为的原因。

现在，您可以使用以下命令启动代码：

```
$ java -cp target/SortTutorial-1.0.0-SNAPSHOT.jar packt.java11.example.App
```

您可以在以下屏幕截图中看到示例运行的结果：

![](img/79cf1967-fbf9-4427-ba2b-be4ef9d20cc5.png)

# 译

Ant 和 Maven 是两个世界，并使用一个或另一个可能导致互联网论坛上的加热辩论。 蚂蚁为开发人员提供自由，以创建一个适合他们品味的构建过程。 Maven 限制了团队使用更标准的构建过程。 某些与任何标准构建不匹配的特殊过程，但有时在某些环境中需要哪些有时需要使用 Maven 实现。 在 Ant 中，您可以使用内置任务的脚本几乎与您可以编程 Bash 的方式。 利用 Maven 并不那么简单，而且，它通常需要编写插件。 即使写入插件不是火箭科学，开发人员通常希望以更简单的方式制作东西的可能性。 我们有两种方法，两种心态和风格，而不是一个符合所有需求的单一工具。 毫无疑问，当 java 技术开发时，新的构建工具正在出现。

Gradle 尝试使用两全其美，利用时间不可用的技术 Maven 和 Ant 的开发。

Gradle 拥有内置的目标和生命周期，但与此同时，您也可以编写自己的目标。 您可以配置一个项目，就像使用 Maven 一样，而无需脚本任务，但同时，您也可以像蚂蚁一样脚本您自己的目标。 更重要的是，Gradle Integrated Ant，因此为 Ant 实施的任何任务也适用于 Gradle。

Maven 和 Ant 使用 XML 文件来描述构建。 今天，XML 是过去的技术。 我们仍然使用它，开发人员应该流利地处理，阅读和编​​写 XML 文件，但现代工具不使用 XML 进行配置。 JSON 等新的，花哨的格式更受欢迎。 Gradle 也不例外。 Gradle 的配置文件使用基于 Groovy 的**域特定语言**（ **DSL** ）。 对于程序员来说，这种语言更可读，并提供更多的自由来编程构建过程。 这也是 Gradle 的危险。

在开发人员手中拥有强大的 JVM 语言 Groovy 来创建构建工具，提供自由和诱惑，以创建复杂的构建过程，这在一开始时似乎是一个好主意，但后来可能是太复杂和艰难的，而且， 因此，保持昂贵。 这正是为什么 Maven 首先实施。

在进入另一个是加热和无意义的辩论的地面之前，我必须停下来。 Gradle 是一个极其强大的构建工具。 你应该仔细使用它，就像你会使用武器 - 不要射击你的腿。

# 安装 Gradle.

要安装 Gradle，您必须从 [https://gradle.org/gradle-dowload/](https://gradle.org/gradle-download/) 网站下载编译的二进制文件。

再次，我想强调使用校验和检查下载完整性的重要性。 我在关于 Ant 安装的部分中有一种详细的方法。 不幸的是，Gradle 网站没有提供可下载文件的校验和值。

Gradle 可按 ZIP 格式下载。 要解压缩文件，您必须使用 unzip 命令：

```
$ unzip gradle-4.9-bin.zip
```

创建的子目录是 DEARLE 的可用二进制分布。 通常，我将它移动到`~/bin`下，仅在 OS X 上为我的用户提供。在此之后，您应该将安装的`bin`目录添加到`PATH`。

为此，您应该编辑`~/.bashrc`文件并添加以下行：

```
export GRADLE_HOME=~/bin/gradle-4.9/
export PATH=${GRADLE_HOME}bin:$PATH
```

然后，重新启动终端应用程序，或仅键入`. ~/.bashrc`并通过键入以下内容来测试 Gradle 的安装：

```
$ gradle -version
```

我们将获得以下输出：

![](img/c845eff4-c1bc-4604-95a9-39945edcc020.png)

# 使用 maven 设置项目

要启动项目，我们将使用目录结构和`pom.xml`，当我们从以下命令行开始时由 maven 本身创建：

```
$ mvn archetype:generate
```

它创建了目录，`pom.xml`文件和`App.java`文件。 现在，我们将通过创建新文件来扩展此项目。 我们将首先在`packt.java11.example.stringsort`包中为排序算法进行编码：

![](img/555d22db-702c-4229-b824-6f89b9cc9c1a.png)

当我们在 IDE 中创建新包时，编辑器将自动在已存在的`src/main/java/packt/java11/example`目录下创建`stringsort`子目录：

![](img/bfe2ed29-1d64-4fdc-83a5-a868a4113c1e.png)

使用 IDE 创建新的`Sort`类将在此目录中自动创建一个名为`Sort.java`的新文件，它将填写类的骨架：

```
package packt.java11.example.stringsort;

public class Sort {
}
```

我们现在将`App.java`包含以下代码：

```
package packt.java11.example;

public class App {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

Maven 创建了它作为起始版本。 我们将编辑此文件以提供排序算法可以排序的示例列表。 我建议您使用 IDE 来编辑文件，也可以编译并运行代码。 IDE 提供快捷菜单以启动代码，这比键入终端中的命令更容易。 通常，建议您熟悉 IDE 功能以节省时间并避免重复任务，例如键入终端命令。 专业开发人员几乎完全使用命令行来测试命令行功能，并在可能时使用 IDE：

![](img/74e29fa7-672e-4f34-891d-2594b077859d.png)

# 编码这类

Maven 和 IDE 创建了 Sort 程序的文件。 它们为我们的代码形成了骨架，现在是时候为他们生长一些肌肉来让它移动。 我们花了很长一段时间通过访问不同的构建工具来设置项目，仅限学习如何编译代码。

我希望这并没有分散你的注意力，但无论如何，我们应该看到一些真正的代码。

首先，我们将为排序代码和之后创建代码，然后调用排序的代码。 调用排序的代码是一种测试代码。 为简单起见，我们现在只需使用`public static void main()`方法来启动代码。 我们将在后面的章节中使用测试框架。

至于现在，排序的代码将如下所示：

```
var n = names.length;
while (n > 1) {
    for (var j = 0; j < n - 1; j++) {
        if (names[j].compareTo(names[j + 1]) > 0) {
            final var tmp = names[j + 1];
            names[j + 1] = names[j];
            names[j] = tmp;
        }
    }
    n--;
}
```

这是对排序的课程。 此类中只有一种方法，可以进行排序。 该方法的参数是包含字符串的数组，方法对此数组进行排序。 该方法没有返回值。 这在声明中使用 pseudotype `void`表示。 方法使用其参数执行一些任务，并可能返回一个值。 该方法的参数由值传递，这意味着该方法无法修改作为参数传递的变量。 但是，它可以修改参数包含的对象。 在这种情况下，修改数组，我们将对其进行排序。 另一方面，`actualNames`变量将指向相同的阵列，`sort()`方法不能做任何事情来使该变量指向不同的数组。

此类中没有`main()`方法，这意味着它无法从命令行上启动。 此类只能从某些其他类中使用，因为每个 Java 程序都应该具有一个具有我们单独创建的`public static void main()`方法的类。

我也可以将`main()`方法放入类中以使其可执行，但这不是一个很好的做法。 真正的程序由许多课程组成，一个班级不应该做很多事情。 相反，这是相反的。 *单责任原则*说单一课程应该负责一件事; 因此，`class sort`排序。 执行应用程序是一个不同的任务，因此必须在不同的类中实现。

通常，我们不实现包含`main()`方法的类; 框架提供了它。 例如，编写在 servlet 容器中运行的 servlet 需要包含实现`javax.servlet.Servlet`界面的类。 在这种情况下，该程序似乎没有`main()`方法。 servlet 容器的实际实现确实如此。 Java 命令行启动容器，容器在需要时加载 servlet。

在以下示例代码中，我们实现了包含`main()`方法的`App`类：

```
package packt.java11.example.stringsort;

public class App {
    public static void main(String[] args) {
        var actualNames = new String[]{
                "Johnson", "Wilson",
                "Wilkinson", "Abraham", "Dagobert"};
        Sort.sort(actualNames);
        for (final String name : actualNames) {
            System.out.println(name);
        }
    }
}
```

此代码包含一个字符串数组初始化以包含常量值，创建`Sort`类的新实例，调用`sort()`方法，然后将代码打印到标准输出。

在真实的计划中，我们几乎从未在方案代码中拥有这样的常量; 我们将它们放入资源文件中，并有一些代码来读取实际值。 这将代码与数据分开并减轻维护，消除了仅在要更改数据时意外修改的风险。 同样，我们几乎从不使用`System.out`将任何东西写入标准输出。 通常，我们将使用不同来源可获得的日志操作。 有不同的库提供日志记录功能，并且 JDK 本身也可获得日志记录。

至于现在，我们将专注于简单的解决方案，不要将您的焦点从 Java 分散到不同的库和工具。 在即将到来的部分中，我们将查看编码算法时使用的 Java 语言构造。 首先，我们将一般地查看它们，然后，更详细地查看它们。 这些语言功能与另一个彼此不合适，因此，解释将首先是一般的，我们将详细介绍以下小节。

# 了解算法和语言构造

该算法在章节开始时解释。 实现在`sort()`方法中的`Sort`类中，它仅由几行组成：

```
var n = names.length;
while (n > 1) {
    for (var j = 0; j < n - 1; j++) {
        if (names[j].compareTo(names[j + 1]) > 0) {
            final var tmp = names[j + 1];
            names[j + 1] = names[j];
            names[j] = tmp;
        }
    }
    n--;
}
```

`n`变量在排序开始时保持阵列的长度。 Java 中的数组始终具有一个提供长度的属性，并且它被称为`length`。 当我们开始排序时，我们将从阵列的开始到结束，并且如您所在的那样，最后一个元素威尔逊将在第一次迭代期间走到最后一个位置。 随后的迭代将缩短，因此，变量`n`将减少。

# 块

Java 中的代码是在代码块中创建的。 `{`和`}`字符之间的任何东西都是块。 在前面的示例中，该方法的代码是块。 它包含命令，其中一些，例如`while`循环，也包含一个块。 在该块内部，有两个命令。 其中一个是`for`循环，再次用块。 虽然我们可以有单个表达式来形成循环的主体，但我们通常使用块。 我们将在几页中详细讨论循环。

正如我们在前面的示例中看到的那样，循环可以嵌套，因此是`{`和`}`字符形式对。 块可以在另一个块内部，但两个块不能重叠。 当代码包含`}`字符时，它将关闭最后打开的块。

# 变量

在 Java 中，就像几乎任何编程语言一样，我们使用变量。 键入 Java 中的变量。 这意味着变量可以保持单个类型的值。 变量不可能在程序中的某个点处保持`int`类型，稍后是`String`类型。 声明变量时，它们的类型将写入变量名称前面。 当局部变量获取声明的行上的初始值时，可以使用名为`var`的特殊保留类型。 这意味着与分配运算符右侧的表达式完全相同的类型。

这就是代码的样子：

```
var n = names.length;
```

它也可以写如下：

```
int n = names.length;
```

这是因为表达式`names.length`具有`int`类型。 此功能称为局部变量类型推断，因为类型从右侧推断出该类型。 如果变量不是本地的方法，则不能使用此操作。

当我们声明一个字段时（在类的类外部的类级别上的变量，而不是在初始化程序块或构造函数内），我们必须指定我们希望变量的确切类型。

变量也具有可见性范围。 方法中的局部变量只能在定义它们的块内使用。 可以在方法中使用变量，或者它们可以属于类或对象。 要区分两者，我们通常会调用这些变量字段。

# 类型

每个变量都有一种类型。 在 Java 中，有两种主要的类型 - 原始和参考类型。 原语类型是预定义的，您无法定义或创建新的原始类型。 存在八种原始类型 - `byte`，`short`，`short`，`long`，`float`，`double`，`boolean`和`char`。

前四种类型`byte`，`short`，`int`和`long`是符号的数字整数类型，能够存储 8,16,32 和 64 位上的正数和负数。

`float`和`double`在 IEEE 754 浮点格式中的 32 和 64 位上的浮点数。

`boolean`类型是一种原始类型，只能是`true`或`false`。

`char`类型是存储单个 16 位 Unicode 字符的字符数据类型。

对于每个原始类型，存在相应的类。 该类的实例可以存储相同类型的值。 当必须将原始类型转换为匹配类类型时，它会自动完成。 它被称为自动拳击。 这些类型是`Byte`，`Short`，`Integer`，`Long`，`Float`，`Double`，`Double`和`Character`。 例如，采用以下变量声明：

```
Integer a = 113;
```

这将转换为`int`编号的值`113`，到`Integer`对象。

这些类型是运行时的一部分，也是语言的一部分。

有一个特殊的类，名为`String`。 此类型的对象包含字符。 `String`没有原始的对应物，但我们多次使用它是一种原始类型，它不是。 它在 Java 程序中无处不在，有一些语言构造，例如连接直接使用此类型的字符串。

原始类型和对象之间的主要差异是原始类型不能用于调用它们的方法。 它们只是价值观。 当我们创建并发程序时，它们不能用作锁。 另一方面，它们消耗较少的内存。 内存消耗与其对速度后果之间的差异很重要，尤其是当我们有一系列值时。

# 阵列

变量可以是根据其声明的原始类型，或者它们可能会持有对象的引用。 特殊对象类型是数组。 当变量保持对数组的引用时，它可以与`[`和`]`字符索引，以及由 0 或正值组成的积分值，范围为小于数组的长度，以访问特定的 阵列的元素。 Java 也支持多维阵列，当数组有数组时，Java 也支持。 数组在 Java 中从零索引。 在运行时检查或过度索引，结果是异常。

异常是一个中断正常执行流程的特殊条件，并停止执行代码或跳转到最近的括号`catch`语句。 我们将讨论例外以及如何在下一章中处理它们。

当代码有一个原始类型的数组时，阵列包含内存插槽，每个内存插槽保持类型的值。 当数组具有引用类型时，换句话说，当它是对象数组时，阵列元素是对对象的引用，每个对象都引用类型的实例。 在`int`的情况下，例如，阵列的每个元素是 32 位，即 4 个字节。 如果数组是一种`Integer`，那么元素是对对象，指针的引用，例如，它通常使用 64 位 JVM 和 32 位 JVM 上的 32 位 64 位。 除此之外，还有一个`Integer`对象在内存中包含 4 字节值，也可以是 24 字节的对象标题。

管理每个对象所需的额外信息的实际大小未在标准中定义。 在 JVM 的不同实现中可能存在不同。 实际编码，甚至环境中的代码的优化，不应依赖于实际大小。 但是，开发人员应该意识到该开销存在，并且在每个对象的大约 20 左右的范围内。 对象在内存消耗方面是昂贵的。

内存消耗是一个问题，但还有其他东西。 当程序使用大量数据和工作需要阵列的连续元素时，CPU 将内存块加载到处理器缓存中。 这意味着 CPU 可以访问更快的数组的元素。 如果数组是原始类型，则它很快。 如果数组是某种类类型，则 CPU 可能需要访问内存以通过在数组中保持的引用获取阵列元素的实际值。 这可能比较慢的 50 倍。

# 表达式

Java 中的表达式非常类似于其他编程语言。 您可以使用可能类似于 C 或 C ++等语言的运算符。 它们如下：

*   一变量之前和之后的 Unary Prefix 和 Postfix 增量运算符（`--`和`++`）
*   Unary Sign（`+`和`-`）运营商
*   逻辑（`!`）和按位（`~`）否定
*   乘法（`*`），划分（`/`）和 modulo（`%`）
*   添加和减法（`+`和`-`再次，但这次是二进制运算符）
*   Shift Operators 移动值按比例移动，左移（`<<`），右（`>>`）shift 和 unsigned 右移（`>>>`）
*   比较运算符是`<`，`>`，`<=`，`>=`，`>=`，`!=`和`instanceof`，结果为`boolean`值
*   有位或（`|`），（`&`），独占或（`^`）运算符，以及类似逻辑的或（`||`），（`&&`）运算符

当评估逻辑运算符时，它们是评估的快捷方式。 这意味着才会在无法从左操作数的结果中识别结果时才会评估右手操作数。

三元运算符也类似于那个，如在 C 上，基于某些条件 - `condition ? expression 1 : expression 2`从其中一个表达式选择。 通常，三元运算符没有问题，但有时您必须小心，因为在两个表达式不相同类型的情况下，有一个复杂的规则控制类型转换。 有两个相同类型的表达总是更好的。

最后，有一个赋值运算符（`=`），将表达式的值分配给变量。 对于每个二进制运算符，存在一个分配版本，它将`=`与二进制运算符组合以执行涉及右操作数的操作，并将结果分配给左操作数，这必须是变量。 这些是`+=`，`-=`，`*=`，`/=`，`/=`，`&=`，`&=`，`|=`，`|=`，`>>=`和`>>=`和`>>>=`。

操作员优先权，可以像往常一样被括号覆盖。

表达式的一个重要部分正在调用方法。 静态方法可以通过类的名称和分隔的方法点的名称调用。 例如，要计算 1.22 的正弦，我们可以编写以下代码行：

```
double z = Math.sin(1.22);
```

这里，`Math`是来自包`java.lang`的类。 在不使用`Math`的实例的情况下调用`sin`方法。 此方法是`static`，我们不太可能需要它的任何其他实施而不是类`Math`中提供的那样。

可以使用实例和使用点分隔两个的方法的方法来调用非静态方法。 例如，考虑以下代码：

```
System.out.println("Hello World");
```

该代码使用`PrintStream`类容易获得的一个实例，通过在`System`类的静态字段。 此变量称为`out`，当我们编写代码时，我们必须将其引用为`System.out`。 `println`方法在`PrintStream`类中定义，我们在`out`变量引用的对象上调用它。 该示例还示出了静态字段也可以通过类的名称和由点分隔的字段来引用。 同样，当我们需要引用非静态字段时，我们可以通过类的实例执行。

可以在没有类名的情况下调用来自调用它的同一类中的静态方法或继承。 调用在同一类别中定义的非静态方法可以在没有显式实例符号的情况下调用或继承。 在这种情况下，实例是执行所在的当前对象。此对象也可以通过`this`关键字可用。 同样，当我们使用我们代码的同一类的字段时，我们只需使用名称。 在静态字段的情况下，我们所在的类是默认值。 在非静态字段的情况下，实例是`this`关键字引用的对象。

您还可以使用`import static`语言功能将静态方法导入代码，在这种情况下，您可以在没有类名的情况下调用该方法。

使用逗号分隔方法调用的参数。 方法和方法参数传递是我们稍后会覆盖的重要主题。

# 循环

让我们再看一下字符串排序的代码。 `while`循环中的`for`循环将通过第一个元素（在 java 中索引到零）上的所有元素到最后一次（用`n-1`索引）。 通常，此`for`循环具有与 C 中相同的语法：

```
for( initial expression ; condition ; increment expression )
  block
```

首先，评估初始表达式。 它可能包含变量声明，如我们的示例中。 前面示例中的`j`变量仅在循环块内部可见。 在此之后，评估条件，并且在每次执行块之后，执行增量表达式。 随着条件为真，循环重复。 如果在执行初始表达式后，条件是假的，则循环根本不会执行。 该块是由分号分隔的命令列表，并括在`{`和`}`字符之间。

代替`{`和`}`，封闭式块 Java 允许您在`for`循环的头部之后使用单个命令。 在`while`循环的情况下，也是如此，也是如此。 实践表明，这不是专业人士应该使用的东西。 专业代码始终使用 Crace 括号，即使只有一个命令块到位。 这可以防止摇摆`else`问题，并且通常使代码更可读。 这类似于许多类似的 C 样语言。 其中大多数允许在这些地方进行一次命令，并且专业程序员避免使用这些语言中的单个命令以进行可读性目的。 它是讽刺意味的是，严格要求在这些地方使用`{`和`}`括号的唯一语言是 perl - 对于不可读的代码臭名昭着的一种语言。

`for (var j = 0; j < n - 1; j++) {`样本中的循环从零开始并转到`n-2`。 在这种情况下，写入`j < n-1`是相同的，如`j <= n-2`。 我们将限制`j`在阵列结束前停止在阵列之前，因为我们通过比较和有条件地交换由`j`和`j+1`索引的元素来达到索引`j`之外。 如果我们进一步前进了一个元素，我们会尝试访问不存在的数组的元素，它会导致运行时异常。 尝试将循环条件修改为`j < n`或`j <= n-1`，您将收到以下错误消息：

![](img/37826676-a01e-48e5-8343-6eff833dfc07.png)

它是 Java 的一个重要特征，运行时检查内存访问并在错误的数组索引的情况下抛出异常。 在美好的日子里，在 C 中编写，经常编码，我们面临了不可解释的错误，以便在稍后的情况下停止我们的代码，并且在真正错误的位置完全不同的代码位置。 C 中的数组索引默默地损坏了内存。 Java 一旦犯了错误就会阻止你。 它遵循您应该在代码中使用的故障快速方法。 如果出现问题，则程序应失败。 没有代码应该尝试使用或克服来自编码错误的错误。 在它们引起更多损坏之前，应修复编码错误。

Java-`while`循环中还有两个更多的循环构造和`do`循环。 以下示例包含`while`循环。 它是外环运行，只要有至少两个可能需要在阵列中交换的元素：

```
while (n > 1) {
```

`while`循环的一般语法和语义非常简单，如以下代码所示：

```
while ( condition ) block
```

只要条件为`true`，只要重复执行块的执行。 如果在循环的开始时条件不正确，则根本不会执行块。 `do`循环也是相似的，但它检查块的每次执行后检查条件：

```
do block while( condition );
```

由于某种原因，程序员很少使用`do`循环。

# 条件执行

排序的核心是循环内部交换的条件和值。

```
if (names[j].compareTo(names[j + 1]) > 0) {
                    final String tmp = names[j + 1];
                    names[j + 1] = names[j];
                    names[j] = tmp;
                }
```

Java 中只有一个条件命令，`if`命令。 它具有以下格式：

```
if( condition ) block else block
```

代码结构的含义非常简单。 如果条件是`true`，则执行第一块，否则，执行第二块。 `else`关键字以及第二个块是可选的。 创建`else`和一个块是可选之后的块。 如果当条件是`false`时没有什么可执行的，那么我们就不会创建`else`部分。 如果用`j`索引的数组元素稍后以排序顺序而不是元素`j+1`，则我们会换流; 但是，如果他们已经是秩序，那就与他们无关。

要交换两个数组元素，我们使用名为`tmp`的临时变量。 此变量的类型是`String`，此变量被声明为`final`。 `final`关键字具有不同的含义，具体含义，取决于它在 Java 中使用的位置。 除非你被警告它，否则这可能会对初学者混淆，就像现在一样。 a `final`类或方法是比`final`字段完全不同的东西，它再次与局部变量不同。

请注意，这次我们使用显式类型`String`声明变量。 我们可以使用`var`，而不是`final var`，而是将推断出相同的类型。 这里使用显式键入的唯一原因是用于演示目的。

# 最终变量

在我们的情况下，`tmp`是一个`final`局部变量。 此变量的范围仅限于`if`语句之后的块，而在此块之外，此变量仅获取一次值一次。 在代码执行期间，该块执行多次，并且每次变量进入范围时，都会获得值。 但是，该值无法在块内更改，并且在块外不存在。 这可能有点令人困惑。 每次块执行时，您都可以将其视为具有新的`tmp`。 变量被宣布; 首先，它是未定义的，然后它得到一个值。

最终的本地变量不需要获得所声明的值。 您可以在稍后将值分配给`final`变量。 重要的是，不应该有一个代码执行，它为`final`变量分配了一个已分配了一个值的`final`变量。 如果有可能重新分配`final`变量，则编译器检查它，并且不会编译代码。 编译器还检查变量未定义时不应使用本地变量（不仅`final`变量）的值。

要将变量声明为`final`通常是为了便于可易读代码。 当您在声明为`final`的代码中看到变量时，您可以假设变量的值不会改变，无论在该方法中使用何处，变量的含义都将始终相同。 当您尝试修改某些`final`变量时，它还可以帮助您避免一些错误，并且 IDE 将立即抱怨它。 在这种情况下，它可能是一个非常早期发现的编程错误。

原则上，可以编写一个程序，其中所有变量都是`final`。 一般是一种良好的做法，声明可以被声明为`final`的所有`final`变量，并且如果可能没有声明某些变量`final`，则尝试以不同方式找到多种编码方法的方式。

如果您需要介绍一个新变量来执行此操作，它可能意味着您使用一个变量来存储两个不同的东西。 这些事情的类型是相同的，并且在不同时间存储在相同的变量中，但逻辑上，它们仍然是不同的东西。 不要尝试优化使用变量。 永远不要使用变量，因为您已在可用的代码中已有相同类型的变量。 如果它是逻辑上的，则声明一个新变量。 编码时，始终喜欢源代码清晰度和可读性。 在 Java 中，特别是，刚刚在时间编译器将为您优化所有这些。

虽然我们没有明确倾向于在方法的参数列表中使用`final`关键字，但是如果在声明参数`final`，则确保您的方法编译和工作是好的做法。 一些专家在内，包括我，相信该方法参数应该在语言中默认完成。 这是在任何版本的 Java 中都不会发生的事情，只要 Java 遵循向后兼容性哲学。

# 班级

既然我们已经看过实际的代码线，并已理解算法如何工作，让我们来看看更多的代码的全局结构，使其在一起括起来的类和包。

Java 程序中的每个文件都定义了一个类。 Java 程序中的任何代码都在一个类中。 与 C，Python，Go 或其他语言中的全局变量或全局函数相同。 Java 完全面向对象。

单个文件中可能有多个类，但通常，一个文件是一个类。 后来，我们会看到一个类时候有内部类别在另一个班级时，但是，因为现在，我们将一个班级放入一个文件。

Java 语言有一些功能，我们不使用。 创建语言时，这些功能似乎是一个好主意。 CPU，内存和其他资源，包括平庸开发人员，也比今天更多。 可能是一些特征，也许是因为这些环境限制而变得更有意义。 有时，我会提到这些。 在类的情况下，只要只有一个是`public`，您可以将多个类放入单个文件中。 这是糟糕的做法，我们永远不会那样做。 Java 从未过时过这些功能。 这是 Java 的哲学，与所有以前的版本保持兼容，直到最近，这种哲学变化缓慢。 这对已经写的很多遗产代码有益。 用旧版本编写和测试的 Java 代码将在更新的环境中工作。 与此同时，这些特征引起了错误的风格。 出于这个原因，有时候，我甚至不会提及这些功能。 例如，这里，我可以说 - *文件中有一个类。* 这不是绝对正确的。 与此同时，在很大程度上解释我建议不要使用的功能或多或少。 后来，我可以简单地跳过它们。 这些功能中没有太多。

使用`class`关键字定义一个类，每个类必须具有名称。 该名称应在包中是唯一的（请参阅下一节），并且必须与文件的名称相同。 类可以实现接口或扩展另一个类，我们稍后会看到一个示例。 类也可以是`abstract`，`final`和`public`。 这些都以适当的关键字定义，如您将在以下示例中看到。

我们的计划有两个课程。 他们两个都是`public`。 从任何地方都可以访问`public`类。 不是`public`的类仅在包内可见。 内部和嵌套类也可以是`private`只能在文件级别定义的顶级类内可见。

包含 Java 环境调用的`main()`方法的类应为`public`。 这是因为它们被 JVM 调用。

该类在包裹声明之后在文件的开头开始，`{`和`}`字符之间属于类。 方法，字段，内部或嵌套类，依此类推是类的一部分。 通常，卷曲括号在 Java 中表示一些块。 这是在 C 语言中发明的，而且许多语言遵循这种表示法。 类声明是一个块，使用块，循环和条件命令所有使用块定义方法。

当我们使用类时，我们必须创建类的实例。 这些实例是对象。 换句话说，通过实例化类来创建对象。 为此，`new`关键字用于 Java。 当行`final Sort sorter = new Sort();`在`App`类中执行时，它会创建一个实例化`Sort`类的新对象。 我们还会说我们创建了一个新的`Sort`对象，或者对象的类型是`Sort`。 创建新对象时，会调用对象的构造函数。 我可以说，有点邋 and，构造函数是类中的特殊方法，它与类本身具有相同的名称，并且没有返回值。 这是因为它返回创建的对象。 要精确，构造函数不是方法。 它们是初始化者，它们不会返回新对象。 他们在不准备好的物体上工作。 当未完全初始化执行对象的构造函数时，可能不会初始化某些最终字段，如果构造函数抛出异常，则仍然失败的整个初始化仍然失败。 在我们的示例中，我们在代码中没有任何构造函数。 在这种情况下，Java 创建一个默认构造函数，接受任何参数，也不会修改已分配但未初始化的对象。 如果 Java 代码定义初始化程序，则 Java 编译器不会创建默认值。

类可以具有许多构造函数，每个构造函数都具有不同的参数列表。

除构造函数外，Java 类还可以包含初始化程序块。 它们是类级别的块，与构造函数和方法相同。 这些块中的代码被编译为构造函数，并在构造函数执行时执行。

还可以在静态初始化程序块中初始化静态字段。 这些是在课程中的顶层上的块，其中`static`关键字在它们面前。 它们仅执行一次，即加载类时。

我们在我们的榜样`App`和`Sort`中命名课程。 这是 Java 示例`App`和`Sort`的“公约”。 这是 Java 中的一个公约，您必须在 CamelCase 中命名一切。

骆驼箱是在没有空格的情况下写入的时候。 第一个单词可以以小写或大写字母开始，并且要表示第二个和后续字的开始，它们以大写字母开头。 `ForExampleThisIsALongCamelCase`名称。

类名以大写字母开头。 这不是正式语言的要求，但这是每个程序员都应该遵循的惯例。 这些编码约定可帮助您创建其他程序员更易于理解的代码，并导致更容易维护。 静态代码分析仪工具（如 Checkstyle）（ [http://checkstyle.sourceforge.net/](http://checkstyle.sourceforge.net/) ），也检查程序员遵循约定。

# 内部，嵌套，本地和匿名课程

我已经提到了上一节中的内部和嵌套类。 现在，我们会更详细地查看它们。

此时内部和嵌套类的细节可能很困难。 如果您完全不了解本节，请不要感到惭愧。 如果太困难，请跳到下一节并读取关于包并稍后返回。 嵌套，内在和本地类很少使用，尽管它们有其角色并在 Java 中使用。 匿名类别在 GUI 编程中非常流行，使用 Swing 用户界面允许开发人员创建 Java GUI 应用程序。 凭借 Java 8 和 Lambda 功能，这些天匿名课程并不是那么重要，并且随着新兴的 JavaScript 和浏览器技术，Java Gui 变得不受欢迎。

当一个类在自己的文件中定义了一个类时，它被称为顶级类。 在另一个阶级内部的课程显然不是顶级类。 如果它们在与字段相同的级别的类内定义（某些方法或其他块不是本地的变量），则它们是内部或嵌套类。 它们之间有两个差异。 一个是嵌套类在其定义中`class`关键字之前的`static`关键字，而内部类别不会。

其他区别是没有周围类的实例可以存在嵌套类的实例。 内部类实例始终对周围类的实例引用。

由于内部类实例在没有周围类的实例的情况下，因此只能通过提供外部类的实例来创建它们的实例。 如果周围的类实例是实际的`this`变量，我们会看到没有区别，但如果我们想从周围类外部创建一个内部类的实例，那么我们必须在`new`关键字之前提供一个实例变量 用点分开，就像一个新的是一种方法。 例如，我们可以拥有一个名为`TopLevel`的类，其中包含一个名为`InnerClass`，如以下代码片段所示：

```
public class TopLevel {

    class InnerClass { }
}
```

然后，我们可以只使用`TopLevel`对象从外部创建`InnerClass`的实例，如以下代码片段所示：

```
TopLevel tl = new TopLevel();
InnerClass ic = tl.new InnerClass();
```

由于非静态内部类对封闭类的实例具有隐式引用，内部类内的代码可以访问封闭类的字段和方法。

嵌套类对封闭类的实例没有隐式引用，并且可以使用`new`关键字实例化，而不对任何其他类的任何实例的任何引用。 因此，除非它们是静态字段，否则无法访问括号类的字段。

本地类是在方法，构造函数或初始化程序块内定义的类。 我们很快就会谈论初始化程序块和构造函数。 本地类可以在定义它们的块内使用。

在一个命令中定义和实例化匿名类。 它们是嵌套，内部或本地类的短形式，以及课堂的实例化。 匿名类始终实现一个接口或扩展名为 Class。 新的关键字后跟接口的名称或带有参数列表的类到括号之间的构造函数。 在构造函数调用之后，定义匿名类的主体的块立即站立。 在扩展接口的情况下，构造函数可以是唯一一个没有参数的一个。 没有名称的匿名类不能拥有自己的构造函数。 在现代 Java 中，我们通常使用 Lambda 而不是匿名课程。

最后但并非最不重要的是，实际上，至少我应该提到嵌套和内部类也可以嵌套在更深的结构中。 内部类不能包含嵌套类，但嵌套类可以包含内部类。 为什么？ 我从未见过任何可以可靠地告诉我真正原因的人。 没有建筑原因。 它可能就是这样。 Java 不允许。 但是，这并不是很有趣。 如果您碰巧编写有多个类嵌套级别的代码，那么只需停止执行此操作。 最可能你做错了什么。

# 包

类组织成包，文件中的第一个代码行应指定类所处的包：

```
package packt.java11.example.stringsort;
```

如果未指定包，则该类将在默认包中。 除了您想要尝试一些代码的最简单情况之外，除了最简单的情况外，不应使用。 使用 Java 11，您可以为此目的使用`jshell`。 因此，与以前的 Java 相关的版本相反，现在建议变得非常简单 - 切勿在默认包中放置任何类。

包的名称是分层的。 名称的部分由点分开。 使用包名称可帮助您避免姓名冲突。 类的名称通常保持短，并将其放入包中有助于组织该程序。 类的全名包括类中的包的名称。通常，我们将这些类放入以某种方式相关的包，并将内容添加到程序的类似方面。 例如，MVC 模式程序中的控制器保持在单个包中。 包装还可以帮助您避免姓名的碰撞。 但是，这仅将问题从类名称碰撞中推动到包名称碰撞。 我们必须确保包的名称是唯一的，并且当我们的代码与任何其他库一起使用时不会导致任何问题。 开发应用程序时，我们无法知道在更高版本中将使用其他库。 要为意外准备，“公约”是根据某些 Internet 域名命名包。 当开发公司有域名`acmecompany.com`时，他们的软件通常在`com.acmecompany...`包下。 这不是严格的语言要求。 只有将域名从右向左写入域名，并使用它作为包名称，但这证明在实践中是相当善的。 有时，就像我在这本书中那样，一个人可以偏离这种做法，所以你可以看到这个规则没有雕刻在石头上。

当橡胶击中道路时，将代码编译为字节码，包成为类的名称。 因此，`Sort`类的全名是`packt.java11.example.stringsort.Sort`。 当您使用其他包中的类时，可以使用此全名或将类导入类。 同样，这是在语言级别。 使用完全限定的名称或导入不会在 Java 变为字节码时无差异。

# 方法

我们已经讨论了方法，但不详细地讨论过，并且仍然存在我们在继续之前会见的一些方面。

样本类中有两种方法。 课程中可能有许多方法。 方法名称也是按照惯例套接的骆驼，并且名称以小写字母开头，而不是类。

方法可能会返回一个值。 如果方法返回一个值，则该方法必须声明它返回的值的类型，在这种情况下，代码的任何执行都必须使用`return`语句完成。 `return`语句在关键字之后具有表达式，在执行方法时评估并被该方法返回。 只有一种良好的做法，只能从一种方法中返回一次，但在一些简单的情况下，可以宽恕该编码约定。 编译器检查可能的方法执行路径，如果某些路径不返回值，则是编译时错误。

当方法不返回任何值时，必须声明为`void`。 这是一种特殊类型，意味着没有值。 方法是`void`，例如`public static void main()`方法，可能只会错过返回声明并刚刚结束。 如果存在`return`语句，则无任何表达式的位置定义`return`关键字后的返回值。 同样，这是一个编码约定，以便在没有返回任何值的方法的情况下不使用`return`语句，但在某些编码模式中，可能不会遵循这一点。

方法可以是`private`，`protected`，`public`和`static`，我们将稍后讨论其含义。

我们已经看到，当程序启动时调用的`main()`方法是`static`方法。 这样的方法属于类，并且可以在没有类别的实例的情况下调用。 使用`static`修饰符声明静态方法，它们无法访问任何不静态的字段或方法。

在我们的示例中，`sort()`方法不是静态的，但由于它没有访问任何字段并且不调用任何非静态方法（事实上，它根本不会调用任何方法）; 它也可以是`static`。 如果我们将方法的声明更改为`public static void sort(String[] names) {`（请注意单词`static`），则程序仍然有效，但 IDE 将在编辑时发出警告，如以下示例所示：

```
Static member 'packt.java11.example.stringsort.Sort.sort(java.lang.String[])' accessed via instance reference
```

这是因为您可以通过`Sort.sort(actualNames);`类的名称，在没有实例的情况下无法访问该方法，而无需`sorter`变量。 通过一个实例变量调用静态方法，可以在 Java 中（再次，似乎在 Java 的 Genesis 的一个好主意，但可能不是），但它可能会误导代码的读者思考该方法是 实例方法。

使`sort()`方法`static`，`main()`方法可以如下：

```
public static void main(String[] args) {
    String[] actualNames = new String[]{
            "Johnson", "Wilson",
            "Wilkinson", "Abraham", "Dagobert"
    };
    Sort.sort(actualNames);
    for (final String name : actualNames) {
        System.out.println(name);
    }
}
```

它似乎更简单（它是），而且，如果方法不使用任何字段，您可能认为没有理由使方法不静态。 在 Java 的前 10 年中，静态方法均沉重。 甚至有一个术语，实用类，这意味着一个只有静态方法的类，不应实例化。 随着**反演的**控制器的出现**容器，我们倾向于使用较少的静态方法。 当使用静态方法时，使用**依赖注入**更难，并且创建测试也更加困难。 我们将在接下来的几章中讨论这些高级主题。 目前，您就会通知您可以使用哪些静态方法; 然而，通常，除非对他们非常特别需要，否则我们将避免它们。**

稍后，我们将查看类别在层次结构中如何实现，以及类如何实现接口并扩展其他类。 当看看这些功能时，我们会看到有所谓的抽象类，可能包含抽象方法。 这些方法具有`abstract`修饰符，而不是仅限定义的名称，参数类型（和名称），并指定返回类型。 扩展抽象类的混凝土（非抽象）类应该定义它们。

抽象方法的相反是使用`final`修饰符声明的最终方法。 在子类中不能覆盖`final`方法。

# 界面

方法也在接口中声明。 在接口中声明的方法未定义该方法的实际行为; 它们不包含代码。 他们只有该方法的头部; 换句话说，它们隐含地是抽象的。 虽然没有人，但在定义方法时，您甚至可能在接口中使用`abstract`关键字。

接口看起来非常类似于类，而不是使用`class`关键字，我们使用`interface`关键字。 由于接口主要用于定义方法，因此如果使用修改器，则方法是`public`。

接口也可以定义字段，但由于接口不能具有实例（仅实现类可以具有实例），因此这些字段都是`static`，它们也必须是`final`。 这是接口中字段的默认字段，因此如果我们在接口中定义的字段，我们无需编写这些。

这是一个常见的做法，只能在某些接口中定义常量，然后在类中使用这些。 为此，最简单的方法是实现界面。 由于这些接口未定义任何方法，因此该实现不仅仅是将 Implements 关键字和接口的名称写入类声明的标题中。 这是糟糕的做法，因为这种方式是界面成为课堂公开声明的一部分，尽管在课堂内需要这些常量。 如果您需要定义类不是本地的常量，但在许多类中使用，则在类中定义它们并使用`import static`导入字段，或者只使用类和字段的名称。

接口也可以具有嵌套类，但它们不能拥有内部类。 这是一个明显的原因是内部类实例对封闭类的一个实例引用。 在接口的情况下，没有实例，因此内部类无法对封闭界面的实例引用，因为刚刚不存在。 这个快乐的部分是，我们不需要在嵌套类的情况下使用`static`关键字，因为这是默认值，就像在字段的情况一样。

随着 Java 8 的出现，您还可以在接口中具有`default`方法，该方法提供实现接口的类方法的默认实现。 自 Java 9 以来，也可以在接口中有`static`和`private`方法。

方法由其名称和参数列表标识。 您可以重用用于方法的名称并具有不同的参数类型; Java 将识别基于实际参数的类型使用的方法。 这被称为**方法重载**。 通常，很容易判断您呼叫哪种方法，但是当存在彼此延伸的类型时，情况变得更加复杂。 该标准定义了非常精确的规则，用于实际选择编译器所遵循的方法，因此没有歧义。 但是，读取代码的同伴程序员可能会误解的方法，或者至少将识别实际调用哪种方法。 方法重载也可能在您想要扩展您的类时妨碍向后兼容性。 一般建议是在创建超载方法之前三思而后行。 它们有利可图，但有时可能是昂贵的。

# 论证传递

在 Java 中，参数通过价值传递。 当方法修改参数变量时，只有修改原始值的副本。 在方法调用期间复制任何原始值。 当对象传递为参数时，通过对对象的引用副本进行传递。

这样，对象可用于修改该方法。 在具有其原始对应物的类的情况下，以及在`String`和某些其他类类型的情况下，对象根本不提供修改状态的方法或字段。 这对于语言的完整性很重要，并且当对象和原始值自动转换时，不会遇到麻烦。

在其他情况下，当物体可修改时，该方法可以有效地处理它传递到的非常物体。 这也是我们示例中的`sort()`方法在数组上的工作方式。 修改了相同的阵列，其也是一个对象本身。

这个参数传递比其他语言更简单。 其他语言让开发人员通过引用和**通过 value** 参数传递。 在 Java 中，当您使用变量作为表达式将参数传递给一种方法时，可以确定永远不会修改变量本身。 然而，该对象是指其，但是，如果它是可变的，则可以修改。

如果可以修改，则对象是可变的，直接或通过某些方法调用更改其一些字段的值。 当一个类以没有正常方法创建对象后没有正常方法来修改对象之后的状态时，对象是不可变的。 在 JDK 中设计了类`Byte`，`Short`，`Long`，`Long`，`Long`，`Double`，`Double`，以及`String`，使得对象 是不可变的。 可以克服使用反思的某些类别的不可变性实施的限制，但这样做是黑客攻击而不是专业的编码。 这样做可以为一个单一的目的做出更好的了解和了解一些 Java 类的内部工作，但没有别的。

# 领域

字段是类级别的变量。 它们代表物体的状态。 它们是具有定义类型和可能的初始值的变量。 字段可以是`static`，`final`，`transient`和`volatile`，并且可以用`public`，`protected`和`private`关键字来修改访问。

静态字段属于课程。 这意味着他们中的一个由类的所有实例共享。 正常，非静态字段属于对象。 如果您有一个名为`f`的字段，则每个类实例都有自己的`f`。 如果声明`f` `static`，则实例将共享相同的`f`字段。

在初始化后，无法修改`final`字段。 初始化可以在初始化程序块中或构造函数代码中声明的行上完成。 严格的要求是初始化必须在构造函数返回之前发生。 这样，在这种情况下，`final`关键字的含义非常不同，在类或方法的情况下意味着。 无法扩展`final`类，并且在扩展的类中无法覆盖`final`方法，因为我们将在下一章中看到。 `final`字段要么未初始化或在实例创建期间获取值。 编译器还检查代码在对象实例创建期间或在类加载期间初始化所有`final`字段，以防`final`字段是`static`，并且代码未访问/读取任何`final`尚未初始化的字段。

它是一种常见的误解，即在声明中必须初始化`final`字段。 它可以在初始化器代码或构造函数中完成。 限制是，无论在还有哪个构造函数，如果有更多的情况下，必须完全初始化`final`字段一次。

`transient`字段不是对象序列化状态的一部分。 序列化是将对象的实际值转换为物理字节的行为。 当从字节创建对象时，反序列化是相反的。 它用于在某些框架中保存状态。 序列化`java.lang.io.ObjectOutputStream`的代码仅适用于实现`Serializable`界面的类，并仅使用来自不是`transient`的对象的字段。 非常明显，`transient`字段也不会从表示对象的序列化形式的字节中恢复，因为它们的值不存在。

序列化通常用于分布式程序。 一个很好的例子是 servlet 的会话对象。 当 servlet 容器在群集节点上运行时，存储到会话对象的某些字段可以在 HTTP 命中致法消失。 这是因为序列化保存并重新加载会话以在节点之间移动会话。 如果开发人员不知道会话中存储的大型对象的副作用，则序列化也可能是性能问题。

`volatile`关键字是一个关键字，它告诉编译器可以由不同的线程使用该字段。 当任何代码访问`volatile`字段时，JIT 编译器会生成代码，这可确保访问的字段的值是最新的。

当一个字段不易失值时，编译器生成的代码可以将字段的字段的值存储在处理器缓存或注册表中，以便在某些后续代码片段中看到该值时更快地访问。 在`volatile`字段的情况下，无法完成此优化。 此外，请注意，将值保存到内存和从中加载，这些时间可能比从注册表或缓存中访问值慢的 50 或更多次。

# 修饰符

方法，构造函数，字段，接口和类可以具有访问修饰符。 一般规则是，如果没有修饰符，方法，构造函数等的范围是包。 同一包中的任何代码都可以访问它。

当使用`private`修改器时，范围限于所谓的编译单元。 这意味着在一个文件中的类。 内部一个文件可以看到和使用声明为`private`的任何文件。 这样，内部和嵌套类可以彼此访问`private`变量，这可能不是一个很好的编程风格，但 Java 允许。

`private`成员可从同一顶级类中的代码访问。 如果顶级类中存在内部类，则编译器从这些文件生成单独的类文件。 JVM 不知道内部类是什么。 对于 JVM，一个类只是一个班级。 `private`成员仍然必须从作为顶级类别的类别访问，或者是在`private`成员（方法或字段）的相同顶级类中。 一切顺利，其他类都不能够访问`private`字段。 要解决此歧义，Java 生成了从外部可见的所谓的合成代理方法，因此可访问。 当您想从相同的顶级类别呼叫`private`方法但在不同的内部类中时，编译器生成代理类。 这是许多次 IDES 警告`private`方法可能与性能的角度来说可能不是最佳的原因。

这与 Java 11 发生了变化，介绍了巢的概念。 顶级类是巢主机，每个类都可以告诉他们巢中，谁是他们的巢主机。 这样，JVM 知道是否可以允许访问`private`成员（读取或写入字段或调用方法）。 同时，Java 11 不再生成合成代理方法了。

`private`的对立是`public`。 如果项目是 Java 模块，它会扩展到整个 Java 程序的可见性，或者至少在整个模块中。

有一种中间方法：`protected`。 在包内部可以访问此修改器的任何内容，也可以在扩展课程的类中（无论包裹如何），即受保护的方法，字段等。

# Object Initializers 和构造函数

实例化对象时，调用适当的构造函数。 构造函数声明看起来像具有以下偏差的方法 - 构造函数没有返回值。 这是因为在调用`new`命令运算符时，构造函数在不完全就绪实例上工作，并且不返回任何内容。 具有与类相同名称的构造函数不能彼此区分。 如果需要多个构造函数，则必须重载。 因此，构造函数可以互相调用，几乎就像它们是`void`方法，具有不同的参数。 但是，当构造函数调用另一个时，存在限制 - 必须是构造函数中的第一条指令。 使用`this()`语法与适当的参数列表，该参数列表可能为空，以调用另一个构造函数的构造函数。

对象实例的初始化也执行初始化程序块。 这些是包含`{`内的可执行代码和方法和构造函数外的`}`字符中的可执行代码。 它们在构造函数之前执行它们在代码中显示的顺序，以及在其声明包含值初始化的情况下初始化字段的初始化。

如果在初始化程序块前面看到`static`关键字，则块属于类，并在加载类时执行，以及静态字段初始化器。

# 编译和运行程序

最后，我们将从命令行编译和执行我们的程序。 这个在这个中没有什么新鲜事; 我们只使用以下两个命令应用我们在本章中学到的内容：

```
$ mvn package
```

这会编译程序，将结果打包到 JAR 文件中，最后执行以下命令：

```
$ java -cp target/SortTutorial-1.0.0-SNAPSHOT.jar packt.java11.example.App
```

这将在命令行上打印以下结果：

![](img/d3fff99a-f5dd-415d-bafa-ea71d509071b.png)

# 概括

在本章中，我们开发了一种非常基本的排序算法。 它是有目的地简单的，因此我们可以重复基本和最重要的 Java 语言元素，类，包，变量，方法等。 我们还看了构建工具，因此在项目中包含超过两个文件时，我们不会空手而归。 我们将在即将到来的章节中使用 Maven 和 Gradle。

在下一章中，我们将使 Sort 程序更复杂，实现更高效的算法，也使我们的代码灵活，让我们有机会了解更多高级 Java 语言功能。