# 制作我们的游戏专业 - 作为一个 Web 应用程序

在本章中，我们将编程 Web 应用程序。 我们将建立在我们已经取得的成就并创建了 MasterMind 游戏的 Web 版本。 这一次，它不仅可以单独运行，猜测和回答位置和匹配的颜色，还与用户进行通信，要求猜测猜测的答案。 这将是您可以玩的真正游戏。 Web 编程对于 Java 开发人员来说非常重要。 大多数程序都是 Web 应用程序。 互联网上可用的通用客户端是 Web 浏览器。 瘦客户端，基于 Web 浏览器的架构也被广泛接受在企业中。 当架构与 Web 客户端分开的东西时，只有一些例外情况。 如果您想成为专业的 Java 开发人员，您必须熟悉 Web 编程。 这也很有趣！

我们将在开发期间访问许多技术主题。 首先，我们将讨论网络和 Web 架构。 这是整个建筑的混凝土基地。 它不是太性感，就像你建造建筑物一样。 你花了很多钱和努力挖沟，然后你埋葬了混凝土并最终，在这个阶段结束时，你看起来有什么在平坦的地面，除了有基础。 没有这个基地的建筑物，房子在建筑过程之后或期间很快就会崩溃。 网络对网络编程同样重要。 似乎有很多看似与编程无关的主题。 尽管如此，它是建筑物的基础，当您编程 Web 应用程序时，您还将发现它的有趣方面。

我们还将有点谈论 HTML，CSS 和 JavaScript，但不是太多。 我们无法避免它们，因为它们对网络编程也很重要，但它们也是您可以从其他地方学习的主题。 如果您不是这些领域的一些专家，则企业项目团队通常通常可以延长您的知识。 （在网络的情况下，没有怜悯。）除此之外，JavaScript 是一个如此复杂的主题，它应该从一个全书开始。 只有一个非常少数的专家对 Java 和 JavaScript 有深刻理解。 我理解它在它运行的语言和环境的一般结构，但我不能跟上这些天每周发布的新框架，据我在其他领域的作用。

您将学习如何在码头中创建在应用程序服务器上运行的 Java 应用程序，并且我们将看到 servlet 是什么。 要跳跃开始，我们将创建一个 Web *Hello World* 应用程序。 然后，我们将创建 MasterMind 的 servlet 版本。 请注意，我们几乎不会直接编程 Servlet，而无需实现代码以处理参数，身份验证以及不特定于应用程序的许多其他内容的框架。 我们仍然将粘在本章中的裸体播放器，因为无法有效地使用框架，例如春天，而无需首先了解 servlet 是什么。 成为工程师，你必须先弄脏你的手。 春天将进入下一章。

我们将提到 **JavaServer 页面**（ **JSP** ），只有您可以符合一些使用该技术开发的传统应用程序，但现代 Web 应用程序不使用 JSP。 仍然，JSP 是 Servlet 标准的一部分，可供使用。 这些日子还有其他在过去开发的技术，但这几天似乎并不是未来的证据。 它们仍然可用，但仅出现在遗留应用程序中，并为新项目选择它们相当有问题。 我们将在单独的部分中不久讨论这些技术。

到本章末尾，您将了解基本的 Web 技术如何工作以及主要架构元素是如何，您将能够创建简单的 Web 应用程序。 这不足以成为一个专业的 Java Web 开发人员，但对于下一章来说将是一个很好的基础，我们将看看当今企业的专业框架进行真正的应用程序发展。

# 网络和网络

在计算机上运行的程序，计算机连接到 Internet。 该网络在过去的 60 年中开发，首先提供了对火箭袭击的军事数据通信，然后延长成为一个学术网络，后来成为任何人使用的商业网络，几乎可以在世界各地普遍存在。

网络和研究的设计与对 Gagarin 在六十年代的地球的轨道的回应开始。 将 Gagarin 送到太空，绕地球绕地球是一个示威，俄罗斯可以在地球上的任何地方派火箭，可能是原子爆炸物。 这意味着任何需要一些中央控制的数据网络都不适应这种攻击。 拥有一个带有中心位置作为单一故障的网络是不可行的。 因此，即使将其缺少任何部分，也开始研究继续运行的网络。

# IP.

该网络在连接到它的任何两台计算机之间提供数据包。 网络上使用的协议是 IP，这只是 Internet 协议的缩写。 使用 IP，计算机可以将数据包发送到另一个数据包。 包包含标题和数据内容。 标题包含发件人的 Internet 地址和目标机器，其他标志和包含包的信息。 由于机器未直接连接到彼此，因此路由器转发数据包。 这就像邮政局彼此发送信件，直到他们进入邮递员的手中你知道的，谁可以直接将它交给你的邮箱。 为此，路由器使用标题中的信息。 路由器如何交互的算法和组织是复杂的，我们不需要知道的东西，以便成为 Java 专业人士。

如果您需要编程以便直接发送 IP 数据包，则应查看`java.net.DatagramPacket`，因为其余在 JDK 中实现，在操作系统中，并在网卡的固件上实现。 您可以创建数据包; 发送并改变网卡上的调制电压或向光纤发出光子不是您的担忧。

IP 目前有两个版本。 旧版本仍在使用中是 IPv4。 与旧版本共存的新版本是 IPv6，或 ipng（ *ng* 代表*新一代*）。 可能涉及 Java 开发人员的主要区别是版本 4 使用 32 位地址，并且版本 6 使用 128 位地址。 当您看到版本 4 个地址时，您将看到类似`192.168.1.110`的内容，其中包含由点分隔的十进制格式的四个字节。 IPv6 地址表示为`2001:db8:0:0:0:0:2:1`，作为以十六进制分开的十六进制表示的八个 16 位数字。

Web 比发送数据包更复杂。 如果发送数据包类似于发送单页字母，那么网页下载就像在纸邮件中讨论合同。 在初始纸质邮件中应该有一个协议，以便发送什么，何时签署，依据合同签署。 在互联网上，该协议称为**传输控制协议**（ **TCP** ）。 虽然它非常不可能（但可能）您将达到 IP 路由问题，是 Java 开发人员，但您肯定会面临 TCP 编程。 因此，我们将介绍 TCP 如何效果。 请注意，这是非常简短的。 真的。 您将不会成为阅读下一节的 TCP 专家，但您将获得影响 Web 编程的最重要问题。

# TCP / IP.

TCP 协议在操作系统中实现，提供比 IP 更高的界面。 当您编程 TCP 时，您不处理数据报。 相反，您有一个字节流的频道，您可以在其中将字节交付给另一台计算机，您可以从其他计算机发送的频道中读取字节，正如他们发送的顺序所示。 这是两台计算机之间的一种连接，以及两个程序之间的内容。

还有其他通过 IP 实现的协议，而不是面向连接的协议。 其中一个是**用户数据报协议**（ **UDP** ）。 它在不需要连接时用于服务。 当数据可能丢失时也使用它更重要的是，数据更重要地以及时的方式进入目的地，而不是丢失任何数据包（视频流，电话）。 协议的另一个应用是当数据量很小时，如果丢失，可以再次请求; 请求的成本再比使用更复杂的 TCP 协议更便宜。 最后一次使用类型的典型示例是 DNS 请求，我们将在下一节中详细介绍。

在操作系统中实现的 TCP 软件层涉及数据包处理的复杂性。 重新发送丢失的包，重新排序符合不同订单的软件包，而不是原本应该是由此应该多次到达的额外软件包，这层层都是自动完成的。 该层普遍称为 **TCP 堆栈**。

由于 TCP 是一个连接的协议，因此需要某些东西告诉 TCP 堆栈的 TCP 堆栈该数据报何时到达时属于 TCP 堆栈。 该流由两个端口标识。 端口是 16 位整数。 一个标识启动连接的程序，称为源端口。 另一个识别目标程序 - 目标端口。 这些包含在交付的每个 TCP 数据包中。 当机器运行 **secure shell** （ **ssh** ）服务器以及 Web 服务器时，这些应用程序使用不同的端口。 这些端口通常是`22`和`80`。 当一个包来到 TCP 标题中包含目标端口号`22`时，TCP 堆栈知道数据包中的数据属于 SSH 服务器处理的流。 同样，如果目标端口是`80`，则数据转到 Web 服务器。

当我们编程服务器时，我们通常必须定义端口号; 否则，客户端无法找到服务器程序。 Web 服务器通常在侦听端口`80`，客户端尝试连接到该端口。 客户端端口通常不重要，未指定; 它由 TCP 堆栈自动分配。

要从客户端代码连接到服务器很容易 - 这只是需要几行代码。 有时，它只是一行代码。 但是，在引擎盖下，TCP 堆栈有很多工作要做，因为它需要时间来构建 TCP 连接需要时间，它可以大大影响我们应用的性能。

要具有连接，TCP 堆栈将数据报发送到目的地。 这不足以具有连接，但这是建立连接的第一步。 此数据包是空的，它的名称是 SYN。 发送此数据包后，客户端开始等待服务器以应答。 如果没有服务器，或者如果它过于忙于回答，或者它因为任何原因而无法给出这个特定客户端的答案，那么发送任何进一步的包都将是网络流量浪费。

当服务器收到 SYN 包时，它会使用 SYN-ACK 包回复。 最后，在收到 SYN-ACK 包后，客户端发送一个名为 ACK 的包。 如果数据包通过大西洋，这对于每个包装约为 45 毫秒，这相当于官僚时间的 4500 万秒。 这几乎是一个半年半。 我们需要三个来设置连接，这只是连接建立; 到目前为止我们尚未发送任何数据。

建立 TCP 连接时，客户端不会在没有自动控制的情况下开始发送数据。 它开始只发送几个包，然后等待查看会发生什么。 如果封装到达并且服务器确认它们，则会发送更多，随着该卷可以看到连接和服务器能够接受更高卷包的卷。 发送数据服务器未准备好，并且无法处理，不仅是无用的，而且浪费网络资源。 TCP 旨在优化网络使用情况。 客户端发送一些数据，然后等待确认。 TCP 堆栈会自动管理此功能。 如果确认到达，则会发送更多数据包。 如果在 TCP 堆栈中实现的精心设计的优化算法，相信发送更多，它会在第一步中发送比在第一步中的更多数据。 如果存在否定致谢告诉客户端的服务器无法接受一些数据并且必须丢弃它，那么客户端将减少它没有确认的数据包的数量。 但首先，它开始缓慢而谨慎。

这被称为 TCP 慢速开始，我们必须了解它。 虽然这是一个低级别的网络功能，它的后果，我们已经在我们的 Java 考虑代码，我们使用数据库连接池，而不是每次都需要对一些数据创建到数据库的新连接; 我们尝试尽可能少地与 Web 服务器的连接，使用诸如*保持活动*， *SPDY* 协议，或 *HTTP / 2* （也更换 SPDY ）。

至于现在，TCP 面向连接的是足够的，您可以在其中建立与服务器的连接，发送和接收字节，最后关闭连接。 当您有网络性能问题时，您必须查看先前详细的问题（并询问网络专家）。

# DNS.

TCP 协议使用机器的 IP 地址创建一个频道。 在浏览器中键入 URL 时，它通常不会包含 IP 号。 它包含机器名称。 使用名为**域名系统**（ **DNS** ）的分布式数据库将该名称转换为 IP 号。 此数据库分发，当程序需要将名称转换为地址时，它将 DNS 请求发送到其认识的 DNS 服务器之一。 这些服务器将查询彼此发送，或告诉客户要求谁，直到客户知道分配给名称的 IP 地址。 服务器和客户端也缓存最近请求的名称，因此应答速度快。 另一方面，当服务器的 IP 地址更改此名称时，并非所有客户端都将立即查看全球的地址分配。 可以轻松编程 DNS 查找，并且在 JDK 中有类和方法支持这一点，但通常，我们不需要担心; 当我们编程时，它是在 Web 编程中自动完成的。

# HTTP 协议

**超文本传输​​协议**（ **HTTP** ）构建在 TCP 之上。 在浏览器中键入 URL 时，浏览器将打开到服务器的 TCP 通道（当然是 DNS 查找之后）并向 Web 服务器发送 HTTP 请求。 服务器在收到请求后，生成响应并将其发送到客户端。 之后，可以关闭 TCP 信道或者保持其他 HTTP 请求 - 响应对的活动。

请求和响应都包含标题和可选（可能为零）主体。 标题处于文本格式，并通过空行与正文分隔。

更确切地说，标题和主体由四个字节 - `0x0D`，`0x0A`，`0x0D`和`0x0A`分开，它们是两个`CR`，`LF`线分离器。 HTTP 协议使用回车返回和行馈送来终止标题中的线路，因此，空线是彼此的两个`CRLF`。

标题的开始是状态行加上标题字段。 以下是 HTTP 请求示例：

```
GET /html/rfc7230 HTTP/1.1
Host: tools.ietf.org
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
DNT: 1
Referer: https://en.wikipedia.org/
Accept-Encoding: gzip, deflate, sdch, br
Accept-Language: en,hu;q=0.8,en-US;q=0.6,de;q=0.4,en-GB;q=0.2
```

这是回应：

```
HTTP/1.1 200 OK
Date: Tue, 04 Oct 2016 13:06:51 GMT
Server: Apache/2.2.22 (Debian)
Content-Location: rfc7230.html
Vary: negotiate,Accept-Encoding
TCN: choice
Last-Modified: Sun, 02 Oct 2016 07:11:54 GMT
ETag: "225d69b-418c0-53ddc8ad0a7b4;53e09bba89b1f"
Accept-Ranges: bytes
Cache-Control: max-age=604800
Expires: Tue, 11 Oct 2016 13:06:51 GMT
Content-Encoding: gzip
Strict-Transport-Security: max-age=3600
X-Frame-Options: SAMEORIGIN
X-Xss-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html; charset=UTF-8

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
```

请求不包含身体。 状态行如下：

```
GET /html/rfc7230 HTTP/1.1
```

它包含请求的所谓方法，请求的对象以及请求使用的协议版本。 标题的剩余请求包含具有格式`label: value`格式的标题字段。 一些行被包装在打印版本中，但标题线上没有换行符。

响应指定它使用的协议（通常与请求相同），状态代码和状态的消息格式：

```
HTTP/1.1 200 OK
```

在此之后，响应标题字段具有与请求中相同的语法。 一个重要的标题字段是内容类型：

```
Content-Type: text/html; charset=UTF-8
```

它指定响应主体（在打印输出中截断）是 HTML 文本。

实际请求被发送到 [https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230) ，这是定义 1.1 版本的标准。 您可以轻松查看自己，启动浏览器并打开开发人员工具。 如今，这种工具内置于每个浏览器中。 您可以通过查看字节级别的实际 HTTP 请求和响应来使用它来调试网络应用程序级别上的程序行为。 以下屏幕截图显示了开发人员工具如何显示此通信：

![](img/cb519a47-a096-4844-a57b-ec20d735e182.png)

# http 方法

该请求状态行中的第一个单词的方法告诉服务器处理请求。 该标准定义了不同的方法，例如`GET`，`HEAD`，`POST`，`PUT`，`DELETE`和其他方法。

当客户端想要获取资源内容时，客户端使用`GET`方法。 在`GET`请求的情况下，请求的主体是空的。 这是浏览器在下载网页时使用的方法。 JavaScript 程序在他们希望从服务器获取一些信息时多次使用此方法，但不希望向服务器发送许多信息。

当客户端使用`POST`时，意图通常将数据发送到服务器。 服务器回复，并且通常，还有一个身体在答复中。 但是，请求/回复通信的主要目的是将来自客户端发送到服务器的信息。 这与一种方式与`GET`方法相反。

`GET`和`POST`方法是最常用的方法。 虽然有一个通用指导要使用`GET`来检索数据和`POST`将数据发送到服务器，但它只是一个推荐，而且两种情况下没有干净的分离。 许多次，`GET`用于将数据发送到服务器。 毕竟，它是具有状态行和标题字段的 HTTP 请求，但请求中没有身体，但是遵循状态行中的方法的对象（URL 的一部分）仍然能够提供参数。 通常，它也很容易测试响应 A `GET`请求的服务，因为您只需要使用参数键入 URL 的浏览器，然后查看浏览器开发人员工具中的响应。

如果您看到使用`GET`请求的应用程序执行修改 Web 服务器上的状态的操作，则不会感到惊讶。 但是，没有惊讶并不意味着批准。 您应该意识到，在大多数情况下，这些都不是良好的做法。 当我们使用`GET`请求发送敏感信息时，URL 中的参数可在浏览器的地址行中的客户端中使用。 当我们发送使用`POST`时，客户端仍然可以访问参数（毕竟，客户端发送的信息是由客户端生成的，因此不能不可用），但对于简单的安全性并不容易 不知道用户复制和粘贴信息，然后将其转发到恶意的第三方。 使用`GET`和`POST`之间的决定应始终考虑实用性和安全问题。

`HEAD`方法与`GET`请求相同，但响应不会包含一个主体。 当客户端对实际响应不感兴趣时​​，使用这一点。 可能会发生客户端已经拥有该对象，并希望查看它是否已更改。 `Last-Modified`标题将包含资源最近更改的时间，并且客户端可以决定它是否具有较新的请求或需要在新请求中询问资源。

当客户端想要在服务器上存储某些东西时使用`PUT`方法，当客户端想要擦除某些资源时使用`DELETE`。 这些方法仅由通常用 JavaScript 编写而不是直接由浏览器编写的应用程序使用。

标准中有其他方法定义，但这些方法是最重要和最常使用的方法。

# 状态代码

响应从状态代码开始。 这些代码也被定义，并且在响应中有有限数量的代码。 最重要的是`200`，这表示一切正常; 响应包含请求所需的内容。 代码始终在`100`到`599`的范围内，并包含三位数。 它们根据第一个数字进行分组，如下所示：

*   `1xx`：这些代码是信息代码。 它们很少使用，但在某些情况下可能非常重要。 例如，`100`意味着继续。 服务器可以在获取`POST`请求时发送此代码，并且服务器希望向客户端发送客户端以发送请求的主体，因为它可以处理它。 使用此代码，然后客户端等待此代码，如果在服务器上正确实现，也可以保存大量带宽以及客户端。
*   `2xx`：这些代码意味着成功。 该请求已正确回答，或者实施请求的服务。 在标准中定义的`200`，`201`和`202`有代码，并且有关于何时使用一个或另一个的描述。
*   `3xx`：这些代码是指重定向。 当服务器无法直接为请求直接服务但知道可以的 URL 时，将发送这些代码中的一个。 实际代码可以区分永久重定向（当众所周知，所有将来的未来请求应发送到新 URL）和临时重定向（当您在此处发送任何较高的请求时，可能提供或重定向时），但决定是 保持在服务器端。
*   `4xx`：这些是错误代码。 最着名的代码是`404`，这意味着找不到，即服务器无法响应请求，因为找不到资源。 `401`意味着可以提供服务的资源，但需要进行身份验证。 `403`是一个代码，信号请求有效，但仍然拒绝由服务器提供服务。
*   `5xx`：这些代码是服务器错误代码。 当响应保持其中一个错误代码时，含义在于服务器上存在错误。 例如，当服务器正在处理太多请求时，该错误可能是临时的，并且无法响应计算密集响应的新请求（这通常由错误代码`503`）或未实现该功能时（ 代码`501`）。 常规错误代码`500`被解释为内部错误，这意味着没有任何信息，无论是关于服务器出现的错误，但它进展不顺利，因此没有有意义的回应即将到来。

# http / 2

自上次发布 HTTP 以来近 20 年后，最新版本的 HTTP 于 2015 年发布。这个新版本的协议有几个增强功能 Vis-à-in invers 版本。 其中一些增强功能也会影响服务器应用程序的开发方式。

第一个也是最重要的增强，即新协议将使可以在单个 TCP 连接中发送多个并行的资源。 保持活动标志已经可用，以避免 TCP 通道的娱乐，但在慢慢创建响应时它没有帮助。 在新协议中，即使在完全服务于请求之前，其他资源也可以在相同的 TCP 通道中传送。 这需要协议中的复杂包装处理。 这是隐藏的服务器应用程序员以及浏览器程序员。 Application Server，servlet 容器和浏览器透明地实现。

HTTP / 2 将始终加密。 因此，在浏览器 URL 中，不可能使用`http`作为协议。 它永远是`https`。

需要更改 Servlet 编程的功能以利用新版本的协议的优点是服务器推送。 Servlet 规范的 4.0 版包括对 HTTP / 2 的支持。 该规范可从 [https://javaee.github.io/servlet-spec/downloads/servlet-4.0/servlet-4_0_final.pdf](https://javaee.github.io/servlet-spec/downloads/servlet-4.0/servlet-4_0_FINAL.pdf) 可用。

服务器推送是对未来会出现的请求的 HTTP 响应。 服务器如何应答甚至签发的请求？ 好吧，服务器预计。 例如，该应用程序发送具有对许多小图片和图标的引用的 HTML 页面。 客户端下载 HTML 页面，构建 DOM 结构，分析它，并意识到需要图片，并发送图片请求。 应用程序员知道在浏览器请求之前，也可以将服务器代码发送图片以发送图片。 这种性质的每个响应都包括此响应的 URL。 当浏览器想要资源时，它意识到它已经存在并且不会发出新请求。 在`HttpServlet`中，程序应通过请求的新`getPushBuilder()`方法访问`PushBuilder`，并使用该方法将资源推向客户端。

# 曲奇饼

Cookie 由浏览器维护，并使用`Cookie`标题字段在 HTTP 请求标头中发送。 每个 cookie 都有一个名称，值，域，路径，到期时间和一些其他参数。 当请求发送到与域匹配的 URL 时，客户端将 Cookie 发送到服务器的非过期 cookie 的路径。 cookie 通常由浏览器或本地数据库中存储在客户端上的小文件中。 实际实现是浏览器的业务，我们不必担心它。 它只是客户端未执行的文本信息。 当某些规则（主要是域和路径）匹配时，它只发送回服务器。 Cookie 由服务器创建，并使用`Set-Cookie`标题字段将其发送到 HTTP 响应中的客户端。 因此，基本上，服务器告诉客户，“嘿，这是这个饼干，每当你下次来找我时，向我展示这件事，所以我会知道是你”。 Cookie 也可以由 JavaScript 客户端代码创建。 但是，由于 JavaScript 代码也来自服务器，因此这些 cookie 也可以被视为来自服务器的。

饼干通常旨在记住客户。 需要记住他们正在谈论谁的广告商和在线商店大量使用它。 但这不是唯一的用途。 这些天，维护用户会话的任何应用程序都使用 cookie 将来自同一用户的 HTTP 请求加载。 登录应用程序时，要将您用于标识自己的用户名和密码仅发送到服务器，并且在后续请求中，仅发送特殊 cookie 以识别已登录的用户。 此使用 cookie 强调为什么要使用无法轻易猜到的 cookie 值非常重要。 如果用于识别用户的 cookie 很容易猜到，那么攻击者只能创建一个 cookie 并将其发送到模拟其他用户的服务器。 为此目的，Cookie 值通常是长而随机字符串。

Cookie 并不总是发送回他们源自的服务器。 发送 Cookie 后，服务器指定 Cookie 应发送回来的 URL 的域。 当从提供需要身份验证的服务的不同服务器执行用户身份验证时使用这一点。

应用程序有时将值核发成 cookie。 这并不一定是坏的，但在大多数实际情况下，它是。 在将某些内容进行编码时，我们应该始终考虑 cookie 通过网络旅行的事实。 随着越来越多的数据，具有编码数据的 Cookie 可以增长巨大。 他们可以在网络上造成不必要的负担。 通常，最好只发送一个唯一的，否则毫无意义，随机键，并将值存储在数据库中，将其置于磁盘或内存中。

# 客户端服务器和 Web 架构

到目前为止我们开发的应用程序在单个 JVM 上运行。 我们已经拥有一定的经验并发编程，这是现在友好的东西。 当我们编程 Web 应用程序时，部分代码将在服务器上运行，并且应用程序逻辑的一部分将在浏览器中执行。 服务器部分将写入 Java 中，浏览器部分将以 HTML，CSS 和 JavaScript 实现。 由于这是一个 Java 书籍，我们将主要关注在服务器部分，但我们仍然应该意识到大部分功能可以的事实，并且应该在浏览器中运行。 这两个程序通过 IP 网络互相通信，即互联网，或者在企业内部应用程序，公司网络的情况下。

今天，浏览器可以执行强大的应用程序，在 JavaScript 中实现。 新的浏览器版本也支持 webassembly。 此技术在具有正常编译器的虚拟机中执行代码，就像 Java 虚拟机一样，因此，代码执行就像本机应用程序一样快。 已经展示了浏览器内部运行的图形游戏的安装。 C，Rust 和 Go 等语言可以编译为 WebAsseMbly，我们可以期望其他语言也可以使用。 这意味着将替换浏览器的编程方法，并且在客户端应用程序中将实现越来越多的功能。 这样，应用程序将变得越来越像传统的旧客户端 - 服务器应用程序，差异现在是客户端将在浏览器的沙箱中运行，通信是 HTTP 协议。

几年前，这样的应用程序需要使用客户端操作系统的窗口功能在 Delphi，C ++或 Java 中实现客户端应用程序。

最初，客户端 - 服务器架构意味着应用程序的功能是在客户端实现的，并且该程序仅使用服务器使用常规服务。 服务器提供了数据库访问和文件存储，但更重要。 稍后，三层体系结构将业务功能放在使用用于数据库和其他常规服务的其他服务器的服务器上，并且客户端应用程序实现了用户界面和有限的业务功能。

当 Web 技术开始渗透企业计算时，Web 浏览器开始在许多用例中替换客户端应用程序。 以前，浏览器无法运行复杂的 JavaScript 应用程序。 应用程序在 Web 服务器上执行，客户端显示作为应用程序逻辑的一部分创建的服务器的 HTML。 每次在用户界面上更改某些东西时，浏览器都开始与服务器通信，并且在 HTTP 请求 - 响应对中，替换浏览器内容。 Web 应用程序本质上是一系列表单填充和表单数据向服务器发送操作，并且服务器响应 HTML 格式的页面，可能是包含新表单的。

JavaScript 口译员被制定，变得越来越有效和标准化。 如今，现代 Web 应用程序包含 HTML（这是客户端代码的一部分，而不是由飞行的服务器生成），CSS 和 JavaScript。 从 Web 服务器下载代码时，JavaScript 开始执行并与服务器通信。 它仍然是 HTTP 请求和响应，但响应不包含 HTML 代码。 它包含纯数据，通常以 JSON 格式为单位。 此数据由 JavaScript 代码使用，并且如果需要，某些数据将在 JavaScript 控制的 Web 浏览器显示屏上显示。 这在功能上等同于三级架构，具有几个小但非常重要的差异。

第一个区别是代码未安装在客户端上。 客户端从 Web 服务器下载应用程序，并且唯一安装的是现代浏览器。 这消除了许多企业维护负担和成本。

第二个区别是客户端无法访问客户端计算机的资源，或者只有有限的访问。 厚客户端应用程序可以在本地文件中保存任何内容或访问本地数据库。 对于浏览器应用程序，出于安全原因，这非常有限。 与此同时，这是一个方便的限制，因为客户不是，不应该是架构的可信部分。 客户端计算机中的磁盘升起昂贵。 它可以用笔记本偷来并加密它昂贵。 有工具可以保护客户端存储，但大多数情况下，存储服务器上的数据只是一个更可行的解决方案。

它也是信任客户端应用程序的常见程序设计错误。 客户端物理控制客户端计算机，虽然可以在技术上非常困难地进行，但客户端仍然可以克服客户端设备和客户端代码的安全限制。 如果它只是检查某些功能或数据的有效性的客户端应用程序，则不使用服务器物理控制提供的物理安全性。 无论何时从客户端发送到服务器，都必须在有效的情况下检查数据，无论客户端应用程序是什么。 实际上，由于可以更改客户端应用程序，因此我们只是真的不知道客户端应用程序真正是什么。

在本章中，事实上，在本书中，我们专注于 Java 技术; 因此，示例应用程序几乎不包含任何客户端技术。 我忍不住创建了一些 CSS。 另一方面，我肯定避免了 javascript。 因此，我必须再次强调该示例，旨在展示服务器端的编程，并且仍然提供真正有效的东西。 现代应用程序将使用 REST 和 JSON 通信，并且不会在服务器端的飞行中创建 HTML。 最初，我想创建一个 JavaScript 客户端和 REST 服务器应用程序，但是从服务器端 Java 编程中搬到了这个想法的焦点是如此多的重点。 另一方面，您可以将应用程序扩展为类似的应用程序。

# 写一个 servlet.

servlet 是在实现 servlet 容器环境的 Web 服务器中执行的 Java 类。 第一个 Web 服务器只能将静态 HTML 文件传送到浏览器。 对于每个 URL，Web 服务器上有一个 HTML 页面，服务器响应浏览器发送的请求，服务器提供此文件的内容。 很快，需要扩展 Web 服务器以便能够在处理请求时，可以启动计算响应的内容的程序。

第一个标准是定义的**公共网关接口**（ **CGI** ）。 它开始响应请求的新过程。 新过程得到了标准输入的请求，并将标准输出发送回客户端。 这种方法浪费了大量资源。 从上一章中学到的，开始新的进程，只是为了响应 HTTP 请求的方式太高。 甚至开始一个新的线程似乎是不必要的，但是，我们在自己之前跑了一下。

下一个方法是 FastCGI，不断地执行外部过程并重用它。 FastCGI 遵循的方法都使用进程中的扩展。 在这些情况下，计算响应的代码在与 Web 服务器相同的过程中运行。 此类标准或扩展接口是 Microsoft IIS Server，Netscape Server 的 NSAspi 和 Apache 模块界面的 ISAPI。 这些中的每一个都可以创建一个**动态加载的库**（ **dll** ，或在 unix 系统上的共享对象**所以**文件）被 web 加载 启动期间的服务器并映射在这些库中实现的代码处理的某些请求。

例如，当某人程序 PHP 时，Apache 模块扩展名是 PHP 解释器，可读取 PHP 代码并作出作用。 当某人为 Microsoft IIS 进行 ASP 页面时，执行实现 ASP 页面解释器的 ISAPI 扩展（嗯，这有点邋 and 并超薄地说，但是作为一个例子工作）。

对于 Java，接口定义是在 4.0 版本中的 JSR369 中定义的 servlet。

JSR 代表 Java 规范请求。 这些是修改 Java 语言，库接口和其他组件的请求。 请求通过评估过程，并且当他们被接受时，它们成为标准。 该过程由 Java 社区进程（JCP）定义。 JCP 还记录并具有不同的版本。 当前版本为 2.10，可以在 [https://jcp.org/en/procedures/overview](https://jcp.org/en/procedures/overview) 中找到。

servlet 程序实现 servlet 接口。 通常，这是通过扩展`HttpServlet`类的影响。 此类是`Servlet`界面的抽象实现。 此抽象类实现方法，例如`doGet()`，`doPost()`，`doPut()`，`doDelete()`，`doDelete()`，`doOption()`和`doOption()`，可由延伸的实际类自由覆盖。 如果 servlet 类未覆盖这些方法中的一个，则发送相应的 HTTP 方法`GET`，`POST`，依此类推，将返回`405 Not Allowed`状态代码。

# 你好世界 servlet.

在进入技术细节之前，让我们创建一个非常简单的 *hello world* servlet。 要做到这一点，我们将使用构建文件，`build.gradle`，`src/main/java/packt/java9/by/example/mastermind/servlet/HelloWorld.java`文件中的 servlet 类设置一个 Gradle 项目，最后但并非最不重要的是，我们必须创建文件`src/main/webapp/WEB-INF/web.xml`。 `gradle.build`文件看起来像以下内容：

```
apply plugin: 'java'
apply plugin: 'war'
apply from: 'https://raw.github.com/gretty-gradle-plugin/gretty/master/pluginScripts/gretty.plugin'

repositories {
    jcenter()
}
targetCompatibility = "1.10"
sourceCompatibility = "1.10"
dependencies {
    providedCompile "javax.servlet:javax.servlet-api:3.1.0"
    testCompile 'junit:junit:4.12'
    compile 'org.slf4j:slf4j-api:1.7.7'
    compile 'ch.qos.logback:logback-classic:1.0.11'
    compile 'com.google.inject:guice:4.1.0'
}
```

Gradle 构建文件使用两个插件，`java`和`gretty`。 我们已经在上一章中使用了`java`插件。 `gretty`插件添加了加载 jetty servlet 容器的`appRun`等任务，并启动应用程序。 `gretty`插件还使用`war`插件，将 Web 应用程序编译为 Web 归档（战争）打包格式。

战争包装格式实际上与 jar 相同; 它是一个 zip 文件，包含一个`lib`目录，其中包含 Web 应用程序取决于的所有 JAR 文件。 应用程序的类位于目录，`WEB-INF/classes`，并且有一个`WEB-INF/web.xml`文件，它描述了 servlet URL 映射，我们将很快详细探讨。

由于我们想要开发一个非常简单的 servlet，我们将 servlet api 添加为项目的依赖项。 但是，这不是`compile`依赖性。 当 servlet 在容器中运行时，API 可用。 仍然，当编译器编译代码时，它必须可用; 因此，由指定为`providedCompile`的伪像提供*虚拟*实现。 因为指定了这样一个方式，构建过程不会将库打包到生成的 WAR 文件中。 生成的文件将包含特定于码头或任何其他 servlet 容器的文件。

servlet 容器将提供 servlet 库的实际实现。 部署并在码头中启动应用程序时，ClassPath 中将可用 Servlet 库的 jetty 特定实现。 将应用程序部署到 Tomcat 时，将可用的 Tomcat 特定实现。

我们在我们的项目中创建一个类，如下：

```
package packt.java11.mastermind.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

public class HelloWorld extends HttpServlet {

    private String message;

    public void init() throws ServletException {
        message = "Hello World";
    }

    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<h1>" + message + "</h1>");
    }

    public void destroy() {
    }
}
```

启动 servlet 时，调用`init`方法。 当 Servlet 取消服务时，调用`destroy`方法。 这些方法可以被覆盖以提供比构造函数和其他最终化可能性更细粒度的控制。 servlet 对象可以多次投入使用，并且在调用`destroy`之后，servlet 容器可以再次调用`init`; 因此，该循环并不严格地绑定到物体的生命周期。 通常，我们在这些方法中没有多么做，但有时，您可能需要一些代码。

另外，请注意，即使同时，也可以使用单个 servlet 对象来服务许多请求; 因此，它的 Servlet 类和方法应该是线程安全的。 规范要求 servlet 容器仅在容器在非分布式环境中运行时使用一个 servlet 实例。 如果容器在同一台计算机上运行多个进程，则每个过程执行 JVM，甚至在不同的计算机上，可能会有许多处理请求的 Servlet 实例。 通常，应设计 Servlet 类，使得它们不认为只有一个线程正在执行它们，但同时，它们也不应该假设该实例对于不同的请求是相同的。 我们根本无法知道。

这是什么意思？ 您不应该使用特定于某个请求的实例字段。 在前面的示例中，初始化以保持消息的字段对每个请求保持相同的值; 基本上，变量几乎是最终常数。 它仅用于演示`init`方法的一些功能。

当 servlet 容器使用`GET`方法获取 HTTP 请求时调用`doGet`方法。 该方法有两个参数。 第一个代表请求，第二个代表响应。 `request`可用于收集请求中的所有信息。 在前面的示例中，没有类似的。 我们不使用任何输入。 如果请求来到我们的 servlet，那么无论如何，我们都会回答`Hello, World`字符串。 稍后，我们将在从请求中读取参数时，我们会看到示例。 `response`提供可用于处理输出的方法。

在该示例中，我们获取`PrintWriter`，用于将字符发送到 HTTP 响应的主体。 这是浏览器中显示的内容。 我们发送的 MIME 类型是`text/html`，通过调用`setContentType`方法来设置这一点。 这将进入 HTTP 标头字段`Content-Type`。 类的标准和 javadoc 文档定义了可以使用的所有方法，以及如何使用这些方法。

最后，我们有一个`web.xml`文件，它声明了在我们的代码中实现的 servlet。 这是，正如文件的名称指示，XML 文件。 它声明了解归档中包含的所有 Servlet 以及其他参数。 在以下示例中，未定义参数，仅定义 servlet 和映射到 URL。 由于在此示例中只有一个单个 servlet，因此 WAR 文件，它映射到根上下文。 此 Servlet 将提供到达 Servlet 容器和此存档的每个`GET`请求：

```
<web-app version="2.5" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

    <servlet>
        <display-name>HelloWorldServlet</display-name>
        <servlet-name>HelloWorldServlet</servlet-name>
        <servlet-class>packt.java11.mastermind.servlet.HelloWorld</servlet-class>
    </servlet>
    <servlet>
        <display-name>Mastermind</display-name>
        <servlet-name>Mastermind</servlet-name>
        <servlet-class>packt.java11.mastermind.servlet.Mastermind</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>HelloWorldServlet</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>Mastermind</servlet-name>
        <url-pattern>/master</url-pattern>
    </servlet-mapping>

</web-app>
```

# JavaServer 页面

我答应了你，我不会用 javaServer 页面（JSP）来厌倦你，因为这是过去的技术。 即使是过去，它仍然不是历史，因为有许多程序运行仍然使用 JSP。

JSP 页面是包含 HTML 和 Java 代码的网页。 当 JSP 页面提供 HTTP 请求时，Servlet 容器读取 JSP 页面，执行 Java 部件，按照它们呈现 HTML 零件，以这种方式将两个混合在一起，创建发送的 HTML 页面 到浏览器：

```
<%@ page language="java"
         contentType="text/html; charset=UTF-8"
         pageEncoding="UTF-8"%>
<html>
<body>
<% for( int i = 0 ; i < 5 ; i ++ ){ %>
  hallo<br/>
<% } %>
</body>
</html>
```

前面的页面将创建一个包含文本`hallo`的 html 页面，每个次数在标记`br`分隔的新行中。 在幕后，servlet 容器将 JSP 页面转换为 Java Servlet，然后使用 Java 编译器编译 servlet，然后运行 servlet。 每次有源 JSP 文件的更改时都会这样做; 因此，使用 JSP 逐步逐步制作一些简单的代码。 从前面的 JSP 文件生成的代码是 138 行长（在 Tomcat 8.5.5 版本上），这只是长而无聊的列出，但可能有助于了解 Java 文件生成工作的部分仅包括 几行。

如果要查看生成的 servlet 类的所有行，则可以将应用程序部署到 Tomcat 服务器中，并查看`work/Catalina/localhost/hello/org/apache/jsp/`目录。 在开发人员中，这段代码实际保存到磁盘并可提供，这是一个鲜为人知的事实。 当您需要调试某些 JSP 页面时，它偶尔有帮助。

以下是从前面的代码生成的一些兴趣线：

```
out.write("n");
      out.write("<html>n");
      out.write("<body>n");
 for( int i = 0 ; i < 5 ; i ++ ){
      out.write("n");
      out.write("  hallo<br/>n");
 }
      out.write("n");
      out.write("</body>n");
      out.write("</html>n");
```

JSP 编译器将 JSP 代码的内部输出，外部。在 JSP 代码中，Java 被 HTML 包围，并且在生成的 Servlet Java 源代码中，HTML 由 Java 包围。 就像你想修补衣服的时候：第一件事就是把衣服翻出来。

它不仅可以在 JSP 页面中混合到 HTML 中的 Java 代码，还是所谓的标签。 标签被收集到标记库中，在 Java 中实现，并打包到 JAR 文件中，并且应在要使用的类路径上使用它们。 使用来自特定库的标记的 JSP 页面应声明使用：

```
<%@ taglib prefix="c"
           uri="http://java.sun.com/jsp/jstl/core" %>
```

标签看起来像 HTML 标记，但它们由 JSP 编译器处理，并由`taglib`库中实现的代码执行。 JSP 还可以指在 JSP 范围内可用的 Java 对象的值。 要在 HTML 页面内执行此操作，可以使用 JSP 表达式语言。

JSP 最初创建，以便于开发 Web 应用程序。 主要优势是开发的快速启动。 在开发过程中没有必要进行繁琐的配置，设置和其他辅助任务，并且当 jsp 页面有任何更改时，不需要再次编译整个应用程序 - servlet 容器生成 Java 代码，将其编译为 类文件将代码加载到内存中，并执行。 JSP 是 Microsoft ASP 页面的竞争对处，它使用 VisualBasic 代码混合 HTML。

由于应用程序开始扩展，使用 JSP 技术导致更多的问题而不是解决。 配的业务逻辑和应用的角度来看，它是如何在浏览器中呈现，成为杂乱的代码。 开发 JSP 需要前端技术知识。 Java 开发人员预计将知道一些前端技术，但很少是设计专家和 CSS Guru。 现代代码还包含 JavaScript，许多次嵌入在 HTML 页面中。 毕竟，JSP 的大优势在于它包含在服务器上运行的代码以及客户端代码。 开发人员多次遵循范式，因此不要惊讶地看到包含 Java，HTML，CSS 和 JavaScript 的一些遗留代码都在 JSP 文件中混合。 由于 Java 和 JavaScript 有时句子和 JavaScript，因此看出在服务器上执行的内容并在客户端上执行的内容并不明显。 我甚至看到了从 JSP 文件中从 Java 代码创建了 JavaScript 代码的代码。 这是不同责任的总组合，并一团糟几乎不可能维护。 这导致了今天 jsp 的总弃用。

JSP 的弃用不是官方的。 这是我的专家意见。 您可以遇到一些经验丰富的开发人员，这些开发人员仍然爱着 JSP，您可能会发现自己需要在 JSP 中开发程序的项目。 这样做是不可耻的。 有些人对金钱做得更糟。

为了修复凌乱的情况，有技术旨在越来越多地主张服务器代码和客户端功能的分离。 这些技术包括 Wicket，Vaadin，JSF 和不同 Java 模板发动机，例如 Freemarker，Apache 速度和胸部。 当您从 Java 生成文本输出时，后一种技术也可能是有趣的，即使代码根本没有网站，也可以是有趣的。

这些技术，具有纪律，帮助控制中等和大型网络项目的开发和维护成本，但架构的基本问题仍然存在：没有明确的关注分离。

今天，现代应用程序在单独的项目中实现了 Web 应用程序的代码：一个用于客户端，使用 HTML，CSS 和 JavaScript，以及一个单独的一个用于在 Java 中实现服务器功能（或者在其他内容中，但我们专注于 Java ）。 两者之间的通信是其余协议，我们将在后续章节中涵盖。

# HTML，CSS 和 JavaScript

HTML，CSS 和 JavaScript 是客户端技术。 这些对 Web 应用程序非常重要，专业的 Java 开发人员应该了解它们。 这两天，这两个地区专家的开发人员都被称为全堆叠开发人员，尽管我发现这个名字有点误导。 一定的理解是不可避免的。

HTML 是结构化文本的文本表示。 文本作为字符，如任何文本文件所示。 标签表示结构。 起始标签以`<`字符开头，然后启动标签，然后是标签的名称，然后，可选地，`name="value"`属性，最后是关闭`>`字符。 结束标签以`</`开头，然后以标签的名称，然后`>`。 标签括在层次结构中; 因此，您不应该比稍后打开的那样更快地关闭标记。 首先，上次打开的标签必须关闭，然后是下一个等等。 这样，HTML 中的任何实际标签都有一个级别，并且在开始和结束标签之间的所有标签都是此标签的*。 无法附带其他标记或文本的一些标签没有结束标签并自己站立。 考虑以下样本：*

```
<html>
  <head>
    <title>this is the title</title>
  </head>
</html>
```

标签`head`在`html`下方，`title`在`head`下方。 这可以构造成树，如下：

```
html
+ head
  + title
    + "this is the title"
```

浏览器将 HTML 文本存储在树结构中，此树是网页文档的对象模型，因此名称**文档对象模型**（ **dom** 树）树。

原始的 HTML 概念混合格式和结构以及即使使用当前版本的 HTML5，我们仍然具有诸如`b`，`i`和`tt`的标签，该标签建议浏览器在开始和结束之间显示文本 分别以粗体，斜体和图张型标记。

作为 HTML 的名称，站在超文本标记语言，建议，文本可以包含以超链接的形式对其他网页的引用。 这些链接被分配给使用`a`标记（站立为锚点）的文本，或者某种形式可以由不同的字段组成，当按下表单的提交按钮时，字段的内容被发送到服务器 a `POST`请求。 发送表单时，字段的内容在所谓的`application/x-www-form-urlencoded`表单中编码。

HTML 结构始终试图促进结构和格式的分离。 为此，格式化为样式。 在**级联样式表中定义的样式**（ **CSS** ）提供比 HTML 格式更多的灵活性; CSS 的格式对于格式化更有效。 创建 CSS 的目标是设计可以从文本的结构解耦。

如果我不得不选择三个中的一个，我会选择 CSS 作为 Java 服务器端 Web 开发人员最不重要的 CSS，同时对用户最重要的是最重要的（事情应该看起来不错）。

JavaScript 是客户端技术的第三支支柱。 JavaScript 是由浏览器执行的全功能，解释的编程语言。 它可以访问 DOM 树，并读取和修改它。 修改 DOM 树后，浏览器会自动显示修改后页面。 可以调度 JavaScript 函数并在事件发生时注册。 例如，您可以在完全加载文档时注册要调用的函数，当用户按下按钮时，点击链接，或者仅在某些部分上悬停鼠标。 虽然 JavaScript 首先仅用于在浏览器上创建有趣的动画，但今天它可以使用浏览器的功能来编程全功能客户端。 在 JavaScript 中有真正有强大的程序，甚至是 PC 仿真器的电源饥饿的应用。

最后，但绝不是最少的，美国 Java 开发人员必须关注我之前描述的新型网络装载技术。

在本书中，我们专注于 Java，并尽可能多地使用客户端技术。 然而，作为一个 Java Web 开发者专业人士，您必须在一定程度上学习这些技术，以便了解客户可以做些什么，并能够与负责前端技术负责的专业人士合作。

# mastermind servlet.

通过 Web 播放 MasterMind 游戏有点不同于它的用途。 到目前为止，我们没有任何用户互动，我们的课程是相应的。 例如，我们可以向表添加新的猜测，以及程序计算的部分和完整匹配。 现在，我们必须分开创建一个新的猜测，将其添加到游戏中，并设置完整和部分匹配。 这次，我们必须先显示表，用户必须计算并提供匹配的数量。

我们必须修改一些课程以便能够做到这一点。 我们需要为`Game.java`添加一个新方法：

```
public Row addGuess(Guess guess, int full, int partial) {
    assertNotFinished();
    final Row row = new Row(guess, full, partial);
    table.addRow(row);
    if (itWasAWinningGuess(full)) {
        finished = true;
    }
    return row;
}
```

到目前为止，我们只有一种添加一个新的猜测，并且由于程序知道秘密，它立即计算`full`和`partial`的值。 该方法的名称可以是`addNewGuess`，重载原始方法，但这次，该方法不仅用于添加新的猜测，还可以添加旧猜测来重建表。 这是因为我们从浏览器向服务器发送到服务器的信息中重建游戏的实际状态，每次播放器给出下一个猜测的答案时都会向服务器发送到服务器。 游戏的状态存储在客户端中，它将在 HTTP 请求中发送到服务器。

程序开始时，没有猜测。 该程序创建一个，第一个。 稍后，当用户告诉程序完整和部分匹配时，程序需要使用`Table`和`Row`对象的`Game`结构，其中包含`Guess`对象和`full`和`partial`匹配值。 这些已经可用，但当新的 HTTP 命中进来时，我们必须从某个地方拉出它。 编程 servlet，我们必须在某处存储游戏状态并在新的 HTTP 请求击中服务器时恢复。

# 储存状态

存储状态可以在两个地方完成。 一个地方，我们首先在我们的代码中做，是客户。 当程序创建新的猜测时，它将其添加到表中，并发送一个不仅包含新猜测的 HTML 页面，还包含所有先前的猜测和`full`和`partial`匹配用户所提供的值 行。 要将数据发送到服务器，值存储在表单的字段中。 提交表单时，浏览器会收集字段中的信息，从字段的内容中创建编码字符串，并将内容放入`POST`请求的主体中。

存储实际状态的其他可能性位于服务器上。 服务器可以存储游戏的状态，并且在创建新猜测时可以重建结构。 在这种情况下，问题是要知道要使用的游戏。 如果状态存储在服务器上，那么它应该存储许多游戏，至少为每个用户提供一个游戏。 用户可以同时使用该应用程序。 它并不一定意味着沿着前一章中审查的线条的强劲并发。

即使用户在多个线程中同时不提供用户，也可以有活动的游戏。 可以有多个用户玩多个游戏，在服务 HTTP 请求时，我们应该知道我们正在服务的用户。

Servlets 维护可用于此目的的会话，因为我们将在下一节中看到。

决定存储应用程序的位置是一个重要的架构问题。 在做出决定时，您应该考虑可靠性，信任，安全性，它本身也取决于信任，性能和可能的其他因素。

# http 会话

当客户端向同一浏览器发送到同一 servlet 的请求时，一系列请求属于一个会话。 要知道请求属于同一会话，servlet 容器会自动向客户端发送一个名为`JSESSIONID`的 cookie，此 cookie 有很长，随机，难以猜测的值（`tkojxpz9qk9xo7124pvanc1z`，因为我运行 在码头中的应用）。 servlet 维护包含`HttpSession`实例的会话存储。 在`JSESSIONID` cookie 的值中行进的密钥字符串标识实例。 当 HTTP 请求到达 servlet 时，容器将会话附加到存储对象的请求对象。 如果键没有会话，则创建一个，并且代码可以通过调用`request.getSession()`方法来访问会话对象。

`HttpSession`对象可以存储属性。 该程序可以调用`setAttribute(String,Object)`，`getAttribute(String)`和`removeAttribute(String)`方法来存储，检索或删除属性对象。 每个属性被分配给`String`，可以是任何`Object`。

虽然会话属性存储基本上看起来像`Map<String,?>`对象一样简单，但它不是。 当 servlet 容器在群集或其他分布式环境中运行时，存储在会话中存储在会话中的值可以从一个节点移动到另一个节点。 为此，值序列化; 因此，存储在会话中的值应该是`Serializable`。 未能这样做是一个非常常见的新手错误。 在开发过程中，在简单开发 Tomcat 或 jetty 容器中执行代码实际上从未将会话序列化为磁盘，也不会将其从序列化表单加载。 这意味着使用`setAttribute`设置的值将通过调用`getAttribute`来可用。 我们第一次在群集环境中安装了应用程序时遇到麻烦。 只要 HTTP 请求到达不同节点`getAttribute`可能会返回`null`。 在一个节点上调用方法`setAttribute`，并且在处理下一个请求期间，在不同节点上的`getAttribute`无法将来自节点之间共享的磁盘的属性值进行反序列。 这通常是又悲伤的，生产环境。

虽然目前，会话只能可靠地存储实现`Serializable`界面的类对象，我们应该知道 Java 序列化将来会改变一些时间。 序列化是一个低级功能，并且它将它连接到语言中不是一个良好的决定，因为 Java 创建了时间。 至少似乎现在不是。 在序列化 - Servlet 标准方面没有什么可担心的，但实施将正确处理这种情况。 另一方面，由于框架提供的代码以外的代码使用序列化是反直观的。

您作为开发人员，也应该意识到序列化和反序列化对象是一种繁重的运行，成本了几个 CPU 周期。 如果应用程序的结构只使用提供大多数 HTTP 请求的客户端状态，那么这是一个浪费 CPU，以从序列化形式创建内存中的整个状态，然后再次序列化。 在这种情况下，更有建议只能在会话中存储一个密钥，并使用某些数据库（SQL 或 NoSQL）或某些其他服务来存储密钥引用的实际数据。 企业应用程序几乎完全使用此结构。

# 在客户端存储状态

首先，我们将通过在客户端上存储状态来开发我们的代码。 发送用户输入所需的表单和新的完整和部分匹配的数量也包含用户当时给出的所有猜测和答案的所有先前颜色。 为此，我们创建一个新的辅助类来格式化 HTML 代码。 这是在现代企业环境中使用模板，JSP 文件或完全避免使用纯休息和企业环境中的一个页面应用程序所做的事情。 然而，在这里，我们将使用旧技术来展示在现代发动机罩下旋转的齿轮：

```
package packt.java11.mastermind.servlet;

import packt.java11.mastermind.Color;
import packt.java11.mastermind.Table;

import javax.inject.Inject;
import javax.inject.Named;

public class HtmlTools {
    @Inject
    Table table;

    @Inject
    @Named("nrColumns")
    private int NR_COLUMNS;

    public String tag(String tagName, String... attributes) {
        StringBuilder sb = new StringBuilder();
        sb.append("<").append((tagName));
        for (int i = 0; i < attributes.length; i += 2) {
            sb.append(" ").
                    append(attributes[i]).
                    append("=\"").
                    append(attributes[i + 1]).
                    append("\"");
        }
        sb.append(">");
        return sb.toString();
    }

    public String inputBox(String name, String value) {
        return tag("input", "type",
                "text", "name", name, "value", value, "size", "1");
    }

    public String colorToHtml(Color color, int row, int column) {
        return tag("div",
                "class", "color" + color) +
                tag("/div") +
                tag("div",
                        "class", "spacer") +
                tag("/div");
    }

    public String paramNameFull(int row) {
        return "full" + row;
    }

    public String paramNamePartial(int row) {
        return "partial" + row;
    }

    public String paramNameGuess(int row, int column) {
        return "guess" + row + column;
    }

    public String tableToHtml() {
        StringBuilder sb = new StringBuilder();
        sb.append("<html><head>");
        sb.append("<link rel=\"stylesheet\"")
                .append(" type=\"text/css\" href=\"colors.css\">");
        sb.append("<title>Mastermind guessing</title>");
        sb.append("<body>");
        sb.append(tag("form",
                "method", "POST",
                "action", "master"));

        for (int row = 0; row < table.nrOfRows(); row++) {
            for (int column = 0; column < NR_COLUMNS; column++) {
                final String html =
                        colorToHtml(table.getColor(row, column),
                                row, column);
                sb.append(html);
            }
            if (row < table.nrOfRows() - 1) {
                sb.append("" + table.getFull(row));
                sb.append(tag("div", "class", "spacer"))
                        .append(tag("/div"));
                sb.append("" + table.getPartial(row));
            } else {
                sb.append(inputBox(paramNameFull(row), "" + table.getFull(row)));
                sb.append(inputBox(paramNamePartial(row), "" + table.getPartial(row)));
            }
            sb.append("<p>");
        }
        return sb.toString();
    }
}
```

除了`@Inject`注释，其余代码简单且简单。 我们将在近期专注于`@Inject`。 我们要关注的是代码生成的 HTML 结构。 生成的页面看起来像这样：

```
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="colors.css">
        <title>Mastermind guessing</title>
        <body>
            <form method="POST" action="master">
                <input type="hidden" name="guess00" value="3">
                <div class="color3"></div>

                <div class="spacer"></div>

                <input type="hidden" name="guess01" value="2">
                <div class="color2"></div>

                <div class="spacer"></div>

                <input type="hidden" name="guess02" value="1">
                <div class="color1"></div>

                <div class="spacer"></div>

                <input type="hidden" name="guess03" value="0">
                <div class="color0"></div>

                <div class="spacer"></div>

                <input type="text"
                       name="full0" value="0" size="1">
                <input type="text"
                       name="partial0" value="2" size="1">

                <input type="hidden" name="guess10" value="5">
                <div class="color5"></div>

...deleted content that just looks almost the same...

                <input type="submit" value="submit">
            </form>
        </body>
    </head>
</html>
```

该表单包含`div`标签中的颜色，它还包含隐藏字段中颜色的*字母*。 当表单提交时，这些输入字段将发送到服务器，就像任何其他字段一样，但它们不会出现在屏幕上，用户无法编辑它们。 完整和部分匹配显示在文本输入字段中。 由于无法在 HTML 文本中显示`Color`对象，因此我们使用`LetteredColor`和`LetteredColorFactory`，该`LetteredColorFactory`将单个字母分配给颜色。 前六种颜色简单地编号为`0`，`1`，`2`，`3`，`4`和`5`。 CSS 文件可以控制颜色如何在浏览器窗口上查找。

您可能会记得我们如何以及在哪里实现单个颜色的显示。 首先，我们创建了一个专用打印类，该类是将字母分配给已经存在的颜色，但这仅适用于非常有限的环境（主要是单位测试，主要是）。 现在，我们再次有问题。 我们有刻字颜色，但现在我们需要真实的颜色，因为这次，我们有一个能够显示颜色的客户端显示。

现代网络技术的真正力量在这里闪耀。 内容和格式可以彼此分开。 不同颜色的 PEG 在 HTML 中列为`div`标签。 它们有一个格式类，但实际的外观是在 CSS 文件中定义的，这些文件是责任，除了外观之外：

```
.color0 {
    background: red;
    width : 20px;
    height: 20px;
    float:left
}
.color1 {
    background-color: green;
    width : 20px;
    height: 20px;
    float:left
}
... .color2 to .color5 is deleted, content is the same except different colors ...

.spacer {
    background-color: white;
    width : 10px;
    height: 20px;
    float:left
}
```

# 依赖性注射带柔官

servlet 类非常简单，如以下代码所示：

```
package packt.java11.mastermind.servlet;

import com.google.inject.Guice;
import com.google.inject.Injector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class Mastermind extends HttpServlet {
    private static final Logger log =
            LoggerFactory.getLogger(Mastermind.class);

    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
            throws ServletException, IOException {
        doPost(request, response);
    }

    public void doPost(HttpServletRequest request,
                       HttpServletResponse response)
            throws ServletException, IOException {
        Injector injector =
                Guice.createInjector(new MastermindModule());
        MastermindHandler handler =
                injector.getInstance(MastermindHandler.class);
        handler.handle(request, response);
    }
}
```

因为许多线程同时使用 servlet，因此我们不能使用持有数据的实例字段为单个命中，servlet 类不再赘述，但是创建了一个`MastermindHandler`类的新实例并调用其`handle`方法。 由于每个请求都有一个`MastermindHandler`的新实例，它可以将特定于请求特定的字段中的对象存储。 要创建处理程序，我们使用 Google 创建的 Guice 库。

我们已经谈到了依赖注入。 处理程序需要一个`Table`对象播放，一个`ColorManager`对象来管理颜色，以及一个`Guesser`对象创建一个新的猜测，但是创建这些或从某处获取一些预制实例不是核心功能 处理程序。 处理程序必须做一件事 - 处理请求; 应从外部注入执行此操作的情况。 这是由`Guice`注射器完成的。

要使用 guice，我们必须在`build.gradle`中的依赖关系中列出库。 在`HelloWorld` servlet 之前，文件的实际内容已列出。

然后，我们必须创建一个`injector`实例，该实例将进行注入。 在 servlet 中使用以下行创建注射器：

```
Injector injector = Guice.createInjector(new MastermindModule());
```

`MastermindModule`的实例指定注入何处的内容。 这基本上是 Java 格式的配置文件。 使用的其他依赖性注射器框架，并继续使用，XML 和注释来描述注入绑定和注入的内容，但 Guice 仅使用 Java 代码。 以下是 DI 配置代码：

```
public class MastermindModule extends AbstractModule {
    @Override
    protected void configure() {
        bind(int.class)
                .annotatedWith(Names.named("nrColors"))
                .toInstance(6);
        bind(int.class)
                .annotatedWith(Names.named("nrColumns"))
                .toInstance(4);
        bind(ColorFactory.class)
                .to(LetteredColorFactory.class);
        bind(Guesser.class)
                .to(UniqueGuesser.class);
    }
```

`configure`方法中使用的方法以流畅的 API 方式创建，以便在另一个之后一个地将方法链接，使得代码几乎可以读取。 可以在 [https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-.c 资料/](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/) 中找到一个很好的介绍流利的 API。 例如，第一配置线可以用英语读取为：

*"Bind to the class `int` wherever it is annotated with the* `@Name` *annotation having* `"nrColor"` *value to the instance* `6`.*"*

`MastermindHandler`类包含已用`@Inject`注释注释的字段：

```
@Inject
@Named("nrColors")
private int NR_COLORS;
@Inject
@Named("nrColumns")
private int NR_COLUMNS;
@Inject
private HtmlTools html;
@Inject
Table table;
@Inject
ColorManager manager;
@Inject
Guesser guesser;
```

此注释不是特定的。 `@Inject`是`javax.inject`包的一部分，是 JDK 的标准部分。 JDK 不提供**依赖性注射器**（ **di** ）框架，但支持不同的框架，以便它们可以使用标准的 jdk 注释，并且在替换 DI 框架的情况下，注释可能 保持不变，而不是特定于框架。

当调用喷射器以创建`MastermindHandler`的实例时，它会看看类，看到它有一个`@Inject`和`@Named("nrColors")`的`int`字段，并在这样一个字段应该具有的配置中找到 值 6.它在返回`MastermindHandler`对象之前将值注入字段。 同样，它还将值注入到另一个字段中，并且如果需要创建要注入的任何对象，则它确实如此。 如果这些对象中有字段，则还会通过注入其他对象等来创建它们。

通过这种方式，DI 框架消除了从程序员肩部创建实例的负担。 这是一个相当无聊的东西，无论如何都不是课程的核心特征。 相反，它创建具有功能`MastermindHandler`所需的所有对象，并通过 Java 对象引用将它们链接在一起。 这样，不同对象的依赖关系（`MastermindHandler`需要`Guesser`，`ColorManager`和`Table`; `ColorManager`需要`ColorFactory`，并且`Table`也需要`ColorManager`，依此类推）成为 声明，使用字段上的注释指定。 这些声明位于类的代码中，它是他们的正确位置。 我们还可以在哪里指定课程所需的课程，而不是课程本身？

我们的示例中的配置指定无论在哪里需要`ColorFactory`，我们将使用`LetteredColorFactory`，无论我们需要`Guesser`，我们将使用`UniqueGuesser`。 这与代码分开，它必须像那样。 如果我们想更改猜测策略，我们替换配置，代码应该在不修改使用猜测程序的类的情况下工作。

Guice 是聪明的聪明，你不需要指定任何需要`Table`，我们将使用`Table` - 没有`bind(Table.class).to(Table.class)`。 首先，我在配置中创建了一条线，但 Guice 用错误消息奖励我，现在，在简单的英语中再次写作它，我觉得真的很愚蠢。 如果我需要一个表，我需要一个表。 真的吗？

使用 Java 9 或更高版本以及我们的代码使用 JPMS 时，我们必须向我们使用的框架打开代码库。 模块不允许外部的代码来操作私有类或使用反射的对象成员。 如果我们不声明我们想要使用 guice 的模块定义文件，我们允许 guice 访问私人字段，它将无法执行此操作，这样，它将无法正常工作。 要将模块打开到 Guice，我们必须编辑`module_info.java`文件并插入`opens`关键字，指定需要注入的类的包。

# MasterMindHandler 类

我们已经开始了`MastermindHandler`类的列表，因为此类课程超过一百条线路，我将不会在这里将其作为整体纳入其中。 此类最重要的方法是`handle`：

```
public void handle(HttpServletRequest request,
                   HttpServletResponse response)
        throws ServletException, IOException {

    Game game = buildGameFromRequest(request);
    Guess newGuess = guesser.guess();
    response.setContentType("text/html");
    PrintWriter out = response.getWriter();
    if (game.isFinished() || newGuess == Guess.none) {
        displayGameOver(out);
    } else {
        log.debug("Adding new guess {} to the game", newGuess);
        game.addGuess(newGuess, 0, 0);
        displayGame(out);
    }
    bodyEnd(out);
}
```

我们执行三个步骤。 步骤 1 正在创建表，我们从请求中完成。 如果这不是游戏的开始，则已经有一个表，HTML 表单包含所有上一个猜测颜色和对这些的答案。 然后，作为第二步，我们基于该步骤创建新的猜测。 步骤 3 是将新的 HTML 页面发送到客户端。

同样，这不是一种现代方法，在 servlet 代码上创建 HTML，但使用 REST，JSON 和 JavaScript 展示纯粹的 servlet 功能，以及一些框架，将这一章只能使这一章一百页长，这绝对会转移 我们远离 Java 的注意力。

将 HTML 文本打印到`PrintWriter`不是本书这一点应该是新的东西; 因此，我们不会在此列出该代码。 您可以从 packt github 存储库下载工作示例。 我们将专注于 Servlet 参数处理。

请求参数通过`getParameter()`方法可用，返回参数的字符串值。 此方法假定任何参数，它是`GET`或`POST`，仅在请求中仅出现一次。 如果有多次出现的参数，则该值应该是`String`数组。 在这种情况下，我们应该使用`getParameterMap()`，返回整个映射与`String`键和`String[]`值。 即使我们这个时候没有多个键的值，我们也知道键的值作为`POST`参数，我们仍将使用后一种方法。 原因是我们稍后将使用会话存储这些值，并且我们希望在这种情况下具有可重用的方法。

要达到该阶段，我们将请求的`Map<String,String[]>`转换为`Map<String,String>`：

```
private Game buildGameFromRequest(HttpServletRequest request) {
    return buildGameFromMap(toMap(request));
}

private Map<String, String> toMap(HttpServletRequest request) {
    log.debug("converting request to map");
    return request.getParameterMap().entrySet().
            stream().collect(
            Collectors.toMap(
                    Map.Entry::getKey,
                    e -> e.getValue()[0]));
}
```

然后，我们使用该地图重新创建游戏：

```
private Game buildGameFromMap(Map<String, String> params) {
    var secret = new Guess(new Color[NR_COLUMNS]);
    var game = new Game(table, secret);
    for (int row = 0;
         params.containsKey(html.paramNameGuess(row, 0));
         row++) {
        Color[] colors = getRowColors(params, row);
        Guess guess = new Guess(colors);
        var full = Integer.parseInt(params.get(html.paramNameFull(row)));
        var partial = Integer.parseInt(params.get(html.paramNamePartial(row)));
        log.debug("Adding guess to game");
        game.addGuess(guess, full, partial);
    }
    return game;
}
```

从`String`到`int`的转换是通过方法`parseInt()`完成的。 当输入不是数字时，此方法抛出`NumberFormatException`。 尝试运行游戏，使用浏览器，并查看码头在 servlet 抛出异常时如何处理这种情况。 您在潜在黑客使用的浏览器中看到了多少宝贵信息？ 修复代码，使其再次询问用户，如果其中任何数字不是很好的格式化！

# 在服务器上存储状态

应用程序状态通常不会保存在客户端上。 除了您编写教育代码并想要演示如何不执行此操作之外，可能存在一些特例。 通常，与实际使用相关的应用程序的状态存储在会话对象或某些数据库中。 当应用程序要求用户输入大量数据时，这尤其重要，并且如果在客户端计算机中存在一些打嗝，则不希望用户丢失工作。

您花了很多时间在在线商店中选择相应的项目，选择合适的项目，共同努力，创建新模型飞机的配置，以及您家中的所有停电。 如果状态存储在客户端上，则必须从头开始。 如果状态存储在服务器上，则状态将保存到磁盘; 通过电池支持的电源供给服务器，并且当您重新启动时，您的客户机和电源回到您家中，您登录并奇迹般地，您的购物篮中的物品都在那里。 好吧，这不是一个奇迹; 它是网络编程。

在我们的情况下，第二个版本将在会话中存储游戏的状态。 这将让用户在会话就会恢复游戏。 如果用户退出并重新启动浏览器，会话丢失，并且可以启动新游戏。

由于不需要在此时间发送实际颜色并在隐藏的字段中匹配，因此 HTML 生成已修改一下，因此生成的 HTML 也会更简单：

```
<html>
<head>
    <link rel="stylesheet" type="text/css" href="colors.css">
    <title>Mastermind guessing</title>
<body>
<form method="POST" action="master">
    <div class="color3"></div>
    <div class="spacer"></div>
    <div class="color2"></div>
    <div class="spacer"></div>
    <div class="color1"></div>
    <div class="spacer"></div>
    <div class="color0"></div>
    <div class="spacer"></div>
0
    <div class="spacer"></div>
2
    <div class="color5"></div>
...
    <div class="spacer"></div>
    <div class="color1"></div>
    <div class="spacer"></div>
    <input type="text" name="full2" value="0" size="1">
    <input type="text" name="partial2" value="0" size="1">
    <input type="submit" value="submit">
</form></body></head></html>
```

完整和部分匹配的颜色的数量显示为简单的数字，因此此版本不允许*作弊*或修改先前的结果。 （这些是具有 CSS 类`spacer`的`div`标记之后的数字`0`和`2`。）

`MastermindHandler`中的`handle`方法也会更改，如以下代码所示：

```
public void handle(HttpServletRequest request,
                   HttpServletResponse response)
        throws ServletException, IOException {

    Game game = buildGameFromSessionAndRequest(request);
    Guess newGuess = guesser.guess();
    response.setContentType("text/html");
    PrintWriter out = response.getWriter();
    if (game.isFinished() || newGuess == Guess.none) {
        displayGameOver(out);
    } else {
        log.debug("Adding new guess {} to the game", newGuess);
        game.addGuess(newGuess, 0, 0);
        sessionSaver.save(request.getSession()); // note the added line
        displayGame(out);
    }
    bodyEnd(out);
}
```

变量`sessionSaver`是具有类型`SessionSaver`的字段，它由 guice 喷射器注入类中。 `SessionSaver`是我们创建的类。 此类将当前`Table`转换为存储在会话中的某些内容，并且还将表中的数据从存储在会话中的数据重新创建。 `handle`方法使用`buildGameFromSessionAndRequest`方法恢复表，并添加用户刚刚在请求中提供的完整和部分匹配答案。 当该方法创建新猜测并将其填写在表中时，并且还将其发送到响应中的客户端，它通过通过`sessionSaver`对象调用`save()`方法来节省会话中的状态。

`buildGameFromSessionAndRequest`方法替换了我们命名的其他版本`buildGameFromRequest`：

```
private Game buildGameFromSessionAndRequest(HttpServletRequest request) {
    var game = buildGameFromMap(sessionSaver.restore(request.getSession()));
    var params = toMap(request);
    int row = getLastRowIndex(params);
    log.debug("last row is {}", row);
    if (row >= 0) {
        var full = Integer.parseInt(params.get(html.paramNameFull(row)));
        var partial = Integer.parseInt(params.get(html.paramNamePartial(row)));
        log.debug("setting full {} and partial {} for row {}", full, partial, row);
        table.setPartial(row, partial);
        table.setFull(row, full);
        if (full == table.nrOfColumns()) {
            game.setFinished();
        }
    }
    return game;
}
```

请注意，此版本具有在 JDK 中的`Integer`类中使用`parseInt()`方法的疾病，这些疾病抛出异常。

# GamesEsionSaver 类

此类有三种公共方法：

*   `save()`：这将表保存到用户会话中
*   `restore()`：从用户会话中获取表
*   `reset()`：这删除了可能在会话中的任何表

该类的代码如下：

```
public class GameSessionSaver {
    private static final String STATE_NAME = "GAME_STATE";
    @Inject
    private HtmlTools html;
    @Inject
    Table table;
    @Inject
    ColorManager manager;

    public void save(HttpSession session) {
        var params = convertTableToMap();
        session.setAttribute(STATE_NAME, params);
    }

    public void reset(HttpSession session) {
        session.removeAttribute(STATE_NAME);
    }

    public Map<String, String> restore(HttpSession session) {
        return (Map<String, String>)
                Optional.ofNullable(session.getAttribute(STATE_NAME))
                        .orElse(new HashMap<>());
    }

    private Map<String, String> convertTableToMap() {
        var params = new HashMap<String, String>();
        for (int row = 0; row < table.nrOfRows(); row++) {
            for (int column = 0;
                 column < table.nrOfColumns();
                 column++) {
                params.put(html.paramNameGuess(row, column),
                        table.getColor(row, column).toString());
            }
            params.put(html.paramNameFull(row),
                    "" + table.getFull(row));
            params.put(html.paramNamePartial(row),
                    "" + table.getPartial(row));
        }
        return params;
    }
}
```

当我们保存会话并将表转换为地图时，我们使用`HashMap`。 在这种情况下实现很重要。 `HashMap`类实现`Serializable`界面; 因此，我们可以安全地进入会议。 单独的这种情况并不能保证`HashMap`中的一切是`Serializable`。 键和案例中的值是字符串，幸运的是，`String`类还实现了`Serializable`界面。 这样，转换的`HashMap`对象可以安全地存储在会话中。

另请注意，虽然序列化可能很慢，但在会话中存储`HashMap`频繁地实​​现了自己的序列化机制。 优化此实现，避免序列化取决于地图的内部结构。

现在是时候考虑在这个类中有`convertTableToMap()`方法和`MastermindHandler`中的`buildGameFromMap()`。 将游戏和表格转换为`Map`，另一方面应该一起实现。 它们只是两个相同转换的方向。 另一方面，`Table`的实现应该使用`Serializable`的`Map`版本。 这与会话处理非常相关。 通常，转换`Map`对象一般到一个`Table`对象是一个级别更高，从它存储的位置恢复表 - 客户端，会话，数据库或云的水分。 会话存储只是一个可能的实现，并且方法应该在满足抽象级别的类中实现。 最好的解决方案可以在单独的类中实现这些问题。 你有功课！

`reset()`方法不在处理程序中使用。 从`Mastermind`类中调用此，即 servlet 类以重置游戏，当我们启动它时：

```
public void doGet(HttpServletRequest request,
                  HttpServletResponse response)
        throws ServletException, IOException {
    var sessionSaver = new GameSessionSaver();
    sessionSaver.reset(request.getSession());
    doPost(request, response);
}
```

如果没有这个，每次想在我们退出浏览器之前就可以再次启动完成的游戏一次，只会显示完成的游戏，直到我们退出浏览器并在浏览器的高级菜单中的某处明确删除`JSESSIONID` cookie。 调用`reset`不会删除会话。 会话保持不变，因此也是`JSESSIONID` cookie 的值，但是从 servlet 容器维护的会话对象中删除游戏。

# 运行 jetty web servlet

由于我们已将 Jetty 插件包含在我们的 Gradle Build 中，因此可以使用插件的目标。 启动 Jetty 与键入以下内容一样简单：

```
gradle appRun
```

这将编译代码，构建 WAR 文件，并启动 Jetty Servlet 容器。 要帮助我们记住，它还在命令行上打印以下内容：

```
Running at http://localhost:8080//hello
```

我们可以打开此 URL 并查看游戏的打开屏幕，颜色是作为第一猜测创建的程序：

![](img/49fa4e7c-64d8-4ba6-8a91-73604503f2c4.png)

现在，是时候享受一些乐趣和游戏，给出了该计划的答案。 代码不要让它轻松！ 请参阅以下屏幕截图：

![](img/05bcf6ca-8690-432d-b48b-6167ae468a68.png)

与此同时，如果您查看所输入的控制台`gradle appRun`，您将看到代码正在打印出日志消息，如以下屏幕截图所示：

![](img/744ce854-5a85-43ed-aa4b-879982a3e3c9.png)

这些打印输出通过我们在代码中的记录器来源。 在前一章中，我们使用`System.out.println()`方法调用向控制台发送信息邮件。 这是在任何程序中不应遵循的练习，这些程序比 *hello world* 更复杂。

# 记录

有几种可用于 Java 的日志记录框架，每个记录框架都具有优势和缺点。 在`java.util.logging`封装中有一个内置的 JDK 中，`System.Logger`和`System.LoggerFinder`类中的`System.getLogger()`方法支持符号。 即使`java.util.logging`自 JDK 1.4 以来，Java 已用 Java，很多程序都使用其他日志解决方案。 除了内置日志记录外，我们还必须提及`log4j`，`slf4j`和 Apache Commons 日志记录。 在进入不同框架的详细信息之前，让我们讨论为什么要使用日志记录而不是仅打印到标准输出非常重要。

# 可配置性

最重要的原因是可配置性和易用性。 我们使用日志记录来记录有关代码操作的信息。 这不是应用程序的核心功能，但有一个可以操作的程序是不可避免的。 有些消息我们打印出日志，操作人员可以使用，以识别环境问题。 例如，当抛出`IOException`并记录时，操作可以查看日志并标识磁盘已满。 它们可能删除文件，或添加新磁盘并扩展分区。 没有日志，唯一的信息将是程序不起作用。

日志也使用多次来捕捉错误。 一些错误在测试环境中没有明显，并且非常难以重现。 在这种情况下，打印出关于执行代码的详细信息的日志是找到一些错误的根本原因的唯一来源。

由于日志记录需要 CPU，IO 带宽和其他资源，因此应仔细检查有关何时记录的。 这项检查和决定可以在编程过程中完成，事实上，如果我们使用`System.out.println`以进行记录，这是唯一可能性。 如果我们需要找到一个错误，我们应该记录很多。 如果我们记录很多，系统的性能将下降。 结论是，我们只应该在需要时记录。 如果系统中有一个无法再现的错误，开发人员会要求操作在短时间内打开调试日志记录。 使用`System.out.println`使用时，不可能在打开和关闭不同部分的日志记录时。 打开调试级别日志时，性能可能会下降一段时间，但同时，日志可用于分析。

同时，如果有一个小（几百兆字节）日志文件而不是大量 2 GB，我们必须找到相关的日志行（并且您不知道的日志行，则分析更简单 压缩日志文件以查找行。

使用日志记录框架，您可以定义标识日志消息源和日志级别的记录器。 字符串通常标识记录器，并且常常使用创建日志消息的类的名称。 这是一个常见的做法，不同的日志框架提供了获取课程本身而不是其名称的工厂类，以获取记录器。

在不同的日志记录框架中可能的日志级别可能略有不同，但最重要的级别如下：

*   `FATAL`：当日志消息涉及阻止程序继续执行时的错误时使用。
*   `ERROR`：当存在严重错误时使用这一点，但即使是最有可能的，该程序仍然可以运作。
*   `WARNING`：当存在一个不是直接问题的条件时使用这一点，但如果没有参加，可能会导致错误; 例如，程序识别磁盘接近完整，某些数据库连接在限制内应答，但接近超时值，以及类似情况。
*   `INFO`：这用于创建有关可能有趣的正常操作的消息，以便操作，并且不是错误或警告。 这些消息可以帮助调试操作环境设置的操作。
*   `DEBUG`：这用于记录有关该程序的信息（希望）足够详细以在代码中找到错误。 诀窍是，当我们将日志语句放入代码时，我们不知道它可能是什么错误。 如果我们知道，修复它会更好。
*   `TRACE`：这是关于执行代码的更详细信息。

日志框架通常使用配置文件配置。 配置可能会限制日志记录，从而关闭某些级别。 在正常操作环境中，前三个级别通常接通，并且在真正需要时接通`INFO`，`DEBUG`和`TRACE`。 也可以仅对某些记录器开启和关闭某些级别。 如果我们知道错误肯定在`GameSessionSaver`类中，那么我们可以打开该类的`DEBUG`级别。

日志文件还可能包含我们未直接代码的其他信息，并且打印到标准输出非常麻烦。 通常，每个日志消息包含创建消息的精确时间，记录器的名称，以及在许多情况下，线程的标识符。 想象一下，如果你被迫将所有这一切放入每个`println`的争论; 你可能很快就会写一些额外的课程来做到这一点。 别！ 它已经完成了专业 - 它是记录器框架。

记录器也可以配置为将消息发送到不同的位置。 登录控制台只是一种可能性。 记录框架准备向文件，数据库，Windows 事件记录器，syslog 服务或任何其他目标发送消息。 这种灵活性，要打印的消息，要打印的额外信息以及将 Logger Framework 在单个责任原理中分离为几个类的不同任务来达到额外信息。

记录器框架通常包含创建日志的记录器，格式化从原始日志信息格式化消息，通常增加诸如线程 ID 和时间戳的信息，以及将格式化消息附加到目的地的附加器。 这些类实现了日志记录框架中定义的接口，除了书的大小中，只能停止我们创建自己的格式化器和附录。

配置日志时，将 Appenders 和 Gradatters 配置为授予实现它们的类。 因此，当您想向特殊目的地发送一些日志时，您不仅限于框架的作者提供的附录。 对于不同的日志记录框架，有很多独立的开源项目为不同的目标提供了附加器。

# 表现

使用记录框架的第二个原因是性能。 虽然在我们配置了代码（过早优化）之前，但使用已知的方法，但是使用速度的方法是不好的，虽然可以慢慢地将多条线路插入我们的性能关键代码，但调用慢速方法也不是真正的专业。 使用完善的高度优化的框架，这种方式是行业最佳实践不应该是值得怀疑的。

使用`System.out.println()`将消息发送到流并仅在完成 IO 操作时返回。 使用实际记录将信息处理到记录器，并允许符号异步执行记录，并且它不等待完成。

如果存在系统故障，则日志信息可能会丢失日志信息真的是一个缺点，但考虑到恰好发生的事情以及工资表现的另一边，这通常不是严重的问题。 如果磁盘已满时有丢失的调试日志行，我们会丢失什么，在任何情况下渲染系统无法使用？

此审核日志记录有一个例外 - 当有关系统交易的某些日志信息必须保存为法律原因，以便审核操作和实际事务。 在这种情况下，日志信息以事务方式保存，使得事务的日志部分。 因为这是一个完全不同的要求，所以审计日志记录通常不会与这些框架中的任何一个进行。

此外，`System.out.println()`不同步，因此，不同的线程可能只是摇动输出。 日志框架注重此问题。

# 日志框架

最广泛使用的日志记录框架是 **apache** **log4j** 。 它目前有一个第二版本，它是第一个版本的总重写。 它是非常通用的，有许多附录和格式化人。 log4j 的配置可以是 XML 或属性文件格式，也可以通过 API 配置。

log4j 版本 1 的作者创建了一个新的日志记录框架 - **slf4j** 。 此日志记录库本质上是一种可以与任何其他日志记录框架一起使用的外立面。 因此，当您在您开发的库中使用 SLF4J 时，您的代码被添加到程序中作为使用不同日志记录框架的依赖项，很容易配置 SLF4J 将日志发送到其他框架的记录器。 因此，日志将被处理在一起而不是在单独的文件中，这是为了降低操作成本而期望的。 开发库代码或使用 SLF4J 的应用程序时，无需选择另一个日志记录框架到 SLF4J。 它有自己的简单实现，称为 Backlog。

Apache Commons Logging 也是一个外立面，如果没有其他任何内容失败了。 SLF4J 的主要区别在于它在配置中更灵活，使用底层日志记录，它实现了一个运行时算法，以发现哪些日志记录框架可用且要使用。 行业最佳实践表明，这种灵活性也是不需要更高的复杂性和成本。

# Java Logging.

Java 自版本 9 以来包括用于日志记录的外墙实现。 它的应用很简单，我们可以期望伐木框架很快就会开始支持这个外观。 这个立面内置于 JDK 的事实有两个主要优势：

*   想要记录的库不再需要在任何日志记录框架或记录外观上具有任何依赖性。 无论如何，唯一的依赖性就是 jdk logfaçade。
*   记录自己使用此外观的 JDK 库，因此，它们将登录与应用程序相同的日志文件。

如果我们使用带有 JDK 提供的 LoggingFaçade，`ColorManager`类的开始将更改为以下内容：

```
package packt.java11.mastermind;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.lang.System.Logger;

import static java.lang.System.Logger.Level.DEBUG;

@Singleton
public class ColorManager {
    protected final int nrColors;
    protected final Map<Color, Color> successor = new HashMap<>();
    private Color first;
    private final ColorFactory factory;
    private static final Logger log
            = System.getLogger(ColorManager.class.getName());

    @Inject
    public ColorManager(@Named("nrColors") int nrColors,
                        ColorFactory factory) {
        log.log(DEBUG, "creating colorManager for {0} colors", nrColors);
        this.nrColors = nrColors;
        this.factory = factory;
        createOrdering();
    }

    private Color[] createColors() {
        var colors = new Color[nrColors];
        for (int i = 0; i < colors.length; i++) {
            colors[i] = factory.newColor();
        }
        return colors;
    }

    private void createOrdering() {
        var colors = createColors();
        first = colors[0];
        for (int i = 0; i < nrColors - 1; i++) {
            successor.put(colors[i], colors[i + 1]);
        }
    }

    public Color firstColor() {
        return first;
    }

    public boolean thereIsNextColor(Color color) {
        return successor.containsKey(color);
    }

    public Color nextColor(Color color) {
        return successor.get(color);
    }
}
```

在此版本中，我们不会导入 SLF4J 类。 相反，我们导入`java.lang.System.Logger`类。

请注意，由于从`java.lang`包自动导入的类，我们无需导入系统类。 对于`System`类中嵌套类的类别不正确。

要访问记录器，请调用静态方法`System.getLogger()`。 此方法查找可用的实际记录器，并返回一个我们作为参数传递的名称。 没有版本的`getLogger()`方法，它接受类作为参数。 如果我们想坚持“会议”，那么我们必须写入`ColorManager.class.getName()`以获取类的名称，或者我们可以将类的名称写在那里。 第二种方法具有缺点，即它不会遵循类的名称的变更。 智能 IDES，如 Intellij，Eclipse 或 NetBeans，自动将引用重命名为类，但它们具有较难的时间，在字符串中使用类的名称。

`System.Logger`接口不会声明熟悉其他日志框架和外观的便利方法`error`，`debug`，`warning`等。 只有一个名为`log()`的方法，此方法的第一个参数是我们问题的实际日志的级别。 定义了八个级别 - `ALL`，`TRACE`，`DEBUG`，`INFO`，`WARNING`，`ERROR,`和`OFF`。 创建日志消息时，我们应该使用中间六个级别之一。 `ALL`和`OFF`仅用于将其传递给`isLoggable()`方法。 此方法可用于检查是否已记录实际的日志级别。 例如，如果级别设置为`INFO`，则不会打印与`DEBUG`或`TRACE`发送的消息。

实际实现使用 JDK 使用服务加载器功能。 日志实现必须在模块中通过一些实现提供`java.lang.System.LoggerFinder`界面。 换句话说，模块应该具有实现`LoggerFinder`界面的类，`module-info.java`应该声明哪个类使用代码：

```
provides java.lang.System.LoggerFinder with
                            packt.java11.MyLoggerFinder;
```

`MyLoggerFinder`类必须使用`getLogger()`方法扩展`LoggerFinder`抽象类。

# 伐木练习

伐木的做法非常简单。 如果您不想花费太多时间尝试使用不同的日志处理，并且您没有特定的要求，那么只需使用 SLF4J，将 JAR 添加到依赖项列表中作为编译依赖项，并开始使用源代码中的日志记录 。

由于日志记录不是实例 - 特定的，并且记录器实现线程安全性，我们通常使用的日志对象存储在`static`字段中，并且由于只要使用类，因此使用它们，该字段也是`final` 。 例如，使用 SLF4J 外观，我们可以使用以下命令获取记录器：

```
private static final Logger log =
           LoggerFactory.getLogger(MastermindHandler.class);
```

要获取记录器，使用 Logger Factory，刚刚创建记录器或返回已有的 Logger。

变量的名称通常是`log`或`logger,`，但如果看到`LOG`或`LOGGER`，则不会感到惊讶。 updocing 变量名称的原因是某些静态代码分析检查器将`static final`变量视为常量，因为它们确实是常量，并且 Java 社区中的“公约”是为这些变量使用大写名称。 这是一个味道; 通常，`log`和`logger`用于小写。

要创建日志项，`trace()`，`debug()`，`info()`，`warn()`和`error()`方法将创建具有相应级别的消息，因为名称暗示。 例如，考虑以下代码行：

```
log.debug("Adding new guess {} to the game", newGuess);
```

它创建了一个调试消息。 SLF4j 支持使用`{}`文字内部字符串格式化。 这样，无需从小部分附加字符串，并且如果实际日志项目未发送到日志目标，格式将不会执行。 如果我们在任何形式中使用`String`连接以将字符串传递为参数，则即使不需要按照示例而不期望调试日志记录，将发生格式。

日志记录方法还具有仅获取两个 Arguments-A `String`消息和`Throwable`的版本。 在这种情况下，日志记录框架将处理异常和堆栈跟踪的输出。 如果在异常处理代码中记录某些内容，请记录异常并让记录器格式化。

# 其他技术

我们讨论了 Servlet 技术，一些 JavaScript，HTML 和 CSS。 在真实的专业环境中编程时，通常使用这些技术。 然而，创建应用程序的用户界面并不总是基于这些技术。 旧的操作系统 - 本机 GUI 应用程序，以及 Swing，AWT 和 SWT，使用不同的方法来创建 UI。 它们从程序代码中建立了面向用户的 UI，并且 UI 构建为组件的层次结构。 当 Web 编程启动时，Java 开发人员对这些和项目创建了尝试隐藏 Web 技术层的框架的技术有经验。

值得一提的一个值得一提的是 Google Web Toolkit，它实现了服务器以及 Java 中的浏览器代码，但由于浏览器中没有实现 Java 环境，因此它将代码的客户端从 Java 转换为 JavaScript。 两年前在 2014 年之前创建了最新的 Toolkit 发布，从那时起，谷歌已发布了支持本机 JavaScript，HTML 和 CSS 客户端开发的其他类型的 Web 编程工具包。

**Vaadin** 也是一个工具包，你可能会遇到。 它允许您在 Java 中的服务器上编写 GUI 代码。 它基于 GWT 的顶部，并且是商业支持的。 如果有可用的开发人员可以在 Java 中具有 GUI 开发的经验，但不在 Web 原生技术的情况下，这可能是一个不错的选择，并且应用程序不需要在客户端上进行特殊可用性调整。 典型的 Intranet 公司应用程序可以选择它作为一种技术。

**JavaServer Faces** （ **JSF** ）是一种技术，它试图将应用程序的客户端开发卸载，从提供准备使用的小部件和服务器端的开发人员。 它是几个 **Java 规范请求**（ **JSR** ）的集合，并且有几种实现。 组件及其关系在 XML 文件中配置，服务器创建客户端本机代码。 在这项技术中，Java 到 JavaScript 没有仲裁。 它更像是使用有限但大量的小部件，限制了仅限于那些的，并放弃了 Web 浏览器的直接编程。 但是，如果他们有经验和知识，他们可以在 HTML，CSS 和 JavaScript 中创建新的小部件。

还有许多其他技术是为了支持 Java 中的 Web 应用程序而开发。 大多数大玩家主张所倡导的现代方法是使用单独的工具集和方法开发服务器端和客户端，并使用 REST 通信连接两个。

# 概括

在本章中，您了解了 Web 编程的结构。 如果没有了解 TCP / IP 网络的基础知识，这是不可能的，这是互联网的协议。 它的应用级别协议是 HTTP，目前在一个非常新的版本中，2.0，它已经由 servlet 标准版本 4.0 支持。 我们创建了一个 MasterMind 游戏的版本，这次可以使用浏览器真正播放，我们可以使用 Jetty 在开发环境中启动。 我们审查了如何存储游戏状态并实现两个版本。 最后，我们学习了伐木的基础知识，我们看着其他技术。 与此同时，我们还研究了 Google 的依赖注入实现顾问，我们研究了如何在引擎盖下工作，以及为什么以及如何使用它。

在本章之后，您将能够在 Java 中开始开发 Web 应用程序，并将了解此类程序的体系结构。 当您开始使用 Spring Framework 开始学习如何编程 Web 应用程序时，您将了解引擎盖下的内容，它隐藏了 Web 编程的许多复杂性。