# 功能性风格编程 - 深度潜水

本章包括 22 个涉及 Java 功能式编程的问题。 在这里，我们将专注于涉及在流中遇到的经典操作的几个问题（例如`filter`和`map`），并讨论无限流，空安全流和默认方法。 此综合问题列表将涵盖分组，分区和收集器，包括 JDK 12 `teeing()`收集器并编写自定义收集器。 此外，还将讨论`takeWhile()`，`dropWhile()`，作曲功能，谓词和比较器，测试和调试 Lambdas 以及其他很酷的主题。

一旦您介绍了此次和上一章，您就可以在生产应用程序上释放功能式编程。 以下问题将为您提供广泛的用例，包括角落案例或陷阱。

# 问题

使用以下问题来测试功能样式编程实力。 我强烈建议您在转向解决方案并下载示例程序之前尝试举出每个问题：

177.  **测试高阶函数**：写几个单元测试，以测试所谓的高阶函数。
178.  **使用 Lambdas** 的测试方法：为使用 Lambdas 的测试方法写几个单元测试。
179.  **调试 lambdas** ：提供调试 Lambdas 的技术。
180.  **过滤流的非零元素**：写入滤除流的非零元素的流流水线。
181.  **无限流，** `takeWhile()`，**和** `dropWhile()`：写几个代码代码，它与无限流合作。 此外，写入与`takeWhile()`和`dropWhile()` API 一起使用的几个例子。
182.  **映射流**：通过`map()`和`flatMap()`写入映射流的几个例子。
183.  **在 Stream** 中找到不同的元素：写一个用于在流中查找不同元素的程序。
184.  **匹配流中的不同元素**：写一个程序，用于匹配流中的不同元素。
185.  **sum，max 和 min 中的流**：写一个通过原始专用`Stream`和`Stream.reduce()`的原始专用来计算用于计算给定流的总和。
186.  **收集流的结果**：写几个代码片段，用于收集列表，映射和设置的流的结果。
187.  **加入流的结果**：写几个代码片段，以将流的结果加入`String`。
188.  **摘要收集器**：写几个代码片段以揭示摘要收集器的使用情况。
189.  **分组**：编写用于处理`groupingBy()`收集器的代码片段。
190.  **分区**：写几个代码片段以与`partitioningBy()`收集器一起使用。
191.  **过滤，扁平化和映射收集器**：写几个代码片段，以示例用于滤波，扁平化和映射收集器的使用。
192.  **teeing** ：写几个合并两个收集器结果的示例（JDK 12 和`Collectors.teeing()`）。
193.  **编写自定义收集器**：写一个表示自定义收集器的程序。
194.  **方法参考**：写入方法引用的示例。
195.  **流的并行处理流**：提供流的并行处理的简要概述。 为`parallelStream()`，`parallel()`和`spliterator()`提供至少一个示例。
196.  **null-safe streams** ：写一个从元素或元素集合返回空安全流的程序。
197.  **作曲函数，谓词和**比较器：写几个用于构思功能，谓词和比较器的示例。
198.  **默认方法**：写一个包含`default`方法的接口。

# 解决方案

以下部分描述了前述问题的解决方案。 请记住，几乎不是一个正确的方法来解决特定问题。 另外，请记住，这里所示的解释仅包括解决问题所需的最有趣和最重要的细节。 您可以下载示例解决方案以查看其他详细信息并与 [https://github.com/packtpublishing/java-coding-problems 的程序进行实验](https://github.com/PacktPublishing/Java-Coding-Problems)。

# 177.测试高阶函数

a *高阶函数*是一个术语，用于表征返回函数的函数或用作参数的函数。

基于此声明，在 Lambdas 的上下文中测试高阶功能应涵盖两个主要情况：

*   测试将 Lambda 作为参数的方法
*   测试返回功能界面的方法

我们将在即将到来的部分中了解这两个测试。

# 测试将 Lambda 作为参数的方法

通过将不同的 LAMBDA 传递给此方法，测试将 Lambda 作为参数的方法测试。 例如，让我们假设我们有以下功能界面：

```
@FunctionalInterface
public interface Replacer<String> {
  String replace(String s);
}
```

我们还假设我们有一种方法，它需要`String -> String`类型的 lambdas，如下所示：

```
public static List<String> replace(
    List<String> list, Replacer<String> r) {

  List<String> result = new ArrayList<>();
  for (String s: list) {
    result.add(r.replace(s));
  }

  return result;
}
```

现在，让我们使用两个 lambdas 为此方法写一个 JUnit 测试：

```
@Test
public void testReplacer() throws Exception {

  List<String> names = Arrays.asList(
    "Ann a 15", "Mir el 28", "D oru 33");

  List<String> resultWs = replace(
    names, (String s) -> s.replaceAll("\\s", ""));
  List<String> resultNr = replace(
    names, (String s) -> s.replaceAll("\\d", ""));

  assertEquals(Arrays.asList(
    "Anna15", "Mirel28", "Doru33"), resultWs);
  assertEquals(Arrays.asList(
    "Ann a ", "Mir el ", "D oru "), resultNr);
}
```

# 测试返回功能界面的方法

另一方面，测试返回功能界面的方法可以解释为测试该功能界面的行为。 让我们考虑以下方法：

```
public static Function<String, String> reduceStrings(
    Function<String, String> ...functions) {

  Function<String, String> function = Stream.of(functions)
    .reduce(Function.identity(), Function::andThen);

  return function;
}
```

现在，我们可以测试返回`Function<String, String>`的行为，如下所示：

```
@Test
public void testReduceStrings() throws Exception {

  Function<String, String> f1 = (String s) -> s.toUpperCase();
  Function<String, String> f2 = (String s) -> s.concat(" DONE");

  Function<String, String> f = reduceStrings(f1, f2);

  assertEquals("TEST DONE", f.apply("test"));
}
```

# 178.测试方法使用 lambdas

让我们首先测试一个没有用方法包裹的 lambda。 例如，以下 Lambda 与字段相关联（用于重用），并且我们希望测试其逻辑：

```
public static final Function<String, String> firstAndLastChar
  = (String s) -> String.valueOf(s.charAt(0))
    + String.valueOf(s.charAt(s.length() - 1));
```

让我们考虑一个 Lambda 生成功能界面的实例; 然后，我们可以测试该实例的行为，如下所示：

```
@Test
public void testFirstAndLastChar() throws Exception {

  String text = "Lambda";
  String result = firstAndLastChar.apply(text);
  assertEquals("La", result);
}
```

另一种解决方案包括将 Lambda 包装在方法调用和写入单元测试中，以便进行方法调用。

通常，λ在方法内使用。 对于大多数情况而言，测试包含 Lambda 的方法是可以接受的，但是在我们想要测试 Lambda 本身时存在案例。 解决此问题的解决方案包括三个主要步骤：

1.  提取`static`方法中的 LAMBDA
2.  用*方法参考*更换 LAMBDA
3.  测试此`static`方法

例如，让我们考虑以下方法：

```
public List<String> rndStringFromStrings(List<String> strs) {

  return strs.stream()
    .map(str -> {
      Random rnd = new Random();
      int nr = rnd.nextInt(str.length());
      String ch = String.valueOf(str.charAt(nr));

      return ch;
    })
    .collect(Collectors.toList());
}
```

我们的目标是从这种方法测试 Lambda：

```
str -> {
  Random rnd = new Random();
  int nr = rnd.nextInt(str.length());
  String ch = String.valueOf(str.charAt(nr));

  return ch;
})
```

所以，让我们应用前三个步骤：

1.  让我们在`static`方法中提取此 lambda：

```
public static String extractCharacter(String str) {

  Random rnd = new Random();
  int nr = rnd.nextInt(str.length());
  String chAsStr = String.valueOf(str.charAt(nr));

  return chAsStr;
}
```

2.  让我们用相应的方法参考替换 Lambda：

```
public List<String> rndStringFromStrings(List<String> strs) {

  return strs.stream()
    .map(StringOperations::extractCharacter)
    .collect(Collectors.toList());
}
```

3.  让我们测试`static`方法（这是 Lambda）：

```
@Test
public void testRndStringFromStrings() throws Exception {

  String str1 = "Some";
  String str2 = "random";
  String str3 = "text";

  String result1 = extractCharacter(str1);
  String result2 = extractCharacter(str2);
  String result3 = extractCharacter(str3);

  assertEquals(result1.length(), 1);
  assertEquals(result2.length(), 1);
  assertEquals(result3.length(), 1);
  assertThat(str1, containsString(result1));
  assertThat(str2, containsString(result2));
  assertThat(str3, containsString(result3));
}
```

建议避免具有多行代码的 Lambdas。 因此，通过遵循前面的技术，Lambdas 易于测试。

# 179.调试 Lambdas.

调试 Lambdas 时至少有三种解决方案：

*   检查堆栈跟踪
*   记录
*   依赖 IDE 支持（例如，NetBeans，Eclipse 和 Intellij Idea 支持调试 Lambdas *框*或为其提供插件）

让我们专注于前两个，因为依靠 IDE 是一个非常大的和具体的主题，它不是本书的范围。

检查λ或流管道内发生的故障的堆栈迹线可能是非常令人费解的。 让我们考虑以下代码片段：

```
List<String> names = Arrays.asList("anna", "bob", null, "mary");

names.stream()
  .map(s -> s.toUpperCase())
  .collect(Collectors.toList());
```

由于此列表中的第三个元素是`null`，我们将获得`NullPointerException`，以及定义流管道的整个呼叫序列是公开的，如以下屏幕截图所示：

![](img/1d5f65be-2910-42da-8f79-11ba3fa54a2f.png)

突出的线告诉我们，此`NullPointerException`在命名为`lambda$main$5`的 Lambda 表达式内部发生。 此名称由编译器组成，因为 lambdas 没有名字。 此外，我们不知道哪个元素是`null`。

因此，我们可以得出结论，报告 Lambda 或流管道内部失败的堆栈迹线并不是非常直观。

或者，我们可以尝试记录输出。 这将有助于我们调试流中的操作管道。 这可以通过`forEach()`方法来完成：

```
List<String> list = List.of("anna", "bob",
  "christian", "carmen", "rick", "carla");

list.stream()
  .filter(s -> s.startsWith("c"))
  .map(String::toUpperCase)
  .sorted()
  .forEach(System.out::println);
```

这将为我们提供以下输出：

```
CARLA
CARMEN
CHRISTIAN
```

在某些情况下，这种技术可能是有用的。 当然，我们必须记住，`forEach()`是终端操作，因此流将被消耗。 由于流只能被消耗一次，因此这可能是一个问题。

此外，如果我们向列表中添加`null`值，则输出将再次变化。

更好的替代方案包括依赖于`peek()`方法。 这是一种中间操作，它在当前元素上执行特定动作，并将元素转发到流水线中的下一个操作。 下图显示了工作中的`peek()`操作：

![](img/3417a264-ab2a-4d7e-a0c7-e1c999a487a7.png)

让我们在代码表单中看到它：

```
System.out.println("After:");

names.stream()
  .peek(p -> System.out.println("\tstream(): " + p))
  .filter(s -> s.startsWith("c"))
  .peek(p -> System.out.println("\tfilter(): " + p))
  .map(String::toUpperCase)
  .peek(p -> System.out.println("\tmap(): " + p))
  .sorted()
  .peek(p -> System.out.println("\tsorted(): " + p))
  .collect(Collectors.toList());
```

以下是我们可能会收到的输出的示例：

![](img/ac5b81df-0a34-4fc7-90db-62e813798c01.png)

现在，让我们有意地将`null`值添加到列表中并再次运行：

```
List<String> names = Arrays.asList("anna", "bob", 
  "christian", null, "carmen", "rick", "carla");
```

在向列表中添加`null`值后，获得了以下输出：

![](img/2a4b5c75-e4c9-41f5-9cd7-fcb8b592cbcf.png)

这次，我们可以看到应用`stream()`后发生`null`值。 由于`stream()`是第一个操作，我们可以轻松弄清楚错误驻留在列表内容中。

# 180.过滤流的非零元素

在[第 8 章](08.html)，*功能样式编程 - 基本原理和设计模式*中，在*中写作功能接口[h​​tg8]部分，我们定义了基于功能界面的`filter()`方法 命名为`Predicate`。 Java Stream API 已经具有这样的方法，功能界面称为`java.util.function.Predicate`。*

让我们假设我们有以下`List`的整数：

```
List<Integer> ints = Arrays.asList(1, 2, -4, 0, 2, 0, -1, 14, 0, -1);
```

流媒体此列表并仅完成非零元素可以完成如下：

```
List<Integer> result = ints.stream()
  .filter(i -> i != 0)
  .collect(Collectors.toList());
```

生成的列表将包含以下元素：1,2，-4,2，-1,14，-1

下图显示了`filter()`如何在内部工作：

![](img/50aeef03-4be8-43bd-a3db-7b158a66880e.png)

请注意，对于几种常见操作，Java Stream API 已经提供了中间操作的*。 因此，不需要提供`Predicate`。 其中一些操作如下：*

*   `distinct()`：从流中删除重复项
*   `skip(*n*)`：丢弃第一个 *N* 元素
*   `limit(*s*)`：截断流长度不超过 *s*
*   `sorted()`：根据自然秩序对流进行排序
*   `sorted(Comparator<? super T> comparator)`：根据给定的`Comparator`对流进行排序

让我们将这些操作和`filter()`添加到一个例子。 我们将过滤零，过滤器重复，跳过 1 值，将剩余流截断到两个元素，并按自然顺序排序它们：

```
List<Integer> result = ints.stream()
  .filter(i -> i != 0)
  .distinct()
  .skip(1)
  .limit(2)
  .sorted()
  .collect(Collectors.toList());
```

生成的列表将包含以下两个元素： **-4** 和 **2** 。

下图显示了该流管道如何在内部工作：

![](img/0c7d98fc-4e96-404d-b908-df834912a2b3.png)

当`filter()`操作需要复杂/化合物或长条件时，建议在辅助`static`方法中提取它，并依赖于*方法参考*。 因此，避免这样的东西：

```
List<Integer> result = ints.stream()
  .filter(value -> value > 0 && value < 10 && value % 2 == 0)
  .collect(Collectors.toList());
```

您应该更喜欢这样的东西（`Numbers`是包含辅助方法的类：

```
List<Integer> result = ints.stream()
  .filter(Numbers::evenBetween0And10)
  .collect(Collectors.toList());

private static boolean evenBetween0And10(int value) {
  return value > 0 && value < 10 && value % 2 == 0;
}
```

# 181.无限流，upothlile（）和 dropwhile（）

在这个问题的第一部分，我们将讨论无限流。 在第二部分中，我们将讨论`takeWhile()`和`dropWhile()` API。

无限制流是无限期创建数据的流。 因为溪流是懒惰的，他们可以是无限的。 更精确地，完成无限流作为中间操作，因此在执行流水线的终端操作之前没有创建数据。

例如，以下代码理论上将永远运行。 此行为由`forEach()`终端操作触发，由缺少约束或限制引起：

```
Stream.iterate(1, i -> i + 1)
  .forEach(System.out::println);
```

Java Stream API 允许我们以多种方式创建和操作无限流，因为您很快就会看到。

此外，取决于所定义的*遇到顺序*，A `Stream`可以是或*无序*。 流是否具有*遇到顺序*取决于数据源和中间操作。 例如，具有`List`作为其源的`Stream`被排序，因为`List`具有内在的排序。 另一方面，具有`Set`作为其源的`Stream`是无序的，因为`Set`不保证订单。 一些中间操作（例如，`sorted()`）可以向无序的`Stream`施加顺序，而一些终端操作（例如，`forEach()`）可以忽略遇到顺序。**

通常，顺序流的性能通过排序而微不足道地影响，但根据所应用的操作，并行流的性能可能受到有序`Stream`的存在显着影响。

不要将`Collection.stream().forEach()`与`Collection.forEach()`混淆。 虽然`Collection.forEach()`可以通过依靠集合的迭代器（如果有）来保持订单，但是未定义的`Collection.stream().forEach()`订单。 例如，通过`list.forEach()`迭代`List`处理插入顺序中的元素，而`list.parallelStream().forEach()`在每个运行时产生不同的结果。 通常，如果不需要流，则通过`Collection.forEach()`迭代集合。

我们可以通过`BaseStream.unordered()`将有序流转换为无序流，如下例所示：

```
List<Integer> list 
  = Arrays.asList(1, 4, 20, 15, 2, 17, 5, 22, 31, 16);

Stream<Integer> unorderedStream = list.stream()
  .unordered();
```

# 无限顺序排序流

可以通过`Stream.iterate​(T seed, UnaryOperator<T> f)`获得无限的顺序排序流。 得到的流从指定的种子开始，并继续通过将`f`函数应用于先前元素（例如，`n`元素是`f(n-1)`）。

例如，可以如下创建 1,2,3，...，n 的整数流，如下：

```
Stream<Integer> infStream = Stream.iterate(1, i -> i + 1);
```

此外，我们可以为各种目的使用此流。 例如，让我们使用它来获取前 10 个偶数整数的列表：

```
List<Integer> result = infStream
  .filter(i -> i % 2 == 0)
  .limit(10)
  .collect(Collectors.toList());
```

`List`内容将如下（请注意，无限流将创建元素 1,2,3，...，20，但只有以下元素匹配我们的滤波器，直到达到 10 个元素的限制）：

```
2, 4, 6, 8, 10, 12, 14, 16, 18, 20
```

注意存在`limit()`中间操作。 它的存在是强制性的; 否则，代码将无限期地运行。 我们必须明确丢弃流; 换句话说，我们必须明确地指定应在最终列表中收集匹配我们的过滤器的元素。 一旦达到限制，丢弃无限流。

但是，假设我们不希望第一个 10 甚至整数的列表，并且我们实际上希望甚至整数列表，直到 10（或任何其他限制）。 从 JDK 9 开始，我们可以通过新的`Stream.iterate()`的新风味来塑造这种行为。 这种风味允许我们将`hasNext`谓词直接嵌入到流声明中（`iterate​(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next)`）。 一旦`hasNext`谓词返回`false`，流终止了：

```
Stream<Integer> infStream = Stream.iterate(
  1, i -> i <= 10, i -> i + 1);
```

这一次，我们可以删除`limit()`中间操作，因为我们的`hasNext`谓词施加了 10 个元素的限制：

```
List<Integer> result = infStream
  .filter(i -> i % 2 == 0)
  .collect(Collectors.toList());
```

生成的`List`如下（符合我们的`hasNext`谓词，无限流创建元素 1,2,3，...，10，但只有以下五个元素匹配我们的流过滤器）：

```
2, 4, 6, 8, 10
```

当然，我们可以将这种味道与`Stream.iterate()`和`limit()`结合在一起更复杂的情景。 例如，以下流将创建新元素，直到 *vert* 谓词，`i -> i <= 10`。 由于我们使用随机值，因此`hasNext`谓词将返回`false`的那一刻是非定值：

```
Stream<Integer> infStream = Stream.iterate(
  1, i -> i <= 10, i -> i + i % 2 == 0 
    ? new Random().nextInt(20) : -1 * new Random().nextInt(10));
```

此流的一个可能的输出如下：

```
1, -5, -4, -7, -4, -2, -8, -8, ..., 3, 0, 4, -7, -6, 10, ...
```

现在，以下管道将收集通过`infStream`创建的 25 个数字：

```
List<Integer> result = infStream
  .limit(25)
  .collect(Collectors.toList());
```

现在，无限流可以从两个地方丢弃。 如果`hasNext`谓词返回`false`，直到我们收集 25 个元素，那么我们仍然存在于当时的收集元素（小于 25）。 如果`hasNext`谓词不会返回`false`，直到我们收集 25 个元素，那么`limit()`操作将丢弃其余流。

# 无限制的伪随机值

如果我们想创建无限制的伪随机值，我们可以依赖于`Random`的方法，例如`ints()`，`longs()`和`doubles()`。 例如，可以如下声明伪随机整数值的无限制流（所生成的整数将在[1,100]范围内）：

```
IntStream rndInfStream = new Random().ints(1, 100);
```

尝试获取 10 个即使是伪随机整数值的列表可以依赖此流：

```
List<Integer> result = rndInfStream
  .filter(i -> i % 2 == 0)
  .limit(10)
  .boxed()
  .collect(Collectors.toList());
```

一个可能的输出如下：

```
8, 24, 82, 42, 90, 18, 26, 96, 86, 86
```

这一次，它难以说出在收集上述列表之前实际生成了多少个数字。

另一种`ints()`的味道是`ints​(long streamSize, int randomNumberOrigin, int randomNumberBound)`。 第一个参数允许我们指定应生成多少个伪随机值。 例如，以下流将在[1,100]范围内生成 10 个值：

```
IntStream rndInfStream = new Random().ints(10, 1, 100);
```

我们可以从这 10 个中获取偶数值，如下所示：

```
List<Integer> result = rndInfStream
  .filter(i -> i % 2 == 0)
  .boxed()
  .collect(Collectors.toList());
```

一个可能的输出如下：

```
80, 28, 60, 54
```

我们可以将此示例用作生成固定长度的随机字符串的基础，如下所示：

```
IntStream rndInfStream = new Random().ints(20, 48, 126);
String result = rndInfStream
  .mapToObj(n -> String.valueOf((char) n))
  .collect(Collectors.joining());
```

一个可能的输出如下：

```
AIW?F1obl3KPKMItqY8>
```

`Stream.ints()` comes with two more flavors: one that doesn't take any argument (an unlimited stream of integers) and another that takes a single argument representing the number of values that should be generated, that is, `ints​(long streamSize)`.

# 无限顺序无序流

为了创建无限顺序无序流，我们可以依赖于`Stream.generate​(Supplier<? extends T> s)`。 在这种情况下，每个元素由提供的`Supplier`生成。 这适用于生成恒定流，随机元素流等。

例如，让我们假设我们有一个简单的帮助程序，可以生成八个字符的密码：

```
private static String randomPassword() {

  String chars = "abcd0123!@#$";

  return new SecureRandom().ints(8, 0, chars.length())
    .mapToObj(i -> String.valueOf(chars.charAt(i)))
    .collect(Collectors.joining());
}
```

此外，我们希望定义一个无限的顺序无序流，返回随机密码（`Main`是包含前后帮助程序的类）：

```
Supplier<String> passwordSupplier = Main::randomPassword;
Stream<String> passwordStream = Stream.generate(passwordSupplier);
```

此时，`passwordStream`可以无限期地创建密码。 但让我们创建 10 个这样的密码：

```
List<String> result = passwordStream
  .limit(10)
  .collect(Collectors.toList());
```

一个可能的输出如下：

```
213c1b1c, 2badc$21, d33321d$, @a0dc323, 3!1aa!dc, 0a3##@3!, $!b2#1d@, 0@0#dd$#, cb$12d2@, d2@@cc@d
```

# 虽然谓词返回真实

从 JDK 9 开始的`Stream`类中添加到`Stream`类的最有用方法之一是`takeWhile​(Predicate<? super T> predicate)`。 此方法具有两个不同的行为，如下所示：

*   如果排序流，则返回由匹配给定谓词匹配的此流的*的元素*的最长前缀组成的流。
*   如果流是无序的，并且此流的某些（但不是全部）该流的元素匹配给定的谓词，那么该操作的行为是非法的; 它可以自由地采用任何匹配元素（包括空集）的子集。

在有序`Stream`的情况下，*元素的最长前缀*是与给定谓词匹配的流的连续元素序列。

请注意，一旦给定的谓词返回`false`，将丢弃剩余流。

例如，获取 10 个整数的列表可以如下完成：

```
List<Integer> result = IntStream
  .iterate(1, i -> i + 1)
  .takeWhile(i -> i <= 10)
  .boxed()
  .collect(Collectors.toList());
```

这将为我们提供以下输出：

```
1, 2, 3, 4, 5, 6, 7, 8, 9, 10
```

或者，我们可以在第一个生成的值小于 50 时获取随机偶数整数的`List`：

```
List<Integer> result = new Random().ints(1, 100)
  .filter(i -> i % 2 == 0)
  .takeWhile(i -> i >= 50)
  .boxed()
  .collect(Collectors.toList());
```

我们甚至可以加入`takeWhile()`的谓词：

```
List<Integer> result = new Random().ints(1, 100)
  .takeWhile(i -> i % 2 == 0 && i >= 50)
  .boxed()
  .collect(Collectors.toList());
```

可以如下获得一种可能的输出（也可以是空的）：

```
64, 76, 54, 68
```

如何获取随机密码的`List`，直到第一个生成的密码不包含`!`字符？

嗯，基于我们之前列出的帮助者，我们可以这样做：

```
List<String> result = Stream.generate(Main::randomPassword)
  .takeWhile(s -> s.contains("!"))
  .collect(Collectors.toList());
```

可以如下获得一种可能的输出（也可以是空的）：

```
0!dac!3c, 2!$!b2ac, 1d12ba1!
```

现在，让我们假设我们有一个无序的整数流。 以下代码片段采用小于或等于 10 的元素子集：

```
Set<Integer> setOfInts = new HashSet<>(
  Arrays.asList(1, 4, 3, 52, 9, 40, 5, 2, 31, 8));

List<Integer> result = setOfInts.stream()
  .takeWhile(i -> i<= 10)
  .collect(Collectors.toList());
```

一个可能的输出如下（请记住，对于无序流，结果是非正式的）：

```
1, 3, 4
```

# 删除谓词返回真实

从 JDK 9 开始，我们还有`Stream.dropWhile​(Predicate<? super T> predicate)`方法。 这种方法与`takeWhile()`相反。 在给定的谓词返回`false`之前，而不是占用元素，而是丢弃元素，直到给定的元素返回`false`，并包括返回的流中的其余元素：

*   如果排序流，则返回丢弃与给定谓词匹配的的*最长前缀之后由此流的剩余元素组成的流。*
*   如果流是无序的，并且此流的某些（但不是全部）该流的元素匹配给定的谓词，那么该操作的行为是非法的; 它可以自由地删除任何匹配元素的子集（包括空集）。

在有序`Stream`的情况下，元素的*最长前缀*是匹配给定谓词的流的连续元素序列。

例如，让我们在第一个 10 下降后收集 5 个整数：

```
List<Integer> result = IntStream
  .iterate(1, i -> i + 1)
  .dropWhile(i -> i <= 10)
  .limit(5)
  .boxed()
  .collect(Collectors.toList());
```

这将始终提供以下输出：

```
11, 12, 13, 14, 15
```

或者，我们可以提取五个随机的偶数整数大于 50（至少，这是我们可能认为代码的）：

```
List<Integer> result = new Random().ints(1, 100)
  .filter(i -> i % 2 == 0)
  .dropWhile(i -> i < 50)
  .limit(5)
  .boxed()
  .collect(Collectors.toList());
```

一个可能的输出如下：

```
78, 16, 4, 94, 26
```

但为什么 16 和 4 有？ 他们甚至是，但不超过 50！ 好吧，他们是在那里，因为他们在第一个元素之后出现，这失败了谓词。 主要是，我们正在丢弃值，而它们小于 50（`dropWhile(i -> i < 50)`）。 78 值将失败这一谓词，因此`dropWhile`结束了其工作。 此外，所有生成的元素都包含在结果中，直到`limit(5)`采取动作。

让我们看看另一个类似的陷阱。 让我们获取包含`!`字符的五个随机密码的`List`（至少，这是我们可能认为代码的）：

```
List<String> result = Stream.generate(Main::randomPassword)
  .dropWhile(s -> !s.contains("!"))
  .limit(5)
  .collect(Collectors.toList());
```

一个可能的输出如下：

```
bab2!3dd, c2@$1acc, $c1c@cb@, !b21$cdc, #b103c21
```

再次，我们可以看到不包含`!`字符的密码。 `bab2!3dd`密码将失败我们的谓词，最终将在最终结果（`List`）中。 将四个生成的密码添加到结果，而不会受到`dropWhile()`的影响。

现在，让我们假设我们有一个无序的整数流。 以下代码片段丢弃了小于或等于 10 的元素的子集，并保持其余部分：

```
Set<Integer> setOfInts = new HashSet<>(
  Arrays.asList(5, 42, 3, 2, 11, 1, 6, 55, 9, 7));

List<Integer> result = setOfInts.stream()
  .dropWhile(i -> i <= 10)
  .collect(Collectors.toList());
```

一个可能的输出如下（请记住，对于无序流，结果是非正式的）：

```
55, 7, 9, 42, 11
```

如果所有元素都匹配给定的谓词，那么`takeWhile()`需要和`dropWhile()`丢弃所有元素（如果流订购或无序，则无关紧要）。 另一方面，如果没有元素匹配给定的谓词，则`takeWhile()`只需要（返回空流）和`dropWhile()`丢弃（返回流）。

避免在并行流的上下文中使用`take` / `dropWhile()`，因为它们是昂贵的操作，尤其是有序流。 如果它适用于这种情况，那么只需通过`BaseStream.unordered()`删除排序约束。

# 182.映射流的元素

映射流的元素是通过将给定函数应用于每个元素并在新的`Stream`中累积结果（例如，）来将*将*将转换为它们的新版本的中间操作。 将`Stream<String>`转换为`Stream<Integer>`，或将`Stream<String>`转换为另一个`Stream<String>`，等等）。

# 使用 Stream.map（）

基本上，我们调用`Stream.map​(Function<? super T,​? extends R> mapper)`在流的每个元素上应用`mapper`函数。 结果是一个新的`Stream`。 它不会修改源`Stream`。

让我们假设我们有以下`Melon`类：

```
public class Melon {

  private String type;
  private int weight;

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}
```

我们还需要假设我们有`List<Melon>`：

```
List<Melon> melons = Arrays.asList(new Melon("Gac", 2000),
  new Melon("Hemi", 1600), new Melon("Gac", 3000),
  new Melon("Apollo", 2000), new Melon("Horned", 1700));
```

此外，我们希望仅在另一个列表中提取甜瓜的名称`List<String>`。

对于此任务，我们可以依赖`map()`，如下所示：

```
List<String> melonNames = melons.stream()
  .map(Melon::getType)
  .collect(Collectors.toList());
```

输出将包含以下类型的甜瓜：

```
Gac, Hemi, Gac, Apollo, Horned
```

下图描绘了`map()`如何为此示例工作：

![](img/000bb488-d1bd-46e4-aa28-2778c8608518.png)

因此，`map()`方法获取`Stream<Melon>`并输出`Stream<String>`。 每个`Melon`通过`map()`方法，该方法提取甜瓜的类型（这是一个`String`）并将其存储在另一个`Stream`中。

同样，我们可以提取甜瓜的重量。 由于权重是整数，因此`map()`方法将返回`Stream<Integer>`：

```
List<Integer> melonWeights = melons.stream()
  .map(Melon::getWeight)
  .collect(Collectors.toList());
```

输出将包含以下权重：

```
2000, 1600, 3000, 2000, 1700
```

除了`map()`之外，`Stream`类还为原语（如`mapToInt()`，`mapToLong()`和`mapToDouble()`提供了 Flavors。 这些方法返回`Stream`的`int`原始专业化`IntStream`，`long`原始专业化`Stream`（`LongStream`）和`double`原始专业技术`Stream`（`StreamDouble`） 。

虽然`map()`可以通过`Function`将`Stream`的元素映射到新的`Stream`，不要得出结论，我们可以执行以下操作：

```
List<Melon> lighterMelons = melons.stream()
  .map(m -> m.setWeight(m.getWeight() - 500))
  .collect(Collectors.toList());
```

这将无法正常运行/编译，因为`setWeight()`方法返回`void`。 为了使其工作，我们需要返回`Melon`，但这意味着我们必须添加一些敷衍代码（例如，`return`）：

```
List<Melon> lighterMelons = melons.stream()
  .map(m -> {
    m.setWeight(m.getWeight() - 500);

    return m;
  })
  .collect(Collectors.toList());
```

您如何看待`peek()`诱惑？ 嗯，`peek()`代表*外观，但不要触摸*，但它可以用于突变状态，如下：

```
List<Melon> lighterMelons = melons.stream()
  .peek(m -> m.setWeight(m.getWeight() - 500))
  .collect(Collectors.toList());
```

输出将包含以下瓜（这看起来不错）：

```
Gac(1500g), Hemi(1100g), Gac(2500g), Apollo(1500g), Horned(1200g)
```

这比使用`map()`更清晰。 调用`setWeight()`是我们计划变异状态的清晰信号，但文档指定传递给`peek()`的`Consumer`应该是*不干扰* action（不修改数据 流的来源）。

对于顺序流（例如前一），可以在没有副作用的情况下保持打破这种预期; 但是，对于并行流管道，问题可能变得更加复杂。

可以在任何时间内容并且在任何线程中都可以调用该动作，而该元素由上游操作提供，因此如果动作修改了共享状态，则负责提供所需的同步。

作为经验的规则，在使用`peek()`之前，请在使用`peek()`进行突变状态。 此外，请注意，这种做法是一个堕落的辩论，甚至是反模式雨伞。

# 使用 stream.flatmap（）

正如我们刚刚看到的那样，`map()`知道如何在`Stream`中包装一系列元素。

这意味着`map()`可以产生诸如`Stream<String[]>`，`Stream<List<String>>`，`Stream<Set<String>>`，甚至`Stream<Stream<R>>`的流。

但问题是通过流操作（如`sum()`，`distinct()`，`filter()`等）不能成功地操纵这些类型的流（或者，或者，我们预期）。

例如，让我们考虑以下数组`Melon`：

```
Melon[][] melonsArray = {
  {new Melon("Gac", 2000), new Melon("Hemi", 1600)}, 
  {new Melon("Gac", 2000), new Melon("Apollo", 2000)}, 
  {new Melon("Horned", 1700), new Melon("Hemi", 1600)}
};
```

我们可以通过`Arrays.stream()`播放此数组并将其包装在流中，如以下代码片段所示：

```
Stream<Melon[]> streamOfMelonsArray = Arrays.stream(melonsArray);
```

有许多其他方法可以获得阵列的`Stream`。 例如，如果我们有一个字符串，`s`，那么`map(s -> s.split(""))`将返回一个`Stream<String[]>`。

现在，我们可能认为获得 Distinct `Melon`实例足以调用`distinct()`，如下所示：

```
streamOfMelonsArray
  .distinct()
  .collect(Collectors.toList());
```

但这不会工作，因为`distinct()`不会寻找一个不同的`Melon`; 相反，它将查找一个不同的阵列`Melon[]`，因为这是我们在流中拥有的东西。

此外，在这种情况下返回的结果是`Stream<Melon[]>`类型，而不是`Stream<Melon>`类型。 最终结果将在`List<Melon[]>`中收集`Stream<Melon[]>`。

我们如何解决这个问题？

我们可以考虑应用`Arrays.stream()`以将`Melon[]`转换为`Stream<Melon>`：

```
streamOfMelonsArray
  .map(Arrays::stream) // Stream<Stream<Melon>>
  .distinct()
  .collect(Collectors.toList());
```

再次，`map()`不会做我们可能认为的事情。

首先，调用`Arrays.stream()`将从给定`Melon[]`中的每一个返回`Stream<Melon>`。 但是，`map()`返回元素的`Stream`，因此它将将`Arrays.stream()`应用于`Stream`。 它最终会在`Stream<Stream<Melon>>`中。

因此，这次，`distinct()`试图检测不同的`Stream<Melon>`元素：

![](img/368e3557-d155-4aae-bba2-c26bc0a960be.png)

为了解决这个问题，我们必须依赖`flatMap()`。 下图描绘了`flatMap()`如何在内部工作：

![](img/a59fe93d-cdd6-42f0-afc9-767558fcab8f.png)

与`map()`不同，此方法通过展平所有分隔的流来返回流。 因此，所有阵列都将在同一流中最终起来：

```
streamOfMelonsArray
  .flatMap(Arrays::stream) // Stream<Melon>
  .distinct()
  .collect(Collectors.toList());
```

输出将根据`Melon.equals()`实现，包含不同的瓜子：

```
Gac(2000g), Hemi(1600g), Apollo(2000g), Horned(1700g)
```

现在，让我们尝试另一个问题，以`List<List<String>>`开始，如下：

```
List<List<String>> melonLists = Arrays.asList(
  Arrays.asList("Gac", "Cantaloupe"),
  Arrays.asList("Hemi", "Gac", "Apollo"),
  Arrays.asList("Gac", "Hemi", "Cantaloupe"),
  Arrays.asList("Apollo"),
  Arrays.asList("Horned", "Hemi"),
  Arrays.asList("Hemi"));
```

我们试图从这个列表中获取甜瓜的不同名称。 如果可以通过`Arrays.stream()`将数组包装到流中，对于集合，我们有`Collection.stream()`。 因此，第一次尝试可能如下：

```
melonLists.stream()
  .map(Collection::stream)
  .distinct();
```

但基于以前的问题，我们已经知道这将不起作用，因为`map()`将返回`Stream<Stream<String>>`。

该解决方案由`flatMap()`提供，如下：

```
List<String> distinctNames = melonLists.stream()
  .flatMap(Collection::stream)
  .distinct()
  .collect(Collectors.toList());
```

输出如下：

```
Gac, Cantaloupe, Hemi, Apollo, Horned
```

除了`flatMap()`之外，`Stream`类还为原语（如`flatMapToInt()`，`flatMapToLong()`和`flatMapToDouble()`提供了 Flavors。 这些方法返回`Stream`的`int`原始专业化（`IntStream`），`long`原始专业化`Stream`（`LongStream`），`double`原始专业化`Stream`（`StreamDouble` ）。

# 183.在流中查找要素

除了使用`filter()`之外，它允许我们通过谓词过滤流的元素，我们可以通过`anyFirst()`和`findFirst()`在流中找到一个元素。

让我们假设我们有以下列表包裹在流中：

```
List<String> melons = Arrays.asList(
  "Gac", "Cantaloupe", "Hemi", "Gac", "Gac", 
    "Hemi", "Cantaloupe", "Horned", "Hemi", "Hemi");
```

# findany.

`findAny()`方法从流中返回任意（非识别型）元素。 例如，以下代码片段将从前面列表中返回一个元素：

```
Optional<String> anyMelon = melons.stream()
  .findAny();

if (!anyMelon.isEmpty()) {
  System.out.println("Any melon: " + anyMelon.get());
} else {
  System.out.println("No melon was found");
}
```

请注意，无法保证它将在每次执行时返回相同的元素。 在并行化流的情况下，此声明是真的。

我们也可以将`findAny()`与其他操作组合起来。 这是一个例子：

```
String anyApollo = melons.stream()
  .filter(m -> m.equals("Apollo"))
  .findAny()
  .orElse("nope");
```

这一次，结果将是`nope`。 列表中没有`Apollo`，因此`filter()`操作将产生空流。 此外，`findAny()`也会返回一个空流，因此`orElse()`将作为指定的字符串`nope`返回最终结果。

# findFirst.

如果`findAny()`返回任何元素，则`findFirst()`从流返回第一个元素。 显然，当我们仅在流的第一个元素中感兴趣的方法时，这种方法非常有用（例如，比赛的获胜者应该是竞争对手排序列表中的第一个元素）。

然而，如果流没有*遇到* *顺序*，则可以返回任何元素。 根据文档，*流可以或可能没有定义的遇到顺序。 这取决于源和中间操作*。 同样的规则也适用于并行性。

现在，让我们假设我们希望在列表中的第一个瓜：

```
Optional<String> firstMelon = melons.stream()
  .findFirst();

if (!firstMelon.isEmpty()) {
  System.out.println("First melon: " + firstMelon.get());
} else {
  System.out.println("No melon was found");
}
```

输出将如下：

```
First melon: Gac
```

我们也可以将`findFirst()`与其他操作组合起来。 这是一个例子：

```
String firstApollo = melons.stream()
  .filter(m -> m.equals("Apollo"))
  .findFirst()
  .orElse("nope");
```

这次，由于`filter()`将产生空流，结果将是`nope`。

以下是整数的另一个问题（只需遵循右侧评论即可快速发现流程）：

```
List<Integer> ints = Arrays.asList(4, 8, 4, 5, 5, 7);

int result = ints.stream()
  .map(x -> x * x - 1)     // 23, 63, 23, 24, 24, 48
  .filter(x -> x % 2 == 0) // 24, 24, 48
  .findFirst()             // 24
  .orElse(-1);
```

# 184.汇集溪流中的元素

要匹配`Stream`中的某些元素，我们可以依赖以下方法：

*   `anyMatch()`
*   `noneMatch()`
*   `allMatch()`

所有这些方法都需要`Predicate`作为参数，并获取`boolean`结果反对它。

这三个操作依赖于*短路*技术。 换句话说，在我们处理整个流之前，这些方法可能会返回。 例如，如果`allMatch()`匹配`false`（评估给定的`Predicate`为`false`），则没有理由继续。 最终结果是`false`。

让我们假设我们有以下列表包裹在流中：

```
List<String> melons = Arrays.asList(
  "Gac", "Cantaloupe", "Hemi", "Gac", "Gac", "Hemi", 
    "Cantaloupe", "Horned", "Hemi", "Hemi");
```

现在，让我们试着回答以下问题：

*   元素是否与`Gac`字符串匹配？ 让我们看一下以下代码：

```
boolean isAnyGac = melons.stream()
  .anyMatch(m -> m.equals("Gac")); // true
```

*   元素是否与`Apollo`字符串匹配？ 让我们看一下以下代码：

```
boolean isAnyApollo = melons.stream()
  .anyMatch(m -> m.equals("Apollo")); // false
```

作为一般问题 - 在具有给定谓词中的流中有一个元素吗？

*   没有元素匹配`Gac`字符串？ 让我们看一下以下代码：

```
boolean isNoneGac = melons.stream()
  .noneMatch(m -> m.equals("Gac")); // false
```

*   没有元素匹配`Apollo`字符串？ 让我们看一下以下代码：

```
boolean isNoneApollo = melons.stream()
  .noneMatch(m -> m.equals("Apollo")); // true
```

作为一般问题 - 在匹配给定谓词中是否没有元素？

*   所有元素是否符合`Gac`字符串？ 让我们看一下以下代码：

```
boolean areAllGac = melons.stream()
  .allMatch(m -> m.equals("Gac")); // false
```

*   所有元素都大于 2？ 让我们看一下以下代码：

```
boolean areAllLargerThan2 = melons.stream()
  .allMatch(m -> m.length() > 2);
```

作为一般问题 - DOM 流中的所有元素都匹配给定的谓词？

# 185.汇总，最大和最小值

让我们假设我们有以下`Melon`类：

```
public class Melon {

  private String type;
  private int weight;

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}
```

我们还假设我们在流中包裹的`Melon`列表：

```
List<Melon> melons = Arrays.asList(new Melon("Gac", 2000),
  new Melon("Hemi", 1600), new Melon("Gac", 3000),
  new Melon("Apollo", 2000), new Melon("Horned", 1700));
```

让我们使用`sum()`，`min()`和`max()`终端操作在`Melon`类上工作。

# sum（），min（）和 max（）终端操作

现在，让我们将此流的元素组合以表达以下查询：

*   我们如何计算甜瓜的总重量（`sum()`）？
*   什么是最重的甜瓜（`max()`）？
*   什么是最轻的甜瓜（`min()`）？

为了计算甜瓜的总重量，我们需要总结所有重量。 对于`Stream`（`IntStream`，`LongStream`等）的原始专业，Java 流 API 暴露了名为`sum()`的终端操作。 当其名称建议时，此方法总结了流的元素：

```
int total = melons.stream()
  .mapToInt(Melon::getWeight)
  .sum();
```

`sum()`之后，我们还具有`max()`和`min()`终端操作。 显然，`max()`返回流的最大值，而`min()`是相反的：

```
int max = melons.stream()
  .mapToInt(Melon::getWeight)
  .max()
  .orElse(-1);

int min = melons.stream()
  .mapToInt(Melon::getWeight)
  .min()
  .orElse(-1);
```

`max()`和`min()`操作返回`OptionalInt`（例如`OptionalLong`）。 如果无法计算最大值或最小值（例如，在空流的情况下），则选择返回`-1`。 由于我们正在使用权重，并且通过他们的性质，返回`-1`是有道理的。 但是不要把它作为规则。 根据这种情况，应返回另一个值，或者可能使用`orElseGet()` / `orElseThrow()`会更好。

对于非原始专业，请查看本章的*摘要收集器*部分。

让我们了解下一节中的减少。

# 减少

`sum()`，`max()`和`min()`称为*的特殊情况*。 通过*减少*，我们的意思是基于两个主要陈述的抽象：

*   占据初始值（`T`）
*   拿一个`BinaryOperator<T>`结合两个元素并产生一个新值

减少可以通过命名为`reduce()`的终端操作来完成，这遵循此抽象并定义两个签名（第二个不使用初始值）：

*   `T reduce​(T identity, BinaryOperator<T> accumulator)`
*   `Optional<T> reduce​(BinaryOperator<T> accumulator)`

有了这个，我们可以依靠`reduce()`终端操作来计算元素的和，如下所示（初始值为 0，并且 Lambda 是`(m1, m2) -> m1 + m2)`）：

```
int total = melons.stream()
  .map(Melon::getWeight)
  .reduce(0, (m1, m2) -> m1 + m2);
```

下图描绘了`reduce()`操作的工作原理：

![](img/e68d3bbb-1916-4c06-87ef-47fcca63edda.png)

那么，`reduce()`操作如何工作？

让我们来看看以下步骤来解决这个问题：

1.  首先，0 用作 Lambda（`m1`）的第一个参数，从流中消耗 2,000 并用作第二参数`(m2)`。 0 + 2000 生成 2000，这成为新的累计值。
2.  然后，用累积值和流的下一个元素再次调用 Lambda，其中 1,600 个产生新的累计值 3,600。
3.  向前移动，λ再次调用累积值和下一个元素，3,000，其产生 6,600。
4.  如果我们再次前进，则使用累积值和下一个元素，2,000 再次调用 lambda，该值为 8,600。
5.  最后，λ用 8,600 和溪流的最后一个元素调用，1,700，产生最终值 10,300。

还可以计算最大和最小值：

```
int max = melons.stream()
  .map(Melon::getWeight)
  .reduce(Integer::max)
  .orElse(-1);

int min = melons.stream()
  .map(Melon::getWeight)
  .reduce(Integer::min)
  .orElse(-1);
```

使用`reduce()`的优点是，我们可以通过简单地传递另一个λ轻松改变计算。 例如，我们可以快速更换与产品的总和，如下例所示：

```
List<Double> numbers = Arrays.asList(1.0d, 5.0d, 8.0d, 10.0d);

double total = numbers.stream()
  .reduce(1.0 d, (x1, x2) -> x1 * x2);
```

尽管如此，请注意可能导致不需要的结果的案例。 例如，如果我们想计算给定数字的谐波均值，那么没有*的*特殊情况*的特殊情况*，因此我们只能依赖于`reduce()` ， 如下：

```
List<Double> numbers = Arrays.asList(1.0d, 5.0d, 8.0d, 10.0d);
```

谐波平均公式如下：

![](img/d8c10384-922c-4c02-b3b5-663a638b9d71.png)

在我们的情况下， *n* 是列表的大小， *h* 为 2.80701。 使用 Naive `reduce()`功能将如下所示：

```
double hm = numbers.size() / numbers.stream()
  .reduce((x1, x2) -> (1.0d / x1 + 1.0d / x2))
  .orElseThrow();
```

这将产生 3.49809。

这种解释依赖于我们如何表达计算。 在第一步中，我们计算 1.0 / 1.0 + 1.0 / 5.0 = 1.2。 然后，我们可能希望执行 1.2 + 1.0 / 1.8，但实际上，计算为 1.0 / 1.2 + 1.0 / 1.8。 显然，这不是我们想要的。

我们可以使用`mapToDouble()`来解决此问题，如下所示：

```
double hm = numbers.size() / numbers.stream()
  .mapToDouble(x -> 1.0d / x)
  .reduce((x1, x2) -> (x1 + x2))
  .orElseThrow();
```

这将产生预期的结果，即 2.80701。

# 186.收集流的结果

让我们假设我们有以下`Melon`类：

```
public class Melon {

  private String type;
  private int weight;

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}
```

让我们也假设我们有`Melon`的`List`：

```
List<Melon> melons = Arrays.asList(new Melon("Crenshaw", 2000),
  new Melon("Hemi", 1600), new Melon("Gac", 3000),
  new Melon("Apollo", 2000), new Melon("Horned", 1700),
  new Melon("Gac", 3000), new Melon("Cantaloupe", 2600));
```

通常，流流水线最终有概述流中的元素。 换句话说，我们需要在诸如`List`，`Set`或`Map`（及其同伴）之类的数据结构中收集结果。

为了完成此任务，我们可以依赖`Stream.collect​(Collector<? super T,​A,​R> collector)`方法。 此方法获取表示`java.util.stream.Collector`或用户定义的`Collector`的单个参数。

最着名的收藏家包括以下内容：

*   `toList()`
*   `toSet()`
*   `toMap()`
*   `toCollection()`

他们的名字为自己说话。 让我们来看看几个例子：

*   过滤器甜瓜比 1,000g 重 1,000 克，并通过`toList()`和`toCollection()`收集`List`和`toCollection()`：

```
List<Integer> resultToList = melons.stream()
  .map(Melon::getWeight)
  .filter(x -> x >= 1000)
  .collect(Collectors.toList());

List<Integer> resultToList = melons.stream()
  .map(Melon::getWeight)
  .filter(x -> x >= 1000)
  .collect(Collectors.toCollection(ArrayList::new));
```

`toCollection()`方法的参数是一个`Supplier`，它提供了一个新的空`Collection`，结果将插入结果。

*   过滤膜比 1,000g 重 1,000 克，并通过`toSet()`和`toCollection()`在`Set`中没有重复的结果，并`toCollection()`：

```
Set<Integer> resultToSet = melons.stream()
  .map(Melon::getWeight)
  .filter(x -> x >= 1000)
  .collect(Collectors.toSet());

Set<Integer> resultToSet = melons.stream()
  .map(Melon::getWeight)
  .filter(x -> x >= 1000)
  .collect(Collectors.toCollection(HashSet::new));
```

*   过滤膜比 1000 克更重，收集结果而无需重复，并且通过`toCollection()`在`Set`中排序为升序：

```
Set<Integer> resultToSet = melons.stream()
  .map(Melon::getWeight)
  .filter(x -> x >= 1000)
  .collect(Collectors.toCollection(TreeSet::new));
```

*   过滤一个不同的`Melon`并通过`toMap()`收集`Map<String, Integer>`中的结果：

```
Map<String, Integer> resultToMap = melons.stream()
  .distinct()
  .collect(Collectors.toMap(Melon::getType, 
    Melon::getWeight));
```

`toMap()`方法的两个参数表示用于生成键的映射函数及其各自的值（如果两个`Melon`具有相同的密钥，则容易出现`java.lang.IllegalStateException`重复密钥异常）。

*   过滤一个不同的`Melon`，并使用随机键（如果生成两个相同的键），通过随机键（容易出现`java.lang.IllegalStateException`复制键）：

```
Map<Integer, Integer> resultToMap = melons.stream()
  .distinct()
  .map(x -> Map.entry(
    new Random().nextInt(Integer.MAX_VALUE), x.getWeight()))
  .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
```

*   通过`toMap()`在地图中收集`Melon`，并通过选择关键碰撞的情况下，通过选择现有（旧的）值来避免潜在的`java.lang.IllegalStateException`重复密钥：

```
Map<String, Integer> resultToMap = melons.stream()
  .collect(Collectors.toMap(Melon::getType, Melon::getWeight,
    (oldValue, newValue) -> oldValue));
```

`toMap()`方法的最后一个参数是合并功能，用于解析与`Map.merge(Object, Object, BiFunction)`相关联的与相同键相关的值之间的碰撞。

显然，可以使用`(oldValue, newValue) -> newValue`选择新值：

*   将前面的示例放入排序的`Map`（例如，按重量）：

```
Map<String, Integer> resultToMap = melons.stream()
 .sorted(Comparator.comparingInt(Melon::getWeight))
 .collect(Collectors.toMap(Melon::getType, Melon::getWeight,
   (oldValue, newValue) -> oldValue,
     LinkedHashMap::new));
```

此`toMap()` Flavor 的最后一个参数表示一个`Supplier`，它提供了一个新的空`Map`，在该空间中将插入结果。 在此示例中，需要该`Supplier`以在排序后保留订单。 由于`HashMap`不保证插入顺序，我们需要依赖`LinkedHashMap`。

*   通过`toMap()`收集单词频率计数：

```
String str = "Lorem Ipsum is simply 
              Ipsum Lorem not simply Ipsum";

Map<String, Integer> mapOfWords = Stream.of(str)
  .map(w -> w.split("\\s+"))
  .flatMap(Arrays::stream)
  .collect(Collectors.toMap(
    w -> w.toLowerCase(), w -> 1, Integer::sum));
```

除了`toList()`，`toMap()`和`toSet()`旁边，`Collectors`类还将收集器暴露于未经可拆卸和并发集合，例如`toUnmodifiableList()`，`toConcurrentMap()`等。

# 187.加入流的结果

让我们假设我们有以下`Melon`类：

```
public class Melon {

  private String type;
  private int weight;

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}
```

让我们也假设我们有`Melon`的`List`：

```
List<Melon> melons = Arrays.asList(new Melon("Crenshaw", 2000),
  new Melon("Hemi", 1600), new Melon("Gac", 3000),
  new Melon("Apollo", 2000), new Melon("Horned", 1700),
  new Melon("Gac", 3000), new Melon("Cantaloupe", 2600));
```

在以前的问题中，我们讨论了内置于`Collectors`中的`Stream` API。 在此类别中，我们也有`Collectors.joining()`。 这些收集器的目标是将流的元素连接到*遇到顺序*中的`String`。 可选地，这些收集器可以使用分隔符，前缀和后缀，因此最全面的`joining()`味道是`String joining​(CharSequence delimiter, CharSequence prefix, CharSequence suffix)`。

但是，如果我们想要的只是在没有分隔符的情况下连接甜瓜的名称，那么这就是要去的方式（只是为了有趣，让我们排序和删除重复项）：

```
String melonNames = melons.stream()
  .map(Melon::getType)
  .distinct()
  .sorted()
  .collect(Collectors.joining());
```

我们将收到以下输出：

```
ApolloCantaloupeCrenshawGacHemiHorned
```

更好的解决方案包括添加分隔符，例如逗号和空格：

```
String melonNames = melons.stream()
  ...
  .collect(Collectors.joining(", "));
```

我们将收到以下输出：

```
Apollo, Cantaloupe, Crenshaw, Gac, Hemi, Horned
```

我们还可以通过前缀和后缀来丰富输出：

```
String melonNames = melons.stream()
  ...
  .collect(Collectors.joining(", ", 
    "Available melons: ", " Thank you!"));
```

我们将收到以下输出：

```
Available melons: Apollo, Cantaloupe, Crenshaw, Gac, Hemi, Horned Thank you!
```

# 188.总结收集者

让我们假设我们拥有众所周知的`Melon`类（使用`type`和`weight`）和`Melon`的`List`：

```
List<Melon> melons = Arrays.asList(new Melon("Crenshaw", 2000),
  new Melon("Hemi", 1600), new Melon("Gac", 3000),
  new Melon("Apollo", 2000), new Melon("Horned", 1700),
  new Melon("Gac", 3000), new Melon("Cantaloupe", 2600));
```

Java `Stream` API 在*摘要*中的计数，总和，min，平均值和最大操作组。 专用于执行*摘要*操作的方法在`Collectors`类中找到。

我们将在以下部分中查看所有这些操作。

# 汇总

让我们假设我们想要总结所有的甜瓜。 我们通过`Stream`的原始专业技术在流部分中的*和 MIN 中完成了这一点。 现在，让我们通过`summingInt​(ToIntFunction<? super T> mapper)`收藏家来做：*

```
int sumWeightsGrams = melons.stream()
  .collect(Collectors.summingInt(Melon::getWeight));
```

因此，`Collectors.summingInt()`是一个工厂方法，它采用了一个能够将对象映射到必须求和为参数的`int`的函数。 返回收集器，通过`collect()`方法执行*摘要*。 下图描绘了如何`summingInt()`工作：

![](img/29b1ee07-f595-4c82-821a-af4776bf2edc.png)

在遍历流的同时，每个权重（`Melon::getWeight`）映射到其数量，并且此数量将从初始值开始，即 0 的从初始值中添加到累加器。

`summingInt()`之后，我们有`summingLong()`和`summingDouble()`。 我们如何总结龙以千克的重量？ 这可以通过`summingDouble()`完成，如下：

```
double sumWeightsKg = melons.stream()
  .collect(Collectors.summingDouble(
    m -> (double) m.getWeight() / 1000.0d));
```

如果我们只需要千克的结果，我们仍然可以在克中执行总和，如下：

```
double sumWeightsKg = melons.stream()
  .collect(Collectors.summingInt(Melon::getWeight)) / 1000.0d;
```

由于*摘要*实际上*减少*，`Collectors`类也提供了`reducing()`方法。 显然，这种方法具有更普遍的利用率，允许我们通过其三种口味提供各种 Lambdas：

*   `reducing​(BinaryOperator<T> op)`
*   `reducing​(T identity, BinaryOperator<T> op)`
*   `reducing​(U identity, Function<? super T,​? extends U> mapper, BinaryOperator<U> op)`

`reducing()`的论点非常简单。 我们具有减少的`identity`值（以及没有输入元素时返回的值），映射函数适用于每个输入值，以及用于减少映射值的函数。

例如，让我们通过`reducing()`重写代码前面的代码片段。 请注意，我们从 0 开始总和，通过映射函数将其从克转换为千克，并通过 Lambda 减少值（产生的千克）：

```
double sumWeightsKg = melons.stream()
  .collect(Collectors.reducing(0.0,
    m -> (double) m.getWeight() / 1000.0d, (m1, m2) -> m1 + m2));
```

或者，我们可以简单地转换为千克：

```
double sumWeightsKg = melons.stream()
  .collect(Collectors.reducing(0,
    m -> m.getWeight(), (m1, m2) -> m1 + m2)) / 1000.0d;
```

无论何时没有合适的内置解决方案，依赖于`reducing()`。 想想`reducing()`作为*广义摘要*。

# 平均

计算甜瓜的平均重量怎么样？

为此，我们有`Collectors.averagingInt()`，`averagingLong()`和`averagingDouble()`：

```
double avgWeights = melons.stream()
  .collect(Collectors.averagingInt(Melon::getWeight));
```

# 数数

计算一篇文本中的单词数是可以通过`count()`解决的常见问题：

```
String str = "Lorem Ipsum is simply dummy text ...";

long numberOfWords = Stream.of(str)
  .map(w -> w.split("\\s+"))
  .flatMap(Arrays::stream)
  .filter(w -> w.trim().length() != 0)
  .count();
```

但是，让我们看看我们的流中有 3,000 的`Melon`有多少：

```
long nrOfMelon = melons.stream()
  .filter(m -> m.getWeight() == 3000)
  .count();
```

我们可以使用`counting()`出厂方法返回的收集器：

```
long nrOfMelon = melons.stream()
  .filter(m -> m.getWeight() == 3000)
  .collect(Collectors.counting());
```

我们还可以使用使用`reducing()`的笨拙方法：

```
long nrOfMelon = melons.stream()
  .filter(m -> m.getWeight() == 3000)
  .collect(Collectors.reducing(0L, m -> 1L, Long::sum));
```

# 最大和最少

在流部分中的*和 MAX 中，我们已经通过`min()`和`max()`方法计算了最小值和最大值。 这一次，让我们通过`Collectors.maxBy()`和`Collectors.minBy()`收集器来计算最重和最轻的`Melon`。 这些收集器采用`Comparator`作为比较流中的元素的参数并返回`Optional`（如果流为空，则将`Optional`为空）：*

```
Comparator<Melon> byWeight = Comparator.comparing(Melon::getWeight);

Melon heaviestMelon = melons.stream()
  .collect(Collectors.maxBy(byWeight))
  .orElseThrow();

Melon lightestMelon = melons.stream()
  .collect(Collectors.minBy(byWeight))
  .orElseThrow();
```

在这种情况下，如果流是空的，我们只是扔`NoSuchElementException`。

# 得到所有人

有没有办法在单一的酉操作中获得计数，总和，平均，最小值和最大值？

就在这里！ 每当我们需要两个或更多这些操作中，我们都可以依赖于`Collectors.summarizingInt​()`，`summarizingLong()`和`summarizingDouble()`。 这些方法分别在`IntSummaryStatistics`，`LongSummaryStatistics`和`DoubleSummaryStatistics`中包装这些操作，如下所示：

```
IntSummaryStatistics melonWeightsStatistics = melons
  .stream().collect(Collectors.summarizingInt(Melon::getWeight));
```

打印此对象会产生以下输出：

```
IntSummaryStatistics{count=7, sum=15900, min=1600, average=2271.428571, max=3000}
```

对于这些操作中的每一个，我们有专用的吸气器：

```
int max = melonWeightsStatistics.getMax()
```

我们都完成了！ 现在，让我们谈谈流的分组元素。

# 189.分组

让我们假设我们有以下`Melon`类和`Melon`的`List`：

```
public class Melon {

  enum Sugar {
    LOW, MEDIUM, HIGH, UNKNOWN
  }

  private final String type;
  private final int weight;
  private final Sugar sugar;

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}

List<Melon> melons = Arrays.asList(
  new Melon("Crenshaw", 1200),
  new Melon("Gac", 3000), new Melon("Hemi", 2600),
  new Melon("Hemi", 1600), new Melon("Gac", 1200),
  new Melon("Apollo", 2600), new Melon("Horned", 1700),
  new Melon("Gac", 3000), new Melon("Hemi", 2600)
);
```

Java `Stream` API 通过`Collectors.groupingBy()`将与 SQL `GROUP BY`子句相同的功能。

虽然 SQL `GROUP BY`子句适用于数据库表，但 HTG1]适用于流的元素。

换句话说，`groupingBy()`方法能够与某些区别特征分组元素。 在流和功能式编程（Java 8）之前，通过一堆 *spaghetti* 代码将这些任务应用于繁琐，冗长和容易出错的收集。 从 Java 8 开始，我们有*分组收集器*。

让我们来看看下一节中的单级别分组和多级分组。 我们将从单级分组开始。

# 单级分组

所有分组收集器都有一个*分类函数*（将流的元素分类为不同组的函数）。 主要是，这是`Function<T, R>`功能界面的实例。

流（`T`类型）的每个元素通过此功能，返回将是*分类器对象*（`R`类型）。 所有返回的`R`类型表示`Map<K, V>`的键（`K`），每个组是此`Map<K, V>`中的值。

换句话说，密钥（`K`）是分类函数返回的值，并且该值（`V`）是具有该分类值的流中的元素列表（`K`）。 因此，最终结果是`Map<K, List<T>>`类型。

让我们来看看一个例子来带一些光线到这个脑戏弄的解释。 此示例依赖于`groupingBy()`的最简单风味，即`groupingBy​(Function<? super T,​? extends K> classifier)`。

所以，通过类型组群组`Melon`：

```
Map<String, List<Melon>> byTypeInList = melons.stream()
  .collect(groupingBy(Melon::getType));
```

输出将如下：

```
{
  Crenshaw = [Crenshaw(1200 g)],
  Apollo = [Apollo(2600 g)],
  Gac = [Gac(3000 g), Gac(1200 g), Gac(3000 g)],
  Hemi = [Hemi(2600 g), Hemi(1600 g), Hemi(2600 g)],
  Horned = [Horned(1700 g)]
}
```

我们还可以按重量组进行`Melon`：

```
Map<Integer, List<Melon>> byWeightInList = melons.stream()
  .collect(groupingBy(Melon::getWeight));
```

输出将如下：

```
{
  1600 = [Hemi(1600 g)],
  1200 = [Crenshaw(1200 g), Gac(1200 g)],
  1700 = [Horned(1700 g)],
  2600 = [Hemi(2600 g), Apollo(2600 g), Hemi(2600 g)],
  3000 = [Gac(3000 g), Gac(3000 g)]
}
```

此分组如下图所示。 更确切地说，这是当`Gac(1200 g)`通过分类函数时的时刻的快照（`Melon::getWeight`）：

![](img/f66eb284-6695-44a3-83c3-f787b1cd75a3.png)

因此，在甜瓜分类示例中，密钥是`Melon`的权重，其值是包含该权重的所有`Melon`对象的列表。

分类功能可以是方法参考或任何其他 Lambda。

前面方法的一个问题是存在不需要的重复。 这发生是因为在`List`中收集了值（例如，`3000=[Gac(3000g), Gac(3000g)`）。 但我们可以通过依靠另一种`groupingBy()`的味道来解决这个问题，即`groupingBy​(Function<? super T,​? extends K> classifier, Collector<? super T,​A,​D> downstream)`。

这次，我们可以将所需的下游收集器指定为第二个参数。 因此，除了分类功能外，我们也有一个下游收集器。

如果我们希望拒绝重复，我们可以使用`Collectors.toSet()`，如下所示：

```
Map<String, Set<Melon>> byTypeInSet = melons.stream()
  .collect(groupingBy(Melon::getType, toSet()));
```

输出如下：

```
{
  Crenshaw = [Crenshaw(1200 g)],
  Apollo = [Apollo(2600 g)],
  Gac = [Gac(1200 g), Gac(3000 g)],
  Hemi = [Hemi(2600 g), Hemi(1600 g)],
  Horned = [Horned(1700 g)]
}
```

我们也可以重量来做到这一点：

```
Map<Integer, Set<Melon>> byWeightInSet = melons.stream()
  .collect(groupingBy(Melon::getWeight, toSet()));
```

输出将如下：

```
{
  1600 = [Hemi(1600 g)],
  1200 = [Gac(1200 g), Crenshaw(1200 g)],
  1700 = [Horned(1700 g)],
  2600 = [Hemi(2600 g), Apollo(2600 g)],
  3000 = [Gac(3000 g)]
}
```

当然，在这种情况下，也可以使用`distinct()`：

```
Map<String, List<Melon>> byTypeInList = melons.stream()
  .distinct()
  .collect(groupingBy(Melon::getType));
```

通过重量来实现这一目标：

```
Map<Integer, List<Melon>> byWeightInList = melons.stream()
  .distinct()
  .collect(groupingBy(Melon::getWeight));
```

好吧，没有更多的重复项，但结果未订购。 使用键订购此地图是很好的，因此默认`HashMap`不是很有用。 如果我们可以指定`TreeMap`而不是默认`HashMap`，则问题将被解决。 我们可以通过另一种`groupingBy()`的味道来完成这件事，即`groupingBy​(Function<? super T,​? extends K> classifier, Supplier<M> mapFactory, Collector<? super T,​A,​D> downstream)`。

此风味的第二个论点允许我们提供一个提供新的空`Map`的`Supplier`对象，结果将插入结果：

```
Map<Integer, Set<Melon>> byWeightInSetOrdered = melons.stream()
  .collect(groupingBy(Melon::getWeight, TreeMap::new, toSet()));
```

现在，排序输出：

```
{
  1200 = [Gac(1200 g), Crenshaw(1200 g)],
  1600 = [Hemi(1600 g)],
  1700 = [Horned(1700 g)],
  2600 = [Hemi(2600 g), Apollo(2600 g)],
  3000 = [Gac(3000 g)]
}
```

我们还可以拥有一个含有 100 个瓜分的`List<Integer>`：

```
List<Integer> allWeights = new ArrayList<>(100);
```

我们希望将此列表拆分为 10 个 10 重量的 10 个列表。 基本上，我们可以通过分组获得这一点，如下所示（我们也可以应用`parallelStream()`）：

```
final AtomicInteger count = new AtomicInteger();
Collection<List<Integer>> chunkWeights = allWeights.stream()
  .collect(Collectors.groupingBy(c -> count.getAndIncrement() / 10))
  .values();
```

现在，让我们解决另一个问题。 默认情况下，`Stream<Melon>`分为`List<Melon>`的套件。 但我们可以将`Stream<Melon>`划分为`List<String>`的套件，其中每个列表只持有瓜类，而不是`Melon`实例？

嗯，转换流的元素通常是`map()`的作业。 但内部`groupingBy()`，这是`Collectors.mapping()`的作业（更多细节可以在*滤波，扁平化和映射收集器*部分中找到）：

```
Map<Integer, Set<String>> byWeightInSetOrdered = melons.stream()
  .collect(groupingBy(Melon::getWeight, TreeMap::new,
    mapping(Melon::getType, toSet())));
```

这一次，输出正是我们想要的：

```
{
  1200 = [Crenshaw, Gac],
  1600 = [Hemi],
  1700 = [Horned],
  2600 = [Apollo, Hemi],
  3000 = [Gac]
}
```

好的，到目前为止，这么好！ 现在，让我们专注于`groupingBy()`的三种口味中的两个接受收集器作为参数的事实（例如，`toSet()`）。 这可以是任何收集器。 例如，我们可能希望按类型组群体并计算它们。 为此，`Collectors.counting()`非常有帮助（更多细节可以在*摘要收集器*部分中找到）：

```
Map<String, Long> typesCount = melons.stream()
  .collect(groupingBy(Melon::getType, counting()));
```

输出将如下：

```
{Crenshaw=1, Apollo=1, Gac=3, Hemi=3, Horned=1}
```

我们也可以重量来做到这一点：

```
Map<Integer, Long> weightsCount = melons.stream()
  .collect(groupingBy(Melon::getWeight, counting()));
```

输出将如下：

```
{1600=1, 1200=2, 1700=1, 2600=3, 3000=2}
```

我们可以通过类型组分组最轻和最重的甜瓜吗？ 我们当然可以！ 我们可以通过`Collectors.minBy()`和`maxBy()`进行这一点，该*摘要收集器*部分：

```
Map<String, Optional<Melon>> minMelonByType = melons.stream()
  .collect(groupingBy(Melon::getType,
    minBy(comparingInt(Melon::getWeight))));
```

输出将如下（请注意`minBy()`返回`Optional`）：

```
{
  Crenshaw = Optional[Crenshaw(1200 g)],
  Apollo = Optional[Apollo(2600 g)],
  Gac = Optional[Gac(1200 g)],
  Hemi = Optional[Hemi(1600 g)],
  Horned = Optional[Horned(1700 g)]
}
```

我们也可以通过`maxMelonByType()`来完成以下操作：

```
Map<String, Optional<Melon>> maxMelonByType = melons.stream()
  .collect(groupingBy(Melon::getType,
    maxBy(comparingInt(Melon::getWeight))));
```

输出将如下（请注意`maxBy()`返回`Optional`）：

```
{
  Crenshaw = Optional[Crenshaw(1200 g)],
  Apollo = Optional[Apollo(2600 g)],
  Gac = Optional[Gac(3000 g)],
  Hemi = Optional[Hemi(2600 g)],
  Horned = Optional[Horned(1700 g)]
}
```

`minBy()`和`maxBy()`收集器将`Comparator`作为参数。 在这些示例中，我们使用内置的`Comparator.comparingInt​()`功能。 从 JDK 8 开始，`java.util.Comparator`课程丰富了几种新比较器，包括用于链接比较器的`thenComparing()`口味。

此处的问题由应删除的选项表示。 更一般地，这类问题继续将收集器返回的结果调整到不同类型。

嗯，特别是对于这些任务，我们有`collectingAndThen​(Collector<T,​A,​R> downstream, Function<R,​RR> finisher)`工厂方法。 此方法采用函数将应用于下游收集器（Finisher）的最终结果。 它可以用如下：

```
Map<String, Integer> minMelonByType = melons.stream()
  .collect(groupingBy(Melon::getType,
    collectingAndThen(minBy(comparingInt(Melon::getWeight)),
      m -> m.orElseThrow().getWeight())));
```

输出将如下：

```
{Crenshaw=1200, Apollo=2600, Gac=1200, Hemi=1600, Horned=1700}
```

我们也可以使用`maxMelonByType()`：

```
Map<String, Integer> maxMelonByType = melons.stream()
  .collect(groupingBy(Melon::getType, 
    collectingAndThen(maxBy(comparingInt(Melon::getWeight)),
      m -> m.orElseThrow().getWeight())));
```

输出将如下：

```
{Crenshaw=1200, Apollo=2600, Gac=3000, Hemi=2600, Horned=1700}
```

我们还可能想按照`Map<String, Melon[]>`键入甜瓜。 再次，我们可以依赖于`collectingAndThen()`，如下所示：

```
Map<String, Melon[]> byTypeArray = melons.stream()
  .collect(groupingBy(Melon::getType, collectingAndThen(
    Collectors.toList(), l -> l.toArray(Melon[]::new))));
```

或者，我们可以创建通用收集器并调用它，如下所示：

```
private static <T> Collector<T, ? , T[]> 
    toArray(IntFunction<T[]> func) {

  return Collectors.collectingAndThen(
    Collectors.toList(), l -> l.toArray(func.apply(l.size())));
}

Map<String, Melon[]> byTypeArray = melons.stream()
  .collect(groupingBy(Melon::getType, toArray(Melon[]::new)));
```

# 多级分组

早些时候，我们提到了`groupingBy()`的三种味道中的两个将另一个收集器作为参数。 而且，我们说这可以是任何收藏家。 通过任何收集器，我们也意味着`groupingBy()`。

通过将`groupingBy()`传递给`groupingBy()`，我们可以实现 *n* - 分组或多级别分组。 主要是，我们有 *n* - 分类功能。

让我们考虑以下列表`Melon`：

```
List<Melon> melonsSugar = Arrays.asList(
  new Melon("Crenshaw", 1200, HIGH),
  new Melon("Gac", 3000, LOW), new Melon("Hemi", 2600, HIGH),
  new Melon("Hemi", 1600), new Melon("Gac", 1200, LOW),
  new Melon("Cantaloupe", 2600, MEDIUM),
  new Melon("Cantaloupe", 3600, MEDIUM),
  new Melon("Apollo", 2600, MEDIUM), new Melon("Horned", 1200, HIGH),
  new Melon("Gac", 3000, LOW), new Melon("Hemi", 2600, HIGH));
```

因此，每个`Melon`具有糖水平的类型，重量和指标。 首先，我们希望通过糖指示器（`LOW`，`MEDIUM`，`HIGH`或`UNKNOWN`（默认）组群组。 此外，我们希望将甜瓜群体组成。 这可以通过两个级别的分组来完成，如下：

```
Map<Sugar, Map<Integer, Set<String>>> bySugarAndWeight = melonsSugar.stream()
  .collect(groupingBy(Melon::getSugar,
    groupingBy(Melon::getWeight, TreeMap::new,
      mapping(Melon::getType, toSet()))));
```

输出如下：

```
{
  MEDIUM = {
    2600 = [Apollo, Cantaloupe], 3600 = [Cantaloupe]
  },
  HIGH = {
    1200 = [Crenshaw, Horned], 2600 = [Hemi]
  },
  UNKNOWN = {
    1600 = [Hemi]
  },
  LOW = {
    1200 = [Gac], 3000 = [Gac]
  }
}
```

我们现在可以说 Crenshaw 和有角的重量为 1,200 克，含有高百分比的糖。 我们也有 2,600 克的 Hemi，糖百分比高。

我们甚至可以代表表中的数据，如下图所示：

![](img/6fdf13c0-edd7-4213-a615-26cdc3faed3e.png)

现在，让我们了解分区。

# 190.分区

分区是一种依赖于`Predicate`的分组类型，将流划分为两组（用于`true`的组和`false`的组）。 `true`的组存储已传递谓词的流的元素，而`false`的组存储其余元素（失败谓词的元素）。

此`Predicate`表示分区的*分类函数*，称为*分区功能*。 由于`Predicate`评估为`boolean`值，因此分区操作返回`Map<Boolean, V>`。

让我们假设我们有以下`Melon`类和`Melon`的`List`：

```
public class Melon {

  private final String type;
  private int weight;

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}

List<Melon> melons = Arrays.asList(new Melon("Crenshaw", 1200),
  new Melon("Gac", 3000), new Melon("Hemi", 2600),
  new Melon("Hemi", 1600), new Melon("Gac", 1200),
  new Melon("Apollo", 2600), new Melon("Horned", 1700),
  new Melon("Gac", 3000), new Melon("Hemi", 2600));
```

通过`Collectors.partitioningBy​()`完成分区。 此方法有两个味道，其中一个是一个参数，即`partitioningBy​(Predicate<? super T> predicate)`。

例如，分区瓜分重量为 2,000 克，可以如下进行：

```
Map<Boolean, List<Melon>> byWeight = melons.stream()
  .collect(partitioningBy(m -> m.getWeight() > 2000));
```

输出将如下：

```
{
  false=[Crenshaw(1200g),Hemi(1600g), Gac(1200g),Horned(1700g)],
  true=[Gac(3000g),Hemi(2600g),Apollo(2600g), Gac(3000g),Hemi(2600g)]
}
```

通过过滤分区的优势包括：分区保留流元素的两个列表。

下图描绘了`partitioningBy()`如何在内部工作：

![](img/cc4f001a-fe91-42f2-966b-9707181a41ff.png)

如果我们想拒绝重复，那么我们可以依赖于`partitioningBy()`的其他口味，例如`partitioningBy​(Predicate<? super T> predicate, Collector<? super T,​A,​D> downstream)`。 第二个参数允许我们指定另一个`Collector`以实现下游减少：

```
Map<Boolean, Set<Melon>> byWeight = melons.stream()
  .collect(partitioningBy(m -> m.getWeight() > 2000, toSet()));
```

输出不包含重复项：

```
{
  false=[Horned(1700g), Gac(1200g), Crenshaw(1200g), Hemi(1600g)], 
  true=[Gac(3000g), Hemi(2600g), Apollo(2600g)]
}
```

当然，在这种情况下，`distinct()`也将完成作业：

```
Map<Boolean, List<Melon>> byWeight = melons.stream()
  .distinct()
  .collect(partitioningBy(m -> m.getWeight() > 2000));
```

其他收藏家也可以使用。 例如，我们可以通过`counting()`计算来自这两组中的每一个的元素：

```
Map<Boolean, Long> byWeightAndCount = melons.stream()
  .collect(partitioningBy(m -> m.getWeight() > 2000, counting()));
```

输出将如下：

```
{false=4, true=5}
```

我们还可以在没有重复的情况下计算元素：

```
Map<Boolean, Long> byWeight = melons.stream()
  .distinct()
  .collect(partitioningBy(m -> m.getWeight() > 2000, counting()));
```

这次，输出将如下：

```
{false=4, true=3}
```

最后，`partitioningBy()`可以与`collectingAndThen()`组合，我们在*分组*部分中引入。 例如，让我们将瓜分分重 2,000 克，并保持每个分区的最重物：

```
Map<Boolean, Melon> byWeightMax = melons.stream()
  .collect(partitioningBy(m -> m.getWeight() > 2000,      
    collectingAndThen(maxBy(comparingInt(Melon::getWeight)),
      Optional::get)));
```

输出将如下：

```
{false=Horned(1700g), true=Gac(3000g)}
```

# 191.过滤，平整和映射收集器

让我们假设我们有以下`Melon`类和`Melon`的`List`：

```
public class Melon {

  private final String type;
  private final int weight;
  private final List<String> pests;

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}

List<Melon> melons = Arrays.asList(new Melon("Crenshaw", 2000),
  new Melon("Hemi", 1600), new Melon("Gac", 3000),
  new Melon("Hemi", 2000), new Melon("Crenshaw", 1700),
  new Melon("Gac", 3000), new Melon("Hemi", 2600));
```

Java `Stream` API 提供`filtering()`，`flatMapping()`和`mapping()`，特别是在多级别减少（例如`groupingBy()`或`partitioningBy()`的下游）。

概念上，`filtering()`的目标与`filter()`相同，`flatMapping()`的目标与`flatMap()`相同，并且`mapping()`的目标是 AS `map()`。

# 过滤（）

用户问题：*我想把所有比 2000 克更重的甜瓜并通过它们的类型进行分组。 对于每种类型，将它们添加到适当的容器（每个类型都有一个容器 - 只需检查容器的标签）。*

通过使用`filtering​(Predicate<? super T> predicate, Collector<? super T,​A,​R> downstream)`，我们将谓词应用于集电器的每个元素，并累积下游收集器中的输出。

因此，要通过类型分组比 2,000 g 重的甜瓜，我们可以写下以下流管道：

```
Map<String, Set<Melon>> melonsFiltering = melons.stream()
  .collect(groupingBy(Melon::getType,
    filtering(m -> m.getWeight() > 2000, toSet())));
```

输出将如下（每个`Set<Melon>`是容器）：

```
{Crenshaw=[], Gac=[Gac(3000g)], Hemi=[Hemi(2600g)]}
```

请注意，没有超过 2,000 克的 CRENSHAW，因此`filtering()`已将此类型映射到空集（容器）。 现在，让我们通过`filter()`重写这一点：

```
Map<String, Set<Melon>> melonsFiltering = melons.stream()
  .filter(m -> m.getWeight() > 2000)
  .collect(groupingBy(Melon::getType, toSet()));
```

因为`filter()`对失败其谓词的元素没有执行映射，所以输出将如下所示：

```
{Gac=[Gac(3000g)], Hemi=[Hemi(2600g)]}
```

用户问题：*这次，我对 Hemi 类型的甜瓜感兴趣。 有两个容器：一个用于半甜瓜比（或等于）2,000 克，一个用于半甜度比 2,000 克更重。*

过滤也可以与`partitioningBy()`一起使用。 分隔甜瓜比 2,000 克更重，通过某种类型（在这种情况下，Hemi）过滤，我们有以下几种：

```
Map<Boolean, Set<Melon>> melonsFiltering = melons.stream()
  .collect(partitioningBy(m -> m.getWeight() > 2000,
    filtering(m -> m.getType().equals("Hemi"), toSet())));
```

输出如下：

```
{false=[Hemi(1600g), Hemi(2000g)], true=[Hemi(2600g)]}
```

应用`filter()`将导致相同的结果：

```
Map<Boolean, Set<Melon>> melonsFiltering = melons.stream()
  .filter(m -> m.getType().equals("Hemi"))
  .collect(partitioningBy(m -> m.getWeight() > 2000, toSet()));
```

输出如下：

```
{false=[Hemi(1600g), Hemi(2000g)], true=[Hemi(2600g)]}
```

# 映射（）

用户问题：*对于每种类型的瓜，我希望以升序列表升值。*

通过使用`mapping​(Function<? super T,​? extends U> mapper, Collector<? super U,​A,​R> downstream)`，我们可以将映射函数应用于当前收集器的每个元素并累积下游收集器中的输出。

例如，要按类型分组甜瓜的权重，我们可以编写以下代码片段：

```
Map<String, TreeSet<Integer>> melonsMapping = melons.stream()
  .collect(groupingBy(Melon::getType,
    mapping(Melon::getWeight, toCollection(TreeSet::new))));
```

输出将如下：

```
{Crenshaw=[1700, 2000], Gac=[3000], Hemi=[1600, 2000, 2600]}
```

用户问题：*我想要两个列表。 一个应该含有比（或等于）2,000g 的甜瓜类型，另一个应该包含其余类型。*

分区甜瓜比 2,000 克更重，只能如下进行，如下所示：

```
Map<Boolean, Set<String>> melonsMapping = melons.stream()
  .collect(partitioningBy(m -> m.getWeight() > 2000,
    mapping(Melon::getType, toSet())));
```

输出如下：

```
{false=[Crenshaw, Hemi], true=[Gac, Hemi]}
```

# 平面映射（）

为了快速提醒趋平流，建议读取*映射流*部分。

现在，让我们假设我们有以下`Melon`列表（请注意，我们也添加了害虫的名称）：

```
List<Melon> melonsGrown = Arrays.asList(
  new Melon("Honeydew", 5600,
    Arrays.asList("Spider Mites", "Melon Aphids", "Squash Bugs")),
  new Melon("Crenshaw", 2000,
    Arrays.asList("Pickleworms")),
  new Melon("Crenshaw", 1000,
    Arrays.asList("Cucumber Beetles", "Melon Aphids")),
  new Melon("Gac", 4000,
    Arrays.asList("Spider Mites", "Cucumber Beetles")),
  new Melon("Gac", 1000,
    Arrays.asList("Squash Bugs", "Squash Vine Borers")));
```

用户问题：*对于每种类型的甜瓜，我想要他们的害虫清单。*

所以，让我们按类型组成甜瓜并收集他们的害虫。 每个甜瓜都没有，一种或多种害虫，因此我们期望`Map<String, List<String>>`类型的输出。 第一次尝试将依赖`mapping()`：

```
Map<String, List<List<String>>> pests = melonsGrown.stream()
  .collect(groupingBy(Melon::getType, 
    mapping(m -> m.getPests(), toList())));
```

显然，由于返回的类型是`Map<String, List<List<String>>>`，这不是一个好的方法。

依赖于映射的另一个天真的方法如下：

```
Map<String, List<List<String>>> pests = melonsGrown.stream()
  .collect(groupingBy(Melon::getType, 
    mapping(m -> m.getPests().stream(), toList())));
```

显然，由于返回的类型是`Map<String, List<Stream<String>>>`，这不是一个好方法。

是时候介绍`flatMapping()`了。 通过使用`flatMapping​(Function<? super T,​? extends Stream<? extends U>> mapper, Collector<? super U,​A,​R> downstream)`，我们将`flatMapping`函数应用于当前收集器的每个元素，并累积下游收集器中的输出：

```
Map<String, Set<String>> pestsFlatMapping = melonsGrown.stream()
  .collect(groupingBy(Melon::getType, 
    flatMapping(m -> m.getPests().stream(), toSet())));
```

这次，类型看起来很好，输出如下：

```
{
  Crenshaw = [Cucumber Beetles, Pickleworms, Melon Aphids],
  Gac = [Cucumber Beetles, Squash Bugs, Spider Mites, 
         Squash Vine Borers],
  Honeydew = [Squash Bugs, Spider Mites, Melon Aphids]
}
```

用户问题：*我想要两个列表。 一个应该含有比 2000 克更轻的甜瓜的害虫，另一个应该含有其余甜瓜的害虫。*

分区甜瓜比 2,000 克更重，收集害虫可以如下进行：

```
Map<Boolean, Set<String>> pestsFlatMapping = melonsGrown.stream()
  .collect(partitioningBy(m -> m.getWeight() > 2000, 
    flatMapping(m -> m.getPests().stream(), toSet())));
```

输出如下：

```
{
  false = [Cucumber Beetles, Squash Bugs, Pickleworms, Melon Aphids,
           Squash Vine Borers],
  true = [Squash Bugs, Cucumber Beetles, Spider Mites, Melon Aphids]
}
```

# 192\. Teeing.

从 JDK 12 开始，我们可以通过`Collectors.teeing()`合并两个收集器的结果：

*   `public static <T,​R1,​R2,​R> Collector<T,​?,​R> teeing​(Collector<? super T,​?,​R1> downstream1, Collector<? super T,​?,​R2> downstream2, BiFunction<? super R1,​? super R2,​R> merger)`：

![](img/41ea4499-922d-4d62-bbe0-82f2bdd36311.png)

结果是`Collector`，即两个通过的下游收集器的复合物。 从下游收集器处理传递给生成的收集器的每个元素都处理，然后使用指定的`BiFunction`将其结果合并到最终结果。

让我们来看看一个经典的问题。 以下类简单地存储整数流中的元素数及其总和：

```
public class CountSum {

  private final Long count;
  private final Integer sum;

  public CountSum(Long count, Integer sum) {
      this.count = count;
      this.sum = sum;
    }
    ...
}
```

我们可以通过`teeing()`获取此信息，如下所示：

```
CountSum countsum = Stream.of(2, 11, 1, 5, 7, 8, 12)
  .collect(Collectors.teeing(
    counting(),
    summingInt(e -> e),
    CountSum::new));
```

在这里，我们已经将两个收集器应用于来自流（`counting()`和`summingInt()`）的每个元素，并且结果已在`CountSum`的实例中合并：

```
CountSum{count=7, sum=46}
```

让我们来看看另一个问题。 这次，`MinMax`类存储整数流的最小和最大值：

```
public class MinMax {

  private final Integer min;
  private final Integer max;

  public MinMax(Integer min, Integer max) {
      this.min = min;
      this.max = max;
    }
    ...
}
```

现在，我们可以获得这样的信息：

```
MinMax minmax = Stream.of(2, 11, 1, 5, 7, 8, 12)
  .collect(Collectors.teeing(
    minBy(Comparator.naturalOrder()),
    maxBy(Comparator.naturalOrder()),
    (Optional<Integer> a, Optional<Integer> b) 
      -> new MinMax(a.orElse(Integer.MIN_VALUE),
        b.orElse(Integer.MAX_VALUE))));
```

在这里，我们已经将两个收集器应用于来自流（`minBy()`和`maxBy()`）的每个元素，并且结果已在`MinMax`的实例中合并：

```
MinMax{min=1, max=12}
```

最后，让我们考虑`Melon`的以下`Melon`类和`List`：

```
public class Melon {

  private final String type;
  private final int weight;

  public Melon(String type, int weight) {
    this.type = type;
    this.weight = weight;
  }
  ...
}

List<Melon> melons = Arrays.asList(new Melon("Crenshaw", 1200),
  new Melon("Gac", 3000), new Melon("Hemi", 2600),
  new Melon("Hemi", 1600), new Melon("Gac", 1200),
  new Melon("Apollo", 2600), new Melon("Horned", 1700),
  new Melon("Gac", 3000), new Melon("Hemi", 2600));
```

这里的目的是计算这些瓜的总重量并列出其权重。 我们可以如下映射：

```
public class WeightsAndTotal {

  private final int totalWeight;
  private final List<Integer> weights;

  public WeightsAndTotal(int totalWeight, List<Integer> weights) {
    this.totalWeight = totalWeight;
    this.weights = weights;
  }
  ...
}
```

解决此问题的解决方案依赖于`Collectors.teeing()`，如下所示：

```
WeightsAndTotal weightsAndTotal = melons.stream()
  .collect(Collectors.teeing(
    summingInt(Melon::getWeight),
    mapping(m -> m.getWeight(), toList()),
    WeightsAndTotal::new));
```

这次，我们已经应用了`summingInt()`和`mapping()`收藏家。 输出如下：

```
WeightsAndTotal {
  totalWeight = 19500,
  weights = [1200, 3000, 2600, 1600, 1200, 2600, 1700, 3000, 2600]
}
```

# 193.撰写自定义收藏家

让我们假设我们有以下`Melon`类和`Melon`的`List`：

```
public class Melon {

  private final String type;
  private final int weight;
  private final List<String> grown;

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}

List<Melon> melons = Arrays.asList(new Melon("Crenshaw", 1200),
  new Melon("Gac", 3000), new Melon("Hemi", 2600),
  new Melon("Hemi", 1600), new Melon("Gac", 1200),
  new Melon("Apollo", 2600), new Melon("Horned", 1700),
  new Melon("Gac", 3000), new Melon("Hemi", 2600));
```

在*分区*部分中，我们看到如何使用`partitioningBy()`收集器来分区瓜，以重复重复 2,000 克：

```
Map<Boolean, List<Melon>> byWeight = melons.stream()
  .collect(partitioningBy(m -> m.getWeight() > 2000));
```

现在，让我们看看我们是否可以通过专用的自定义收集器实现相同的结果。

让我们首先说写一个自定义收集器不是日常任务，但知道如何做到这一点可能很有用。 内置 Java `Collector`界面如下所示：

```
public interface Collector<T, A, R> {
  Supplier<A> supplier();
  BiConsumer<A, T> accumulator();
  BinaryOperator<A> combiner();
  Function<A, R> finisher();
  Set<Characteristics> characteristics();
  ...
}
```

要编写自定义收集器，知道`T`，`A`和`R`表示如下：

*   `T`表示来自`Stream`的元素类型（将收集的元素）。
*   `A`表示在称为*累加器*的收集过程中使用的对象类型，其用于在*可变结果容器中累积流元素。*
*   `R`表示收集过程（最终结果）之后对象的类型。

收集器可以将累加器本身作为最终结果返回，或者可以在累加器上执行可选的变换以获得最终结果（从中间累积类型，`A`执行最终结果类型的最终结果`R` ）。

就我们的问题而言，我们知道`T`是`Melon`，`A`是`Map<Boolean, List<Melon>>`，`R`是`Map<Boolean, List<Melon>>`。 该收集器通过`Function.identity()`将累加器本身作为最终结果返回。 那个说，我们可以开始自定义收集器如下：

```
public class MelonCollector implements
  Collector<Melon, Map<Boolean, List<Melon>>,
    Map<Boolean, List<Melon>>> {
  ...
}
```

因此，`Collector`由四个功能指定。 这些功能正在一起工作以将条目累积到可变结果容器中，并可选择对结果执行最终的转换。 它们如下：

*   创建新的空变形结果容器（`supplier()`）
*   将新数据元素结合到可变结果容器中（`accumulator()`）
*   将两个可变结果容器组合成一个（`combiner()`）
*   在可变结果容器上执行可选的最终转换以获得最终结果（`finisher()`）

此外，收集器的行为在最后一种方法中定义`characteristics()`。 `Set<Characteristics>`可能包含以下四个值：

*   `UNORDERED`：累积/收集元素的顺序对于最终结果并不重要。
*   `CONCURRENT`：流的元素可以通过并发方式由多个线程累积（最后，收集器可以执行流的并行减小流。由流的并行处理产生的容器在单个中组合 结果容器。数据源应该通过其性质或`UNORDERED`标志出现。
*   `IDENTITY_FINISH`：表示累加器本身是最终结果（基本上，我们可以将`A`施放到`R`）; 在这种情况下，不调用`finisher()`。

# 供应商 - 供应商

`supplier()`的作业是返回（在每个呼叫）A `Supplier`的空变形效果容器中。

在我们的情况下，结果容器是`Map<Boolean, List<Melon>>`类型，因此`supplier()`可以如下实现：

```
@Override
public Supplier<Map<Boolean, List<Melon>>> supplier() {

  return () -> {
    return new HashMap<Boolean, List<Melon>> () {
      {
        put(true, new ArrayList<>());
        put(false, new ArrayList<>());
      }
    };
  };
}
```

在并行执行中，可以多次调用此方法。

# 累积元素 - Biconsumer 

`accumulator()`方法返回执行减少操作的函数。 这是`BiConsumer`，它是接受两个输入参数的操作，并不返回结果。 第一个输入参数是当前结果容器（迄今为止还原的结果），第二个输入参数是来自流的当前元素。 此函数通过累积遍历元素或遍历此元素的效果来修改结果容器本身。 在我们的情况下，`accumulator()`将当前遍历的元素添加到两个 ArrayList 中的一个：

```
@Override
public BiConsumer<Map<Boolean, List<Melon>>, Melon> accumulator() {

  return (var acc, var melon) -> {
    acc.get(melon.getWeight() > 2000).add(melon);
  };
}
```

# 应用最终变换 - 功能 

`finisher()`方法返回在累积过程结束时应用的函数。 调用此方法时，没有更多的流元素来遍历。 所有元素将累积从中间累积类型`A`，最终结果类型`R`。 如果不需要转换，则我们可以返回中间结果（累加器本身）：

```
@Override
public Function<Map<Boolean, List<Melon>>,
    Map<Boolean, List<Melon>>> finisher() {

  return Function.identity();
}
```

# 并行化收集器 - BinaryOperator 

如果并行地处理流，则不同的线程（累加器）将产生部分结果容器。 最终，必须在单个中合并这些部分结果。 这正是`combiner()`的表现。 在这种情况下，`combiner()`方法需要通过将第二个`Map`的两个列表中的所有值添加到第一个`Map`中的相应列表中的所有值来合并两个映射：

```
@Override
public BinaryOperator<Map<Boolean, List<Melon>>> combiner() {

  return (var map, var addMap) -> {
    map.get(true).addAll(addMap.get(true));
    map.get(false).addAll(addMap.get(false));

    return map;
  };
}
```

# 返回最终结果 - 功能 

最终结果在`finisher()`方法中计算。 在这种情况下，我们只需返回`Function.identity()`，因为累加器不需要任何进一步的转换：

```
@Override
public Function<Map<Boolean, List<Melon>>,
    Map<Boolean, List<Melon>>> finisher() {

  return Function.identity();
}
```

# 特点 - 设置<characteristics>特征（）;</characteristics>

最后，我们表明我们的收藏家是`IDENTITY_FINISH`和`CONCURRENT`：

```
@Override
public Set<Characteristics> characteristics() {
  return Set.of(IDENTITY_FINISH, CONCURRENT);
}
```

与本书捆绑在一起的代码将所有拼图中的所有拼图粘贴在名为`MelonCollector`的类中。

# 测试时间

`MelonCollector`可以通过`new`关键字使用，如下所示：

```
Map<Boolean, List<Melon>> melons2000 = melons.stream()
  .collect(new MelonCollector());
```

我们将收到以下输出：

```
{
  false = [Crenshaw(1200 g),Hemi(1600 g),Gac(1200 g),Horned(1700 g)],
  true = [Gac(3000 g),Hemi(2600 g),Apollo(2600 g),
          Gac(3000 g),Hemi(2600 g)]
}
```

我们也可以通过`parallelStream()`使用它：

```
Map<Boolean, List<Melon>> melons2000 = melons.parallelStream()
  .collect(new MelonCollector());
```

如果我们使用`combiner()`方法，则输出可能如下所示：

```
{false = [], true = [Hemi(2600g)]} 
    ForkJoinPool.commonPool - worker - 7
...
{false = [Horned(1700g)], true = []} 
    ForkJoinPool.commonPool - worker - 15 
{false = [Crenshaw(1200g)], true = [Gac(3000g)]} 
    ForkJoinPool.commonPool - worker - 9
...
{false = [Crenshaw(1200g), Hemi(1600g), Gac(1200g), Horned(1700g)], 
true = [Gac(3000g), Hemi(2600g), Apollo(2600g), 
        Gac(3000g), Hemi(2600g)]}
```

# 通过 Collect（）定制收集

在`IDENTITY_FINISH`收集操作的情况下，至少有一个用于获得自定义收集器的解决方案。 通过以下方法促进了该解决方案：

```
<R> R collect​(Supplier<R> supplier, BiConsumer<R,​? super T> accumulator, BiConsumer<R,​R> combiner)
```

这种`collect()`的味道很有契合，只要我们处理`IDENTITY_FINISH`收集操作，我们可以提供供应商，累加器和组合器。

让我们来看看一些例子：

```
List<String> numbersList = Stream.of("One", "Two", "Three")
  .collect(ArrayList::new, ArrayList::add,
    ArrayList::addAll);

Deque<String> numbersDeque = Stream.of("One", "Two", "Three")
  .collect(ArrayDeque::new, ArrayDeque::add,
    ArrayDeque::addAll);

String numbersString = Stream.of("One", "Two", "Three")
  .collect(StringBuilder::new, StringBuilder::append,
    StringBuilder::append).toString();
```

您可以使用这些示例标识更多 jdk 类，其签名非常适合使用方法引用作为`collect()`的参数。

# 194.方法参考

让我们假设我们有以下`Melon`类和`Melon`的`List`：

```
public class Melon {

  private final String type;
  private int weight;

  public static int growing100g(Melon melon) {
    melon.setWeight(melon.getWeight() + 100);

    return melon.getWeight();
  }

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}

List<Melon> melons = Arrays.asList(
  new Melon("Crenshaw", 1200), new Melon("Gac", 3000),
  new Melon("Hemi", 2600), new Melon("Hemi", 1600));
```

简而言之，*方法参考*是 Lambda 表达式的快捷方式。

主要是，方法引用是一种技术，它用于按名称调用方法而不是通过描述如何调用它。 主要好处是可读性。

通过将目标参考放置在分隔符（HTG0]之前，通过在其上提供方法的名称来写入方法引用。

我们将在即将到来的部分中查看所有四种方法引用。

# 方法参考静态方法

我们可以从上述列表中分组每个`Melon`，该列表通过称为`static`方法（称为`growing100g()`）：

*   没有方法参考：

```
melons.forEach(m -> Melon.growing100g(m));
```

*   方法参考：

```
melons.forEach(Melon::growing100g);
```

# 方法引用实例方法

让我们假设我们定义以下`Comparator` `Melon`：

```
public class MelonComparator implements Comparator {

  @Override
  public int compare(Object m1, Object m2) {
    return Integer.compare(((Melon) m1).getWeight(),
      ((Melon) m2).getWeight());
  }
}
```

现在，我们可以提及如下：

*   没有方法参考：

```
MelonComparator mc = new MelonComparator();

List<Melon> sorted = melons.stream()
  .sorted((Melon m1, Melon m2) -> mc.compare(m1, m2))
  .collect(Collectors.toList());
```

*   方法参考：

```
List<Melon> sorted = melons.stream()
  .sorted(mc::compare)
  .collect(Collectors.toList());
```

当然，我们也可以直接调用`Integer.compare()`：

*   没有方法参考：

```
List<Integer> sorted = melons.stream()
  .map(m -> m.getWeight())
  .sorted((m1, m2) -> Integer.compare(m1, m2))
  .collect(Collectors.toList());
```

*   方法参考：

```
List<Integer> sorted = melons.stream()
  .map(m -> m.getWeight())
  .sorted(Integer::compare)
  .collect(Collectors.toList());
```

# 方法引用构造函数

参考构造函数可以通过`new`关键字来完成，如下所示：

```
BiFunction<String, Integer, Melon> melonFactory = Melon::new;
Melon hemi1300 = melonFactory.apply("Hemi", 1300);
```

关于方法引用构造函数的更多详细信息和示例可在上一章中实现工厂模式部分的*中提供。*

# 195.溪流的并行处理

简而言之，并行处理流是指由三个步骤组成的过程：

1.  将流的元素分成多个块
2.  处理单独的线程中的每个块
3.  在单一结果中加入处理结果

这三个步骤通过默认的`ForkJoinPool`方法在[第 10 章](10.html)，*并发 - 线程池，可调用和同步器*和[第 11 章](11.html)[和](11.html)[中进行了这些步骤。 HTG6]，*并发 - 深潜水*。](11.html)

通常，并行处理只能应用于*无状态*（元素的状态不影响另一个元素），*不干扰*（数据源不受影响 ），*关联*（结果不受操作数量的影响）操作。

让我们假设我们的问题是总结双打列表的元素：

```
Random rnd = new Random();
List<Double> numbers = new ArrayList<>();

for (int i = 0; i < 1 _000_000; i++) {
  numbers.add(rnd.nextDouble());
}
```

我们也可以直接作为流，

```
DoubleStream.generate(() -> rnd.nextDouble()).limit(1_000_000)
```

以顺序方法，我们可以如下所述：

```
double result = numbers.stream()
  .reduce((a, b) -> a + b).orElse(-1d);
```

此操作可能会在幕后的单个核心上进行（即使我们的机器有更多核心），如下图所示：

![](img/f931ae6f-ad6f-49ad-a91e-3175966f1d78.png)

此问题是杠杆并行化的好候选者，因此我们可以调用`parallelStream()`而不是`stream()`，如下所示：

```
double result = numbers.parallelStream()
  .reduce((a, b) -> a + b).orElse(-1d);
```

一旦我们调用`parallelStream()`，Java 将采取操作并使用多个线程处理流。 并行化可以通过`parallel()`方法来完成：

```
double result = numbers.stream()
  .parallel()
  .reduce((a, b) -> a + b).orElse(-1d);
```

这次，处理通过叉/加入进行处理，如下图所示（每个可用核心有一个线程）：

![](img/66dc63de-6937-4cb4-b79f-619d94554237.png)

在`reduce()`的上下文中，可以描绘并行化如下：

![](img/2feff59c-840e-4668-b5ce-763da1cdbf12.png)

默认情况下，Java `ForkJoinPool`将尝试将尽可能多的线程作为可用的处理器获取：

```
int noOfProcessors = Runtime.getRuntime().availableProcessors();
```

我们可以影响全局的线程数（所有并行流将使用它），如下所示：

```
System.setProperty(
  "java.util.concurrent.ForkJoinPool.common.parallelism", "10");
```

或者，我们可以影响单个并行流的线程数，如下所示：

```
ForkJoinPool customThreadPool = new ForkJoinPool(5);

double result = customThreadPool.submit(
  () -> numbers.parallelStream()
    .reduce((a, b) -> a + b)).get().orElse(-1d);
```

影响线程数是一个重要的决定。 试图根据环境确定最佳线程数不是一件容易的任务，并且在大多数情况下，默认设置（*线程=处理器数*）是最合适的。

即使问题是杠杆并行化的好候选者，它并不意味着并行处理是银弹。 决定使用并行处理或不应该是在基准测试和比较顺序与并行处理之后进行的决定。 最常见的是，在巨大数据集的情况下，并行处理使得更好。

不要陷入陷阱的迹象，即大量的线程导致更快的处理。 避免如下的内容（这些数字只是带有 8 个核心机器的指示器）：

```
5 threads (~40 ms)
20 threads (~50 ms)
100 threads (~70 ms)
1000 threads (~ 250 ms)
```

# 分散器

一个 Java `Spliterator`接口（也被称为*可分离的迭代器*）是所使用遍历源的元件的接口（例如，一个集合或流）并联。 此接口定义以下方法：

```
public interface Spliterator<T> {
  boolean tryAdvance(Consumer<? super T> action);
  Spliterator<T> trySplit();
  long estimateSize();
  int characteristics();
}
```

让我们考虑一个 10 个整数的简单列表：

```
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
```

我们可以为此列表获取`Spliterator`界面，如下所示：

```
Spliterator<Integer> s1 = numbers.spliterator();
```

我们也可以从流中做同样的事情：

```
Spliterator<Integer> s1 = numbers.stream().spliterator();
```

为了前进（遍历）第一个元素，我们需要调用`tryAdvance()`方法，如下所示：

```
s1.tryAdvance(e 
  -> System.out.println("Advancing to the 
       first element of s1: " + e));
```

我们将收到以下输出：

```
Advancing to the first element of s1: 1
```

`Spliterator`可以尝试估计通过`estimateSize()`方法留下遍历遍历的元素数量，如下所示：

```
System.out.println("\nEstimated size of s1: " + s1.estimateSize());
```

我们将收到以下输出（我们遍历一个元素;有九点）：

```
Estimated size of s1: 9
```

我们可以使用`trySplit()`方法通过`Spliterator`接口将其分为两个。 结果将是另一个`Spliterator`界面：

```
Spliterator<Integer> s2 = s1.trySplit();
```

检查元素数量显示`trySplit()`的效果：

```
System.out.println("Estimated size s1: " + s1.estimateSize());
System.out.println("Estimated size s2: " + s2.estimateSize());
```

我们将收到以下输出：

```
Estimated size s1: 5
Estimated size s2: 4
```

尝试使用`s1`和`s2`从`forEachRemaining()`打印所有元素，如下所示：

```
s1.forEachRemaining(System.out::println); // 6, 7, 8, 9, 10
s2.forEachRemaining(System.out::println); // 2, 3, 4, 5
```

`Spliterator`接口定义其特征的常数套件 - `CONCURRENT`（`4096`），`DISTINCT`（`1`），`IMMUTABLE`（`1024`），`NONNULL`（`256`）， `ORDERED`（`16`），`SIZED`（`64`），`SORTED`（`4`）和`SUBSIZED`（`16384`）。

我们可以通过`characteristics()`方法打印特性，如下所示：

```
System.out.println(s1.characteristics()); // 16464
System.out.println(s2.characteristics()); // 16464
```

测试是否使用`hasCharacteristics()`呈现某个特性是更简单的：

```
if (s1.hasCharacteristics(Spliterator.ORDERED)) {
  System.out.println("ORDERED");
}

if (s1.hasCharacteristics(Spliterator.SIZED)) {
  System.out.println("SIZED");
}
```

# 编写自定义扫描竞技器

显然，编写自定义`Spliterator`不是每日任务，但是假设我们正在研究一个项目，因为某种原因，我们要求我们处理包含表意绘图字符的字符串（ **cjkv** （简而言之） **中文**，**日语**，**韩语**和**越南**）和非表意。 我们希望并行处理这些字符串。 此命令我们将它们拆分为仅在代表表意标记字符的位置。

显然，默认`Spliterator`不会像我们想要的那样执行，因此我们可能需要编写自定义`Spliterator`。 为此，我们必须实现`Spliterator`界面并提供几种方法的实现。 该实现的实现可用于本书已捆绑在一起。 考虑打开`IdeographicSpliterator`源代码，并在阅读本节的其余部分时保持关闭。

实施的高潮在`trySplit()`方法中。 在这里，我们正试图将当前的字符串分成两半并继续遍历它，直到找到表表字符。 为了检查目的，我们刚刚添加了以下行：

```
System.out.println("Split successfully at character: " 
  + str.charAt(splitPosition));
```

现在，让我们考虑一个包含表意标识的字符串：

```
String str = "Character Information  Development and Maintenance " 
  + "Project  for e-Government MojiJoho-Kiban  Project";
```

现在，让我们为此字符串创建一个并行流，并强制`IdeographicSpliterator`执行作业：

```
Spliterator<Character> spliterator = new IdeographicSpliterator(str);
Stream<Character> stream = StreamSupport.stream(spliterator, true);

// force spliterator to do its job
stream.collect(Collectors.toList());
```

一个可能的输出将揭示分割仅在包含表意字符的位置进行：

```
Split successfully at character: 
Split successfully at character: 
```

# 196.零安全流

可以使用`Optional.ofNullable()`或者通过 JDK 9，`Stream.ofNullable()`来解决可能或可能不是`null`的元素的`Stream`的问题，或者可以通过 JDK 9 来解决：

*   `static <T> Stream<T> ofNullable​(T t)`

此方法获取单个元素（`T`）并返回包含此单个元素的顺序`Stream`（`Stream<T>`）; 否则，它会返回一个空`Stream`，如果它不是`null`。

例如，我们可以编写一个辅助方法，将呼叫呼叫`Stream.ofNullable()`如下：

```
public static <T> Stream<T> elementAsStream(T element) {
  return Stream.ofNullable(element);
}
```

如果此方法生存在名为`AsStreams`的实用程序类中，那么我们可以执行多个呼叫，如下所示：

```
// 0
System.out.println("Null element: " 
  + AsStreams.elementAsStream(null).count());

// 1
System.out.println("Non null element: " 
  + AsStreams.elementAsStream("Hello world").count());
```

请注意，当我们通过`null`时，我们得到一个空流（`count()`方法返回 0）！

如果我们的元素是一个集合，那么事情变得更加有趣。 例如，让我们假设我们有以下列表（请注意此列表包含一些`null`值）：

```
List<Integer> ints = Arrays.asList(5, null, 6, null, 1, 2);
```

现在，让我们编写一个借助返回`Stream<T>`的帮助程序方法，其中`T`是一个集合：

```
public static <T> Stream<T> collectionAsStreamWithNulls(
    Collection<T> element) {
  return Stream.ofNullable(element).flatMap(Collection::stream);
}
```

如果我们用`null`调用此方法，那么我们获取空流：

```
// 0
System.out.println("Null collection: " 
  + AsStreams.collectionAsStreamWithNulls(null).count());
```

现在，如果我们用我们的列表称为`ints`，那么我们获取`Stream<Integer>`：

```
// 6
System.out.println("Non-null collection with nulls: "
  + AsStreams.collectionAsStreamWithNulls(ints).count());
```

请注意，流有六个元素（来自底层列表的所有元素）-5，空，6，null，1 和 2。

如果我们知道集合本身不是`null`，但它可能包含`null`值，然后我们可以编写另一个辅助方法，如下所示：

```
public static <T> Stream<T> collectionAsStreamWithoutNulls(
    Collection<T> collection) {

  return collection.stream().flatMap(e -> Stream.ofNullable(e));
}
```

这次，如果收集本身是`null`，则代码将抛出`NullPointerException`。 但是，如果我们将列表传递给它，那么结果将是一个`Stream<Integer>`而没有`null`值：

```
// 4
System.out.println("Non-null collection without nulls: " 
 + AsStreams.collectionAsStreamWithoutNulls(ints).count());
```

返回的流只有四个元素-5,6,1 和 2。

最后，如果集合本身可能是`null`并且可能包含`null`值，则以下辅助程序将执行作业并返回 null 安全的流：

```
public static <T> Stream<T> collectionAsStream(
    Collection<T> collection) {

  return Stream.ofNullable(collection)
    .flatMap(Collection::stream)
    .flatMap(Stream::ofNullable);
}
```

如果我们通过`null`，那么我们得到一个空的流：

```
// 0
System.out.println(
  "Null collection or non-null collection with nulls: " 
    + AsStreams.collectionAsStream(null).count());
```

如果我们通过我们的列表，我们会获得`Stream<Integer>` Stream 而无需`null`值：

```
// 4
System.out.println(
  "Null collection or non-null collection with nulls: " 
    + AsStreams.collectionAsStream(ints).count());
```

# 197.撰写函数，谓词和比较器

组成（或链接）函数，谓词和比较器允许我们编写应齐声施用的复合标准。

# 撰写谓词

让我们假设我们有以下`Melon`类和`Melon`的`List`：

```
public class Melon {

  private final String type;
  private final int weight;

  // constructors, getters, setters, equals(),
  // hashCode(), toString() omitted for brevity
}

List<Melon> melons = Arrays.asList(new Melon("Gac", 2000),
  new Melon("Horned", 1600), new Melon("Apollo", 3000),
  new Melon("Gac", 3000), new Melon("Hemi", 1600));
```

`Predicate`界面具有三种方法，采用`Predicate`并使用它以获得丰富的`Predicate`。 这些方法是`and()`，`or()`和`negate()`。

例如，让我们假设我们要过滤重金的甜瓜超过 2,000 克。 为此，我们可以写一个`Predicate`，如下所示：

```
Predicate<Melon> p2000 = m -> m.getWeight() > 2000;
```

现在，让我们假设我们想要丰富这款`Predicate`以仅筛选尊重`p2000`的甜瓜，并且是`Gac`或`Apollo`类型。 为此，我们可以使用`and()`和`or()`方法，如下所示：

```
Predicate<Melon> p2000GacApollo 
  = p2000.and(m -> m.getType().equals("Gac"))
    .or(m -> m.getType().equals("Apollo"));
```

这是从左边的权利解释为`a && (b || c)`，我们有以下内容：

*   `a`是`m -> m.getWeight() > 2000`
*   `b`是`m -> m.getType().equals("Gac")`
*   `c`是`m -> m.getType().equals("Apollo")`

显然，我们可以以相同的方式添加更多标准。

让我们将`Predicate`传递给`filter()`：

```
// Apollo(3000g), Gac(3000g)
List<Melon> result = melons.stream()
  .filter(p2000GacApollo)
  .collect(Collectors.toList());
```

现在，让我们假设我们的问题要求我们获得上述复合谓词的否定。 将其作为`!a && !b && !c`或任何其他对应表达式重写为谓词是麻烦的。 更好的解决方案是调用`negate()`方法，如下所示：

```
Predicate<Melon> restOf = p2000GacApollo.negate();
```

让我们将它传递给`filter()`：

```
// Gac(2000g), Horned(1600g), Hemi(1600g)
List<Melon> result = melons.stream()
  .filter(restOf)
  .collect(Collectors.toList());
```

从 JDK 11 开始，我们可以否定作为`not()`方法的参数传递的`Predicate`。 例如，让我们过滤使用`not()`的所有胶片比（或等于）2,000g 轻：

```
Predicate<Melon> pNot2000 = Predicate.not(m -> m.getWeight() > 2000);

// Gac(2000g), Horned(1600g), Hemi(1600g)
List<Melon> result = melons.stream()
  .filter(pNot2000)
  .collect(Collectors.toList());
```

# 组合比较器

让我们从前一节考虑`Melon`的相同`Melon`类和`List`。

现在，让我们使用`Comparator.comparing()`来对`Melon`的`List`进行分类：

```
Comparator<Melon> byWeight = Comparator.comparing(Melon::getWeight);

// Horned(1600g), Hemi(1600g), Gac(2000g), Apollo(3000g), Gac(3000g)
List<Melon> sortedMelons = melons.stream()
  .sorted(byWeight)
  .collect(Collectors.toList());
```

我们也可以按类型对列表进行排序：

```
Comparator<Melon> byType = Comparator.comparing(Melon::getType);

// Apollo(3000g), Gac(2000g), Gac(3000g), Hemi(1600g), Horned(1600g)
List<Melon> sortedMelons = melons.stream()
  .sorted(byType)
  .collect(Collectors.toList());
```

要反转排序顺序，只需调用`reversed()`：

```
Comparator<Melon> byWeight 
  = Comparator.comparing(Melon::getWeight).reversed();
```

到目前为止，一切都很好！

现在，让我们假设我们想要按重量和类型对列表进行排序。 换句话说，当两个甜瓜具有相同的重量（例如，`Horned (1600g)`，`Hemi(1600g`）），它们应该按类型进行分类（例如，`Hemi(1600g)`，`Horned(1600g)`）。 天真的方法将如下所示：

```
// Apollo(3000g), Gac(2000g), Gac(3000g), Hemi(1600g), Horned(1600g)
List<Melon> sortedMelons = melons.stream()
  .sorted(byWeight)
  .sorted(byType)
  .collect(Collectors.toList());
```

显然，结果不是我们的预期。 这发生是因为比较器尚未应用于同一列表。 `byWeight`比较器应用于原始列表，而`byType`比较器应用于`byWeight`的输出。 基本上，`byType`取消`byWeight`的效果。

该解决方案来自`Comparator.thenComparing()`方法。 此方法允许我们扩展比较器：

```
Comparator<Melon> byWeightAndType 
  = Comparator.comparing(Melon::getWeight)
    .thenComparing(Melon::getType);

// Hemi(1600g), Horned(1600g), Gac(2000g), Apollo(3000g), Gac(3000g)
List<Melon> sortedMelons = melons.stream()
  .sorted(byWeightAndType)
  .collect(Collectors.toList());
```

这种`thenComparing()`的味道需要`Function`作为论据。 此`Function`用于提取`Comparable`排序键。 仅当前一个`Comparator`找到两个相等的对象时才应用返回的`Comparator`。

`thenComparing()`的另一种味道获取`Comparator`：

```
Comparator<Melon> byWeightAndType = Comparator.comparing(Melon::getWeight)
  .thenComparing(Comparator.comparing(Melon::getType));
```

最后，让我们考虑`Melon`的以下`List`：

```
List<Melon> melons = Arrays.asList(new Melon("Gac", 2000),
  new Melon("Horned", 1600), new Melon("Apollo", 3000),
  new Melon("Gac", 3000), new Melon("hemi", 1600));
```

我们故意向上次`Melon`添加了一个错误。 它的类型这次是小写的。 如果我们应用`byWeightAndType`比较器，则输出将如下：

```
Horned(1600g), hemi(1600g), ...
```

作为一个词典秩序比较器，`byWeightAndType`将在`hemi`之前放置`Horned`。 因此，以不区分大小写的方式排序类型是有用的。 对此问题的优雅解决方案将依赖于其他`thenComparing()`的其他风味，这使我们能够通过 A `Function`和`Comparator`作为参数。 传递的`Function`提取`Comparable`排序键，给定的`Comparator`用于比较此排序密钥：

```
Comparator<Melon> byWeightAndType = Comparator.comparing(Melon::getWeight)
  .thenComparing(Melon::getType, String.CASE_INSENSITIVE_ORDER);
```

这一次，结果将如下（我们回到轨道）：

```
hemi(1600g), Horned(1600g),...
```

对于`int`，`long`和`double`，我们具有`comparingInt()`，`comparingLong()`，`comparingDouble()`，`thenComparingInt()`，`thenComparingLong()`和`thenComparingDouble()`。 `comparing()`和`thenComparing()`方法具有相同的口味。

# 撰写功能

通过`Function`界面表示的 Lambda 表达式可以通过`Function.andThen()`和`Function.compose()`方法来组成。

`andThen​(Function<? super R,​? extends V> after)`返回组合`Function`，执行以下操作：

*   将此功能应用于其输入
*   将`after`函数应用于结果

让我们来看看这个例子：

```
Function<Double, Double> f = x -> x * 2;
Function<Double, Double> g = x -> Math.pow(x, 2);
Function<Double, Double> gf = f.andThen(g);
double resultgf = gf.apply(4d); // 64.0
```

在该示例中，`f`功能应用于其输入（4）。 施加`f`的结果是 8（`f(4) = 4 * 2`）。 该结果是第二个功能的输入`g`。 应用`g`的结果是 64（`g(8) = Math.pow(8, 2)`）。 下图描绘了四个输入的流动 - **1 **，**， **2** ， **3** 和 **4** ：**

![](img/bb13bcce-901b-4a0c-9af1-9136d137794f.png)

所以，这就像`g(f(x))`。 相反的`f(g(x))`可以用`Function.compose()`形状。 返回的组成函数在功能之前将*应用于其输入，然后将*应用于结果*到结果：*

```
double resultfg = fg.apply(4d); // 32.0
```

在该示例中，`g`功能应用于其输入（4）。 施加`g`的结果是 16（`g(4) = Math.pow(4, 2)`）。 该结果是第二个功能的输入`f`。 施加`f`的结果是 32（`f(16) = 16 * 2`）。 下图描绘了四个输入的流动 - **1 **，**， **2** ， **3** 和 **4** ：**

![](img/299fb4da-3ba6-408e-bf3c-3bf925db688b.png)

根据相同的原则，我们可以通过构图`addIntroduction()`，`addBody()`和`addConclusion()`方法开发用于编辑文章的应用程序。 请查看与本书捆绑在一起的代码以查看此实施。

我们也可以通过用组成过程来编写其他管道，并通过组合过程来玩杂耍。

# 198.默认方法

默认方法被添加到 Java 8.它们的主要目标是为接口提供支持，以便它们可以超出抽象合同（仅包含抽象方法）。 这设施对编写库并希望以兼容方式演变 API 的人来说非常有用。 通过默认方法，可以在不中断现有实现的情况下进行丰富接口。

默认方法直接在接口中实现，并由`default`关键字识别。

例如，以下接口定义了一个名为`area()`的抽象方法，默认方法称为`perimeter()`：

```
public interface Polygon {

  public double area();

  default double perimeter(double...segments) {
    return Arrays.stream(segments)
      .sum();
  }
}
```

由于所有常见多边形（例如，正方形）的周边是边缘的总和，我们可以在此实现它。 另一方面，区域公式与多边形与多边形的不同之处，因此默认实现不会非常有用。

现在，让我们定义实现`Polygon`的`Square`类。 其目标是通过周边表达广场的区域：

```
public class Square implements Polygon {

  private final double edge;

  public Square(double edge) {
    this.edge = edge;
  }

  @Override
  public double area() {
    return Math.pow(perimeter(edge, edge, edge, edge) / 4, 2);
  }
}
```

其他多边形（例如，矩形和三角形）可以实现`Polygon`并基于通过默认实现计算的周长表示该区域。

但是，在某些情况下，我们可能需要覆盖默认方法的默认实现。 例如，`Square`类可以覆盖`perimeter()`方法，如下所示：

```
@Override
public double perimeter(double...segments) {
  return segments[0] * 4;
}
```

我们可以如下称：

```
@Override
public double area() {
  return Math.pow(perimeter(edge) / 4, 2);
}
```

# 概括

我们的工作完成了！ 本章涵盖无限流，空安全流和默认方法。 覆盖分组，分区和收集器的全面问题列表，包括 JDK 12 `teeing()`收集器并编写自定义收集器。 此外，还涵盖了`takeWhile()`，`dropWhile()`，编写功能，谓词和比较器，测试和调试 Lambdas 以及其他很酷的主题。

从本章下载应用程序以查看结果和其他详细信息。