# Java I / O 路径，文件，缓冲区，扫描和格式化

本章包括 20 个问题，涉及 java I / O for 文件。 从操纵，走路和观看流媒体文件和高效阅读/写作文本和二进制文件的方式，我们将涵盖 Java 开发人员可能在日常工作的问题。

通过从本章中获得的技能，您将能够解决涉及 Java I / O 文件的大多数常见问题。 本章中的广泛主题将提供有关 Java 如何解决 I / O 任务的多种信息。

# 问题

看看以下问题，以测试您的 Java I / O 编程实力。 我强烈建议您在转向解决方案并下载示例程序之前尝试举出每个问题：

129.  **创建文件路径**：写入创建几种文件路径的几个例子（例如，绝对路径，相对路径等）。
130.  **转换文件路径**：写入转换文件路径的几个示例（例如，将文件路径转换为字符串，URI，文件等）。
131.  **加入文件路径**：写入连接（组合）文件路径的几个例子。 定义固定路径并将其它不同的路径附加（或用其他路径替换其一部分）。
132.  **构造两个位置之间的路径**：写入若干示例，该示例构成两个给定路径之间的相对路径（从一个路径到另一个路径）。
133.  **比较文件路径**：写入比较给定文件路径的几个例子。
134.  **步行路径**：编写访问目录中的所有文件的程序，包括子目录。 此外，编写一个通过名称搜索文件的程序，删除目录，移动目录并复制目录。
135.  观看路径：写几个程序，这些程序观看某个路径上发生的更改（例如，创建，删除和修改）。
136.  **流媒体文件的内容**：写一个流式传输给定文件内容的程序。
137.  **在文件树中搜索文件/文件夹**：编写一个搜索给定文件树中给定文件/文件夹的程序。
138.  **有效地读取/写入文本文件**：写几个程序以举例说明以有效的方式读取和编写文本文件的不同方法。
139.  **有效地阅读/编写二进制文件**：写几个程序以举例说明以有效的方式读取和编写二进制文件的不同方法。
140.  **在大文件中搜索**：编写一个有效地搜索大文件中给定字符串的程序。
141.  **读取 json / csv 文件作为对象**：写一个将给定的 json / csv 文件作为对象（pojo）读取的程序。
142.  **使用临时文件/文件夹**：编写多个程序，用于使用临时文件/文件夹。
143.  **过滤文件**：为文件写几个用户定义的过滤器。
144.  **发现两个文件之间的不匹配**：写一个程序，该程序在字节级别处发现两个文件之间的不匹配。
145.  **循环字节缓冲区**：写一个表示循环字节缓冲区的实现的程序。
146.  **令授权文件**：写几个代码片段以举例说明授权文件内容的不同技术。
147.  **将格式化输出写入文件**：写一个程序格式化给定数字（整数和双打）并将它们输出到文件。
148.  **使用** `Scanner`：写几个代码片段以显示`Scanner`功能。

# 解决方案

以下部分描述了前述问题的解决方案。 请记住，几乎不是一个正确的方法来解决特定问题。 此外，请记住，这里所示的解释仅包括解决问题所需的最有趣和重要细节。 您可以下载示例解决方案以查看其他详细信息并与 [https://github.com/packtpublishing/java-coding-problems 的程序进行实验](https://github.com/PacktPublishing/Java-Coding-Problems)。

# 129.创建文件路径

从 JDK 7 开始，我们可以通过 NIO.2 API 创建文件路径。 更确切地说，可以通过`Path`和`Paths` API 轻松定义文件路径。

`Path`类是文件系统中路径的程序化表示。 路径字符串包含以下信息：

*   文件名
*   目录列表
*   OWS 相关文件分隔符（例如，Solaris 和 Linux 上的正向斜杠`/`以及 Microsoft Windows 上的反斜杠`\`）
*   其他允许的字符，例如`.`（当前目录）和`..`（父目录）符号

`Path`类与不同文件系统（`FileSystem`）中的文件一起使用，可以使用不同的存储位置（`FileStore`是底层存储）。

用于定义`Path`的常见解决方案是调用`Paths`辅助类的`get()`方法之一。 另一种解决方案依赖于`FileSystems.getDefault().getPath()`方法。

a `Path`驻留在文件系统 - *中，文件系统存储和组织文件或某种形式的介质，通常在一个或多个硬盘驱动器上，这样可以轻松地检索它们*。 可以通过`final`的`java.nio.file.FileSystems`的`final`类获取文件系统，该类用于获取`java.nio.file.FileSystem`的实例。 可以通过`FileSystems().getDefault()`方法获得 JVM 的默认`FileSystem`（通常称为操作系统的默认文件系统）。 一旦我们知道文件系统和文件（或目录/文件夹）的位置，我们就可以为其创建`Path`对象。

另一种方法包括从**统一资源标识符**（ **URI** ）中创建`Path`。 Java 通过`URI`类包裹`URI`; 然后，我们可以通过`URI.create(String uri)`方法从`String`获得`URI`。 此外，`Paths`类提供了一个`get()`方法，它将`URI`对象作为参数，返回相应的`Path`。

从 JDK 11 开始，我们可以通过两个`of()`方法创建`Path`。 其中一个将`URI`转换为`Path`，而另一个将转换为路径字符串或一系列字符串，加入为路径串。

在即将到来的部分中，我们将查看我们可以创建路径的各种方式。

# 创建相对于文件存储根的路径

相对于当前文件存储根的路径（例如，`C:/`）必须以文件分隔符开头。 在以下示例中，如果当前文件存储根源是`C`，则绝对路径为`C:\learning\packt\JavaModernChallenge.pdf`：

```
Path path = Paths.get("/learning/packt/JavaModernChallenge.pdf");
Path path = Paths.get("/learning", "packt/JavaModernChallenge.pdf");

Path path = Path.of("/learning/packt/JavaModernChallenge.pdf");
Path path = Path.of("/learning", "packt/JavaModernChallenge.pdf");

Path path = FileSystems.getDefault()
  .getPath("/learning/packt", "JavaModernChallenge.pdf");
Path path = FileSystems.getDefault()
  .getPath("/learning/packt/JavaModernChallenge.pdf");

Path path = Paths.get(
  URI.create("file:///learning/packt/JavaModernChallenge.pdf"));
Path path = Path.of(
  URI.create("file:///learning/packt/JavaModernChallenge.pdf"));
```

# 创建相对于当前文件夹的路径

当我们创建一个相对于当前工作文件夹的路径时，路径应该*不是*从文件分隔符开始。 如果当前文件夹被命名为`books`并且位于`C` root 下，则以下代码片段返回的绝对路径将是`C:\books\learning\packt\JavaModernChallenge.pdf`：

```
Path path = Paths.get("learning/packt/JavaModernChallenge.pdf");
Path path = Paths.get("learning", "packt/JavaModernChallenge.pdf");

Path path = Path.of("learning/packt/JavaModernChallenge.pdf");
Path path = Path.of("learning", "packt/JavaModernChallenge.pdf");

Path path = FileSystems.getDefault()
  .getPath("learning/packt", "JavaModernChallenge.pdf");
Path path = FileSystems.getDefault()
  .getPath("learning/packt/JavaModernChallenge.pdf");
```

# 创建绝对路径

创建绝对路径可以通过显式指定根目录和包含文件或文件夹的所有其他子目录来完成，如以下示例所示（`C:\learning\packt\JavaModernChallenge.pdf`）所示：

```
Path path = Paths.get("C:/learning/packt", "JavaModernChallenge.pdf");
Path path = Paths.get(
  "C:", "learning/packt", "JavaModernChallenge.pdf");
Path path = Paths.get(
  "C:", "learning", "packt", "JavaModernChallenge.pdf");
Path path = Paths.get("C:/learning/packt/JavaModernChallenge.pdf");
Path path = Paths.get(
  System.getProperty("user.home"), "downloads", "chess.exe");

Path path = Path.of(
  "C:", "learning/packt", "JavaModernChallenge.pdf");
Path path = Path.of(
  System.getProperty("user.home"), "downloads", "chess.exe");

Path path = Paths.get(URI.create(
  "file:///C:/learning/packt/JavaModernChallenge.pdf"));
Path path = Path.of(URI.create(
  "file:///C:/learning/packt/JavaModernChallenge.pdf"));
```

# 使用快捷方式创建路径

我们理解快捷方式是`.`（当前目录）和`..`（父目录）符号。 这种路径可以通过`normalize()`方法归一化。 此方法消除了诸如`.`和`directory/..`的冗余：

```
Path path = Paths.get(
  "C:/learning/packt/chapters/../JavaModernChallenge.pdf")
    .normalize();
Path path = Paths.get(
  "C:/learning/./packt/chapters/../JavaModernChallenge.pdf")
    .normalize();

Path path = FileSystems.getDefault()
  .getPath("/learning/./packt", "JavaModernChallenge.pdf")
    .normalize();

Path path = Path.of(
  "C:/learning/packt/chapters/../JavaModernChallenge.pdf")
    .normalize();
Path path = Path.of(
  "C:/learning/./packt/chapters/../JavaModernChallenge.pdf")
    .normalize();
```

没有归一化，路径的冗余部分不会被删除。

对于创建 100％与当前操作系统兼容的路径，我们可以依赖于`FileSystems.getDefault().getPath()`，或`File.separator`（系统依赖默认名称分隔符）和`File.listRoots()`（可用文件系统根）的组合。 对于相对路径，我们可以依赖以下示例：

```
private static final String FILE_SEPARATOR = File.separator;
```

或者，我们可以依赖于`getSeparator()`：

```

private static final String FILE_SEPARATOR
  = FileSystems.getDefault().getSeparator();

// relative to current working folder
Path path = Paths.get("learning",
  "packt", "JavaModernChallenge.pdf");
Path path = Path.of("learning",
  "packt", "JavaModernChallenge.pdf");
Path path = Paths.get(String.join(FILE_SEPARATOR, "learning",
  "packt", "JavaModernChallenge.pdf"));
Path path = Path.of(String.join(FILE_SEPARATOR, "learning",
  "packt", "JavaModernChallenge.pdf"));

// relative to the file store root
Path path = Paths.get(FILE_SEPARATOR + "learning",
  "packt", "JavaModernChallenge.pdf");
Path path = Path.of(FILE_SEPARATOR + "learning",
  "packt", "JavaModernChallenge.pdf");
```

我们也可以对绝对路径做同样的事情：

```
Path path = Paths.get(File.listRoots()[0] + "learning",
  "packt", "JavaModernChallenge.pdf");
Path path = Path.of(File.listRoots()[0] + "learning",
  "packt", "JavaModernChallenge.pdf");
```

可以通过`FileSystems`获得根目录列表：

```
FileSystems.getDefault().getRootDirectories()
```

# 130.转换文件路径

将文件路径转换为`String`，`URI`，`File`，等等是在各种应用中可能发生的常见任务。 让我们考虑以下文件路径：

```
Path path = Paths.get("/learning/packt", "JavaModernChallenge.pdf");
```

现在，基于 JDK 7 和 NIO.2 API，让我们看看我们如何将`Path`转换为`String`，a `URI`，绝对路径，a *实际*路径，以及一个 文件：

*   将`Path`转换为`String`如呼叫（明确或自动）`Path.toString()`方法一样简单。 请注意，如果通过`FileSystem.getPath()`方法获得路径，则`toString()`返回的路径字符串可能与用于创建路径的初始`String`不同：

```
// \learning\packt\JavaModernChallenge.pdf
String pathToString = path.toString();
```

*   将`Path`转换为`URI`（浏览器格式）可以通过`Path.toURI()`方法来完成。 返回的`URI`包装了可以在 Web 浏览器的地址栏中使用的路径字符串：

```
// file:///D:/learning/packt/JavaModernChallenge.pdf
URI pathToURI = path.toUri();
```

假设我们希望将存在的文件名提取为`URI` / `URL`作为`Path`（这是遇到的常见方案）。 在这种情况下，我们可以依赖以下代码片段：

```
// JavaModernChallenge.pdf
URI uri = URI.create(
  "https://www.learning.com/packt/JavaModernChallenge.pdf");
Path URIToPath = Paths.get(uri.getPath()).getFileName();

// JavaModernChallenge.pdf
URL url = new URL(
  "https://www.learning.com/packt/JavaModernChallenge.pdf");
Path URLToPath = Paths.get(url.getPath()).getFileName();
```

路径的转换可以如下完成：

*   将相对`Path`转换为绝对`Path`，可以通过`Path.toAbsolutePath()`方法来完成。 如果`Path`已经是绝对的，那么将返回相同的结果：

```
// D:\learning\packt\JavaModernChallenge.pdf
Path pathToAbsolutePath = path.toAbsolutePath();
```

*   将`Path`转换为*实际* `Path`可以通过`Path.toRealPath()`方法来完成，其结果取决于实现。 如果未存在的文件不存在，则此方法将抛出`IOException`。 但是，作为拇指的规则，调用此方法的结果是没有冗余元素的绝对路径（归一化）。 此方法获取一个参数，指示应该如何处理*符号链接*。 默认情况下，如果文件系统支持*符号链接*，则此方法将尝试解决它们。 如果您希望忽略*符号链接*，只需将`LinkOption.NOFOLLOW_LINKS`常量传递给方法。 此外，路径名元素将表示目录和文件的实际名称。

例如，让我们考虑以下`Path`和调用此方法的结果（请注意，我们有意添加了几个冗余元素并大写`PACKT`文件夹）：

```
Path path = Paths.get(
  "/learning/books/../PACKT/./", "JavaModernChallenge.pdf");

// D:\learning\packt\JavaModernChallenge.pdf
Path realPath = path.toRealPath(LinkOption.NOFOLLOW_LINKS);
```

*   将`Path`转换为文件可以通过`Path.toFile()`方法来完成。 将文件转换为`Path`，我们可以依赖`File.toPath()`方法：

```
File pathToFile = path.toFile();
Path fileToPath = pathToFile.toPath();
```

# 131.加入文件路径

连接（或组合）文件路径意味着定义固定的根路径并将其附加到它是部分路径或替换它的一部分（例如，需要用另一个文件名替换文件名）。 基本上，当我们想要创建共享公共固定部分的新路径时，这是一种方便的技术。

这可以通过 NiO 2 和`Path.resolve()`和`Path.resolveSibling()`方法来实现。

让我们考虑以下固定的根路径：

```
Path base = Paths.get("D:/learning/packt");
```

让我们也假设我们希望获得两本不同书籍的`Path`：

```
// D:\learning\packt\JBossTools3.pdf
Path path = base.resolve("JBossTools3.pdf");

// D:\learning\packt\MasteringJSF22.pdf
Path path = base.resolve("MasteringJSF22.pdf");
```

我们可以使用此功能来循环一组文件; 例如，让我们的循环成为书籍的`String[]`：

```
Path basePath = Paths.get("D:/learning/packt");
String[] books = {
  "Book1.pdf", "Book2.pdf", "Book3.pdf"
};

for (String book: books) {
  Path nextBook = basePath.resolve(book);
  System.out.println(nextBook);
}
```

有时，固定的根路径也包含文件名：

```
Path base = Paths.get("D:/learning/packt/JavaModernChallenge.pdf");
```

这次，我们可以通过`resolveSibling()`方法用另一个名称替换文件（`JavaModernChallenge.pdf`）的名称。 此方法解析对此路径的父路径的给定路径，如下例所示：

```
// D:\learning\packt\MasteringJSF22.pdf
Path path = base.resolveSibling("MasteringJSF22.pdf");
```

如果我们将`Path.getParent()`方法带入讨论并链接`resolve()`和`resolveSibling()`方法，那么我们可以创建更复杂的路径，如以下示例所示：

```
// D:\learning\publisher\MyBook.pdf
Path path = base.getParent().resolveSibling("publisher")
  .resolve("MyBook.pdf");
```

`resolve()` / `resolveSibling()`方法分别有两种口味 - `resolve​(String other)` / `resolveSibling​(String other)`和`resolve​(Path other)` / `resolveSibling​(Path other)`。

# 132.构建两个位置之间的路径

构造两个位置之间的相对路径是`Path.relativize()`方法的作业。

基本上，所产生的相对路径（由`Path.relativize()`返回）从路径开始，并在另一条路径上结束。 这是一个强大的功能，允许我们使用与前一条路径解析的相对路径之间的不同位置之间导航。

让我们考虑以下两条路径：

```
Path path1 = Paths.get("JBossTools3.pdf");
Path path2 = Paths.get("JavaModernChallenge.pdf");
```

请注意，`JBossTools3.pdf`和`JavaModernChallenge.pdf`是兄弟姐妹。 这意味着我们可以通过上升一个级别然后向下级别来导航到另一个级别。 以下示例揭示了该导航案例：

```
// ..\JavaModernChallenge.pdf
Path path1ToPath2 = path1.relativize(path2);

// ..\JBossTools3.pdf
Path path2ToPath1 = path2.relativize(path1);
```

另一个常见的案例涉及一个常见的根元素：

```
Path path3 = Paths.get("/learning/packt/2003/JBossTools3.pdf");
Path path4 = Paths.get("/learning/packt/2019");
```

所以，`path3`和`path4`共享相同的公共根元素`/learning`。 从`path3`导航到`path4`，我们需要上升两个级别和下降一个级别。 此外，对于从`path4`到`path3`导航，我们需要上升一个水平和两个级别。 查看以下代码：

```
// ..\..\2019
Path path3ToPath4 = path3.relativize(path4);

// ..\2003\JBossTools3.pdf
Path path4ToPath3 = path4.relativize(path3);
```

这两个路径必须包括根元素。 完成此要求并不能保证成功，因为相对路径的构建是依赖的。

# 133.比较文件路径

根据我们如何在两个文件路径之间的平等程度上，有几个解决问题的解决方案。 主要是，可以以不同的目标以不同的方式验证`Path`平等。

让我们假设我们有以下三条路径（考虑在计算机上再现`path3`）：

```
Path path1 = Paths.get("/learning/packt/JavaModernChallenge.pdf");
Path path2 = Paths.get("/LEARNING/PACKT/JavaModernChallenge.pdf");
Path path3 = Paths.get("D:/learning/packt/JavaModernChallenge.pdf");
```

在以下部分中，我们将查看用于比较文件路径的不同方法。

# path.equals（）

是`path1`等于`path2`？ 或者，`path2`等于`path3`？ 嗯，如果我们通过`Path.equals()`执行这些测试，那么可能的结果将显示`path1`等于`path2`，但`path2`不等于`path3`：

```
boolean path1EqualsPath2 = path1.equals(path2); // true
boolean path2EqualsPath3 = path2.equals(path3); // false
```

`Path.equals()`方法遵循`Object.equals()`规范。 虽然此方法无法访问文件系统，但相等取决于文件系统实现。 例如，某些文件系统实现可以以区分大小写的方式比较路径，而其他文件系统可以忽略案例。

# 代表相同文件/文件夹的路径

但是，这可能不是我们想要的那种比较。 说，如果它们是相同的文件或文件夹，则两个路径相等是更有意义的。 这可以通过`Files.isSameFile()`方法来完成。 此方法有两个步骤：

1.  首先，它调用`Path.equals()`，如果此方法返回`true`，则路径相等，不需要进一步的操作。

2.  第二，如果`Path.equals()`返回`false`，则检查两个路径是否表示同一文件/文件夹（根据实现，此操作可能需要打开/访问两个文件，因此必须存在文件以避免文件以避免文件 `IOException`）。

```
//true
boolean path1IsSameFilePath2 = Files.isSameFile(path1, path2);
//true
boolean path1IsSameFilePath3 = Files.isSameFile(path1, path3);
//true
boolean path2IsSameFilePath3 = Files.isSameFile(path2, path3);
```

# 词典比较

如果我们想要的只是路径的词典比较，那么我们可以依赖于`Path.compareTo()`方法（这对排序有用）。

此方法返回以下信息：

*   如果路径相等，则为 0
*   如果第一路径少于参数路径，则值小于零
*   如果第一路径大于参数路径，则值大于零值：

```
int path1compareToPath2 = path1.compareTo(path2); // 0
int path1compareToPath3 = path1.compareTo(path3); // 24
int path2compareToPath3 = path2.compareTo(path3); // 24
```

请注意，您可以获得比前面的示例中的不同值。 此外，在您的业务逻辑中，依赖于其含义而不是它们的值非常重要（例如，说`if(path1compareToPath3 > 0) { ... }`并避免`if(path1compareToPath3 == 24) { ... }`）。

# 部分比较

通过`Path.startsWith()`和`Path.endsWith()`方法可以实现部分比较。 使用这些方法，我们可以测试当前路径是否使用给定路径启动/结尾：

```
boolean sw = path1.startsWith("/learning/packt");       // true
boolean ew = path1.endsWith("JavaModernChallenge.pdf"); // true
```

# 134.步行道路

步行（或访问）路径存在不同的解决方案，其中一个通过`FileVisitor`接口提供了 NIO.2 API。

此接口公开了一组方法，该方法表示访问给定路径的递归过程中的检查点。 通过覆盖这些检查点，我们被允许在此过程中干扰。 我们可以处理当前访问的文件/文件夹，并通过`FileVisitResult`枚举来确定应进一步发生的内容，其中包含以下常量：

*   `CONTINUE`：遍历过程应继续（访问下一个文件，文件夹，跳过故障，等等）
*   `SKIP_SIBLINGS`：遍历过程应继续，而不访问当前文件/文件夹的兄弟姐妹
*   `SKIP_SUBTREE`：遍历过程应继续，而不需要访问当前文件夹中的条目
*   `TERMINATE`：遍历应该残酷终止

通过`FileVisitor`曝光的方法如下：

*   `FileVisitResult visitFile​(T file, BasicFileAttributes attrs) throws IOException`：自动调用每个访问的文件/文件夹
*   `FileVisitResult preVisitDirectory​(T dir, BasicFileAttributes attrs) throws IOException`：在访问其内容之前自动调用文件夹
*   `FileVisitResult postVisitDirectory​(T dir, IOException exc) throws IOException`：访问目录中的内容（包括后代）后自动调用，或者在文件夹的迭代期间，发生 I / O 错误或访问以编程方式中止
*   `FileVisitResult visitFileFailed​(T file, IOException exc) throws IOException`：由于不同的原因无法访问文件（访问）时自动调用（例如，无法读取文件的属性或无法打开文件夹）

好的; 到目前为止，一切都很好！ 让我们继续使用几个实际的例子。

# 琐事遍历文件夹

实现`FileVisitor`界面要求我们覆盖其四种方法。 但是，NIO.2 附带了一个名为`SimpleFileVisitor`的此接口的内置简单实现。 对于简单的情况，扩展此类比实现`FileVisitor`更方便，因为它允许我们仅覆盖必要的方法。

例如，让我们假设我们将我们的电子课程存储在`D:/learning`文件夹的子文件夹中，我们希望通过`FileVisitor` api 访问这些子文件夹中的每一个。 如果在子文件夹的迭代期间出现问题，我们将简单地抛出报告的异常。

为了塑造这种行为，我们需要覆盖`postVisitDirectory()`方法，如下所示：

```
class PathVisitor extends SimpleFileVisitor<Path> {

  @Override
  public FileVisitResult postVisitDirectory(
      Path dir, IOException ioe) throws IOException {

    if (ioe != null) {
      throw ioe;
    }

    System.out.println("Visited directory: " + dir);

    return FileVisitResult.CONTINUE;
  }
}
```

为了使用`PathVisitor`类，我们只需要设置路径并调用其中一个方法，如下所示（这里使用的`walkFileTree()`的味道获取起始文件/文件夹和相应的`FileVisitor`）：

```
Path path = Paths.get("D:/learning");
PathVisitor visitor = new PathVisitor();

Files.walkFileTree(path, visitor);
```

通过使用前面的代码，我们将收到以下输出：

```
Visited directory: D:\learning\books\ajax
Visited directory: D:\learning\books\angular
...
```

# 按名称搜索文件

在计算机上搜索某个文件是一个常见的任务。 通常，我们依靠操作系统或附加工具提供的工具，但如果我们想要以编程方式完成此操作（例如，我们可能希望用特殊功能编写文件搜索工具），那么`FileVisitor`可以帮助我们 以非常直接的方式实现这一目标。 此应用程序的存根列出如下：

```
public class SearchFileVisitor implements FileVisitor {

  private final Path fileNameToSearch;
  private boolean fileFound;
  ...

  private boolean search(Path file) throws IOException {

    Path fileName = file.getFileName();

    if (fileNameToSearch.equals(fileName)) {
      System.out.println("Searched file was found: " +
        fileNameToSearch + " in " + file.toRealPath().toString());

      return true;
    }

    return false;
  }
}
```

让我们来看看主要检查点，并按照名称搜索文件的实施：

*   `visitFile()`是我们的主要检查站。 一旦我们控制，我们就可以查询当前访问的文件，以获取其名称，扩展名，属性等。 需要此信息以绘制与搜索文件中相同信息的比较。 例如，我们比较名称，并在第一场比赛中，我们`TERMINATE`搜索。 但如果我们搜索更多这样的文件（如果我们知道有多个），那么我们可以返回`CONTINUE`：

```
@Override
public FileVisitResult visitFile(
  Object file, BasicFileAttributes attrs) throws IOException {

  fileFound = search((Path) file);

  if (!fileFound) {
    return FileVisitResult.CONTINUE;
  } else {
    return FileVisitResult.TERMINATE;
  }
}
```

`visitFile()`方法不能用于查找文件夹。 使用`preVisitDirectory()`或`postVisitDirectory()`方法。

*   `visitFileFailed()`是第二个重要的检查点。 调用此方法时，我们知道访问当前文件时出现问题。 我们宁愿忽略任何此类问题和`CONTINUE`搜索。 停止搜索过程是毫无意义的：

```
@Override
public FileVisitResult visitFileFailed(
  Object file, IOException ioe) throws IOException {
  return FileVisitResult.CONTINUE;
}
```

`preVisitDirectory()`和`postVisitDirectory()`方法不会携带任何重要任务，因此我们可以跳过简洁性。

为了开始搜索，我们依靠`Files.walkFileTree()`方法的另一个味道。 这次，我们指定搜索的起点（例如，所有根），搜索期间使用的选项（例如，遵循*符号链接*），访问的最大目录级别数（ 例如，`Integer.MAX_VALUE`）和`FileVisitor`（例如，`SearchFileVisitor`）：

```
Path searchFile = Paths.get("JavaModernChallenge.pdf");

SearchFileVisitor searchFileVisitor 
  = new SearchFileVisitor(searchFile);

EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);
Iterable<Path> roots = FileSystems.getDefault().getRootDirectories();

for (Path root: roots) {
  if (!searchFileVisitor.isFileFound()) {
    Files.walkFileTree(root, opts,
      Integer.MAX_VALUE, searchFileVisitor);
  }
}
```

如果您查看用本书捆绑在一起的代码，前面的搜索将以递归方式遍历计算机的所有根（目录）。 前面的示例可以容易地适用于通过扩展，通过模式搜索或从某些文本查看文件。

# 删除文件夹

在尝试删除文件夹之前，必须删除它的所有文件。 此声明非常重要，因为它不允许我们只需调用包含文件的文件夹的`delete()` / `deleteIfExists()`方法。 对此问题的优雅解决方案依赖于从以下存根启动的`FileVisitor`实现：

```
public class DeleteFileVisitor implements FileVisitor {
  ...
  private static boolean delete(Path file) throws IOException {

    return Files.deleteIfExists(file);
  }
}
```

让我们来看看主要的检查点和删除文件夹的实现：

*   `visitFile()`是从给定文件夹或子文件夹中删除每个文件的完美位置（如果无法删除文件，则只需将其传递给下一个文件，但随时可以根据您的需求调整代码）：

```
@Override
public FileVisitResult visitFile(
  Object file, BasicFileAttributes attrs) throws IOException {

  delete((Path) file);

  return FileVisitResult.CONTINUE;
}
```

*   只有为空才能删除文件夹，因此`postVisitDirectory()`是这样做的完美位置（我们忽略了任何潜在的`IOException`，但随时适应代码以满足您的需求（例如，记录名称 无法删除或抛出异常以停止该过程的文件夹）：

```
@Override
public FileVisitResult postVisitDirectory(
    Object dir, IOException ioe) throws IOException {

  delete((Path) dir);

  return FileVisitResult.CONTINUE;
}
```

在`visitFileFailed()`和`preVisitDirectory()`中，我们只是返回`CONTINUE`。

要删除文件夹，请在`D:/learning`中，我们可以调用`DeleteFileVisitor`，如下所示：

```
Path directory = Paths.get("D:/learning");
DeleteFileVisitor deleteFileVisitor = new DeleteFileVisitor();
EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);

Files.walkFileTree(directory, opts, 
  Integer.MAX_VALUE, deleteFileVisitor);
```

通过组合`SearchFileVisitor`和`DeleteFileVisitor`，我们可以获得搜索删除应用程序。

# 复制文件夹

要复制文件，我们可以依赖`Path copy​(Path source, Path target, CopyOption options) throws IOException`方法。 此方法将文件复制到目标文件，其中`options`参数指定如何执行副本。

通过将`copy()`方法与自定义`FileVisitor`组合，我们可以复制整个文件夹（包括其所有内容）。 此自定义`FileVisitor`的存根代码列出如下：

```
public class CopyFileVisitor implements FileVisitor {

  private final Path copyFrom;
  private final Path copyTo;
  ...

  private static void copySubTree(
      Path copyFrom, Path copyTo) throws IOException {

    Files.copy(copyFrom, copyTo, 
      REPLACE_EXISTING, COPY_ATTRIBUTES);
  }
}
```

让我们来看看主要的检查点和复制文件夹的实现（请注意，我们将通过复制我们可以的任何东西来沉迷地行动，并避免抛出异常，但随时适应适合您的需求的代码）：

*   在从源文件夹复制任何文件之前，我们需要复制源文件夹本身。 复制源文件夹（空无论）将导致空目标文件夹。 这是在`preVisitDirectory()`方法中完成的完美任务：

```
@Override
public FileVisitResult preVisitDirectory(
  Object dir, BasicFileAttributes attrs) throws IOException {

  Path newDir = copyTo.resolve(
    copyFrom.relativize((Path) dir));

  try {
    Files.copy((Path) dir, newDir, 
      REPLACE_EXISTING, COPY_ATTRIBUTES);
  } catch (IOException e) {
    System.err.println("Unable to create "
      + newDir + " [" + e + "]");

    return FileVisitResult.SKIP_SUBTREE;
  }

  return FileVisitResult.CONTINUE;
}
```

*   `visitFile()`方法是复制每个文件的完美位置：

```
@Override
public FileVisitResult visitFile(
  Object file, BasicFileAttributes attrs) throws IOException {

  try {
    copySubTree((Path) file, copyTo.resolve(
      copyFrom.relativize((Path) file)));
  } catch (IOException e) {
    System.err.println("Unable to copy " 
      + copyFrom + " [" + e + "]");
  }

  return FileVisitResult.CONTINUE;
}
```

*   可选地，我们可以保留源目录的属性。 只有在将文件复制到`postVisitDirectory()`方法（例如，让您保留最后一个修改时间）之后，只能完成这一点：

```
@Override
public FileVisitResult postVisitDirectory(
    Object dir, IOException ioe) throws IOException {

  Path newDir = copyTo.resolve(
    copyFrom.relativize((Path) dir));

  try {
    FileTime time = Files.getLastModifiedTime((Path) dir);
    Files.setLastModifiedTime(newDir, time);
  } catch (IOException e) {
    System.err.println("Unable to preserve 
      the time attribute to: " + newDir + " [" + e + "]");
  }

  return FileVisitResult.CONTINUE;
}
```

*   如果无法访问文件，则将调用`visitFileFailed()`。 这是检测*循环链接*并报告它们的好时机。 通过以下链接（`FOLLOW_LINKS`），我们可以遇到文件树具有*循环链接*到父文件夹的情况。 通过`visitFileFailed()`中的`FileSystemLoopException`例外报告这些病例：

```
@Override
public FileVisitResult visitFileFailed(
    Object file, IOException ioe) throws IOException {

  if (ioe instanceof FileSystemLoopException) {
    System.err.println("Cycle was detected: " + (Path) file);
  } else {
    System.err.println("Error occured, unable to copy:"
      + (Path) file + " [" + ioe + "]");
  }

  return FileVisitResult.CONTINUE;
}
```

让我们将`D:/learning/packt`文件夹复制到`D:/e-courses`：

```
Path copyFrom = Paths.get("D:/learning/packt");
Path copyTo = Paths.get("D:/e-courses");

CopyFileVisitor copyFileVisitor 
  = new CopyFileVisitor(copyFrom, copyTo);

EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);

Files.walkFileTree(copyFrom, opts, Integer.MAX_VALUE, copyFileVisitor);
```

通过组合`CopyFileVisitor`和`DeleteFileVisitor`，我们可以轻松地为移动文件夹塑造应用程序。 在与本书捆绑的代码中，也有一个移动文件夹的完整示例。 基于我们到目前为止累积的专业知识，如果没有进一步的详细信息，代码应该非常访问。

在记录关于文件的信息时注意（例如，在处理异常的情况下），因为文件（例如，它们的名称，路径和属性）可能包含可以在恶意中被利用的敏感信息 时尚。

# JDK 8，Files.walk（）

从 JDK 8 开始，`Files`类已经丰富了两个`walk()`方法。 这些方法返回一个懒惰地填充`Path`的`Stream`。 它通过步行使用给定的最大深度和选项来携带源性的文件树来实现这一点：

```
public static Stream<Path> walk​(
  Path start, FileVisitOption...options) 
    throws IOException

public static Stream<Path> walk​(
  Path start, int maxDepth, FileVisitOption...options) 
    throws IOException
```

例如，让我们从`D:/learning/books/cdi`开始从`D:/learning`的所有路径：

```
Path directory = Paths.get("D:/learning");

Stream<Path> streamOfPath = Files.walk(
  directory, FileVisitOption.FOLLOW_LINKS);

streamOfPath.filter(e -> e.startsWith("D:/learning/books/cdi"))
  .forEach(System.out::println);
```

现在，让我们计算文件夹的字母表（例如，`D:/learning`）：

```
long folderSize = Files.walk(directory)
  .filter(f -> f.toFile().isFile())
  .mapToLong(f -> f.toFile().length())
  .sum();
```

该方法是弱一致的。 它不会在迭代过程中冻结文件树。 文件树的潜在更新可能或可能不会被反映。

# 135.看路径

观看更改的路径只是可以通过 JDK 7 NiO2，低级`WatchService` API 来完成的线程安全目标之一。

简而言之，通过以下两个主要步骤可以观看一条路径以进行更改：

1.  注册要查看不同类型的事件类型的文件夹（或文件夹）。
2.  当`WatchService`检测到注册的事件类型时，它在单独的线程中处理，因此监视服务不会被阻止。

在 API 级别，起始点是`WatchService`接口。 此接口有不同的文件/操作系统的样本。

此界面与两个主要类一起工作。 它们一起提供了一种方便的方法，您可以实现以将监视功能添加到某个上下文（例如，到文件系统）：

*   `Watchable`：实现此接口的任何对象是一个*无法观察对象*，因此可以观看更改（例如，`Path`）

*   `StandardWatchEventKinds`：此类定义了标准*事件类型*（这些是我们可以注册通知的事件类型：
    *   `ENTRY_CREATE`：创建目录条目
    *   `ENTRY_DELETE`：删除目录条目
    *   `ENTRY_MODIFY`：directory 条目修改; 被视为修改的内容有些特定于平台，但实际修改文件的内容应该始终触发此事件类型
    *   `OVERFLOW`：表示事件可能丢失或丢弃的特殊事件

`WatchService`称为*观察者*，我们说*观察者*手表*观察到*。 在以下示例中，将通过`FileSystem`类创建`WatchService`，并将观看已注册的`Path`。

# 观看文件夹进行更改

让我们从一个存根方法开始，它获取应该监视的文件夹的`Path`，以便更改为参数：

```
public void watchFolder(Path path) 
    throws IOException, InterruptedException {
  ...
}
```

`WatchService`将在给定文件夹上发生任何`ENTRY_CREATE`，`ENTRY_DELETE`和`ENTRY_MODIFY`事件类型时通知我们。 为此，我们需要遵循几个步骤：

1.  创建`WatchService`以便我们可以监视文件系统 - 这是通过`FileSystem.newWatchService()`完成的，如下所示：

```
WatchService watchService 
  = FileSystems.getDefault().newWatchService();
```

2.  注册应该通知的事件类型 - 这是通过`Watchable.register()`完成的：

```
path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
  StandardWatchEventKinds.ENTRY_MODIFY,
  StandardWatchEventKinds.ENTRY_DELETE);
```

对于每个*无法观察对象*，我们将注册令牌接收为`WatchKey`实例（*监视键*）。 我们在注册时间收到此*键*，但每次触发事件时，`WatchService`返回相关的`WatchKey`。

3.  现在，我们需要等待传入的事件。 这在无限循环中完成（当发生事件时，*观察者*负责排队对应的*键*以供稍后检索并将其状态转换为*信号通知* ）：

```
while (true) {
  // process the incoming event types
}
```

4.  现在，我们需要检索*监视键* - 至少有三种专用于检索*监视*的方法：
    *   `poll()`：从队列中返回下一个键并删除它（或者，如果存在键，则会返回`null`）。
    *   `poll​(long timeout, TimeUnit unit)`：从队列中返回下一个密钥并删除它; 如果没有键存在，则它会等待指定的超时并再次尝试。 如果键仍然不可用，那么它返回`null`。
    *   `take()`：从队列中返回下一个密钥并删除它; 如果没有键存在，那么它将等到键排队或无限循环停止：

```
WatchKey key = watchService.take();
```

5.  接下来，我们需要检索*监视键*的待处理事件。 *中的*键*信号通知*状态至少有一个待处理的事件; 我们可以通过`WatchKey.pollEvents()`方法检索和删除某个*监视键*的所有事件（每个事件由`WatchEvent`实例表示）：

```
for (WatchEvent<?> watchEvent : key.pollEvents()) {
  ...
}
```

6.  然后，我们检索有关*事件类型*的信息。 对于每个事件，我们可以获得不同的信息（例如，事件类型，出现次数和上下文专用信息（例如，导致事件的文件名），这对于处理事件是有用的）：

```
Kind<?> kind = watchEvent.kind();
WatchEvent<Path> watchEventPath = (WatchEvent<Path>) watchEvent;
Path filename = watchEventPath.context();
```

7.  接下来，我们重置*监视键*。 a *监视键*具有可以是*的状态*（创建时的初始状态），*信号通知*，或*无效。* 一旦*信号通知*，a *监视键*仍然如此，直到我们调用`reset()`方法，这试图将其放回*准备好*状态 接受事件的状态。 如果从*发出信号*到*就绪*（恢复等待事件）成功，则`reset()`方法返回`true`; 否则，它返回`false`，这意味着*监视键*可以是*无效的*。 一个*监视键*可以在*中无效的*状态如果它不再有效（通过明确调用*监视密钥*的`close()`方法可能引起不活动。 ，关闭观察者，该目录被删除，依此类推）：**

```
boolean valid = key.reset();

if (!valid) {
  break;
}
```

当*中有一个*键*无效的*状态时，没有理由保持在无限循环中。 只需调用`break`跳出循环。

8.  最后，我们关闭了*观察者*。 这可以通过显式调用`WatchService`的方法或依赖于*的方法来实现，如下所示：*

```
try (WatchService watchService
    = FileSystems.getDefault().newWatchService()) {
  ...
}
```

与本书捆绑在一起的代码将所有这些代码片段粘贴到名为`FolderWatcher`的单个类中。 结果将是一个*观察者*，它能够报告创建，删除和修改在指定路径上发生的事件。

要观看路径，即`D:/learning/packt`，我们只需调用`watchFolder()`方法：

```
Path path = Paths.get("D:/learning/packt");

FolderWatcher watcher = new FolderWatcher();
watcher.watchFolder(path);
```

运行应用程序将显示以下消息：

```
Watching: D:\learning\packt
```

现在，我们可以在此文件夹下直接创建，删除或修改文件，然后检查通知。 例如，如果我们只是简单地复制粘贴一个名为`resources.txt`的文件，则输出将如下：

```
ENTRY_CREATE -> resources.txt
ENTRY_MODIFY -> resources.txt
```

最后，不要忘记停止应用程序，因为它将无限期地运行（理论上）。

从这个应用程序开始，用本书捆绑的源代码有两个应用程序。 其中一个是视频捕获系统的模拟，而另一个是打印机托盘观察者的模拟。 通过依靠我们在本节中累积的知识，在没有进一步的详细信息的情况下了解这两种应用应该非常简单。

# 136.流式传输文件的内容

流媒体文件的内容是可以使用`Files.lines()`和`BufferedReader.lines()`方法通过 JDK 8 解决的问题。

`Stream<String> Files.lines​(Path path, Charset cs)`从文件中读取所有行作为`Stream`。 这懒洋洋地发生，因为流被消耗。 在执行终端流操作期间，不应修改文件的内容; 否则，结果是未定义的。

让我们来看看一个读取`D:/learning/packt/resources.txt`文件的内容的示例，并在屏幕上显示它（注意我们在*中运行代码，然后在-uthource* 中，因此文件已关闭 通过关闭流）：

```
private static final String FILE_PATH 
  = "D:/learning/packt/resources.txt";
...
try (Stream<String> filesStream = Files.lines(
  Paths.get(FILE_PATH), StandardCharsets.UTF_8)) {

  filesStream.forEach(System.out::println);
} catch (IOException e) {
  // handle IOException if needed, otherwise remove the catch block
}
```

`BufferedReader`类中有一种没有参数的类似方法：

```
try (BufferedReader brStream = Files.newBufferedReader(
  Paths.get(FILE_PATH), StandardCharsets.UTF_8)) {

  brStream.lines().forEach(System.out::println);
} catch (IOException e) {
  // handle IOException if needed, otherwise remove the catch block
}
```

# 137.在文件树中搜索文件/文件夹

在文件树中搜索文件或文件夹是许多情况下需要的常见任务。 由于 JDK 8 和 New `Files.find()`方法，我们可以轻松实现这一目标。

`Files.find()`方法返回一个`Stream<Path>`，它懒惰地填充了与提供的查找约束匹配的路径填充：

```
public static Stream<Path> find​(
  Path start,
  int maxDepth,
  BiPredicate<Path, ​BasicFileAttributes > matcher,
  FileVisitOption...options
) throws IOException
```

此方法充当`walk()`方法，因此它遍历从给定路径（`start`）开始的当前文件树，并达到最大给定深度（`maxDepth`）。 在当前文件树的迭代期间，此方法适用于给定的谓词（`matcher`）。 通过此谓词，我们指定必须由在最终流中的每个文件匹配的约束。 可选地，我们可以指定一组访问选项（`options`）。

```
Path startPath = Paths.get("D:/learning");
```

让我们来看看一些旨在澄清这种方法的例子：

*   查找以`.properties`扩展结尾的所有文件，然后按照*符号链接*：

```
Stream<Path> resultAsStream = Files.find(
  startPath,
  Integer.MAX_VALUE,
  (path, attr) -> path.toString().endsWith(".properties"),
  FileVisitOption.FOLLOW_LINKS
);
```

*   查找名称以`application`开头的所有常规文件：

```
Stream<Path> resultAsStream = Files.find(
  startPath,
  Integer.MAX_VALUE,
  (path, attr) -> attr.isRegularFile() &amp;&amp;
  path.getFileName().toString().startsWith("application")
);
```

*   查找 2019 年 3 月 16 日以后创建的所有目录：

```
Stream<Path> resultAsStream = Files.find(
  startPath,
  Integer.MAX_VALUE,
  (path, attr) -> attr.isDirectory() &amp;&amp;
    attr.creationTime().toInstant()
      .isAfter(LocalDate.of(2019, 3, 16).atStartOfDay()
        .toInstant(ZoneOffset.UTC))
);
```

如果我们更愿意将约束表达为表达式（例如，正则表达式），那么我们可以使用`PathMatcher`接口。 此接口附带一个名为`matches(Path path)`的方法，可以判断给定路径是否与此匹配器的模式匹配。

a `FileSystem`实现支持 *glob* 和 *regex* 语法（并且可以支持他人）。 约束采用`syntax:pattern`的形式。

基于`PathMatcher`，我们可以编写能够覆盖各种约束的辅助方法。 例如，以下辅助方法仅将辅导给定约束的文件提取为`syntax:pattern`：

```
public static Stream<Path> fetchFilesMatching(Path root,
    String syntaxPattern) throws IOException {

  final PathMatcher matcher
    = root.getFileSystem().getPathMatcher(syntaxPattern);

  return Files.find(root, Integer.MAX_VALUE, (path, attr)
    -> matcher.matches(path) &amp;&amp; !attr.isDirectory());
}
```

通过 *Glob 查找所有 Java 文件*语法可以如下实现：

```
Stream<Path> resultAsStream 
  = fetchFilesMatching(startPath, "glob:**/*.java");
```

如果我们要做的只是列出来自当前文件夹的文件（没有任何约束和单级深度），那么我们可以依赖于`Files.list()`方法，如下图所示：

```
try (Stream<Path> allfiles = Files.list(startPath)) {
  ...
}
```

# 138.有效地阅读/写作文本文件

在 Java 中，有效地阅读文件是选择正确的方法的问题。 为了更好地理解以下示例，假设我们的平台的默认 Charset 是 UTF-8。 以编程方式，可以通过`Charset.defaultCharset()`获得平台的默认字符集。

首先，我们需要区分原始二进制数据和从 Java 透视图中的文本文件。 处理原始二进制数据是两个`abstract`类的作业，即`InputStream`和`OutputStream`。 对于 RAW 二进制数据的流文件，我们专注于`FileInputStream`和`FileOutputStream`类，一次读/写一个字节（8 位）。 对于着名类型的二进制数据，我们还有专用类（例如，应通过`AudioInputStream`而不是`FileInputStream`处理音频文件。

虽然这些类正在为原始二进制数据做出壮观的作业，但它们对文本文件不利，因为它们很慢，可能会产生错误的输出。 如果我们认为通过这些类传输文本文件，则这变得非常清楚意味着从文本文件中读取每个字节并处理（编写字节所需的相同繁琐的流量）。 此外，如果 CHAR 具有超过 1 字节，则可以看到一些奇怪的字符。 换句话说，独立于 Charset（例如，拉丁，中文等）的解码和编码 8 比特可能产生意外输出。

例如，让我们假设我们在 UTF-16 中拥有以下中国诗：

```
Path chineseFile = Paths.get("chinese.txt");

...
```

以下代码不会按预期显示：

```
try (InputStream is = new FileInputStream(chineseFile.toString())) {

  int i;
  while ((i = is.read()) != -1) {
    System.out.print((char) i);
  }
}
```

所以，为了解决这个问题，我们应该指定正确的 Charset。 虽然`InputStream`对此没有支持，但我们可以依赖于`InputStreamReader`（或`OutputStreamReader`）。 此类是从原始字节流到字符流的桥梁，并允许我们指定 charset：

```
try (InputStreamReader isr = new InputStreamReader(
    new FileInputStream(chineseFile.toFile()), 
      StandardCharsets.UTF_16)) {

  int i;
  while ((i = isr.read()) != -1) {
    System.out.print((char) i);
  }
}
```

事情回到了轨道，但仍然很慢！ 现在，应用程序可以一次读取多个单个字节（取决于 charset），并使用指定的 Charset 将它们解码为字符。 但更多的字节仍然很慢。

`InputStreamReader`是射线二进制数据流和字符流之间的桥。 但 Java 也提供了`FileReader`类。 其目标是消除由字符文件表示的字符流的此桥。

对于文本文件，我们有一个被称为`FileReader`类（或`FileWriter`）的专用类。 此类一次读取 2 或 4 个字节（取决于使用的 charset）。 实际上，在 JDK 11 之前，`FileReader`并不支持显式的 Charset。 它只是使用平台的默认 charset。 这对我们不利，因为以下代码不会产生预期的输出：

```
try (FileReader fr = new FileReader(chineseFile.toFile())) {

  int i;
  while ((i = fr.read()) != -1) {
    System.out.print((char) i);
  }
}
```

但从 JDK 11 开始，`FileReader`类被丰富了两个支持显式 Charset 的构造函数：

*   `FileReader​(File file, Charset charset)`
*   `FileReader​(String fileName, Charset charset)`

这次，我们可以重写前面的代码片段并获取预期输出：

```
try (FileReader frch = new FileReader(
    chineseFile.toFile(), StandardCharsets.UTF_16)) {

  int i;
  while ((i = frch.read()) != -1) {
    System.out.print((char) i);
  }
}
```

一次读取 2 或 4 个字节仍然比阅读 1 更好，但它仍然很慢。 此外，请注意，前面的解决方案使用`int`存储检索到的`char`，我们需要将其明确地将其转换为`char`以显示它。 基本上，从输入文件中检索的`char`被转换为`int`，我们将其转换回 A `char`。

这是*缓冲流*进入场景。 想想在网上观看视频时会发生什么。 虽然我们正在观看视频，浏览器提前缓冲传入的字节。 这样，我们有一个平滑的体验，因为我们可以从缓冲区中看到字节，避免通过在网络传输期间看到字节引起的潜在中断：

![](img/73b46680-64fd-4c4b-8286-0dea3ab5997a.png)

相同的原理由诸如`BufferedInputStream`，`BufferedOutputStream`的类用于原始二进制流和`BufferedReader`，以及用于字符流的`BufferedWriter`。 主要思想是在处理之前缓冲数据。 这次，`FileReader`将数据返回到`BufferedReader`，直到它命中行的末尾（例如，`\n`或`\n\r`）。 `BufferedReader`使用 RAM 来存储缓冲数据：

```
try (BufferedReader br = new BufferedReader(
    new FileReader(chineseFile.toFile(), StandardCharsets.UTF_16))) {

  String line;
  // keep buffering and print
  while ((line = br.readLine()) != null) {
    System.out.println(line);
  }
}
```

因此，我们一次读取完整的行，而不是读取 2 个字节，而是更快。 这是一个非常有效的读取文本文件的方法。

为了进一步优化，我们可以通过专用构造函数设置缓冲区的大小。

请注意，`BufferedReader`类了解如何在传入数据的上下文中创建和处理缓冲区，但与数据源无关。 在我们的示例中，数据源是`FileReader`，它是文件，但是相同的`BufferedReader`可以从不同源缓冲数据（例如，网络，文件，控制台，打印机，传感器等）。 最后，我们阅读了我们缓冲的东西。

前面的示例表示 Java 中读取文本文件的主要方法。 从 JDK 8 开始，添加了一组新的方法，使我们的生活更轻松。 为了创建一个`BufferedReader`，我们也可以依赖`Files.newBufferedReader​(Path path, Charset cs)`：

```
try (BufferedReader br = Files.newBufferedReader(
    chineseFile, StandardCharsets.UTF_16)) {

  String line;
  while ((line = br.readLine()) != null) {
    System.out.println(line);
  }
}
```

对于`BufferedWriter`，我们有`Files.newBufferedWriter()`。 这些方法的优点是它们直接支持`Path`。

要将文本文件的内容获取为`Stream<T>`，请查看*中的问题流文件的内容*部分。

可能导致眼睛应变的另一个有效解决方案如下：

```
try (BufferedReader br = new BufferedReader(new InputStreamReader(
    new FileInputStream(chineseFile.toFile()), 
      StandardCharsets.UTF_16))) {

  String line;
  while ((line = br.readLine()) != null) {
    System.out.println(line);
  }
}
```

现在，是时候谈谈读取文本文件直接进入内存。

# 在内存中读取文本文件

`Files`类附带了两种方法，可以在内存中读取整个文本文件。 其中一个是`List<String> readAllLines​(Path path, Charset cs)`：

```
List<String> lines = Files.readAllLines(
  chineseFile, StandardCharsets.UTF_16);
```

此外，我们可以通过`Files.readString​(Path path, Charset cs)`中的`String`中的整个内容：

```
String content = Files.readString(chineseFile, 
  StandardCharsets.UTF_16);
```

虽然这些方法非常方便的文件非常方便，但它们对大文件不是一个不错的选择。 试图在内存中获取大文件易于`OutOfMemoryError`，显然，将消耗很多内存。 或者，在大文件（例如，200 GB）的情况下，我们可以专注于内存映射的文件（`MappedByteBuffer`）。 `MappedByteBuffer`允许我们创建和修改大文件并将其视为非常大的数组。 它们看起来像记忆，即使他们不是。 一切都发生在本土级别：

```
// or use, Files.newByteChannel()
try (FileChannel fileChannel = (FileChannel.open(chineseFile,
    EnumSet.of(StandardOpenOption.READ)))) {

  MappedByteBuffer mbBuffer = fileChannel.map(
    FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());

  if (mbBuffer != null) {
    String bufferContent 
      = StandardCharsets.UTF_16.decode(mbBuffer).toString();

    System.out.println(bufferContent);
    mbBuffer.clear();
  }
}
```

对于巨大的文件，建议遍历具有固定大小的缓冲区，如下所示：

```
private static final int MAP_SIZE = 5242880; // 5 MB in bytes

try (FileChannel fileChannel = (FileChannel.open(chineseFile,
    EnumSet.of(StandardOpenOption.READ)))) {

  int position = 0;
  long length = fileChannel.size();

  while (position < length) {
    long remaining = length - position;
    int bytestomap = (int) Math.min(MAP_SIZE, remaining);

    MappedByteBuffer mbBuffer = fileChannel.map(
      MapMode.READ_ONLY, position, bytestomap);

    ... // do something with the current buffer

    position += bytestomap;
  }
}
```

JDK 13 准备了非易失性映射的释放。 敬请关注！

# 编写文本文件

对于专用于读取文本文件的每个类/方法（例如，`BufferedReader`和`readString()`）Java 提供了编写文本文件的对应物（例如，`BufferedWriter`和`writeString()`）。 以下是通过`BufferedWriter`编写文本文件的示例：

```
Path textFile = Paths.get("sample.txt");

try (BufferedWriter bw = Files.newBufferedWriter(
    textFile, StandardCharsets.UTF_8, StandardOpenOption.CREATE, 
      StandardOpenOption.WRITE)) {
  bw.write("Lorem ipsum dolor sit amet, ... ");
  bw.newLine();
  bw.write("sed do eiusmod tempor incididunt ...");
}
```

将`Iterable`写入文本文件中的一个非常方便的方法是`Files.write​(Path path, Iterable<? extends CharSequence> lines, Charset cs, OpenOption... options)`。 例如，让我们将列表的内容写入文本文件（列表中的每个元素都在文件中写入）：

```
List<String> linesToWrite = Arrays.asList("abc", "def", "ghi");
Path textFile = Paths.get("sample.txt");
Files.write(textFile, linesToWrite, StandardCharsets.UTF_8,
  StandardOpenOption.CREATE, StandardOpenOption.WRITE);
```

最后，要将`String`写入文件，我们可以依靠`Files.writeString​(Path path, CharSequence csq, OpenOption... options)`方法：

```
Path textFile = Paths.get("sample.txt");

String lineToWrite = "Lorem ipsum dolor sit amet, ...";
Files.writeString(textFile, lineToWrite, StandardCharsets.UTF_8,
  StandardOpenOption.CREATE, StandardOpenOption.WRITE);
```

通过`StandardOpenOption`，我们可以控制文件的打开方式。 在前面的示例中，如果它们不存在（`CREATE`），则会创建文件，并且它们被打开以进行写入访问（`WRITE`）。 可用的许多其他选项（例如，`APPEND`，`DELETE_ON_CLOSE`等）。

最后，通过`MappedByteBuffer`来编写文本文件可以如下完成（这对于编写庞大的文本文件很有用）：

```
Path textFile = Paths.get("sample.txt");
CharBuffer cb = CharBuffer.wrap("Lorem ipsum dolor sit amet, ...");

try (FileChannel fileChannel = (FileChannel) Files.newByteChannel(
    textFile, EnumSet.of(StandardOpenOption.CREATE,
      StandardOpenOption.READ, StandardOpenOption.WRITE))) {

  MappedByteBuffer mbBuffer = fileChannel
    .map(FileChannel.MapMode.READ_WRITE, 0, cb.length());

  if (mbBuffer != null) {
    mbBuffer.put(StandardCharsets.UTF_8.encode(cb));
  }
}
```

# 139.有效地阅读/写二进制文件

在以前的问题中，*有效地阅读/写入文本文件*，我们讨论了*缓冲流*（对于清晰的图片，考虑在此之前读取该问题）。 对于二进制文件而言，事情也是如此，因此我们可以直接跳转到一些示例中。

让我们考虑以下二进制文件及其大小以字节：

```
Path binaryFile = Paths.get(
  "build/classes/modern/challenge/Main.class");

int fileSize = (int) Files.readAttributes(
  binaryFile, BasicFileAttributes.class).size();
```

我们可以通过`FileInputStream`在`byte[]`中读取文件的内容（这不使用缓冲）：

```
final byte[] buffer = new byte[fileSize];
try (InputStream is = new FileInputStream(binaryFile.toString())) {

  int i;
  while ((i = is.read(buffer)) != -1) {
    System.out.print("\nReading ... ");
  }
}
```

但是，前面的示例不是很有效。 在读取从该输入流读取`buffer.length`字节时实现高效率，可以通过`BufferedInputStream`完成字节阵列，如下所示：

```
final byte[] buffer = new byte[fileSize];

try (BufferedInputStream bis = new BufferedInputStream(
    new FileInputStream(binaryFile.toFile()))) {

  int i;
  while ((i = bis.read(buffer)) != -1) {
    System.out.print("\nReading ... " + i);
  }
}
```

`FileInputStream`也可以通过`Files.newInputStream()`方法获得。 此方法的优点包括：它直接支持`Path`：

```
final byte[] buffer = new byte[fileSize];

try (BufferedInputStream bis = new BufferedInputStream(
    Files.newInputStream(binaryFile))) {

  int i;
  while ((i = bis.read(buffer)) != -1) {
    System.out.print("\nReading ... " + i);
  }
}
```

如果文件太大，则无法符合文件大小的缓冲区，那么优选的是通过具有固定大小（例如，512 字节）和`read()`味道的较小缓冲区读取它，如下：

*   `read​(byte[] b)`
*   `read​(byte[] b, int off, int len)`
*   `readNBytes​(byte[] b, int off, int len)`
*   `readNBytes​(int len)`

没有参数的`read()`方法将按字节读取输入流字节。 这是最低效的方式，特别是在不使用缓冲的情况下。

或者，如果我们的目标是将输入流读为字节数组，我们可以依赖于`ByteArrayInputStream`（它使用内部缓冲区，因此无需使用`BufferedInputStream`）：

```
final byte[] buffer = new byte[fileSize];

try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer)) {

  int i;
  while ((i = bais.read(buffer)) != -1) {
    System.out.print("\nReading ... ");
  }
}
```

前面的方法适合原始二进制数据，但有时，我们的二进制文件包含某些数据（例如，INTS，Flods 等）。 在这种情况下，`DataInputStream`和`DataOutputStream`为读取和写入某些数据类型提供方便的方法。 让我们考虑我们有一个文件`data.bin`，包含`float`数字。 我们可以有效地阅读如下：

```
Path dataFile = Paths.get("data.bin");

try (DataInputStream dis = new DataInputStream(
    new BufferedInputStream(Files.newInputStream(dataFile)))) {

  while (dis.available() > 0) {
    float nr = dis.readFloat();
    System.out.println("Read: " + nr);
  }
}
```

这两个类只是 Java 提供的*数据过滤器*中的两个。 有关所有支持的*数据过滤器*的概述，请查看`FilterInputStream`的子类。 此外，`Scanner`类是读取某些类型的数据的替代方案。 签出使用扫描仪部分的*中的问题以获取更多信息。*

现在，让我们看看我们如何将二进制文件直接读入内存中。

# 将二进制文件读入内存

通过`Files.readAllBytes()`可以通过`Files.readAllBytes()`来完成将整个二进制文件读取到内存中：

```
byte[] bytes = Files.readAllBytes(binaryFile);
```

`InputStream`类也存在类似的方法。

虽然这些方法非常方便的文件非常方便，但它们对大文件不是一个不错的选择。 试图将大文件获取到内存中易于 OOM 错误，显然，将消耗很多内存。 或者，在巨大的文件（例如，200 GB）的情况下，我们可以专注于内存映射的文件（`MappedByteBuffer`）。 `MappedByteBuffer`允许我们创建和修改大文件并将其视为一个非常大的数组。 它们看起来像是在记忆中，即使它们不是。 一切都发生在本土级别：

```
try (FileChannel fileChannel = (FileChannel.open(binaryFile,
    EnumSet.of(StandardOpenOption.READ)))) {

  MappedByteBuffer mbBuffer = fileChannel.map(
    FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());

  System.out.println("\nRead: " + mbBuffer.limit() + " bytes");
}
```

对于巨大的文件，建议遍历具有固定大小的缓冲区，如下所示：

```
private static final int MAP_SIZE = 5242880; // 5 MB in bytes

try (FileChannel fileChannel = FileChannel.open(
    binaryFile, StandardOpenOption.READ)) {

  int position = 0;
  long length = fileChannel.size();

  while (position < length) {
    long remaining = length - position;
    int bytestomap = (int) Math.min(MAP_SIZE, remaining);

    MappedByteBuffer mbBuffer = fileChannel.map(
      MapMode.READ_ONLY, position, bytestomap);

    ... // do something with the current buffer

    position += bytestomap;
  }
}
```

# 编写二进制文件

通过使用`BufferedOutputStream`的编写二进制文件的有效方式。 例如，将`byte[]`写入文件可以完成如下：

```
final byte[] buffer...;
Path classFile = Paths.get(
  "build/classes/modern/challenge/Main.class");

try (BufferedOutputStream bos = newBufferedOutputStream(
    Files.newOutputStream(classFile, StandardOpenOption.CREATE,
      StandardOpenOption.WRITE))) {

  bos.write(buffer);
}
```

如果您将字节写入字节，请使用`write(int b)`方法，如果您正在编写数据，请使用`write​(byte[] b, int off, int len)`方法。

将`byte[]`写入文件的非常方便的方法是`Files.write​(Path path, byte[] bytes, OpenOption... options)`。 例如，让我们写下前一个缓冲区的内容：

```
Path classFile = Paths.get(
  "build/classes/modern/challenge/Main.class");

Files.write(classFile, buffer,
  StandardOpenOption.CREATE, StandardOpenOption.WRITE);
```

通过`MappedByteBuffer`编写二进制文件可以如下完成（这对于编写庞大的文本文件很有用）：

```
Path classFile = Paths.get(
  "build/classes/modern/challenge/Main.class");
try (FileChannel fileChannel = (FileChannel) Files.newByteChannel(
    classFile, EnumSet.of(StandardOpenOption.CREATE,
      StandardOpenOption.READ, StandardOpenOption.WRITE))) {

  MappedByteBuffer mbBuffer = fileChannel
    .map(FileChannel.MapMode.READ_WRITE, 0, buffer.length);

  if (mbBuffer != null) {
    mbBuffer.put(buffer);
  }
}
```

最后，如果我们正在编写某些数据（不是原始二进制数据），那么我们可以依赖于`DataOutputStream`。 此类附带不同类型数据的`write*Foo*()`方法。 例如，让我们将几个 floats 写入文件：

```
Path floatFile = Paths.get("float.bin");

try (DataOutputStream dis = new DataOutputStream(
    new BufferedOutputStream(Files.newOutputStream(floatFile)))) {
  dis.writeFloat(23.56f);
  dis.writeFloat(2.516f);
  dis.writeFloat(56.123f);
}
```

# 140.在大文件中搜索

在文件中搜索和计数文件中某个字符串的出现次数是常用任务。 尝试尽可能快地实现这一目标是强制性要求，特别是如果文件大（例如，200 GB）。

请注意，以下实现假设字符串 *11* 仅在 *111* 中发生一次，而不是两次。 此外，前三个实现依赖于[第 1 章](01.html)，*字符串，数字和 math* 的辅助方法，*在另一个字符串*部分中计数一个字符串：

```
private static int countStringInString(String string, String tofind) {
  return string.split(Pattern.quote(tofind), -1).length - 1;
}
```

随着那个话，让我们来看看这个问题的几种方法。

# 基于 BufferedReader 的解决方案

我们已经知道从前一种问题，`BufferedReader`非常有效地读取文本文件。 因此，我们也可以使用它来读取一个大文件。 在读取的同时，对于通过`BufferedReader.readLine()`获得的每行，我们需要通过`countStringInString()`计算搜索字符串的出现次数：

```
public static int countOccurrences(Path path, String text, Charset ch)
    throws IOException {

  int count = 0;

  try (BufferedReader br = Files.newBufferedReader(path, ch)) {
    String line;
    while ((line = br.readLine()) != null) {
      count += countStringInString(line, text);
    }
  }

  return count;
}
```

# 基于 Files.ReadAllLines（）的解决方案

如果内存（RAM）对我们来说不是问题，那么我们可以尝试将整个文件读入内存（通过`Files.readAllLines()`）并从那里处理它。 在内存中具有整个文件维持并行处理。 因此，如果我们的硬件可以通过并行处理突出显示，那么我们可以尝试依赖`parallelStream()`，如下所示：

```
public static int countOccurrences(Path path, String text, Charset ch)
    throws IOException {

  return Files.readAllLines(path, ch).parallelStream()
    .mapToInt((p) -> countStringInString(p, text))
    .sum();
}
```

如果`parallelStream()`没有任何好处，那么我们可以简单地切换到`stream()`。 这只是基准的问题。

# 基于 files.lines（）的解决方案

我们也可以通过`Files.lines()`来利用流的流。 这次，我们将文件作为懒惰`Stream<String>`。 如果我们可以利用并行处理（基准测试显示更好的表现），那么通过调用`parallel()`方法并行化`Stream<String>`非常简单：

```
public static int countOccurrences(Path path, String text, Charset ch)
    throws IOException {

  return Files.lines(path, ch).parallel()
    .mapToInt((p) -> countStringInString(p, text))
    .sum();
}
```

# 基于扫描仪的解决方案

从 JDK 9 开始，`Scanner`类配备了一种返回分隔符分隔令牌流`Stream<String> tokens()`的方法。 如果我们将文本视为`Scanner`的分隔符搜索，我们计算`tokens()`返回的`Stream`的条目，然后我们获得了正确的结果：

```
public static long countOccurrences(
  Path path, String text, Charset ch) throws IOException {

  long count;

  try (Scanner scanner = new Scanner(path, ch)
      .useDelimiter(Pattern.quote(text))) {

    count = scanner.tokens().count() - 1;
  }

  return count;
}
```

在 JDK 10 中添加了支持显式 Charset 的扫描仪的构造函数。

# 解决基于映射的不安全的解决方案

我们讨论的最后一个解决方案是基于 Java Nio.2，`MappedByteBuffer`和`FileChannel`。 此解决方案在给定文件上从`FileChannel`打开内存映射的字节缓冲区（`MappedByteBuffer`）。 我们遍历获取的字节缓冲区，并查找搜索字符串的匹配（此字符串被转换为`byte[]`并搜索按字节进行字节）。

对于小文件，将整个文件加载到内存中更快。 对于大/巨大的文件，加载和处理块中的文件更快（例如，块为 5 MB）。 一旦我们加载了块，我们必须计算搜索字符串的出现次数。 我们存储结果并将其传递给下一个数据。 我们重复一次，直到遍历整个文件。

让我们来看看这个实现的核心线条（看看与完整代码一起捆绑的源代码）：

```
private static final int MAP_SIZE = 5242880; // 5 MB in bytes

public static int countOccurrences(Path path, String text)
                                          throws IOException {

  final byte[] texttofind = text.getBytes(StandardCharsets.UTF_8);
  int count = 0;

  try (FileChannel fileChannel = FileChannel.open(path,
                                   StandardOpenOption.READ)) {
    int position = 0;
    long length = fileChannel.size();

    while (position < length) {
      long remaining = length - position;
      int bytestomap = (int) Math.min(MAP_SIZE, remaining);

      MappedByteBuffer mbBuffer = fileChannel.map(
        MapMode.READ_ONLY, position, bytestomap);

      int limit = mbBuffer.limit();
      int lastSpace = -1;
      int firstChar = -1;

      while (mbBuffer.hasRemaining()) {        
        // spaghetti code omitted for brevity
        ...
      }
    }
  }

  return count;
}
```

此解决方案非常速度，因为文件直接从操作系统的存储器读取，而无需加载到 JVM 中。 该操作在本机级别进行，称为操作系统级别。 请注意，此实现仅适用于 UTF-8 Charset，但也适用于其他 CharSet。

# 141.读取 JSON / CSV 文件作为对象

这些天无处不在的 JSON 和 CSV 文件。 阅读（Deserialize）JSON / CSV 文件可以是通常在我们的业务逻辑之前的日常任务。 写作（序列化）JSON / CSV 文件也是一个流行的任务，通常在业务逻辑结束时发生。 在读写此类文件之间，应用程序将数据用作对象。

# 读/写一个 json 文件作为对象

让我们从三个代表典型的 JSON 的映射的文本文件开始：

![](img/e191890d-4de0-4dce-a4ea-f0fc90f0ff43.png)

在`melons_raw.json`中，我们每行有一个 json 条目。 每行都是一个独立于前一行的 JSON，但具有相同的模式。 在`melons_array.json`中，我们有一个 json 阵列，在`melons_map.json`中，我们有一个 json，它在 java `Map`中很好。

对于每个文件，我们有一个`Path`，如下所示：

```
Path pathArray = Paths.get("melons_array.json");
Path pathMap = Paths.get("melons_map.json");
Path pathRaw = Paths.get("melons_raw.json");
```

现在，让我们来看看三个专用的库，用于阅读这些文件的内容作为`Melon`实例：

```
public class Melon {

  private String type;
  private int weight;

  // getters and setters omitted for brevity
}
```

# 使用 json-b

Java EE 8 附带了一个名为 JSON-B（JSR-367）的 JAXB 样式的声明性 JSON 绑定。 JSON-B 与 JAXB 和其他 Java EE / SE API 一致。 Jakarta EE 将 Java EE 8 JSON（P 和 B）带到一个下一级。 它的 API 通过`javax.json.bind.Jsonb`和`javax.json.bind.JsonbBuilder`课程公开：

```
Jsonb jsonb = JsonbBuilder.create();
```

对于反序列化，我们使用`Jsonb.fromJson()`，而对于序列化，我们使用`Jsonb.toJson()`：

*   让我们读取`melons_array.json`作为`Melon`的`Array`：

```
Melon[] melonsArray = jsonb.fromJson(Files.newBufferedReader(
  pathArray, StandardCharsets.UTF_8), Melon[].class);
```

*   让我们读取`melons_array.json`作为`Melon`的`List`：

```
List<Melon> melonsList 
  = jsonb.fromJson(Files.newBufferedReader(
    pathArray, StandardCharsets.UTF_8), ArrayList.class);
```

*   让我们读取`melons_map.json`作为`Melon`的`Map`：

```
Map<String, Melon> melonsMap 
  = jsonb.fromJson(Files.newBufferedReader(
    pathMap, StandardCharsets.UTF_8), HashMap.class);
```

*   让我们读取`melons_raw.json`行进入`Map`：

```
Map<String, String> stringMap = new HashMap<>();

try (BufferedReader br = Files.newBufferedReader(
    pathRaw, StandardCharsets.UTF_8)) {

  String line;

  while ((line = br.readLine()) != null) {
    stringMap = jsonb.fromJson(line, HashMap.class);
    System.out.println("Current map is: " + stringMap);
  }
}
```

*   让我们读取`melons_raw.json`行进入`Melon`：

```
try (BufferedReader br = Files.newBufferedReader(
    pathRaw, StandardCharsets.UTF_8)) {

  String line;

  while ((line = br.readLine()) != null) {
    Melon melon = jsonb.fromJson(line, Melon.class);
    System.out.println("Current melon is: " + melon);
  }
}
```

*   让我们将一个对象写入 JSON 文件（`melons_output.json`）：

```
Path path = Paths.get("melons_output.json");

jsonb.toJson(melonsMap, Files.newBufferedWriter(path,
  StandardCharsets.UTF_8, StandardOpenOption.CREATE, 
    StandardOpenOption.WRITE));
```

# 使用杰克逊

杰克逊是一个专门用于处理（序列化/反序列化）JSON 数据的受欢迎和快速的库。 杰克逊 API 依赖于`com.fasterxml.jackson.databind.ObjectMapper`。 让我们再次走遍前面的例子，但这一次使用杰克逊：

```
ObjectMapper mapper = new ObjectMapper();
```

对于反序列化，我们使用`ObjectMapper.readValue()`，而对于序列化，我们使用`ObjectMapper.writeValue()`：

*   让我们读取`melons_array.json`作为`Melon`的`Array`：

```
Melon[] melonsArray 
  = mapper.readValue(Files.newBufferedReader(
    pathArray, StandardCharsets.UTF_8), Melon[].class);
```

*   让我们读取`melons_array.json`作为`Melon`的`List`：

```
List<Melon> melonsList 
  = mapper.readValue(Files.newBufferedReader(
    pathArray, StandardCharsets.UTF_8), ArrayList.class);
```

*   让我们读取`melons_map.json`作为`Melon`的`Map`：

```
Map<String, Melon> melonsMap 
  = mapper.readValue(Files.newBufferedReader(
    pathMap, StandardCharsets.UTF_8), HashMap.class);
```

*   让我们读取`melons_raw.json`行进入`Map`：

```
Map<String, String> stringMap = new HashMap<>();

try (BufferedReader br = Files.newBufferedReader(
    pathRaw, StandardCharsets.UTF_8)) {

  String line;

  while ((line = br.readLine()) != null) {
    stringMap = mapper.readValue(line, HashMap.class);
    System.out.println("Current map is: " + stringMap);
  }
}
```

*   让我们读取`melons_raw.json`行进入`Melon`：

```
try (BufferedReader br = Files.newBufferedReader(
    pathRaw, StandardCharsets.UTF_8)) {

  String line;

  while ((line = br.readLine()) != null) {
    Melon melon = mapper.readValue(line, Melon.class);
    System.out.println("Current melon is: " + melon);
  }
}
```

*   让我们将一个对象写入 JSON 文件（`melons_output.json`）：

```
Path path = Paths.get("melons_output.json");

mapper.writeValue(Files.newBufferedWriter(path, 
  StandardCharsets.UTF_8, StandardOpenOption.CREATE, 
    StandardOpenOption.WRITE), melonsMap);
```

# 使用 Gson.

GSON 是另一个专用于处理的快速库（序列化/反序列化）JSON 数据。 在 Maven 项目中，可以将其添加为`pom.xml`。 它的 API 依赖于类名`com.google.gson.Gson`。 用本书捆绑在一起的代码为它提供了一套典范。

# 读取 CSV 文件作为对象

最简单的 CSV 文件看起来像以下图中的文件（由逗号分隔的数据行）：

![](img/7282ffe2-5436-478c-8f2f-723f54ba8640.png)

使用这种 CSV 文件的简单有效的解决方案依赖于`BufferedReader`和`String.split()`方法。 我们可以通过`BufferedReader.readLine()`从文件中读取每行，并通过`Spring.split()`将其与逗号分隔符分割。 结果（每行内容）可以存储在`List<String>`中。 最终结果将是`List<List<String>>`，如下：

```
public static List<List<String>> readAsObject(
    Path path, Charset cs, String delimiter) throws IOException {

  List<List<String>> content = new ArrayList<>();

  try (BufferedReader br = Files.newBufferedReader(path, cs)) {

    String line;

    while ((line = br.readLine()) != null) {
      String[] values = line.split(delimiter);
      content.add(Arrays.asList(values));
    }
  }

  return content;
}
```

如果 CSV 数据具有 POJOS 记忆者（例如，我们的 CSV 是序列化一堆`Melon`实例的结果），那么它可以进行反序列化，如下例所示：

```
public static List<Melon> readAsMelon(
    Path path, Charset cs, String delimiter) throws IOException {

  List<Melon> content = new ArrayList<>();

  try (BufferedReader br = Files.newBufferedReader(path, cs)) {

    String line;

    while ((line = br.readLine()) != null) {
      String[] values = line.split(Pattern.quote(delimiter));
      content.add(new Melon(values[0], Integer.valueOf(values[1])));
    }
  }

  return content;
}
```

对于复杂的 CSV 文件，建议依赖于专用库（例如，OpenCSV，Apache Commons CSV，Super CSV 等）。

# 142.使用临时文件/文件夹

Java Nio.2 API 提供了支持使用临时文件夹/文件的支持。 例如，我们可以轻松找到临时文件夹/文件的默认位置，如下所示：

```
String defaultBaseDir = System.getProperty("java.io.tmpdir");
```

通常，在 Windows 中，默认临时文件夹是`C:\Temp, %Windows%\Temp`，或每个用户在`Local Settings\Temp`中的临时目录（此位置通常通过`TEMP`环境变量）。 在 Linux / Unix 中，全局临时目录是`/tmp`和`/var/tmp`。 前面的代码行将返回默认位置，具体取决于操作系统。

在下一节中，我们将学习如何创建临时文件夹/文件。

# 创建临时文件夹/文件

可以使用`Path createTempDirectory​(Path dir, String prefix, FileAttribute<?>... attrs)`完成创建临时文件夹。 这是`Files`类中的`static`方法，可以使用如下：

*   让我们在 OS 的默认位置中创建一个临时文件夹，没有前缀：

```
// C:\Users\Anghel\AppData\Local\Temp\8083202661590940905
Path tmpNoPrefix = Files.createTempDirectory(null);
```

*   让我们在 OS 的默认位置中创建一个临时文件夹，使用自定义前缀：

```
// C:\Users\Anghel\AppData\Local\Temp\logs_5825861687219258744
String customDirPrefix = "logs_";
Path tmpCustomPrefix 
  = Files.createTempDirectory(customDirPrefix);
```

*   让我们在具有自定义前缀的自定义位置中创建一个临时文件夹：

```
// D:\tmp\logs_10153083118282372419
Path customBaseDir 
  = FileSystems.getDefault().getPath("D:/tmp");
String customDirPrefix = "logs_";
Path tmpCustomLocationAndPrefix 
  = Files.createTempDirectory(customBaseDir, customDirPrefix);
```

创建临时文件可以通过`Path createTempFile​(Path dir, String prefix, String suffix, FileAttribute<?>... attrs)`来完成。 这是`Files`类中的`static`方法，可以使用如下：

*   让我们在 OS 的默认位置中创建一个临时文件，没有前缀和后缀：

```
// C:\Users\Anghel\AppData\Local\Temp\16106384687161465188.tmp
Path tmpNoPrefixSuffix = Files.createTempFile(null, null);
```

*   让我们使用自定义前缀和后缀在 OS 的默认位置中创建一个临时文件：

```
// C:\Users\Anghel\AppData\Local\Temp\log_402507375350226.txt
String customFilePrefix = "log_";
String customFileSuffix = ".txt";
Path tmpCustomPrefixAndSuffix 
  = Files.createTempFile(customFilePrefix, customFileSuffix);
```

*   让我们在具有自定义前缀和后缀的自定义位置中创建临时文件：

```
// D:\tmp\log_13299365648984256372.txt
Path customBaseDir 
  = FileSystems.getDefault().getPath("D:/tmp");
String customFilePrefix = "log_";
String customFileSuffix = ".txt";
Path tmpCustomLocationPrefixSuffix = Files.createTempFile(
  customBaseDir, customFilePrefix, customFileSuffix);
```

在以下部分中，我们将以不同的方式查看我们可以删除临时文件夹/文件。

# 通过关机挂钩删除临时文件夹/文件

删除临时文件夹/文件是操作系统或专用工具可以完成的任务。 但是，有时，我们需要根据不同的设计注意事项以编程方式控制此文件并删除文件夹/文件。

解决此问题的解决方案依赖于 *Shutdown-Hook* 机制，其可以通过`Runtime.getRuntime().addShutdownHook()`方法来实现。 只要我们在 JVM 关闭之前，我们需要在 JVM 关闭之前完成某些任务（例如，清理任务）时，此机制很有用。 它以 Java 线程实现为`run()`方法在 *shutdown-hock* 被 jvm at 关闭时调用的 java 线程。 这在以下代码中显示：

```
Path customBaseDir = FileSystems.getDefault().getPath("D:/tmp");
String customDirPrefix = "logs_";
String customFilePrefix = "log_";
String customFileSuffix = ".txt";

try {
  Path tmpDir = Files.createTempDirectory(
    customBaseDir, customDirPrefix);
  Path tmpFile1 = Files.createTempFile(
    tmpDir, customFilePrefix, customFileSuffix);
  Path tmpFile2 = Files.createTempFile(
    tmpDir, customFilePrefix, customFileSuffix);

  Runtime.getRuntime().addShutdownHook(new Thread() {
    @Override
    public void run() {
      try (DirectoryStream<Path> ds 
          = Files.newDirectoryStream(tmpDir)) {
        for (Path file: ds) {
          Files.delete(file);
        }

        Files.delete(tmpDir);
      } catch (IOException e) {
        ...
      }
    }
  });

  //simulate some operations with temp file until delete it
  Thread.sleep(10000);
} catch (IOException | InterruptedException e) {
  ...
}
```

在异常/强制终止的情况下，将不会执行 *Shutdown-Hop* （例如，触发 JVM 崩溃，终端操作等）。 它在所有线程完成或调用`System.exit(0)`时运行。 建议快速运行，因为如果出现问题之前可以在完成之前强行停止（例如，操作系统关闭）。 以编程方式，A *SHUTDOWN-HOOK* 只能通过`Runtime.halt()`停止。

# 通过 deletteonexit（）删除临时文件夹/文件

删除临时文件夹/文件的另一个解决方案依赖于`File.deleteOnExit()`方法。 通过调用此方法，我们可以注册删除文件夹/文件。 当 JVM 关闭时，会发生删除操作：

```
Path customBaseDir = FileSystems.getDefault().getPath("D:/tmp");
String customDirPrefix = "logs_";
String customFilePrefix = "log_";
String customFileSuffix = ".txt";

try {
  Path tmpDir = Files.createTempDirectory(
    customBaseDir, customDirPrefix);
  System.out.println("Created temp folder as: " + tmpDir);
  Path tmpFile1 = Files.createTempFile(
    tmpDir, customFilePrefix, customFileSuffix);
  Path tmpFile2 = Files.createTempFile(
    tmpDir, customFilePrefix, customFileSuffix);

  try (DirectoryStream<Path> ds = Files.newDirectoryStream(tmpDir)) {
    tmpDir.toFile().deleteOnExit();

    for (Path file: ds) {
      file.toFile().deleteOnExit();
    }
  } catch (IOException e) {
    ...
  }

  // simulate some operations with temp file until delete it
  Thread.sleep(10000);
} catch (IOException | InterruptedException e) {
  ...
}
```

建议仅依赖此方法（`deleteOnExit()`）当应用程序管理少量临时文件夹/文件时。 此方法可能会消耗大量内存（它会为删除注册的每个临时资源消耗内存），并且此内存可能不会被释放，直到 JVM 终止。 注意，由于需要调用此方法以便注册每个临时资源，并且删除以相反的注册顺序进行（例如，我们必须在注册其内容之前注册临时文件夹）。

# 通过 delete_on_close 删除临时文件

另一个解决方案删除临时文件依赖于`StandardOpenOption.DELETE_ON_CLOSE`（当流关闭时删除文件）。 例如，以下代码通过`createTempFile()`方法创建临时文件，并将其与`DELETE_ON_CLOSE`打开缓冲写入器流，明确指定：

```
Path customBaseDir = FileSystems.getDefault().getPath("D:/tmp");
String customFilePrefix = "log_";
String customFileSuffix = ".txt";
Path tmpFile = null;

try {
  tmpFile = Files.createTempFile(
    customBaseDir, customFilePrefix, customFileSuffix);
} catch (IOException e) {
  ...
}

try (BufferedWriter bw = Files.newBufferedWriter(tmpFile,
    StandardCharsets.UTF_8, StandardOpenOption.DELETE_ON_CLOSE)) {

  //simulate some operations with temp file until delete it
  Thread.sleep(10000);
} catch (IOException | InterruptedException e) {
  ...
}
```

可以为任何文件采用此解决方案。 它不是特定的临时资源。

# 143.过滤文件

从`Path`中过滤文件是一个非常常见的任务。 例如，我们可能只希望特定类型的文件，具有某种名称模式，今天修改，等等。

# 通过 files 筛选.newdirectorystream（）

如果没有任何类型的过滤器，我们可以通过`Files.newDirectoryStream(Path dir)`方法轻松循环文件夹的内容（一个级别深度）。 此方法返回一个`DirectoryStream<Path>`，它是我们可以用来迭代目录中的条目的对象：

```
Path path = Paths.get("D:/learning/books/spring");

try (DirectoryStream<Path> ds = Files.newDirectoryStream(path)) {

  for (Path file: ds) {
    System.out.println(file.getFileName());
  }
}
```

如果我们希望使用过滤器丰富此代码片段，那么我们至少有两个解决方案。 一种解决方案依赖于`newDirectoryStream()`方法的另一种风味，`newDirectoryStream​(Path dir, String glob)`。 除了`Path`之外，该方法通过使用 *Glob* 语法接收过滤器。 例如，我们可以过滤为 PNG，JPG 和 BMP 类型的文件的`D:/learning/books/spring`文件夹：

```
try (DirectoryStream<Path> ds =
    Files.newDirectoryStream(path, "*.{png,jpg,bmp}")) {

  for (Path file: ds) {
    System.out.println(file.getFileName());
  }
}
```

当 *glob* 语法不能再帮助我们时，是时候使用 GET `newDirectoryStream()`的另一个味道，即`newDirectoryStream​(Path dir, DirectoryStream.Filter<? super Path> filter)`。 首先，让我们定义大于 10 MB 的文件的过滤器：

```
DirectoryStream.Filter<Path> sizeFilter 
    = new DirectoryStream.Filter<>() {

  @Override
  public boolean accept(Path path) throws IOException {
    return (Files.size(path) > 1024 * 1024 * 10);
  }
};
```

我们也可以在功能式中执行以下操作：

```
DirectoryStream.Filter<Path> sizeFilter 
  = p -> (Files.size(p) > 1024 * 1024 * 10);
```

现在，我们可以应用此筛选器如下：

```
try (DirectoryStream<Path> ds =
    Files.newDirectoryStream(path, sizeFilter)) {

  for (Path file: ds) {
    System.out.println(file.getFileName() + " " +
      Files.readAttributes(file, BasicFileAttributes.class).size() 
        + " bytes");
  }
}
```

让我们看看我们可以使用这种技术的更多过滤器：

*   以下是文件夹的用户定义过滤器：

```
DirectoryStream.Filter<Path> folderFilter 
    = new DirectoryStream.Filter<>() {

  @Override
  public boolean accept(Path path) throws IOException {
    return (Files.isDirectory(path, NOFOLLOW_LINKS));
  }
};
```

*   以下是当前已修改的文件的用户定义过滤器：

```
DirectoryStream.Filter<Path> todayFilter 
    = new DirectoryStream.Filter<>() {

  @Override
  public boolean accept(Path path) throws IOException {
    FileTime lastModified = Files.readAttributes(path,
      BasicFileAttributes.class).lastModifiedTime();

    LocalDate lastModifiedDate = lastModified.toInstant()
      .atOffset(ZoneOffset.UTC).toLocalDate();
    LocalDate todayDate = Instant.now()
      .atOffset(ZoneOffset.UTC).toLocalDate();

    return lastModifiedDate.equals(todayDate);
  }
};
```

*   以下是隐藏文件/文件夹的用户定义过滤器：

```
DirectoryStream.Filter<Path> hiddenFilter 
    = new DirectoryStream.Filter<>() {

  @Override
  public boolean accept(Path path) throws IOException {
    return (Files.isHidden(path));
  }
};
```

在以下部分中，我们将以不同的方式查看我们可以过滤文件的不同方式。

# 144.发现两个文件之间的不匹配

在此问题的解决方案正在比较两个文件的内容（一个字节按字节比较），直到找到第一次不匹配或达到 EOF。

让我们考虑以下四个文本文件：

![](img/2c2c2f06-15c9-4ec4-ba0f-bb83eda5044d.png)

只有前两个文件（`file1.txt`和`file2.txt`）是相同的。 任何其他比较应该揭示至少一个不匹配的存在。

一个解决方案是使用`MappedByteBuffer`。 这种解决方案超快速且易于实施。 我们只是打开两个`FileChannels`（每个文件一个），并按字节比较执行字节，直到找到第一个不匹配或 eof。 如果文件在字节方面没有相同的长度，那么我们假设文件不一样，并立即返回：

```
private static final int MAP_SIZE = 5242880; // 5 MB in bytes

public static boolean haveMismatches(Path p1, Path p2) 
    throws IOException {

  try (FileChannel channel1 = (FileChannel.open(p1,
      EnumSet.of(StandardOpenOption.READ)))) {

    try (FileChannel channel2 = (FileChannel.open(p2,
        EnumSet.of(StandardOpenOption.READ)))) {

      long length1 = channel1.size();
      long length2 = channel2.size();

      if (length1 != length2) {
        return true;
      }

      int position = 0;
      while (position < length1) {
        long remaining = length1 - position;
        int bytestomap = (int) Math.min(MAP_SIZE, remaining);

        MappedByteBuffer mbBuffer1 = channel1.map(
          MapMode.READ_ONLY, position, bytestomap);
        MappedByteBuffer mbBuffer2 = channel2.map(
          MapMode.READ_ONLY, position, bytestomap);

        while (mbBuffer1.hasRemaining()) {
          if (mbBuffer1.get() != mbBuffer2.get()) {
            return true;
          }
        }

        position += bytestomap;
      }
    }
  }

  return false;
}
```

JDK 13 准备了非易失性`MappedByteBuffers`的释放。 敬请关注！

从 JDK 12 开始，已经丰富了一种专用于指向两个文件之间的不匹配的新方法。 此方法具有以下签名：

```
public static long mismatch​(Path path, Path path2) throws IOException
```

此方法在两个文件的内容中查找并返回第一个不匹配字节的位置。 如果没有不匹配，那么它返回`-1`：

```
long mismatches12 = Files.mismatch(file1, file2); // -1
long mismatches13 = Files.mismatch(file1, file3); // 51
long mismatches14 = Files.mismatch(file1, file4); // 60
```

# 通过 filenamefilter 过滤

`FilenameFilter`功能界面可用于从文件夹中过滤文件。 首先，我们需要定义过滤器（例如，以下是 PDF 类型文件的过滤器）：

```
String[] files = path.toFile().list(new FilenameFilter() {

  @Override
  public boolean accept(File folder, String fileName) {
    return fileName.endsWith(".pdf");
  }
});
```

我们可以在功能式方面做同样的事情：

```
FilenameFilter filter = (File folder, String fileName) 
  -> fileName.endsWith(".pdf");
```

让我们更简洁：

```
FilenameFilter filter = (f, n) -> n.endsWith(".pdf");
```

要使用此过滤器，我们需要将其传递给重载的`File.list​(FilenameFilter filter)`或`File.listFiles​(FilenameFilter filter)`方法：

```
String[] files = path.toFile().list(filter);
```

文件数组仅包含 PDF 文件的名称。

要将结果获取为`File[]`，我们应该调用`listFiles()`而不是`list()`。

# 通过 FileFilter 过滤

`FileFilter`是可用于过滤文件和文件夹的另一个功能界面。 例如，让我们只过滤文件夹：

```
File[] folders = path.toFile().listFiles(new FileFilter() {

  @Override
  public boolean accept(File file) {
    return file.isDirectory();
  }
});
```

我们可以在功能式方面做同样的事情：

```
File[] folders = path.toFile().listFiles((File file) 
  -> file.isDirectory());
```

让我们更简洁：

```
File[] folders = path.toFile().listFiles(f -> f.isDirectory());
```

最后，我们可以通过会员参考来完成以下操作：

```
File[] folders = path.toFile().listFiles(File::isDirectory);
```

# 循环字节缓冲区

Java Nio.2 API 具有称为`java.nio.ByteBuffer`的字节缓冲区的实现。 基本上，这是一个字节数（`byte[]`），它用专用于操纵此阵列的一套方法包装（例如，`get()`，`put()`等）。 循环缓冲区（循环缓冲区，环形缓冲区或圆形队列）是连接端到端的固定尺寸缓冲区。 下图显示了圆形队列的样子：

![](img/75a2e0e3-a019-44b2-942a-348ebe85bd74.png)

循环缓冲区依赖于预先分配的阵列（预先分配的容量），但是一些实现也可能需要调整大小的能力。 将元素写入背部（*尾部*）并从前部移除/读取（*头*）; 这可以在下图中看到：

![](img/0014d546-a369-4e06-ba75-2a32525b8fd3.png)

对于主要操作，即，读取（GET）和写（PUT），循环缓冲区维护指针（读取指针和写指针）。 两个指针都围绕缓冲容量包裹。 我们可以了解要读取多少元素以及每当我们喜欢时可以写入多少个免费插槽。 此操作发生在`O(1)`中进行。

循环字节缓冲区是字节的圆形缓冲区; 它可以是字符或其他类型。 这正是我们在这里想要实现的。 我们可以首先编写我们实现的存根，如下所示：

```
public class CircularByteBuffer {

  private int capacity;
  private byte[] buffer;
  private int readPointer;
  private int writePointer;
  private int available;

  CircularByteBuffer(int capacity) {
    this.capacity = capacity;
    buffer = new byte[capacity];
  }

  public synchronized int available() {
    return available;
  }

  public synchronized int capacity() {
    return capacity;
  }

  public synchronized int slots() {
    return capacity - available;
  }

  public synchronized void clear() {
    readPointer = 0;
    writePointer = 0;
    available = 0;
  }
  ...
}
```

现在，让我们专注于（编写）新字节和阅读（获取）现有字节。 例如，可以表示容量为 8 的循环字节缓冲区：

![](img/18922da5-a263-4300-932c-ff5b7acc3a72.png)

让我们来看看每一步发生的事情：

1.  循环字节缓冲区为空，两个指针指向插槽 0（第一个插槽）。
2.  我们将相应的 5 个字节放在缓冲区中的 **hello** 。 `readPointer`保持在相同位置，而`writePointer`指向槽 5。
3.  我们得到与 **h** 对应的字节，因此`readPointer`移动到插槽 1。
4.  最后，我们尝试将**世界**的字节放在缓冲区中。 这个词由 5 个字节组成，但我们只有四个免费插槽，直到我们达到缓冲容量。 这意味着我们只能编写与**世界对应的字节**。

现在，让我们来看看下图中的场景：

![](img/814c84be-13e7-48f8-9929-9137f296f19b.png)

从左到右，步骤如下::

1.  前两个步骤与前一个场景的步骤相同。
2.  我们获得 **hell** 的字节。 这将使`readPointer`移动到位 4。
3.  最后，我们将**世界**的字节放在缓冲区中。 这次，字合在缓冲区和`writePointer`中移动到插槽 2。

基于此流程，我们可以轻松实现一种方法，该方法将一个字节放在缓冲区中，另一个从缓冲区获取一个字节，如下所示：

```
public synchronized boolean put(int value) {
  if (available == capacity) {
    return false;
  }

  buffer[writePointer] = (byte) value;
  writePointer = (writePointer + 1) % capacity;
  available++;

  return true;
}

public synchronized int get() {
  if (available == 0) {
    return -1;
  }

  byte value = buffer[readPointer];
  readPointer = (readPointer + 1) % capacity;
  available--;

  return value;
}
```

如果我们检查 Java Nio.2 `ByteBuffer` API，我们会注意到它暴露了`get()`和`put()`方法的多种味道。 例如，我们应该能够将`byte[]`传递给`get()`方法，此方法应将缓冲区的一系列元素复制到此`byte[]`。 从缓冲区读取元素，从电流`readPointer`开始，并从给定的`byte[]`中写入，从指定的`offset`开始。

下图公开了`writePointer`大于`readPointer`的情况：

![](img/345337ae-3f8b-47ae-adac-d3206a178c61.png)

在左侧，我们正在阅读 3 个字节。 这将`readPointer`从其初始插槽中移动到 1，以槽 4.在右侧，我们读取 4（或超过 4）个字节。 由于只有 4 个字节可用，因此从其初始插槽移动到与`writePointer`（插槽 5）相同的插槽移动。

现在，让我们分析`writePointer`小于`readPointer`的情况：

![](img/e0970f73-bc5c-4415-af45-59c4b8c92334.png)

在左侧，我们正在阅读 3 个字节。 这将`readPointer`从其初始插槽移动到 6，以插槽 1.在右侧，我们读取 4（或超过 4）个字节。 这将`readPointer`从其初始插槽 6 移动到插槽 2（与`writePointer`相同的插槽）。

既然我们考虑过这两种用例，我们可以编写一个`get()`方法，以便将一个字节从缓冲区复制到给定的`byte[]`，如下所示（此方法尝试从中读取`len`字节 缓冲区并将它们写入给定的`byte[]`，从给定的`offset`）：

```
public synchronized int get(byte[] dest, int offset, int len) {

  if (available == 0) {
    return 0;
  }

  int maxPointer = capacity;

  if (readPointer < writePointer) {
    maxPointer = writePointer;
  }

  int countBytes = Math.min(maxPointer - readPointer, len);
  System.arraycopy(buffer, readPointer, dest, offset, countBytes);
  readPointer = readPointer + countBytes;

  if (readPointer == capacity) {
    int remainingBytes = Math.min(len - countBytes, writePointer);

    if (remainingBytes > 0) {
      System.arraycopy(buffer, 0, dest,
        offset + countBytes, remainingBytes);
      readPointer = remainingBytes;
      countBytes = countBytes + remainingBytes;
    } else {
      readPointer = 0;
    }
  }

  available = available - countBytes;

  return countBytes;
}
```

现在，让我们专注于将给定`byte[]`放入缓冲区。 从给定的`byte[]`从指定的`offset`开始读取元素，并从电流`writePointer`开始写入缓冲区。 下图公开了`writePointer`大于`readPointer`的情况：

![](img/1a8aea27-0943-4a16-a570-44ace6a2fbc9.png)

在左侧，我们具有缓冲区的初始状态。 所以，`readPointer`指向插槽 2，`writePointer`指向插槽 5.写入 4 个字节（在右侧）之后，我们可以看到`readPointer`不受影响，并且`writePointer`指向插槽 1。

其他用例假设`readPointer`大于`writePointer`：

![](img/f7604607-6cac-413f-b5b5-ca7fa62ba837.png)

在左侧，我们具有缓冲区的初始状态。 所以，`readPointer`指向插槽 4，`writePointer`指向插槽 2.写入 4 个字节（在右侧）之后，我们可以看到`readPointer`不受影响，并且`writePointer`指向插槽 4.请注意，只编写两个字节。 这发生了，因为我们在编写所有 4 个字节之前达到了缓冲区的最大容量。

现在我们有这两种用例的想法，我们可以编写一个`put()`方法，以便将一个字节从给定的`byte[]`复制到缓冲区中，如下所示（方法尝试读取`len`字节 给定的`byte[]`从给定的`offset`开始并尝试从当前`writePointer`开始将它们写入缓冲区中）：

```
public synchronized int put(byte[] source, int offset, int len) {

  if (available == capacity) {
    return 0;
  }

  int maxPointer = capacity;

  if (writePointer < readPointer) {
    maxPointer = readPointer;
  }

  int countBytes = Math.min(maxPointer - writePointer, len);
  System.arraycopy(source, offset, buffer, writePointer, countBytes);
  writePointer = writePointer + countBytes;

  if (writePointer == capacity) {
    int remainingBytes = Math.min(len - countBytes, readPointer);

    if (remainingBytes > 0) {
      System.arraycopy(source, offset + countBytes,
        buffer, 0, remainingBytes);
      writePointer = remainingBytes;
      countBytes = countBytes + remainingBytes;
    } else {
      writePointer = 0;
    }
  }

  available = available + countBytes;

  return countBytes;
}
```

正如我们之前提到的那样，有时，我们需要调整缓冲区的大小。 例如，我们可能希望通过简单地调用`resize()`方法来加倍其尺寸。 基本上，这意味着将所有可用字节（元素）复制到具有双倍容量的新缓冲区：

```
public synchronized void resize() {

  byte[] newBuffer = new byte[capacity * 2];

  if (readPointer < writePointer) {
    System.arraycopy(buffer, readPointer, newBuffer, 0, available);
  } else {
    int bytesToCopy = capacity - readPointer;
    System.arraycopy(buffer, readPointer, newBuffer, 0, bytesToCopy);
    System.arraycopy(buffer, 0, newBuffer, bytesToCopy, writePointer);
  }

  buffer = newBuffer;
  capacity = buffer.length;
  readPointer = 0;
  writePointer = available;
}
```

检查使用本书捆绑的源代码，以查看它如何完整工作。

# 146.授权文件

文件中的内容并不总是以一种方式接收，这意味着它可以立即处理，并且需要一些额外的步骤，以便可以准备进行处理。 通常，我们需要授权从不同的数据结构（阵列，列表，映射等）中提取文件并提取信息。

例如，让我们考虑一个文件`clothes.txt`：

```
Path path = Paths.get("clothes.txt");
```

其内容如下：

```
Top|white\10/XXL&amp;Swimsuit|black\5/L
Coat|red\11/M&amp;Golden Jacket|yellow\12/XLDenim|Blue\22/M
```

此文件包含一些由`&amp;`字符分隔的一些服装文章及其详细信息。 单个文章表示如下：

```
article name | color \ no. available items / size
```

在这里，我们有几个分隔符（`&amp;`，`|`，`\`，`/`）和非常具体的格式。

现在，让我们来看看从这个文件中提取和授权从这个文件中提取和授权的解决方案作为`List`。 我们将在实用程序类中收集此信息`FileTokenizer`。

用于在`List`中提取物品的一种解决方案依赖于`String.split()`方法。 基本上，我们必须按行读取文件行并将`String.split()`应用于每行。 通过`List.addAll()`方法在`List`中收集令牌化的结果：

```
public static List<String> get(Path path, 
    Charset cs, String delimiter) throws IOException {

  String delimiterStr = Pattern.quote(delimiter);
  List<String> content = new ArrayList<>();

  try (BufferedReader br = Files.newBufferedReader(path, cs)) {

    String line;
    while ((line = br.readLine()) != null) {
      String[] values = line.split(delimiterStr);
      content.addAll(Arrays.asList(values));
    }
  }

  return content;
}
```

使用`&amp;`分隔符调用此方法将产生以下输出：

```
[Top|white\10/XXL, Swimsuit|black\5/L, Coat|red\11/M, Golden Jacket|yellow\12/XL, Denim|Blue\22/M]
```

前面的解决方案的另一个风味可以依赖于`Collectors.toList()`而不是`Arrays.asList()`：

```
public static List<String> get(Path path, 
    Charset cs, String delimiter) throws IOException {

  String delimiterStr = Pattern.quote(delimiter);
  List<String> content = new ArrayList<>();

  try (BufferedReader br = Files.newBufferedReader(path, cs)) {

    String line;
    while ((line = br.readLine()) != null) {
      content.addAll(Stream.of(line.split(delimiterStr))
        .collect(Collectors.toList()));
    }
  }

  return content;
}
```

或者，我们可以通过`Files.lines()`以惰性方式处理内容：

```
public static List<String> get(Path path, 
    Charset cs, String delimiter) throws IOException {

  try (Stream<String> lines = Files.lines(path, cs)) {

    return lines.map(l -> l.split(Pattern.quote(delimiter)))
      .flatMap(Arrays::stream)
      .collect(Collectors.toList());
  }
}
```

对于相对较小的文件，我们可以在内存中加载它并相应地处理：

```
Files.readAllLines(path, cs).stream()
  .map(l -> l.split(Pattern.quote(delimiter)))
  .flatMap(Arrays::stream)
  .collect(Collectors.toList());
```

另一种解决方案可以依赖于 JDK 8 的`Pattern.splitAsStream()`方法。 此方法从给定的输入序列创建流。 为了变化，这次，让我们通过`Collectors.joining(";")`收集所产生的列表：

```
public static List<String> get(Path path, 
    Charset cs, String delimiter) throws IOException {

  Pattern pattern = Pattern.compile(Pattern.quote(delimiter));
  List<String> content = new ArrayList<>();

  try (BufferedReader br = Files.newBufferedReader(path, cs)) {

    String line;
    while ((line = br.readLine()) != null) {
      content.add(pattern.splitAsStream(line)
        .collect(Collectors.joining(";")));
    }
  }
  return content;
}
```

让我们用`&amp;` delimiter 来调用此方法：

```
List<String> tokens = FileTokenizer.get(
  path, StandardCharsets.UTF_8, "&amp;");
```

结果如下：

```
[Top|white\10/XXL;Swimsuit|black\5/L, Coat|red\11/M;Golden Jacket|yellow\12/XL, Denim|Blue\22/M]
```

到目前为止，所呈现的解决方案通过应用单个分隔符来获得物品列表。 但有时，我们需要申请更多的分隔符。 例如，让我们假设我们要获取以下输出（列表）：

```
[Top, white, 10, XXL, Swimsuit, black, 5, L, Coat, red, 11, M, Golden Jacket, yellow, 12, XL, Denim, Blue, 22, M]
```

要获取此列表，我们必须应用几个分隔符（`&amp;`，`|`，`\`和`/`）。 这可以通过使用`String.split()`来完成并将正则表达式通过逻辑`OR`运算符（`*x*|*y*`）来实现：

```
public static List<String> getWithMultipleDelimiters(
    Path path, Charset cs, String...delimiters) throws IOException {

  String[] escapedDelimiters = new String[delimiters.length];
  Arrays.setAll(escapedDelimiters, t -> Pattern.quote(delimiters[t]));
  String delimiterStr = String.join("|", escapedDelimiters);

  List<String> content = new ArrayList<>();

  try (BufferedReader br = Files.newBufferedReader(path, cs)) {

    String line;
    while ((line = br.readLine()) != null) {
      String[] values = line.split(delimiterStr);
      content.addAll(Arrays.asList(values));
    }
  }

  return content;
}
```

让我们使用我们的分隔符（`&amp;`，`|`，`\`和`/`）调用此方法以获取所需结果：

```
List<String> tokens = FileTokenizer.getWithMultipleDelimiters(
  path, StandardCharsets.UTF_8, 
    new String[] {"&amp;", "|", "\\", "/"});
```

好的; 到目前为止，一切都很好！ 所有这些解决方案都基于`String.split()`和`Pattern.splitAsStream()`。 另一套解决方案可以依赖于`StringTokenizer`类（它不擅长性能，所以仔细使用）。 此类可以将分隔符（或多个）应用于给定的字符串，并公开两种用于控制它的主要方法，即`hasMoreElements()`和`nextToken()`：

```
public static List<String> get(Path path,
    Charset cs, String delimiter) throws IOException {

  StringTokenizer st;
  List<String> content = new ArrayList<>();

  try (BufferedReader br = Files.newBufferedReader(path, cs)) {

    String line;
    while ((line = br.readLine()) != null) {
      st = new StringTokenizer(line, delimiter);
      while (st.hasMoreElements()) {
        content.add(st.nextToken());
      }
    }
  }

  return content;
}
```

它也可以与`Collectors`结合使用：

```
public static List<String> get(Path path, 
    Charset cs, String delimiter) throws IOException {

  List<String> content = new ArrayList<>();

  try (BufferedReader br = Files.newBufferedReader(path, cs)) {

    String line;
    while ((line = br.readLine()) != null) {
      content.addAll(Collections.list(
          new StringTokenizer(line, delimiter)).stream()
        .map(t -> (String) t)
        .collect(Collectors.toList()));
    }
  }

  return content;
}
```

如果我们使用`//`将它们分开：可以使用多个分隔符：

```
public static List<String> getWithMultipleDelimiters(
    Path path, Charset cs, String...delimiters) throws IOException {

  String delimiterStr = String.join("//", delimiters);
  StringTokenizer st;
  List<String> content = new ArrayList<>();

  try (BufferedReader br = Files.newBufferedReader(path, cs)) {

    String line;
    while ((line = br.readLine()) != null) {
      st = new StringTokenizer(line, delimiterStr);
      while (st.hasMoreElements()) {
        content.add(st.nextToken());
      }
    }
  }

  return content;
}
```

为了更好的性能和正则表达式支持（即高灵活性），建议依赖于`String.split()`而不是`StringTokenizer`。 从相同的类别中，请考虑使用扫描仪部分的*。*

# 147.将格式化输出写入文件

让我们假设我们有 10 个数字（整数和双打），我们希望它们格式化得很好（具有缩进，对齐和多数持续可读性和有用的小数）。

在我们第一次尝试中，我们将它们写入如此（不应用格式化）：

```
Path path = Paths.get("noformatter.txt");

try (BufferedWriter bw = Files.newBufferedWriter(path,
    StandardCharsets.UTF_8, StandardOpenOption.CREATE,
      StandardOpenOption.WRITE)) {

  for (int i = 0; i < 10; i++) {
    bw.write("| " + intValues[i] + " | " + doubleValues[i] + " | ");
    bw.newLine();
  }
}
```

前面代码的输出类似于下图左侧所示的内容：

![](img/9190bf65-dcd3-4e09-b734-13a23e4e8bee.png)

但是，我们希望获得在前图的右侧显示的结果。 为了解决这个问题，我们需要使用`String.format()`方法。 此方法允许我们将格式规则指定为尊重以下模式的字符串：

```
%[*flags*][*width*][.*precision*]*conversion-character*
```

现在，让我们来看看什么代表这个模式的每个组件：

*   `[flags]`是可选的，包括用于修改输出的标准方法。 通常，它们用于格式化整数和浮点数。
*   `[width]`是可选的，并为我们的输出设置字段宽度（写入输出的最小字符数）。
*   `[.precision]`是可选的，并指定浮点值的精度的数字数（或从 A `String`提取的子字符串的长度）。
*   `conversion-character`是强制性的，并告诉我们参数将如何格式化。 最常用的转换字符如下：
    *   `s`：用于格式化字符串
    *   `d`：用于格式化十进制整数
    *   `f`：用于格式化浮点数
    *   `t`：用于格式化日期/时间值

作为一行分隔符，我们可以使用`%n`。

借助格式化规则的知识，我们可以如下获取所需的内容（`%6s`用于整数，而`%.3f`用于双打）：

```
Path path = Paths.get("withformatter.txt");

try (BufferedWriter bw = Files.newBufferedWriter(path,
    StandardCharsets.UTF_8, StandardOpenOption.CREATE, 
      StandardOpenOption.WRITE)) {

  for (int i = 0; i<10; i++) {
    bw.write(String.format("| %6s | %.3f |",
      intValues[i], doubleValues[i]));
    bw.newLine();
  }
}
```

可以通过`Formatter`类提供另一种解决方案。 此类专用于格式化字符串并使用与`String.format()`相同的格式化规则。 它有一个`format()`方法，我们可以用来重写前面的代码片段：

```
Path path = Paths.get("withformatter.txt");

try (Formatter output = new Formatter(path.toFile())) {

  for (int i = 0; i < 10; i++) {
    output.format("| %6s | %.3f |%n", intValues[i], doubleValues[i]);
  }
}
```

格式化整数的数字如何？

![](img/97621d23-cfa7-4409-8a69-a08b13eb29e8.png)

嗯，我们可以通过应用`DecimalFormat`和字符串格式化程序来获得此项，如下所示：

```
Path path = Paths.get("withformatter.txt");
DecimalFormat formatter = new DecimalFormat("###,### bytes");

try (Formatter output = new Formatter(path.toFile())) {

 for (int i = 0; i < 10; i++) {
   output.format("%12s%n", formatter.format(intValues[i]));
 }
}
```

# 148.使用扫描仪

`Scanner`公开 API 用于从字符串，文件，控制台等解析文本。 解析是授权给定输入并根据需要返回它的过程（例如，整数，浮点数，双打等）。 默认情况下，`Scanner`通过使用空白空间（默认分隔符）解析给定的输入，并通过一套`next*Foo*()`方法公开令牌（例如，`next()`，`nextLine()`，`nextInt()`，`nextDouble()` ， 等等）。

从同一类别的问题中，考虑*令授权文件*部分。

例如，假设我们有一个文件（`doubles.txt`），其中包含由空格分隔的双号，如下图所示：

![](img/e89c5754-4095-4295-82e3-9bb178aac4d1.png)

如果我们希望将此文本作为双打获取，那么我们可以阅读它并依赖于 *spaghetti* 代码的片段来授权并将其转换为双打。 或者，我们可以依赖于`Scanner`及其`nextDouble()`方法，如下所示：

```
try (Scanner scanDoubles = new Scanner(
    Path.of("doubles.txt"), StandardCharsets.UTF_8)) {

  while (scanDoubles.hasNextDouble()) {
    double number = scanDoubles.nextDouble();
    System.out.println(number);
  }
}
```

前面代码的输出如下：

```
23.4556
1.23
...
```

但是，文件可能包含不同类型的混合信息。 例如，下图中的文件（`people.txt`）包含由不同分隔符（逗号和分号）分隔的字符串和整数：

![](img/bd0cf797-0e93-4771-b593-c7c12f8782f7.png)

`Scanner`公开了一种称为`useDelimiter()`的方法。 此方法采用`String`或`Pattern`类型的参数，以指定应用作正则表达式的分隔符：

```
try (Scanner scanPeople = new Scanner(Path.of("people.txt"),
    StandardCharsets.UTF_8).useDelimiter(";|,")) {

  while (scanPeople.hasNextLine()) {
    System.out.println("Name: " + scanPeople.next().trim());
    System.out.println("Surname: " + scanPeople.next());
    System.out.println("Age: " + scanPeople.nextInt());
    System.out.println("City: " + scanPeople.next());
  }
}
```

使用此方法的输出如下：

```
Name: Matt
Surname: Kyle
Age: 23
City: San Francisco
...
```

从 JDK 9 开始，`Scanner`公开了一种称为`tokens()`的新方法。 此方法从`Scanner`返回分隔符分隔令牌流。 例如，我们可以使用它来解析`people.txt`文件并将其打印在控制台上，如下所示：

```
try (Scanner scanPeople = new Scanner(Path.of("people.txt"),
    StandardCharsets.UTF_8).useDelimiter(";|,")) {

  scanPeople.tokens().forEach(t -> System.out.println(t.trim()));
}
```

使用前述方法的输出如下：

```
Matt
Kyle
23
San Francisco
...
```

或者，我们可以通过空间加入令牌：

```
try (Scanner scanPeople = new Scanner(Path.of("people.txt"),
    StandardCharsets.UTF_8).useDelimiter(";|,")) {

  String result = scanPeople.tokens()
    .map(t -> t.trim())
    .collect(Collectors.joining(" "));
}
```

在*中搜索大文件*部分，有一个例子是如何使用此方法搜索文件中某个文本的示例。

使用前述方法的输出如下：

```
Matt Kyle 23 San Francisco Darel Der 50 New York ...
```

就`tokens()`方法而言，JDK 9 还配备了一种称为`findAll()`的方法。 这是一种非常方便的方法，用于查找尊重某个正则表达式的所有令牌（作为`String`或`Pattern`提供）。 此方法返回`Stream<MatchResult>`，可以使用如此：

```
try (Scanner sc = new Scanner(Path.of("people.txt"))) {

  Pattern pattern = Pattern.compile("4[0-9]");

  List<String> ages = sc.findAll(pattern)
    .map(MatchResult::group)
    .collect(Collectors.toList());

  System.out.println("Ages: " + ages);
}
```

前面的代码选择所有代币，代表年龄在 40 到 49 岁之间，即 40,43 和 43。

`Scanner`是一种方便的方法，如果我们希望解析控制台中提供的输入：

```
Scanner scanConsole = new Scanner(System.in);

String name = scanConsole.nextLine();
String surname = scanConsole.nextLine();
int age = scanConsole.nextInt();
// an int cannot include "\n" so we need
//the next line just to consume the "\n"
scanConsole.nextLine();
String city = scanConsole.nextLine();
```

请注意，对于数字输入（通过`nextInt()`，`nextFloat()`等），我们也需要消耗换行符（当我们命中*时，我们会发生这种情况，输入*）。 基本上，`Scanner`在解析数字时不会获取此字符，因此它将进入下一个令牌。 如果我们不通过添加`nextLine()`代码行，那么从这一点前进，输入将变得不成集，并导致`InputMismatchException`类型的例外或者到期。
在 JDK 10 中引入了支持 CHARSET 的`Scanner`构造函数。

让我们来看看`Scanner`和`BufferedReader`之间的区别。

# 扫描仪与 BufferedReader.

那么，我们应该使用`Scanner`或`BufferedReader`？ 好吧，如果我们需要解析文件，那么`Scanner`是去的方式; 否则，`BufferedReader`更适合。 他们的头脑比较将揭示以下内容：

*   `BufferedReader`比`Scanner`快，因为它不会执行任何解析操作。
*   `BufferedReader`在阅读时读到读取时读到解析时摘录。
*   默认情况下，`BufferedReader`使用 8 kB 的缓冲区，而`Scanner`使用 1 kB 的缓冲区。
*   `BufferedReader`是读取长串的良好拟合，而`Scanner`对于短输入更好。
*   `BufferedReader`同步，但`Scanner`不是。
*   A `Scanner`可以使用`BufferedReader`，而相反是不可能的。 这在以下代码中显示：

```
try (Scanner scanDoubles = new Scanner(Files.newBufferedReader(
    Path.of("doubles.txt"), StandardCharsets.UTF_8))) { 
  ...
}
```

# 概括

我们已达到本章的末尾，我们涵盖了各种 I / O 特定问题。 从操纵，走路和观看流媒体文件的路径和阅读/写作文本和二进制文件的有效方法，我们已经涵盖了很多。

从本章下载应用程序以查看结果和其他详细信息。