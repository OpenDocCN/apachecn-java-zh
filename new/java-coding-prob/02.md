# 对象，不可变节和切换表达式

本章包括 18 个涉及对象，不变性和`switch`表达的问题。 该章节始于处理`null`参考文献的几个问题。 它继续存在关于检查索引，`equals()`和`hashCode()`的问题，以及免不可变节性（例如，从不可变类中编写不可变类并通过/返回可变对象）。 章节的最后一部分涉及克隆对象和 JDK 12 `switch`表达式。 到本章末尾，您将具有对物体和不可变性的基本知识。 此外，您将知道如何处理新的`switch`表达式。 这些是任何 Java 开发人员的阿森纳都是有价值的和非可选的知识。

# 问题

使用以下问题来测试您的对象，不断性和`switch`表达式编程实力。 我强烈建议您在转向解决方案并下载示例程序之前尝试举出每个问题：

40.  **检查`null`功能样式和** **命令**代码代码：编写一个执行`null`检查给定参考的程序 在功能样式和势在必行的代码中。
41.  **检查`null`引用和抛出定制**错误：写一个执行`null`检查给定引用的程序，并使用自定义消息抛出`NullPointerException`。
42.  **检查`null`引用并抛出指定的异常（例如，** `IllegalArgumentException` **）**：写一个执行`null`检查给定引用的程序 并抛出指定的异常。

43.  **检查`null`引用和返回非`null`默认引用**：写一个执行`null`检查给定参考的程序，如果它是非`null`，然后返回它; 否则，返回非`null`默认引用。
44.  **检查从 0 到长度**的范围内的索引：写一个程序，检查给定索引是否在 0（包含）和给定长度（独占）之间。 如果给定索引超出[0，*长度*]范围，则​​抛出`IndexOutOfBoundsException`。
45.  **检查从 0 到长度的范围内的子范围**：写一个程序检查给定的子范围*的启动*，*结束* ]在[0，*给定长度*的范围内。 如果给定的子范围不在[0，*给定长度*]范围内，则抛出`IndexOutOfBoundsException`。
46.  **`equals()`和** `hashCode()` **：**解释并举例说明`equals()`和`hashCode()`方法在 Java 中工作。
47.  **NutShell 中的不可变量对象：**解释并举例说明 Java 中的一个不可变的对象。
48.  **Im** **可变字符串：**解释为什么`String`类是不可变的。
49.  **编写一个不可变类：**写一个代表一个不可变类的程序。
50.  **将可变对象传递/返回到从不可变类：**写一个通过并从不可变类返回可变对象的程序。
51.  **通过 Builder 模式编写不可变类：**编写一个程序，表示在不可变类中的构建器模式的实现。
52.  **避免了不可变量的错误数据：**编写一个可防止对象中的*坏数据*的程序。
53.  **克隆对象：**写一个程序，例证了浅层和深克隆技术。
54.  **覆盖`toString()`：**解释并举例说明覆盖`toString()`的实践。
55.  **`switch`表达式：**提供 JDK 12 中的`switch`表达式的简要概述。
56.  **多个`case`标签：**编写一个代码片段，用于使用多个`case`标签来举例说明 JDK 12 `switch`。
57.  **语句块：**编写一个代码片段，用于用`case`标签指向卷曲的块的标签。

# 解决方案

以下部分描述了对前述每个问题的解决方案。 请记住，几乎不是一个正确的方法来解决特定问题。 此外，请记住，这里所示的解释仅包括解决问题所需的最有趣和重要的细节。 下载示例解决方案以查看其他详细信息，并在 [https://github.com/packtpublishing/java-coding-problems](https://github.com/PacktPublishing/Java-Coding-Problems) 上进行实验。

# 40.检查功能样式和势在必行代码中的 null 引用

独立于功能样式或命令代码，检查`null`参考文献是一种用于减轻着名`NullPointerException`异常的发生的常见和推荐技术。 这种检查是大量利用方法参数，以确保通过引用不会导致`NullPointerException`或意外行为。

例如，将`List<Integer>`传递给方法可能需要至少两个`null`检查。 首先，该方法应确保列表参考本身不是`null`。 其次，根据使用列表的使用方式，该方法应确保列表不包含`null`对象：

```
List<Integer> numbers 
  = Arrays.asList(1, 2, null, 4, null, 16, 7, null);
```

此列表传递给以下方法：

```
public static List<Integer> evenIntegers(List<Integer> integers) {

  if (integers == null) {
    return Collections.EMPTY_LIST;
  }

  List<Integer> evens = new ArrayList<>();
  for (Integer nr: integers) {
    if (nr != null && nr % 2 == 0) {
      evens.add(nr);
    }
  }

  return evens;
}
```

请注意，前面的代码使用依赖于`==`和`!=`运算符（`integers==null`，`nr !=null`）的经典检查。 从 JDK 8 开始，`java.util.Objects`类包含基于这两个运算符的`null`检查的两种方法：`object == null`被包裹在`Objects.isNull()`中，`object != null`包裹在`Objects.nonNull()`中。

基于这些方法，前面的代码可以如下重写：

```
public static List<Integer> evenIntegers(List<Integer> integers) {

  if (Objects.isNull(integers)) {
    return Collections.EMPTY_LIST;
  }

  List<Integer> evens = new ArrayList<>();

  for (Integer nr: integers) {
    if (Objects.nonNull(nr) && nr % 2 == 0) {
      evens.add(nr);
    }
  }

  return evens;
}
```

现在，代码是一个更具表现力的代码，但这不是这两种方法的主要用法。 实际上，已经为另一个目的（符合 API Notes）添加了这两种方法 - 用于 Java 8 功能样式代码中的谓词。 在功能样式代码中，可以在以下示例中完成`null`检查：

```
public static int sumIntegers(List<Integer> integers) {

  if (integers == null) {
    throw new IllegalArgumentException("List cannot be null");
  }

  return integers.stream()
    .filter(i -> i != null)
    .mapToInt(Integer::intValue).sum();
}

public static boolean integersContainsNulls(List<Integer> integers) {

  if (integers == null) {
    return false;
  }

  return integers.stream()
    .anyMatch(i -> i == null);
}
```

很明显，`i -> i != null`和`i -> i == null`不是与周围代码相同的风格表示。 让我们用`Objects.nonNull()`和`Objects.isNull()`替换这些代码片段：

```
public static int sumIntegers(List<Integer> integers) {

  if (integers == null) {
    throw new IllegalArgumentException("List cannot be null");
  }

  return integers.stream()
    .filter(Objects::nonNull)
    .mapToInt(Integer::intValue).sum();
}

public static boolean integersContainsNulls(List<Integer> integers) {

  if (integers == null) {
    return false;
  }

  return integers.stream()
    .anyMatch(Objects::isNull);
}
```

或者，我们也可以使用`Objects.nonNull()`和`Objects.isNull()`参数方法：

```
public static int sumIntegers(List<Integer> integers) {

  if (Objects.isNull(integers)) {
    throw new IllegalArgumentException("List cannot be null");
  }

  return integers.stream()
    .filter(Objects::nonNull)
    .mapToInt(Integer::intValue).sum();
}

public static boolean integersContainsNulls(List<Integer> integers) {

  if (Objects.isNull(integers)) {
    return false;
  }

  return integers.stream()
    .anyMatch(Objects::isNull);
}
```

惊人的！ 因此，通过结论，无论只要需要`null`检查，功能样式代码应该依赖这两种方法，而在必要的代码中，则是一个偏好的问题。

# 41.检查 NULL 引用和投掷自定义 NullPointerException

使用以下代码检查`null`引用和抛出`NullPointerException`使用自定义消息（此代码执行这四次，在构造函数中两次和`assignDriver()`方法中的两次）：

```
public class Car {

  private final String name;
  private final Color color;

  public Car(String name, Color color) {

    if (name == null) {
      throw new NullPointerException("Car name cannot be null");
    }

    if (color == null) {
      throw new NullPointerException("Car color cannot be null");
    }

    this.name = name;
    this.color = color;
  }

  public void assignDriver(String license, Point location) {

    if (license == null) {
      throw new NullPointerException("License cannot be null");
    }

    if (location == null) {
      throw new NullPointerException("Location cannot be null");
    }
  }
}
```

因此，通过组合`==`操作员和`NullPointerException`类的手动实例化来解决问题。 从 JDK 7 开始，这种代码的组合隐藏在一个名为`Objects.requireNonNull()`的`static`方法中。 通过此方法，可以以表达方式重写前面的代码：

```
public class Car {

  private final String name;
  private final Color color;

  public Car(String name, Color color) {

    this.name = Objects.requireNonNull(name, "Car name cannot be 
      null");
    this.color = Objects.requireNonNull(color, "Car color cannot be 
      null");
  }

  public void assignDriver(String license, Point location) {

    Objects.requireNonNull(license, "License cannot be null");
    Objects.requireNonNull(location, "Location cannot be null");
  }
}
```

因此，如果指定的参考是`null`，则`Objects.requireNonNull()`将抛出一个`NullPointerException`，并提供消息。 否则，它返回已选中的引用。

在构造函数中，当提供的参考文献是`null`时，存在典型的方法来抛出`NullPointerException`。 但是在方法（例如，`assignDriver()`），这是一种有争议的方法。 一些开发人员愿意返回不统一的结果或抛出`IllegalArgumentException`。 下一个问题，检查 null 引用并抛出指定的异常（例如，`IllegalArgumentException`），地址`IllegalArgumentException`方法。

在 JDK 7 中，存在两个`Objects.requireNonNull()`方法，先前使用的方法，以及使用默认消息抛出`NullPointerException`的另一个，如下图所示：

```
this.name = Objects.requireNonNull(name);
```

从 JDK 8 开始，还有一个`Objects.requireNonNull()`。 这个包装`NullPointerException`的自定义消息`Supplier`。 这意味着在给定参考是`null`之前推迟了该消息创建（这意味着使用`+`运算符来连接消息的部分不再是问题）。

这是一个例子：

```
this.name = Objects.requireNonNull(name, () 
  -> "Car name cannot be null ... Consider one from " + carsList);
```

如果此引用不是`null`，则不会创建消息。

# 42.检查 null 引用并抛出指定的异常

当然，一个解决方案需要直接依赖于`==`运营商如下：

```
if (name == null) {
  throw new IllegalArgumentException("Name cannot be null");
}
```

由于没有`requireNonNullElseThrow()`方法，因此无法通过`java.util.Objects`的方法来解决此问题。 抛出`IllegalArgumentException`或其他指定的异常可能需要一组方法，如下屏幕截图所示：

![](img/fcd54997-7ebf-46d7-8eea-c80bb23be82a.png)

让我们专注于`requireNonNullElseThrowIAE()`方法。 这两种方法使用指定为`String`或`Supplier`的自定义消息投掷`IllegalArgumentException`（以避免创建，直到`null`评估为`true`）：

```
public static <T> T requireNonNullElseThrowIAE(
    T obj, String message) {

  if (obj == null) {
    throw new IllegalArgumentException(message);
  }

  return obj;
}

public static <T> T requireNonNullElseThrowIAE(T obj,
    Supplier<String> messageSupplier) {

  if (obj == null) {
    throw new IllegalArgumentException(messageSupplier == null 
      ? null : messageSupplier.get());
  }

  return obj;
}
```

因此，可以通过这两种方法进行抛出`IllegalArgumentException`。 但他们还不够。 例如，代码可能需要抛出`IllegalStateException`，`UnsupportedOperationException`等。 对于这种情况，以下方法是优选的：

```
public static <T, X extends Throwable> T requireNonNullElseThrow(
    T obj, X exception) throws X {

  if (obj == null) {
    throw exception;
  }

  return obj;
}

public static <T, X extends Throwable> T requireNotNullElseThrow(
    T obj, Supplier<<? extends X> exceptionSupplier) throws X {

  if (obj != null) {
    return obj;
  } else {
    throw exceptionSupplier.get();
  }
}
```

考虑将这些方法添加到名为`MyObjects`的辅助类。 如下例所示调用这些方法：

```
public Car(String name, Color color) {

  this.name = MyObjects.requireNonNullElseThrow(name,
    new UnsupportedOperationException("Name cannot be set as null"));
  this.color = MyObjects.requireNotNullElseThrow(color, () ->
    new UnsupportedOperationException("Color cannot be set as null"));
}
```

此外，我们也可以遵循这些例子以与其他类型的异常进行丰富的`MyObjects`。

# 43.检查 null 引用并返回非 NULL 默认引用

通过`if` - `else`（或三元算子）可以轻松提供对此问题的解决方案，如以下示例中（作为变型，`name`和`color`可以被声明为非`final`并在声明时初始化默认值）：

```
public class Car {

  private final String name;
  private final Color color;
  public Car(String name, Color color) {

    if (name == null) {
      this.name = "No name";
    } else {
      this.name = name;
    }

    if (color == null) {
      this.color = new Color(0, 0, 0);
    } else {
      this.color = color;
    }
  }
}
```

但是，从 JDK 9 开始，可以通过来自`Objects`类的两种方法简化前面的代码。 这些方法是`requireNonNullElse()`和`requireNonNullElseGet()`。 它们都采用了两个参考 - 检查无效的参考，而非`null`默认引用在选中的参考中是`null`：

```
public class Car {

  private final String name;
  private final Color color;

  public Car(String name, Color color) {

    this.name = Objects.requireNonNullElse(name, "No name");
    this.color = Objects.requireNonNullElseGet(color,
      () -> new Color(0, 0, 0));
  }
}
```

在前述示例中，这些方法用于构造函数，但它们也可以在方法中使用。

# 44.检查 0 到长度范围内的索引

首先，让我们有一个简单的场景来突出这个问题。 此方案可能会在以下简单类中实现：

```
public class Function {

  private final int x;

  public Function(int x) {

    this.x = x;
  }

  public int xMinusY(int y) {

    return x - y;
  }

  public static int oneMinusY(int y) {

    return 1 - y;
  }
}
```

请注意，前面的代码片段不假设在`x`和`y`上的任何范围限制。 现在，让我们强加以下范围（这与数学函数很常见）：

*   `x`必须在 0（包含）和 11（独占）之间，因此`x`属于[0,11]。
*   在`xMinusY()`方法中，`y`必须在 0（包括）和`x`之间（独占），因此`y`属于[0，`x`。
*   在`oneMinusY()`方法中，`y`必须在 0（包含）和 16 之间（独占）之间，因此`y`属于[0,16）。

可以通过`if`陈述，如下所示，这些范围可以施加在代码中：

```
public class Function {

  private static final int X_UPPER_BOUND = 11;
  private static final int Y_UPPER_BOUND = 16;
  private final int x;

  public Function(int x) {

    if (x < 0 || x >= X_UPPER_BOUND) {
      throw new IndexOutOfBoundsException("..."); 
    }

    this.x = x;
  }

  public int xMinusY(int y) {

    if (y < 0 || y >= x) {
      throw new IndexOutOfBoundsException("...");
    }

    return x - y;
  }

  public static int oneMinusY(int y) {

    if (y < 0 || y >= Y_UPPER_BOUND) {
      throw new IndexOutOfBoundsException("...");
    }

    return 1 - y;
  }
}
```

考虑用更有意义的异常替换`IndexOutOfBoundsException`（例如，扩展`IndexOutOfBoundsException`并创建类型的自定义异常`RangeOutOfBoundsException`）。

从 JDK 9 开始，可以重写代码以使用`Objects.checkIndex()`方法。 此方法验证给定索引是否在[0，*长度*]范围内，并在此范围内返回给定索引或抛出`IndexOutOfBoundsException`：

```
public class Function {

  private static final int X_UPPER_BOUND = 11;
  private static final int Y_UPPER_BOUND = 16;
  private final int x;

  public Function(int x) {

    this.x = Objects.checkIndex(x, X_UPPER_BOUND);
  }

  public int xMinusY(int y) {

    Objects.checkIndex(y, x);

    return x - y;
  }

  public static int oneMinusY(int y) {

    Objects.checkIndex(y, Y_UPPER_BOUND);

    return 1 - y;
  }
}
```

例如，调用`oneMinusY()`，如下一个代码片段所示，将导致`IndexOutOfBoundsException`，因为`y`可以在[0,16）之间取值：

```
int result = Function.oneMinusY(20);
```

现在，让我们进一步进一步，然后在 0 到给定长度的范围内检查子范围。

# 45.检查 0 到长度范围内的子范围

让我们从前一个问题遵循相同的流程。 因此，这次，`Function`类将如下所示：

```
public class Function {

  private final int n;

  public Function(int n) {

    this.n = n;
  }

  public int yMinusX(int x, int y) {

    return y - x;
  }
}
```

请注意，前面的代码片段不假设在`x`，`y`和`n`上的任何范围限制。 现在，让我们强加以下范围：

*   `n`必须在 0（包含）和 101 之间（独家）之间，因此`n`属于[0,101]。
*   在`yMinusX()`方法中，由`x`和`y`，[`x`，[htg2，`y`限定的范围必须是[0，`n`]的子范围。

通过`if`陈述，可以在代码中施加这些范围，如下所示：

```
public class Function {

  private static final int N_UPPER_BOUND = 101;
  private final int n;

  public Function(int n) {

    if (n < 0 || n >= N_UPPER_BOUND) {
      throw new IndexOutOfBoundsException("...");
    }

    this.n = n;
  }

  public int yMinusX(int x, int y) {

    if (x < 0 || x > y || y >= n) {
      throw new IndexOutOfBoundsException("...");
    }

    return y - x;
  }
}
```

基于先前的问题，可以用`Objects.checkIndex()`替换`n`的条件。 此外，JDK 9 `Objects`类附带一个名为`checkFromToIndex(int start, int end, int length)`的方法，该方法检查给定的子范围*给出的开始*，*结束*]是从范围的范围内的范围内 [0，*给定长度*]。 因此，该方法可以应用于`yMinusX()`方法检查由`x`和`y`，[`x`，`y`界定的范围是[0，`n`]的子范围：

```
public class Function {

  private static final int N_UPPER_BOUND = 101;
  private final int n;

  public Function(int n) {

    this.n = Objects.checkIndex(n, N_UPPER_BOUND);
  }

  public int yMinusX(int x, int y) {

    Objects.checkFromToIndex(x, y, n);
    return y - x;
  }
}
```

例如，由于`x`大于`y`，以下测试将导致`IndexOutOfBoundsException`：

```
Function f = new Function(50);
int r = f.yMinusX(30, 20);
```

在此方法旁边，`Objects`附带另一个名为`checkFromIndexSize(int start, int size, int length)`的方法。 该方法检查给定的 start 的子范围[*，*给定的 start +给定尺寸*]在[0，*给定长度*的范围内。*

# 46.等于（）和 hashcode（）

`equals()`和`hashCode()`方法在`java.lang.Object`中定义。 由于`Object`是所有 Java 对象的超类，因此所有对象都可以使用这两种方法。 它们的主要目标是为比较对象提供一种简单，有效和强大的解决方案，并确定它们是否相等。 如果没有这些方法及其合同，则解决方案依赖于大型和繁琐的`if`语句，以比较对象的每个字段。

当未覆盖这些方法时，Java 将使用其默认实现。 不幸的是，默认实现并不真正为确定两个对象是否具有相同值的目标而不是真正服务。 默认情况下，`equals()`检查*标识*。 换句话说，它认为，如果它们由相同的存储器地址（相同对象引用）表示，则两个对象是相等的，而`hashCode()`返回对象存储器地址的整数表示。 这是称为*标识* *哈希码的本机函数。*

例如，让我们假设以下类：

```
public class Player {

  private int id;
  private String name;

  public Player(int id, String name) {

    this.id = id;
    this.name = name;
  }
}
```

然后，让我们创建包含相同信息的此类的两个实例，并让我们将它们与平等进行比较：

```
Player p1 = new Player(1, "Rafael Nadal");
Player p2 = new Player(1, "Rafael Nadal");

System.out.println(p1.equals(p2)); // false
System.out.println("p1 hash code: " + p1.hashCode()); // 1809787067
System.out.println("p2 hash code: " + p2.hashCode()); // 157627094
```

不要使用`==`操作员来测试对象的平等（避免`if(p1 == p2)`）。 `==`操作员比较两个对象的引用指向同一对象，而`equals()`将对象值进行比较（作为人类，这是我们关心的）。

作为拇指的规则，如果两个变量保持相同的引用，它们是*相同的，*但如果它们引用相同的值，则它们是*等于*。 *相同的值*方式由`equals()`定义。

对于我们而言，`p1`和`p2`是相等的，但请注意`equals()`已返回`false`（`p1`和`p2`实例具有完全相同的字段值，但它们存储在不同的内存地址中） 。 这意味着依赖于`equals()`的默认实现是不可接受的。 解决方案是覆盖此方法，为此，重要的是要意识到提出以下陈述的`equals()`合同：

*   **反射性**：一个对象等于自身，这意味着`p1.equals(p1)`必须返回`true`。
*   **对称性**：`p1.equals(p2)`必须返回相同的结果（`true` / `false`）作为`p2.equals(p1)`。
*   **传递**：如果`p1.equals(p2)`和`p2.equals(p3)`，那么也`p1.equals(p3)`。
*   **一致**：除非其中一个更改，否则两个相等的对象必须保持相等。
*   **`Null`返回`false`** ：所有对象必须不等到`null`。

因此，为了尊重本合同，可以覆盖`Player`类的`equals()`方法如下：

```
@Override
public boolean equals(Object obj) {

  if (this == obj) {
    return true;
  }

  if (obj == null) {
    return false;
  }

  if (getClass() != obj.getClass()) {
    return false;
  }

  final Player other = (Player) obj;

  if (this.id != other.id) {
    return false;
  }

  if (!Objects.equals(this.name, other.name)) {
    return false;
  }

  return true;
}
```

现在，让我们再次执行平等测试（这次，`p1`等于`p2`）：

```
System.out.println(p1.equals(p2)); // true
```

好的，到目前为止这么好！ 现在，让我们将这两个`Player`实例添加到集合。 例如，让我们将它们添加到`HashSet`（一个不允许重复的 Java 集合）：

```
Set<Player> players = new HashSet<>();
players.add(p1);
players.add(p2);
```

让我们检查这个`HashSet`的大小以及它是否包含`p1`：

```
System.out.println("p1 hash code: " + p1.hashCode()); // 1809787067
System.out.println("p2 hash code: " + p2.hashCode()); // 157627094
System.out.println("Set size: " + players.size());    // 2
System.out.println("Set contains Rafael Nadal: "
  + players.contains(new Player(1, "Rafael Nadal"))); // false
```

符合`equals()`，`p1`和`p2`的前面实现等于; 因此，`HashSet`尺寸应为 1，而不是 2.此外，它应该含有 Rafael Nadal。 所以发生了什么事？

嗯，常规答案驻留在 Java 如何创建。 易于意味着`equals()`不是快速的方法; 因此，当需要大量的平等比较时，查找将面临性能惩罚。 例如，这在收集中的特定值（例如，`HashSet`，`HashMap`和`HashTable`）中，在查找的情况下增加了严重缺点，因为它可能需要大量的平等比较。

基于此语句，Java 试图通过添加*桶*来降低平等比较。 桶是基于散列的容器，其将相同的对象组成。 这意味着相同的对象应该返回相同的哈希码，而不平等的对象应该返回不同的哈希代码（如果两个不相等的对象具有相同的哈希码，那么这是一个*哈希碰撞，*和对象将进入 相同的桶）。 因此，Java 比较了哈希代码，并且只有在两个不同的对象引用的两个不同的对象引用（不适用于相同的对象引用）时，它会进一步前进并调用`equals()`。 基本上，这会加速收藏中的查找。

但我们的案件发生了什么？ 让我们一步一步一步：

*   创建`p1`时，Java 将根据`p1`存储器地址分配给它哈希码。
*   当`p1`添加到`Set`时，Java 将为`p1`哈希码链接新桶。
*   创建`p2`时，Java 将根据`p2`存储器地址分配给它哈希码。
*   当`p2`添加到`Set`时，Java 将为`p2`哈希码链接到`p2`哈希代码（当发生这种情况时，它看起来像`HashSet`不按预期工作，它允许重复）。
*   当执行`players.contains(new Player(1, "Rafael Nadal"))`时，使用基于`p3`存储器地址的新散列码创建新播放器`p3`。
*   因此，在`contains()`的帧中，检测`p1`和`p3`，`p2`和`p3`，用于等等涉及检查其哈希代码，并且由于`p1`哈希码与`p3`哈希码，`p2`哈希码与`p3`散列码不同，比较停止而不评估`equals()`，这意味着`HashSet`不包含对象（`p3`）

要返回轨道，代码也必须覆盖`hashCode()`方法。 `hashCode()`合同征收以下内容：

*   符合`equals()`的两个相同的对象必须返回相同的哈希码。
*   具有相同哈希码的两个对象不是强制等于的。
*   只要对象保持不变，`hashCode()`必须返回相同的值。

作为经验法则，为了尊重`equals()`和`hashCode()`合同，请遵循两个金规则：

*   当覆盖`equals()`时，也必须覆盖`hashCode()`，也必须反之亦然。
*   以相同的顺序使用两种方法的相同标识属性。

对于`Player`类，可以覆盖`hashCode()`，如下所示：

```
@Override
public int hashCode() {

  int hash = 7;
  hash = 79 * hash + this.id;
  hash = 79 * hash + Objects.hashCode(this.name);

  return hash;
}
```

现在，让我们执行另一个测试（这次，它按预期工作）：

```
System.out.println("p1 hash code: " + p1.hashCode()); // -322171805
System.out.println("p2 hash code: " + p2.hashCode()); // -322171805
System.out.println("Set size: " + players.size());    // 1
System.out.println("Set contains Rafael Nadal: "
  + players.contains(new Player(1, "Rafael Nadal"))); // true
```

现在，让我们枚举一些使用`equals()`和`hashCode()`的常见错误：

*   您覆盖`equals()`并忘记覆盖`hashCode()`，反之亦然（覆盖两者或无）。
*   您使用`==`运算符而不是`equals()`进行比较对象值。
*   在`equals()`中，您省略了以下一个或多个：
    *   通过添加*自检*（`if (this == obj)...`）。
    *   由于任何实例都不等于`null`，因此继续添加 *null-check* （`if(obj == null)...`）。
    *   确保该实例是我们期待的（使用`getClass()`或`instanceof`）。
    *   最后，在这些角落案件之后，添加现场比较。

*   您通过继承违反了`equals()`对称性。 假设`A`和一个类`B`扩展`A`并添加新字段。 `B`类覆盖从`A`继承的`equals()`实现，此实现将添加到新字段中。 依赖于`instanceof`将揭示`b.equals(a)`将返回`false`（按预期），但`a.equals(b)`将返回`true`（未预期），因此因此对称性被打破。 依赖于 *Slice 比较*，因为这破坏了传递和反射性。 修复问题意味着依赖于`getClass()`而不是`instanceof`（通过`getClass()`，类型及其子类型不能等于），或者更好地依赖于组成而不是继承，而不是将其捆绑在本书中的应用程序（`P46_ViolateEqualsViaSymmetry`）。
*   您从`hashCode()`返回常量，而不是每个对象的唯一哈希码。

由于 JDK 7，`Objects`类具有多个帮助处理对象平等和哈希代码，如下所示：

*   `Objects.equals(Object a, Object b)`：测试`a`对象是否等于`b`对象。
*   `Objects.deepEquals(Object a, Object b)`：有用用于测试两个对象是否相等（如果它们是阵列，则通过`Arrays.deepEquals()`执行测试。
*   `Objects.hash(Object ... values)`：为一系列输入值生成哈希码。

确保通过`EqualsVerifier`库（ [https://mvnrepository.com/artifact/nl.jqno.equalsverifier/equalsverifier](https://mvnrepository.com/artifact/nl.jqno.equalsverifier/equalsverifier) 来确保`hashCode()`和`hashCode()`尊重 Java SE 合同。

依赖于`Lombok`库从对象字段生成`hashCode()`和`equals()`（ [https://projectlombok.org/](https://projectlombok.org/) ）。 但要注意与 JPA 实体结合`Lombok`的特殊情况。

# 47.坚果壳的不可变量

一个不可变的对象是创建后无法更改的对象（其状态已修复）。

在 Java 中，以下内容适用：

*   原始类型是不可变的。
*   着名的 Java `String`类是不可变的（其他类也是不可变的，例如`Pattern`和`LocalDate`）
*   阵列不是不可变的。
*   集合可以是可变的，不可改造的或不可变的。

一个未经修复的集合不是自动不变的。 它取决于哪些对象存储在集合中。 如果存储的对象是可变的，则该集合是可变的和不可替换的。 但如果存储的对象是不可变的，那么该系列有效地是不可变的。

不可变的物体在并发（多线程）应用程序和流中是有用的。 由于无法更改不可改变的物体，因此并发问题无法进行并发问题，并且它们不会损坏或不一致。

使用不可变性对象的主要问题之一与创建新对象的惩罚相关，而不是管理可变对象的状态。 但请记住，在垃圾收集期间，不可变的物体利用特殊处理。 此外，它们不容易出现并发问题并消除管理可变对象状态所需的代码。 管理可变对象状态所需的代码易于比创建新对象慢。

看着以下问题将使我们深入了解 Java 中的对象不变性。

# 48.不可变的字符串

每个编程语言都有一种代表字符串的方式。 作为原始类型，字符串是预定义类型的一部分，它们几乎所有类型的 Java 应用程序都使用。

在 Java 中，字符串不是由像`int`，`long`和`float`等原始类型表示的。 它们由名为`String`的引用类型表示。 几乎任何 Java 应用程序都使用字符串，例如，Java 应用程序的`main()`方法作为参数`String`类型的参数。

`String`的诺奇及其广泛的应用程序意味着我们应该详细了解。 除了了解如何宣布和操纵字符串（例如，反向和大写）开发人员应该理解为什么这个类以特殊或不同的方式设计。 更准确地说，为什么`String`不可变？ 或者可能这个问题具有更好的共振，如此 - `String`是不可变的，是什么？

# 字符串不变性

让我们来看看下一节中的一些字符串不变性。

# 字符串常量池或缓存池

有利于字符串不变性的原因之一由 ****Tring 常数池**（ **SCP** ）或缓存池表示。 为了理解这一陈述，让我们潜水有点进入`String`课程在内部工作。**

SCP 是用于存储字符串文字的内存（不是普通堆内存）的特殊区域。 让我们假设以下三个`String`变量：

```
String x = "book";
String y = "book";
String z = "book";
```

已创建多少`String`对象？ 它诱人说三个，但实际上 Java 只创建一个`"book"`值的`String`对象。 这个想法是报价之间的一切都被视为一个字符串文字，并且 Java 在这个特殊的内存区域中存储了称为 SCP 的字符串文字，按照这样的算法（该算法称为**字符串交流**） ：

*   创建字符串文字时（例如，`String x = "book"`），java 检查 scp 以查看此字符串文字是否存在。
*   如果在 SCP 中找不到字符串文字，则在 SCP 和相应变量中创建字符串文字的新字符串对象`x`，将指向它。
*   如果在 SCP 中找到字符串文字（例如，`String y = "book"`，`String z = "book"`），则新变量将指向`String`对象（基本上，具有相同值的所有变量将指向相同的`String`对象）：

![](img/fb650718-b302-4bd2-8298-1b1b7813b4d9.png)

但`x`应该是`"cook"`而不是`"book"`，所以让我们用`"c"` - `x = x.replace("b", "c");`替换`"b"`。

虽然`x`应该是`"cook"`，`y`和`z`应保持不变。 这种行为是由不可变的提供。 Java 将创建一个新对象，并将执行更改，如下所示：

![](img/4c94c088-32d7-4df0-a37b-9ba4e589c142.png)

因此，String Unmutity 允许缓存字符串文字，这允许应用程序使用大量字符串文字，并对堆内存和垃圾收集器产生最小的影响。 在一个可变的上下文中，字符串文字的修改可能导致损坏的变量。

不要将字符串创建为`String x = new String("book")`。 这不是一个字符串文字; 这是一个`String`实例（通过构造函数构建），它将在普通内存堆而不是 SCP 中。 在正常堆内存中创建的字符串可以通过显式调用`String.intern()`作为`x.intern()`来指向 SCP。

# 安全

字符串不动态的另一个好处是其安全方面。 通常，大量敏感的信息（用户名，密码，URL，端口，数据库，套接字连接，参数，属性等）表示并按字符串传递。 通过使此信息不可变，代码变得安全到广泛的安全威胁（例如，意外地或故意修改引用）。

# 线程安全

想象一下使用数千个可变的`String`对象并处理线程安全代码的应用程序。 幸运的是，在这种情况下，由于不变性，我们想象的情景不会成为现实。 任何不可变的物体都是线程安全的。 这意味着可以由多个线程共享和操作字符串，没有损坏和不一致的风险。

# 哈希码缓存

e *quals（）和 hashcode（）*部分`equals()`和`hashCode()`。 每次涉及散列特定活动时应计算哈希代码（例如，在集合中搜索元素）。 由于`String`是不可变的，每个字符串都有一个不变的哈希码，可以缓存并重用，因为在字符串创建后无法更改。 这意味着可以从高速缓存使用字符串的散列码而不是在每个用法中重新计算它们。 例如，`HashMap`散列其键进行不同的操作（例如，`put()`，`get()`），如果这些键是`String`类型，则将从缓存中重用哈希代码而不是重新计算它们 。

# 班级装载

加载存储器中类的典型方法依赖于调用`Class.forName(String className)`方法。 注意表示类名称的`String`参数。 由于字符串不变性，在加载过程中无法更改类名。 但是，如果`String`是可变的，那么想象加载`class A`（例如，`Class.forName("A")`），并且在加载过程中，它的名称将变为`BadA`。 现在，`BadA`对象可以做坏事！

# 字符串不动情的缺点

让我们来看看下一节中的一些字符串不变性的缺点。

# 字符串无法扩展

应宣布一个不可变类`final`以避免可扩展性。 但是，开发人员需要扩展`String`类以增加更多功能，并且这种限制可以被视为不可变的缺点。

尽管如此，开发人员可以编写实用类（例如，Apache Commons Lang，`StringUtils`，Spring 框架，`StringUtils`，Guava 和 Strings），以提供额外的功能，并且只需将字符串作为参数传递给这些类的方法。

# 在内存中的敏感数据很长一段时间

字符串中的敏感数据（例如，密码）可能会长时间驻留在内存（在 SCP 中）。 作为缓存，SCP 利用垃圾收集器的特殊处理。 更确切地说，垃圾收集器没有与其他内存区域相同的频率（周期）的垃圾收集器访问 SCP。 由于这种特殊处理的结果，敏感数据长时间保存在 SCP 中，并且可以容易出现不需要的用法。

为了避免这种潜在的缺点，建议在`char[]`中存储敏感数据（例如，密码）而不是`String`。

# OutofMemoryError.

与其他人相比，SCP 是一个小的记忆区，可以很快填充。 在 SCP 中存储太多字符串文字将导致`OutOfMemoryError`。

# 字符串完全不变吗？

嗯，幕后，`String`使用`private final char[]`来存储字符串的每个字符。 通过使用 Java Reflection API，在 JDK 8 中，以下代码将修改此`char[]`（JDK 11 中的相同代码将抛出`java.lang.ClassCastException`）：

```
String user = "guest";
System.out.println("User is of type: " + user);

Class<String> type = String.class;
Field field = type.getDeclaredField("value");
field.setAccessible(true);

char[] chars = (char[]) field.get(user);

chars[0] = 'a';
chars[1] = 'd';
chars[2] = 'm';
chars[3] = 'i';
chars[4] = 'n';

System.out.println("User is of type: " + user);
```

因此，在 JDK 8 中，`String`有效地*是不可变的，但不是*完全*。*

# 49.写一个不可变的课程

不可变类必须尊重几个要求，例如以下内容：

*   该类应标记为`final`以抑制可扩展性（其他类无法扩展此类;因此，它们无法覆盖方法）
*   应声明所有字段`private`和`final`（它们在其他类中不可见，并且它们仅在此类的构造函数中初始化一次）
*   该类应包含参数化`public`构造函数（或用于创建实例的`private`构造函数和工厂方法）初始化字段
*   该类应该为字段提供 Getters
*   班级不应该暴露定居者

例如，由于它成功传递了前面的清单，因此以下`Point`类是不可变的：

```
public final class Point {

  private final double x;
  private final double y;

  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

  public double getX() {
    return x;
  }

  public double getY() {
    return y;
  }
}
```

如果不可变类应操纵可变对象，请考虑以下问题。

# 50.将可变对象传递/从不可变级别

将可变对象传递给不可变形的类可以分解不变性。 让我们考虑以下可变类：

```
public class Radius {

  private int start;
  private int end;

  public int getStart() {
    return start;
  }

  public void setStart(int start) {
    this.start = start;
  }

  public int getEnd() {
    return end;
  }

  public void setEnd(int end) {
    this.end = end;
  }
}
```

然后，让我们将这个类的实例传递给名为的不可变类`Point`。 乍一看，`Point`类可以写如下：

```
public final class Point {

  private final double x;
  private final double y;
  private final Radius radius;

  public Point(double x, double y, Radius radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  public double getX() {
    return x;
  }

  public double getY() {
    return y;
  }

  public Radius getRadius() {
    return radius;
  }
}
```

这个课程还是不可变吗？ 答案是不。 `Point`类不再是不可变的，因为它的状态可以如以下示例更改：

```
Radius r = new Radius();
r.setStart(0);
r.setEnd(120);

Point p = new Point(1.23, 4.12, r);

System.out.println("Radius start: " + p.getRadius().getStart()); // 0
r.setStart(5);
System.out.println("Radius start: " + p.getRadius().getStart()); // 5
```

请注意，调用`p.getRadius().getStart()`返回两个不同的结果; 因此，`p`的状态已经改变，因此`Point`不再是不可变的。 解决此问题的解决方案正在克隆`Radius`对象并将克隆存储为`Point`的字段：

```
public final class Point {

  private final double x;
  private final double y;
  private final Radius radius;

  public Point(double x, double y, Radius radius) {
    this.x = x;
    this.y = y;

    Radius clone = new Radius();
    clone.setStart(radius.getStart());
    clone.setEnd(radius.getEnd());

    this.radius = clone;
  }

  public double getX() {
    return x;
  }

  public double getY() {
    return y;
  }

  public Radius getRadius() {
    return radius;
  }
}
```

这次，`Point`级不可变形水平增加（呼叫`r.setStart(5)`不会影响`radius`字段，因为该字段是`r`的克隆）。 但是`Point`课程并不完全不变，因为在从不可变类中解决返回的可变对象还有一个问题可能会破坏不可动态。 检查以下代码，分解`Point`的不变性：

```
Radius r = new Radius();
r.setStart(0);
r.setEnd(120);

Point p = new Point(1.23, 4.12, r);

System.out.println("Radius start: " + p.getRadius().getStart()); // 0
p.getRadius().setStart(5);
System.out.println("Radius start: " + p.getRadius().getStart()); // 5
```

再次，调用`p.getRadius().getStart()`返回两个不同的结果; 因此，`p`的状态已经改变。 解决方案包括修改`getRadius()`方法以返回`radius`字段的克隆，如下所示：

```
...
public Radius getRadius() {
    Radius clone = new Radius();
    clone.setStart(this.radius.getStart());
    clone.setEnd(this.radius.getEnd());

    return clone;
  }
...
```

现在，`Point`课程再次是不可变的。 问题解决了！

在选择克隆技术/工具之前，在某些情况下，建议您使用时间和分析/了解 Java 和第三方库中可用的不同可能性（例如，检查*克隆对象*部分 章节）。 对于浅副本，前面的技术可以是正确的选择，但对于深度副本，代码可能需要依赖于不同的方法，如复制构造函数，`Cloneable`界面或外部库（例如，apache commons lang [htg1 `Gson`或杰克逊或任何其他人的 JSON 序列化。

# 51.通过建设者模式撰写不可变类

当类（不可变或可变或可变的）具有太多字段时，它需要具有许多参数的构造函数。 当需要一些这些字段并且其他字段是可选的，此类需要多个构造函数来涵盖所有可能的组合。 这对开发人员和类用户变得麻烦。 这是建造者模式来救援的地方。

根据 **Gang 的四个**（ **gof** ） - *构建器图案将复杂对象的构造与其表示分开，使得相同的施工过程可以产生不同的表示。*

构建器模式可以实现为单独的类或作为内部`static`类。 让我们专注于第二种情况。 `User`类具有三个必填字段（`nickname`，`password`和`created`）和三个可选字段（`email`，`firstname`和`lastname`）。

现在，依赖于构建器模式的不可变`User`类将显示如下：

```
public final class User {

  private final String nickname;
  private final String password;
  private final String firstname;
  private final String lastname;
  private final String email;
  private final Date created;

  private User(UserBuilder builder) {
    this.nickname = builder.nickname;
    this.password = builder.password;
    this.created = builder.created;
    this.firstname = builder.firstname;
    this.lastname = builder.lastname;
    this.email = builder.email;
  }

  public static UserBuilder getBuilder(
      String nickname, String password) {
    return new User.UserBuilder(nickname, password);
  }

  public static final class UserBuilder {

    private final String nickname;
    private final String password;
    private final Date created;
    private String email;
    private String firstname;
    private String lastname;

    public UserBuilder(String nickname, String password) {
      this.nickname = nickname;
      this.password = password;
      this.created = new Date();
    }

    public UserBuilder firstName(String firstname) {
      this.firstname = firstname;
      return this;
    }

    public UserBuilder lastName(String lastname) {
      this.lastname = lastname;
      return this;
    }

    public UserBuilder email(String email) {
      this.email = email;
      return this;
    }

    public User build() {
      return new User(this);
    }
  }

  public String getNickname() {
    return nickname;
  }

  public String getPassword() {
    return password;
  }

  public String getFirstname() {
    return firstname;
  }

  public String getLastname() {
    return lastname;
  }

  public String getEmail() {
    return email;
  }

  public Date getCreated() {
    return new Date(created.getTime());
  }
}
```

以下是一些使用示例：

```
import static modern.challenge.User.getBuilder;
...
// user with nickname and password
User user1 = getBuilder("marin21", "hjju9887h").build();

// user with nickname, password and email
User user2 = getBuilder("ionk", "44fef22")
  .email("ion@gmail.com")
  .build();

// user with nickname, password, email, firstname and lastname
User user3 = getBuilder("monika", "klooi0988")
  .email("monika@gmail.com")
  .firstName("Monika")
  .lastName("Ghuenter")
  .build();
```

# 52.避免在不可变的物体中的坏数据

*坏数据*是对不可变对象的负面影响的任何数据（例如，损坏的数据）。 最重要的是，此数据来自用户输入或来自未在我们的直接控制下的外部数据源。 在这种情况下，坏数据可以击中不可变的对象，最糟糕的部分是没有修复它。 创建后不能改变一个不可变的物体; 因此，只要物体生命，糟糕的数据就会愉快地生活。

解决此问题的解决方案是验证针对一组综合约束中进入不可变形对象中的所有数据。

从自定义验证到内置解决方案，有不同的执行验证方式。 根据应用程序设计，可以在不可变形对象类之外或内部执行验证。 例如，如果通过 Builder 模式构建不可变的对象，则可以在 Builder 类中执行验证。

JSR 380 是 Bean 验证的 Java API 的规范（Java SE / EE），可用于通过注释验证。 Hibernate Validator 是验证 API 的参考实现，它可以在`pom.xml`文件中轻松提供为 Maven 依赖项（检查本书捆绑的源代码）。

此外，我们依赖于专用注释来提供所需的约束（例如，`@NotNull`，`@Min`，`@Max`，`@Size`和`@Email`）。 在以下示例中，约束将添加到 Builder 类中，如下所示：

```
...
public static final class UserBuilder {

  @NotNull(message = "cannot be null")
  @Size(min = 3, max = 20, message = "must be between 3 and 20 
    characters")
  private final String nickname;

  @NotNull(message = "cannot be null")
  @Size(min = 6, max = 50, message = "must be between 6 and 50 
    characters")
  private final String password;

  @Size(min = 3, max = 20, message = "must be between 3 and 20 
    characters")
  private String firstname;

  @Size(min = 3, max = 20, message = "must be between 3 and 20 
    characters")
  private String lastname;

  @Email(message = "must be valid")
  private String email;

  private final Date created;

  public UserBuilder(String nickname, String password) {
    this.nickname = nickname;
    this.password = password;
    this.created = new Date();
  }
...
```

最后，验证过程通过`Validator` API 从代码触发（仅在 Java SE 中需要）。 如果输入 Builder 类的数据无效，则不会创建不可变的对象（不要调用`build()`方法）：

```
User user;
Validator validator 
  = Validation.buildDefaultValidatorFactory().getValidator();

User.UserBuilder userBuilder 
  = new User.UserBuilder("monika", "klooi0988")
    .email("monika@gmail.com")
    .firstName("Monika").lastName("Gunther");

final Set<ConstraintViolation<User.UserBuilder>> violations 
  = validator.validate(userBuilder);
if (violations.isEmpty()) {
  user = userBuilder.build();
  System.out.println("User successfully created on: " 
    + user.getCreated());
} else {
  printConstraintViolations("UserBuilder Violations: ", violations);
}
```

这样，坏数据无法触摸一个不可变的对象。 如果没有 Builder 类，则可以直接在不可变对象中的字段级别添加约束。 前面的解决方案只需在控制台上显示潜在的违规，但根据情况，解决方案可能执行不同的操作（例如，抛出特定的例外）。

# 53.克隆对象

克隆对象不是每日任务，但重要的是要正确做。 主要是，克隆对象是指创建对象的副本。 有两种主要类型的副本 - *浅*副本（尽可能少地复制）和 *deep* 副本（复制所有内容）。

让我们假设以下课程：

```
public class Point {

  private double x;
  private double y;

  public Point() {}
  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

  // getters and setters
}
```

所以，我们有一个类型（x，y）映射在课程中。 现在，让我们执行一些克隆。

# 手动克隆

快速方法包括将当前`Point`手动将当前`Point`复制到新的`Point`（这是一个浅副本）的方法组成：

```
public Point clonePoint() {
  Point point = new Point();
  point.setX(this.x);
  point.setY(this.y);

  return point;
}
```

这里的代码很简单。 只需创建一个新的`Point`实例，并使用当前`Point`的字段填充其字段。 返回的`Point`是一个浅副本（因为`Point`不依赖于其他对象，当前`Point`的深度副本将完全相同：

```
Point point = new Point(...);
Point clone = point.clonePoint();
```

# 克隆通过克隆（）

`Object`类包含一个名为`clone()`的方法。 此方法对于创建浅副本非常有用（它也可以用于深副本）。 要使用它，课程应遵循给定的步骤：

*   实现`Cloneable`接口（如果未实现此接口，则将抛出`CloneNotSupportedException`）。
*   覆盖`clone()`方法（`Object.clone()`是`protected`）。
*   调用`super.clone()`。

`Cloneable`界面不包含任何方法。 它只是 JVM 可以克隆这个对象的信号。 实现此接口后，代码需要覆盖`Object.clone()`方法。 这是因为`Object.clone()`是`protected`，而且，为了通过`super`调用它，代码需要覆盖此方法。 如果`clone()`添加到儿童类，这可能是一个严重的缺点，因为所有超类都应该定义`clone()`方法，以避免`super.clone()`链调用的故障。

此外，`Object.clone()`不依赖于构造函数调用，因此开发人员无法控制对象构造：

```
public class Point implements Cloneable {

  private double x;
  private double y;

  public Point() {}

  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

  @Override
  public Point clone() throws CloneNotSupportedException {
    return (Point) super.clone();
  }

  // getters and setters
}
```

创建克隆可以如下所示：

```
Point point = new Point(...);
Point clone = point.clone();
```

# 通过构造函数克隆

此克隆技术要求您使用构造函数来丰富类，该构造函数采用代表将用于创建克隆的类的实例。

让我们在代码中看到它：

```
public class Point {

  private double x;
  private double y;

  public Point() {}

  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

  public Point(Point another) {
    this.x = another.x;
    this.y = another.y;
  }

  // getters and setters
}
```

创建克隆可以如下所示：

```
Point point = new Point(...);
Point clone = new Point(point);
```

# 通过克隆图书馆克隆

当对象取决于另一个对象时，需要深度复制。 执行深度副本意味着复制对象，包括其依赖链。 例如，让我们假设`Point`有`Radius`类型的字段：

```
public class Radius {

  private int start;
  private int end;

  // getters and setters
}

public class Point {

  private double x;
  private double y;
  private Radius radius;

  public Point(double x, double y, Radius radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  // getters and setters
}
```

执行`Point`的浅副本将创建`x`和`y`的副本，但不会创建`radius`对象的副本。 这意味着影响`radius`对象的修改也将在克隆中反映。 现在是深度副本的时候了。

繁琐的解决方案将涉及调整先前提出的浅拷贝技术以支持深度副本。 幸运的是，有一些解决方案可以在框中应用，其中一个是克隆库（ [https://github.com/kostaskougios/cloning](https://github.com/kostaskougios/cloning) ）：

```
import com.rits.cloning.Cloner;
...
Point point = new Point(...);
Cloner cloner = new Cloner();
Point clone = cloner.deepClone(point);
```

代码是不言自明的。 请注意，克隆库也附带了其他几种好东西，可以在以下屏幕截图中看到：

![](img/c75891ec-3902-49da-8290-62d5f7b09c70.png)

# 通过序列化克隆

此技术需要可序列化对象（实现`java.io.Serializable`）。 基本上，对象在新对象中是序列化（`writeObject()`）和反序列化（`readObject()`）。 能够完成此操作的帮助程序方法如下所示：

```
private static <T> T cloneThroughSerialization(T t) {

  try {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(baos);
    oos.writeObject(t);

    ByteArrayInputStream bais 
      = new ByteArrayInputStream(baos.toByteArray());
    ObjectInputStream ois = new ObjectInputStream(bais);

    return (T) ois.readObject();
  } catch (IOException | ClassNotFoundException ex) {
    // log exception
    return t;
  }
}
```

因此，该对象在`ObjectOutputStream`中序列化，并在`ObjectInputStream`中反序列化。 通过此方法克隆对象可以实现如下：

```
Point point = new Point(...);
Point clone = cloneThroughSerialization(point);
```

Apache Commons Lang 提供基于序列化的内置解决方案，通过`SerializationUtils`提供。 在其方法中，此类提供了一种名为`clone()`的方法，可以使用如下：

```
Point point = new Point(...);
Point clone = SerializationUtils.clone(point);
```

# 通过 JSON 克隆

Java 中的几乎任何 JSON 库都可以序列化任何**纯旧 Java 对象**（ **POJO** ），无需任何额外的配置/映射。 在项目中拥有 JSON 库（以及许多项目）可以保存我们添加额外的库以提供深度克隆。 主要是，解决方案可以利用现有的 JSON 库获得相同的效果。

以下是使用`Gson`库的示例：

```
private static <T> T cloneThroughJson(T t) {

  Gson gson = new Gson();
  String json = gson.toJson(t);

  return (T) gson.fromJson(json, t.getClass());
}

Point point = new Point(...);
Point clone = cloneThroughJson(point);
```

除此之外，还有始终选择致力于克隆对象的自己的图书馆。

# 54.覆盖 ToString（）

`toString()`方法在`java.lang.Object`中定义，JDK 具有默认实现。 此默认实现将自动用于所有对象，该对象是`print()`，`println()`，`printf()`，在开发期间调试，记录，信息性消息中的调试，依此类推。

遗憾的是，默认实现返回的对象的字符串表示不是非常有信息。 例如，让我们考虑以下`User`类：

```
public class User {
  private final String nickname;
  private final String password;
  private final String firstname;
  private final String lastname;
  private final String email;
  private final Date created;

  // constructor and getters skipped for brevity
}
```

现在，让我们创建这个类的一个实例，让我们在控制台上打印它：

```
User user = new User("sparg21", "kkd454ffc",
  "Leopold", "Mark", "markl@yahoo.com");

System.out.println(user);
```

此`println()`方法的输出将如下：

![](img/d41b9942-344f-444f-b3a4-dbd2513c92cf.png)

用于避免如前面的屏幕截图中的输出的解决方案包括覆盖`toString()`方法。 例如，让我们覆盖它以暴露用户详细信息，如下所示：

```
@Override
public String toString() {
  return "User{" + "nickname=" + nickname + ", password=" + password
    + ", firstname=" + firstname + ", lastname=" + lastname
    + ", email=" + email + ", created=" + created + '}';
}
```

这次，`println()`将揭示以下输出：

```
User {
  nickname = sparg21, password = kkd454ffc, 
  firstname = Leopold, lastname = Mark, 
  email = markl@yahoo.com, created = Fri Feb 22 10: 49: 32 EET 2019
}
```

这比以前的输出更具信息量。

但是，请记住，`toString()`自动调用不同的目的。 例如，日志记录可以如下：

```
logger.log(Level.INFO, "This user rocks: {0}", user);
```

在这里，用户密码将点击日志，这可能表示问题。 在应用程序中揭示日志敏感数据，例如密码，帐户和秘密 IP，绝对是一个不好的练习。

因此，要特别注意仔细选择`toString()`的信息，因为此信息可能最终可能会恶意地利用的地方。 在我们的情况下，密码不应成为`toString()`的一部分：

```
@Override
public String toString() {
  return "User{" + "nickname=" + nickname
    + ", firstname=" + firstname + ", lastname=" + lastname
    + ", email=" + email + ", created=" + created + '}';
}
```

通常，`toString()`是通过 IDE 生成的方法。 因此，请注意在 IDE 为您生成代码之前选择的字段。

# 55.切换表达式

在我们简要概述 JDK 12 中介绍的`switch`表达式之前，让我们看看一个典型的旧学校示例包裹在方法中：

```
private static Player createPlayer(PlayerTypes playerType) {

  switch (playerType) {

    case TENNIS:
      return new TennisPlayer();
    case FOOTBALL:
      return new FootballPlayer();
    case SNOOKER:      
      return new SnookerPlayer();
    case UNKNOWN:
      throw new UnknownPlayerException("Player type is unknown");
    default:
      throw new IllegalArgumentException(
        "Invalid player type: " + playerType);

  }
}
```

如果我们忘记了`default`，则代码将无法编译。

显然，前面的例子是可以接受的。 在最坏的情况下，我们可以添加一个杂散变量（例如，`player`），一些杂乱`break`语句，如果缺少`default`，则没有抱怨。 因此，以下代码是一个古老的学校，非常丑陋`switch`：

```
private static Player createPlayerSwitch(PlayerTypes playerType) {

  Player player = null;

  switch (playerType) {
    case TENNIS:
      player = new TennisPlayer();
      break;
    case FOOTBALL:
      player = new FootballPlayer();
      break;
    case SNOOKER:
      player = new SnookerPlayer();
      break;
    case UNKNOWN:
      throw new UnknownPlayerException(
        "Player type is unknown");
    default:
      throw new IllegalArgumentException(
        "Invalid player type: " + playerType);
  }

  return player;
}
```

如果我们忘记了`default`，那么编译器方面不会有投诉。 在这种情况下，可能导致`null`播放器。

但是，由于 JDK 12，我们已经能够依赖于`switch`表达式。 在 JDK 12 时，`switch`是一个语句，构造意味着控制流（例如，作为`if`语句）而不代表结果。 另一方面，将表达式评估为结果。 因此，`switch`表达可以具有结果。

前面的`switch`表达式可以用 JDK 12 的样式编写如下：

```
private static Player createPlayer(PlayerTypes playerType) {

  return switch (playerType) {
    case TENNIS ->
      new TennisPlayer();
    case FOOTBALL ->
      new FootballPlayer();
    case SNOOKER ->
      new SnookerPlayer();
    case UNKNOWN ->
      throw new UnknownPlayerException(
        "Player type is unknown");
    // default is not mandatory
    default ->
      throw new IllegalArgumentException(
        "Invalid player type: " + playerType);
  };
}
```

这次，`default`不是强制性的。 我们可以跳过它。

如果`switch`不涵盖所有可能的输入值，JDK 12 `switch`智能足以发信号信号。 这在 Java `enum`值的情况下非常有用。 JDK 12 `switch`可以检测是否覆盖所有`enum`值，如果不是，则不会强制无用的`default`。 例如，如果我们删除`default`并向`PlayerTypes` `enum`添加新条目（例如，`GOLF`），那么编译器将通过消息发出信号，如下屏幕截图（这来自 NetBeans ）：

![](img/fd6ef71d-5ca7-4757-a37c-3e111bb83418.png)

请注意，在标签和执行之间，我们将使用箭头（Lambda 样式语法）替换冒号。 此箭头的主要作用是防止衰落，这意味着仅执行右权只有代码块。 不需要使用`break`。

不要得出结论，箭头将`switch`语句转化为`switch`表达式。 可以与冒号和`break`一起使用`switch`表达，如下：

```
private static Player createPlayer(PlayerTypes playerType) {

  return switch (playerType) {
    case TENNIS:
      break new TennisPlayer();
    case FOOTBALL:
      break new FootballPlayer();
    case SNOOKER:
      break new SnookerPlayer();
    case UNKNOWN:
      throw new UnknownPlayerException(
        "Player type is unknown");
    // default is not mandatory
    default:
      throw new IllegalArgumentException(
        "Invalid player type: " + playerType);
  };
}
```

我们的示例帖子`switch`超过`enum`，但 JDK 12 `switch`也可以在`int`，`Integer`，`short`，`Short`，`Short`，`byte`，`Byte`，`char` ，`Character`和`String`。

注意，JDK 12 将`switch`表达式带到预览功能。 这意味着它在接下来的几个版本中容易发生变化，并且需要通过编译和运行时通过`--enable-preview`命令行选项解锁。

# 56.多案标签

在 JDK 12 之前，A `switch`语句允许每个`case`单个标签。 从`switch`表达式开始，`case`可以通过逗号分隔多个标签。 查看以下方法，该方法举例说明多个`case`标签：

```
private static SportType 
  fetchSportTypeByPlayerType(PlayerTypes playerType) {

  return switch (playerType) {
    case TENNIS, GOLF, SNOOKER ->
      new Individual();
    case FOOTBALL, VOLLEY ->  
      new Team();    
  };
}
```

因此，如果我们转移到此方法`TENNIS`，`GOLF`或`SNOOKER`，它将返回`Individual`类的实例。 如果我们通过`FOOTBALL`或`VOLLEY`，它将返回`Team`类的实例。

# 57.声明块

标签的箭头可以指向单个语句（如前两个问题的示例中）或者是一个卷曲的块。 这与 Lambda 块相当类似。 查看以下解决方案：

```
private static Player createPlayer(PlayerTypes playerType) {
  return switch (playerType) {
    case TENNIS -> {
      System.out.println("Creating a TennisPlayer ...");
      break new TennisPlayer();
    }
    case FOOTBALL -> {
      System.out.println("Creating a FootballPlayer ...");
      break new FootballPlayer();
    }
    case SNOOKER -> {
      System.out.println("Creating a SnookerPlayer ...");
      break new SnookerPlayer();
    }
    default ->
      throw new IllegalArgumentException(
        "Invalid player type: " + playerType);
  };
}
```

请注意，我们通过`break`从 CURLY-BRACED 块退出，而不是`return`。 换句话说，虽然我们可以从`switch`声明中，我们不能从表达式中`return`。

# 概括

这就是所有人！ 本章向您介绍了几个涉及对象，不变性和`switch`表达的问题。 虽然涵盖对象和不动态的问题代表了编程的基本概念，但涵盖了`switch`表达式的问题致力于引入解决此主题的新 JDK 12 功能。

从本章下载应用程序以查看结果并查看其他详细信息。