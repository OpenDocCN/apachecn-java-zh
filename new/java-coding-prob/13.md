# HTTP 客户端和 WebSocket API

本章包括 20 个涵盖 HTTP 客户端和 WebSocket API 的问题。

你还记得`HttpUrlConnection`？ 嗯，JDK 11 带有 HTTP 客户端 API 作为`HttpUrlConnection`的重塑。 HTTP 客户端 API 易于使用，并支持 HTTP / 2（默认）和 HTTP / 1.1。 为向后兼容性，当服务器不支持 HTTP / 2 时，HTTP 客户端 API 将自动从 HTTP / 2 到 HTTP 1.1 下调。 此外，HTTP 客户端 API 支持同步和异步编程模型，并依赖于传输数据（无功流）。 它还支持 WebSocket 协议，该协议用于实时 Web 应用程序，以提供与低消息开销的客户端服务器通信。

# 问题

使用以下问题来测试 HTTP 客户端和 WebSocket API 编程 Prowess。 我强烈建议您在转向解决方案并下载示例程序之前尝试举出每个问题：

250.  **http / 2** ：提供 http / 2 协议的简要概述
251.  **触发异步`GET`请求**：写一个使用 HTTP 客户端 API 来触发异步`GET`请求并显示响应代码和主体的程序。
252.  **设置代理**：写一个程序，该程序使用 HTTP 客户端 API 通过代理设置连接。
253.  **设置/获取标题**：写一个程序，该程序为请求添加其他标题并获取响应的标题。

254.  **指定 HTTP 方法**：写一个指定请求的 HTTP 方法的程序（例如，`GET`，`POST`，`PUT`和`DELETE`）。
255.  **设置请求主体**：写一个使用 HTTP 客户端 API 的程序将正文添加到请求。
256.  **设置连接身份验证**：编写一个程序，该程序使用 HTTP 客户端 API 通过用户名和密码设置连接身份验证。
257.  **设置超时**：编写一个程序，该程序使用 HTTP 客户端 API 设置要等待响应的时间量（超时）。
258.  **设置重定向策略**：写一个程序，该程序如果需要，使用 HTTP 客户端 API 自动重定向。
259.  **发送 SYNC 和 ASYNC 请求**：编写一个程序，该程序以同步和异步模式发送相同的请求。
260.  **处理 cookie** ：写一个使用 HTTP 客户端 API 来设置 Cookie Handler 的程序。
261.  **获取响应信息**：编写一个程序，该程序使用 HTTP 客户端 API 获取有关响应的信息（例如，URI，版本，标题，状态代码，正文等）。
262.  **处理响应正文类型**：写几个代码片段以举例说明如何通过`HttpResponse.BodyHandlers`处理公共响应正文类型。
263.  **获取，更新和保存 JSON** ：写一个使用 HTTP 客户端 API 来获取，更新和保存 JSON 的程序。
264.  **压缩**：写一个处理压缩响应的程序（例如，`.gzip`）。
265.  **处理表单数据**：写一个使用 HTTP 客户端 API 提交数据表单（`application/x-www-form-urlencoded`）的程序。
266.  **下载资源**：编写一个程序，该程序使用 HTTP 客户端 API 下载资源。
267.  **用 MultiPart** 上传：写一个使用 HTTP 客户端 API 来上载资源的程序。
268.  **HTTP / 2 服务器 PUSH** ：编写一个程序，该程序通过 HTTP 客户端 API 来介绍 HTTP / 2 服务器推送功能。
269.  **websocket** ：写一个打开与 websocket 端点的连接的程序，收集 10 秒钟，然后关闭连接。

# 解决方案

以下部分描述了前述问题的解决方案。 请记住，几乎不是一个正确的方法来解决特定问题。 此外，请记住，这里所示的解释仅包括解决问题所需的最有趣和重要细节。 您可以下载示例解决方案以查看其他详细信息并与 [https://github.com/packtpublishing/java-coding-problems 的程序进行实验](https://github.com/PacktPublishing/Java-Coding-Problems)。

# 250\. http / 2

**HTTP / 2** 是一种有效的协议，其基本上和可测量地改善 **HTTP / 1.1** 协议。

作为更大的图片的一部分， **HTTP / 2** 有两部分：

*   **框架**：这是 **http / 2** 复用核心能力
*   **数据层**：它包含数据（我们通常称为 HTTP 的数据）

下图描绘了 **http / 1.1** （顶部）和 **http / 2** （底部）的通信：

![](img/0ecf8f36-941b-4f96-8d50-01b5ea7f9b31.png)

**HTTP / 2** 被服务器和浏览器广泛采用，并且随着 **HTTP / 1.1** 的以下改进提供了以下内容：

*   **二进制协议**：更不可读的人类，但更多机器友好， **HTTP / 2** *框架*是二进制帧协议。
*   **多路复用**：这是指交织的请求和响应。 多个请求在同一连接上同时运行。
*   **服务器推送**：服务器可以决定向客户端发送其他资源。
*   **与服务器**的单个连接： **http / 2** 使用每个原点（域）的单个通信线（TCP 连接）。
*   **报头压缩**： **HTTP / 2** 依赖于 HPack 压缩以减少标题。 这对冗余字节产生了重大影响。
*   **加密**：通过电线传输的大多数数据被加密。

# 251.触发异步 GET 请求

触发异步`GET`请求是三步作业，如下所示：

1.  创建一个新的`HttpClient`对象（`java.net.http.HttpClient`）：

```
HttpClient client = HttpClient.newHttpClient();
```

2.  构建`HttpRequest`对象（`java.net.http.HttpRequest`）并指定请求（默认情况下，这是一个`GET`请求）：

```
HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();
```

要设置 URI，我们可以调用`HttpRequest.newBuilder(URI)`构造函数或在`Builder`实例上调用`uri(URI)`方法（如之前所做的）。

3.  触发请求并等待响应（`java.net.http.HttpResponse`）。 作为同步请求，应用程序将阻止，直到响应可用：

```
HttpResponse<String> response 
  = client.send(request, BodyHandlers.ofString());
```

如果我们对这三个步骤进行了组并添加了在控制台上显示响应代码和正文的行，则获取以下代码：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();

HttpResponse<String> response 
  = client.send(request, BodyHandlers.ofString());

System.out.println("Status code: " + response.statusCode());
System.out.println("\n Body: " + response.body());
```

前面代码的一个可能的输出如下：

```
Status code: 200
Body:
{
  "data": {
    "id": 2,
    "email": "janet.weaver@reqres.in",
    "first_name": "Janet",
    "last_name": "Weaver",
    "avatar": "https://s3.amazonaws.com/..."
 }
}
```

默认情况下，此请求使用 HTTP / 2 进行。 但是，我们也可以通过`HttpRequest.Builder.version()`显式设置版本。 此方法获取`HttpClient.Version`类型的参数，该参数是暴露两​​个常量的`enum`数据类型：`HTTP_2`和`HTTP_1_1`。 以下是明确降级到 HTTP / 1.1 的示例：

```
HttpRequest request = HttpRequest.newBuilder()
  .version(HttpClient.Version.HTTP_1_1)
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();
```

`HttpClient`的默认设置如下：

*   http / 2
*   没有身份验证者
*   没有连接超时
*   没有 cookie 处理程序
*   默认线程池执行器
*   `NEVER`的重定向策略
*   默认代理选择器
*   默认 SSL 上下文

我们将查看下一节中的查询参数构建器。

# 查询参数构建器

使用包含查询参数的 URI 暗示编码这些参数。 用于完成此任务的 Java 内置方法是`URLEncoder.encode()`。 但是，连接和编码几个查询参数导致类似于以下内容的某些内容：

```
URI uri = URI.create("http://localhost:8080/books?name=" +
  URLEncoder.encode("Games & Fun!", StandardCharsets.UTF_8) +
  "&no=" + URLEncoder.encode("124#442#000", StandardCharsets.UTF_8) +
  "&price=" + URLEncoder.encode("$23.99", StandardCharsets.UTF_8)
);
```

当我们必须使用大量查询参数时，此解决方案不是很方便。 但是，我们可以尝试编写一个帮助方法来隐藏在查询参数集合中的循环中的`URLEncoder.encode()`方法，或者我们可以依赖于 URI 构建器。

在春天，URI Builder 是`org.springframework.web.util.UriComponentsBuilder`。 以下代码是不言自明的：

```
URI uri = UriComponentsBuilder.newInstance()
  .scheme("http")
  .host("localhost")
  .port(8080)
  .path("books")
  .queryParam("name", "Games & Fun!")
  .queryParam("no", "124#442#000")
  .queryParam("price", "$23.99")
  .build()
  .toUri();
```

在非春天应用程序中，我们可以依靠 URI 构建器，例如`urlbuilder`库（ [https://github.com/mikaelhg/urlbuilder](https://github.com/mikaelhg/urlbuilder) ）。 与本书捆绑在一起的代码包含使用此示例。

# 252.设置代理

要设置代理，我们依赖于`Builder`方法的`HttpClient.proxy()`方法。 `proxy()`方法获取`ProxySelector`类型的参数，该参数可以是系统范围的代理选择器（通过`getDefault()`）或通过其地址指向的代理选择器（通过`InetSocketAddress`）。

让我们假设我们在`proxy.host:80`地址有代理。 我们可以如下设置此代理：

```
HttpClient client = HttpClient.newBuilder()
  .proxy(ProxySelector.of(new InetSocketAddress("proxy.host", 80)))
  .build();
```

或者，我们可以设置系统范围的代理选择器，如下所示：

```
HttpClient client = HttpClient.newBuilder()
  .proxy(ProxySelector.getDefault())
  .build();
```

# 253.设置/获取标题

`HttpRequest`和`HttpResponse`公开了一套使用标题的方法。 我们将在即将到来的部分中了解这些方法。

# 设置请求标题

`HttpRequest.Builder`类使用三种方法来设置其他标题：

*   `header​(String name, String value)`和`setHeader​(String name, String value)`：这些用于将标题逐个添加，如下代码所示：

```
HttpRequest request = HttpRequest.newBuilder()
  .uri(...)
  ...
  .header("key_1", "value_1")
  .header("key_2", "value_2")
  ...
  .build();

HttpRequest request = HttpRequest.newBuilder()
  .uri(...)
  ...
  .setHeader("key_1", "value_1")
  .setHeader("key_2", "value_2")
  ...
  .build();
```

`header()`和`setHeader()`之间的差异是前者在后者设置指定的标题时添加指定的标题。 换句话说，`header()`将给定值添加到该名称/键的值列表中，而`setHeader()`覆盖该名称/键的任何先前设置的值。

*   `headers​(String... headers)`：这用于添加由逗号分隔的标题，如以下代码所示：

```
HttpRequest request = HttpRequest.newBuilder()
  .uri(...)
  ...
  .headers("key_1", "value_1", "key_2",
    "value_2", "key_3", "value_3", ...)
  ...
  .build();
```

例如，可以将`Content-Type: application/json`和`Referer: https://reqres.in/`报头添加到由`https://reqres.in/api/users/2` URI 触发的请求中，如下所示：

```
HttpRequest request = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .header("Referer", "https://reqres.in/")
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();
```

您还可以执行以下操作：

```
HttpRequest request = HttpRequest.newBuilder()
  .setHeader("Content-Type", "application/json")
  .setHeader("Referer", "https://reqres.in/")
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();
```

最后，你可以做这样的事情：

```
HttpRequest request = HttpRequest.newBuilder()
  .headers("Content-Type", "application/json",
    "Referer", "https://reqres.in/")
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();
```

根据目标，可以组合所有三种方法以指定请求标头。

# 获取请求/响应标题

可以使用`HttpRequest.headers()`方法完成请求标头。 `HttpResponse`中存在类似的方法来获取响应的标题。 这两种方法都返回`HttpHeaders`对象。

这两种方法都可以以相同的方式使用，因此让我们专注于获取响应标题。 我们可以得到这样的标题：

```
HttpResponse<...> response ...
HttpHeaders allHeaders = response.headers();
```

可以使用`HttpHeaders.allValues()`完成标题的所有值，如下所示：

```
List<String> allValuesOfCacheControl
  = response.headers().allValues("Cache-Control");
```

只使用`HttpHeaders.firstValue()`只能完成标题的第一个值，如下所示：

```
Optional<String> firstValueOfCacheControl
  = response.headers().firstValue("Cache-Control");
```

如果标题的返回值是`Long`，则依靠`HttpHeaders.firstValueAsLong()`。 此方法获取表示标题名称的参数并返回`Optional<Long>`。 如果指定标题的值不能被解析为`Long`，则将抛出`NumberFormatException`。

# 254.指定 HTTP 方法

我们可以使用`HttpRequest.Builder`使用以下方法指示我们的请求所用的 HTTP 方法：

*   `GET()`：此方法使用 HTTP `GET`方法发送请求，如下示例所示：

```
HttpRequest requestGet = HttpRequest.newBuilder()
  .GET() // can be omitted since it is default
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();
```

*   `POST()`：此方法使用 HTTP `POST`方法发送请求，如下示例所示：

```
HttpRequest requestPost = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .POST(HttpRequest.BodyPublishers.ofString(
    "{\"name\": \"morpheus\",\"job\": \"leader\"}"))
  .uri(URI.create("https://reqres.in/api/users"))
  .build();
```

*   `PUT()`：此方法使用 HTTP `PUT`方法发送请求，如下示例所示：

```
HttpRequest requestPut = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .PUT(HttpRequest.BodyPublishers.ofString(
    "{\"name\": \"morpheus\",\"job\": \"zion resident\"}"))
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();
```

*   `DELETE()`：此方法使用 HTTP `DELETE`方法发送请求，如下示例所示：

```
HttpRequest requestDelete = HttpRequest.newBuilder()
  .DELETE()
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();
```

客户端可以处理所有类型的 HTTP 方法，不仅是预定义的方法（`GET`，`POST`，`PUT`和`DELETE`）。 要使用不同的 HTTP 方法创建请求，我们只需要调用`method()`。

以下解决方案触发 HTTP `PATCH`请求：

```
HttpRequest requestPatch = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .method("PATCH", HttpRequest.BodyPublishers.ofString(
    "{\"name\": \"morpheus\",\"job\": \"zion resident\"}"))
  .uri(URI.create("https://reqres.in/api/users/1"))
  .build();
```

无需请求正文时，我们可以依赖`BodyPublishers.noBody()`。 以下解决方案使用`noBody()`方法触发 HTTP `HEAD`请求：

```
HttpRequest requestHead = HttpRequest.newBuilder()
  .method("HEAD", HttpRequest.BodyPublishers.noBody())
  .uri(URI.create("https://reqres.in/api/users/1"))
  .build();
```

在多个类似的请求的情况下，我们可以依靠`copy()`方法复制构建器，如以下代码片段所示：

```
HttpRequest.Builder builder = HttpRequest.newBuilder()
  .uri(URI.create("..."));

HttpRequest request1 = builder.copy().setHeader("...", "...").build();
HttpRequest request2 = builder.copy().setHeader("...", "...").build();
```

# 255.设置请求机构

设置请求主体可以使用`HttpRequest.Builder.POST()`和`HttpRequest.Builder.PUT()`或使用`method()`（例如，`method("PATCH", HttpRequest.BodyPublisher)`）完成。 `POST()`和`PUT()`涉及`HttpRequest.BodyPublisher`类型的参数。 API 在`HttpRequest.BodyPublishers`类中具有此接口（`BodyPublisher`）的多个实现，如下所示：

*   `BodyPublishers.ofString()`
*   `BodyPublishers.ofFile()`
*   `BodyPublishers.ofByteArray()`
*   `BodyPublishers.ofInputStream()`

我们将在以下部分中查看这些实现。

# 从字符串创建一个正文

可以使用`BodyPublishers.ofString()`从字符串中创建一个正文，如以下代码片段所示：

```
HttpRequest requestBody = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .POST(HttpRequest.BodyPublishers.ofString(
    "{\"name\": \"morpheus\",\"job\": \"leader\"}"))
  .uri(URI.create("https://reqres.in/api/users"))
  .build();
```

要指定`charset`呼叫，请使用`ofString(String s, Charset charset)`。

# 从 InputStream 创建一个正文

从`InputStream`创建一个主体可以使用`BodyPublishers.ofInputStream()`完成，如以下代码片段（这里，我们依赖于`ByteArrayInputStream`，但当然，任何其他`InputStream`是合适的）：

```
HttpRequest requestBodyOfInputStream = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .POST(HttpRequest.BodyPublishers.ofInputStream(()
    -> inputStream("user.json")))
  .uri(URI.create("https://reqres.in/api/users"))
  .build();

private static ByteArrayInputStream inputStream(String fileName) {

  try (ByteArrayInputStream inputStream = new ByteArrayInputStream(
    Files.readAllBytes(Path.of(fileName)))) {

    return inputStream;
  } catch (IOException ex) {
    throw new RuntimeException("File could not be read", ex);
  }
}
```

为了利用懒惰创建，`InputStream`必须作为`Supplier`传递。

# 从字节数组创建一个正文

可以使用`BodyPublishers.ofByteArray()`从字节阵列中创建一个主体，如以下代码片段所示：

```
HttpRequest requestBodyOfByteArray = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .POST(HttpRequest.BodyPublishers.ofByteArray(
    Files.readAllBytes(Path.of("user.json"))))
  .uri(URI.create("https://reqres.in/api/users"))
  .build();
```

我们还可以仅使用`ofByteArray(byte[] buf, int offset, int length)`仅发送字节数组的一部分。 此外，我们可以使用`ofByteArrays(Iterable<byte[]> iter)`提供字节阵列的`Iterable`的数据。

# 从文件创建一个正文

可以使用`BodyPublishers.ofFile()`从文件中创建正文，如以下代码片段所示：

```
HttpRequest requestBodyOfFile = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .POST(HttpRequest.BodyPublishers.ofFile(Path.of("user.json")))
  .uri(URI.create("https://reqres.in/api/users"))
  .build();
```

# 256.设置连接身份验证

通常，使用用户名和密码完成对服务器的身份验证。 在代码表单中，这可以通过使用`Authenticator`类（这会协商 HTTP 身份验证的凭据）和`PasswordAuthentication`类（用户名和密码的持有者）一起完成，如下所示：

```
HttpClient client = HttpClient.newBuilder()
  .authenticator(new Authenticator() {

    @Override
    protected PasswordAuthentication getPasswordAuthentication() {

      return new PasswordAuthentication(
        "username",
        "password".toCharArray());
    }
  })
  .build();
```

此外，客户端可用于发送请求：

```
HttpRequest request = HttpRequest.newBuilder()
  ...
  .build();

HttpResponse<String> response
  = client.send(request, HttpResponse.BodyHandlers.ofString());
```

`Authenticator` supports different authentication schemes (for example, *basic* or *digest* authentication).

另一种解决方案包括在标题中添加凭据，如下所示：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .header("Authorization", basicAuth("username", "password"))
  ...
  .build();

HttpResponse<String> response 
  = client.send(request, HttpResponse.BodyHandlers.ofString());

private static String basicAuth(String username, String password) {
  return "Basic " + Base64.getEncoder().encodeToString(
    (username + ":" + password).getBytes());
}
```

在`Bearer`身份验证（HTTP 持票人令牌）的情况下，我们执行以下操作：

```
HttpRequest request = HttpRequest.newBuilder()
  .header("Authorization", 
          "Bearer mT8JNMyWCG0D7waCHkyxo0Hm80YBqelv5SBL")
  .uri(URI.create("https://gorest.co.in/public-api/users"))
  .build();
```

我们也可以在`POST`请求的主体中这样做：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .POST(BodyPublishers.ofString("{\"email\":\"eve.holt@reqres.in\",
    \"password\":\"cityslicka\"}"))
  .uri(URI.create("https://reqres.in/api/login"))
  .build();

HttpResponse<String> response 
  = client.send(request, HttpResponse.BodyHandlers.ofString());
```

不同的请求可以使用不同的凭据。 此外，`Authenticator`提供了一套方法（例如，`getRequestingSite()`），如果我们希望了解应该提供哪些值。 在生产中，应用程序不应以明文提供凭证，就像他们在这些例子中一样。

# 257.设置超时

默认情况下，请求没有超时（无限超时）。 要设置要等待响应的时间（超时），我们可以调用`HttpRequest.Builder.timeout()`方法。 此方法获取`Duration`类型的参数，可以使用如此：

```
HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("https://reqres.in/api/users/2"))
  .timeout(Duration.of(5, ChronoUnit.MILLIS))
  .build();
```

如果指定的超时时间过，则将抛出`java.net.http.HttpConnectTimeoutException`。

# 258.设置重定向策略

当我们尝试访问移动到其他 URI 的资源时，服务器将在`3xx`范围内返回 HTTP 状态代码，以及有关新 URI 的信息。 浏览器是一种能够自动发送另一个请求到新的位置时，他们接收重定向响应（`301`，`302`，`303`，`307`和`308`）。

如果我们通过`followRedirects()`显式设置重定向策略，则 HTTP 客户端 API 可以自动重定向到此新 URI，如下所示：

```
HttpClient client = HttpClient.newBuilder()
  .followRedirects(HttpClient.Redirect.ALWAYS)
  .build();
```

从不重定向，只需将`HttpClient.Redirect.NEVER`常量提供给`followRedirects()`（这是默认值）。

要始终重定向，除了从 HTTPS URL 到 HTTP URL 之外，只需将`HttpClient.Redirect.NORMAL`常量提供给`followRedirects()`。

当重定向策略未设置为`ALWAYS`时，应用程序负责处理重定向。 通常，这是通过读取 HTTP `Location`标题的新地址来实现的，如下所示（如果返回的状态代码是`301`（永久移动）或`308`（永久重定向），则只对重定向感兴趣 ）：

```
int sc = response.statusCode();

if (sc == 301 || sc == 308) { // use an enum for HTTP response codes
  String newLocation = response.headers()
    .firstValue("Location").orElse("");

  // handle the redirection to newLocation
}
```

通过将请求 URI 与响应 URI 进行比较，可以轻松检测到重定向。 如果它们不一样，则发生重定向：

```
if (!request.uri().equals(response.uri())) {
  System.out.println("The request was redirected to: " 
    + response.uri());
}
```

# 259.发送 SYNC 和 ASYNC 请求

可以使用`HttpClient`的以下两种方法向服务器发送请求：

*   `send()`：此方法同步发送请求（直到响应可用或发生超时）
*   `sendAsync()`：此方法异步发送请求（非阻塞）

我们将解释我们可以在下一节中发送请求的不同方式。

# 同步发送请求

我们已经在以前的问题中完成了这一点，因此我们将为您提供快速的余数，如下：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();

HttpResponse<String> response 
  = client.send(request, HttpResponse.BodyHandlers.ofString());
```

# 异步发送请求

为了异步发送请求，HTTP 客户端 API 依赖于`CompletableFeature`，如[第 11 章](11.html)，*并发 - 深潜水*和`sendAsync()`方法所讨论的，如下所示：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();

client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
  .thenApply(HttpResponse::body)
  .exceptionally(e -> "Exception: " + e)
  .thenAccept(System.out::println)
  .get(30, TimeUnit.SECONDS); // or join()
```

或者，让我们假设等待响应，我们也希望执行其他任务：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();

CompletableFuture<String> response
    = client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
  .thenApply(HttpResponse::body)
  .exceptionally(e -> "Exception: " + e);

while (!response.isDone()) {
  Thread.sleep(50);
  System.out.println("Perform other tasks 
    while waiting for the response ...");
}

String body = response.get(30, TimeUnit.SECONDS); // or join()
System.out.println("Body: " + body);
```

# 同时发送多个请求

我们如何同时发送多个请求，并等待可用的所有响应？

如我们所知，`CompletableFuture`附带`allOf()`方法（有关详细信息，请读取[第 11 章](11.html)，*并发 - 深潜水*），可以并行执行任务并等待 所有这些都完成。 `CompletableFuture<Void>`返回。

以下代码等待对四个请求的响应：

```
List<URI> uris = Arrays.asList(
  new URI("https://reqres.in/api/users/2"),      // one user
  new URI("https://reqres.in/api/users?page=2"), // list of users
  new URI("https://reqres.in/api/unknown/2"),    // list of resources
  new URI("https://reqres.in/api/users/23"));    // user not found

HttpClient client = HttpClient.newHttpClient();

List<HttpRequest> requests = uris.stream()
  .map(HttpRequest::newBuilder)
  .map(reqBuilder -> reqBuilder.build())
  .collect(Collectors.toList());

CompletableFuture.allOf(requests.stream()
  .map(req -> client.sendAsync(
     req, HttpResponse.BodyHandlers.ofString())
  .thenApply((res) -> res.uri() + " | " + res.body() + "\n")
  .exceptionally(e -> "Exception: " + e)
  .thenAccept(System.out::println))
  .toArray(CompletableFuture<?>[]::new))
  .join();
```

要收集响应的主体（例如，在`List<String>`）中，请考虑`WaitAllResponsesFetchBodiesInList`类，该类可用于本书捆绑在一起的代码中。

使用自定义`Executor`对象可以如下完成：

```
ExecutorService executor = Executors.newFixedThreadPool(5);

HttpClient client = HttpClient.newBuilder()
  .executor(executor)
  .build();
```

# 260.处理饼干

默认情况下，JDK 11 的 HTTP 客户端支持 Cookie，但有禁用内置支持的实例。 我们可以按如下方式启用：

```
HttpClient client = HttpClient.newBuilder()
  .cookieHandler(new CookieManager())
  .build();
```

因此，HTTP 客户端 API 允许我们使用`HttpClient.Builder.cookieHandler()`方法设置 cookie 处理程序。 此方法获取`CookieManager`类型的参数。

以下解决方案设置了不接受 cookie 的`CookieManager`：

```
HttpClient client = HttpClient.newBuilder()
  .cookieHandler(new CookieManager(null, CookiePolicy.ACCEPT_NONE))
  .build();
```

对于接受 cookie，将`CookiePolicy`设置为`ALL`（接受所有 cookie）或`ACCEPT_ORIGINAL_SERVER`（仅从原始服务器接受 cookie）。

以下解决方案接受所有 cookie 并在控制台中显示它们（如果任何凭据被报告为无效，则考虑从 [https://gorest.co.in/rest-console.html](https://gorest.co.in/rest-console.html) 中获取新令牌 ：

```
CookieManager cm = new CookieManager();
cm.setCookiePolicy(CookiePolicy.ACCEPT_ALL);

HttpClient client = HttpClient.newBuilder()
  .cookieHandler(cm)
  .build();

HttpRequest request = HttpRequest.newBuilder()
  .header("Authorization", 
          "Bearer mT8JNMyWCG0D7waCHkyxo0Hm80YBqelv5SBL")
  .uri(URI.create("https://gorest.co.in/public-api/users/1"))
  .build();

HttpResponse<String> response
  = client.send(request, HttpResponse.BodyHandlers.ofString());

System.out.println("Status code: " + response.statusCode());
System.out.println("\n Body: " + response.body());

CookieStore cookieStore = cm.getCookieStore();
System.out.println("\nCookies: " + cookieStore.getCookies());
```

检查`set-cookie`标题可以如下完成：

```
Optional<String> setcookie 
  = response.headers().firstValue("set-cookie");
```

# 261.获取回复信息

为了获取有关响应的信息，我们可以依赖于`HttpResponse`类的方法。 这些方法的名称非常直观; 因此，以下代码片段是不言自明的：

```
...
HttpResponse<String> response
  = client.send(request, HttpResponse.BodyHandlers.ofString());

System.out.println("Version: " + response.version());
System.out.println("\nURI: " + response.uri());
System.out.println("\nStatus code: " + response.statusCode());
System.out.println("\nHeaders: " + response.headers());
System.out.println("\n Body: " + response.body());
```

考虑探索文档以查找更有用的方法。

# 262.处理响应身体类型

可以使用`HttpResponse.BodyHandler`完成处理响应体类型。 API 附带了`HttpResponse.BodyHandlers`类中此接口（`BodyHandler`）的几种实现，如下所示：

*   `BodyHandlers.ofByteArray()`
*   `BodyHandlers.ofFile()`
*   `BodyHandlers.ofString()`
*   `BodyHandlers.ofInputStream()`
*   `BodyHandlers.ofLines()`

考虑以下要求，让我们来看看处理响应机构的几个解决方案：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();
```

我们将查看如何在以下部分中处理不同类型的响应机构。

# 处理响应身体作为字符串

处理身体响应作为字符串可以使用`BodyHandlers.ofString()`完成，如以下代码片段所示：

```
HttpResponse<String> responseOfString
  = client.send(request, HttpResponse.BodyHandlers.ofString());

System.out.println("Status code: " + responseOfString.statusCode());
System.out.println("Body: " + responseOfString.body());
```

要指定`charset`，请调用`ofString(String s, Charset charset)`。

# 处理响应身体作为文件

处理身体响应作为文件可以使用`BodyHandlers.ofFile()`完成，如以下代码片段所示：

```
HttpResponse<Path> responseOfFile = client.send(
  request, HttpResponse.BodyHandlers.ofFile(
    Path.of("response.json")));

System.out.println("Status code: " + responseOfFile.statusCode());
System.out.println("Body: " + responseOfFile.body());
```

要指定打开选项，请调用`ofFile(Path file, OpenOption... openOptions)`。

# 处理响应主体作为字节数组

可以使用`BodyHandlers.ofByteArray()`完成作为字节阵列的处理身体响应，如以下代码片段所示：

```
HttpResponse<byte[]> responseOfByteArray = client.send(
  request, HttpResponse.BodyHandlers.ofByteArray());

System.out.println("Status code: " 
  + responseOfByteArray.statusCode());
System.out.println("Body: "
  + new String(responseOfByteArray.body()));
```

要消耗字节数组，请调用`ofByteArrayConsumer(Consumer<Optional<byte[]>> consumer)`。

# 处理响应身体作为输入流

可以使用`BodyHandlers.ofInputStream()`来完成作为`InputStream`的身体响应，如以下代码片段所示：

```
HttpResponse<InputStream> responseOfInputStream = client.send(
  request, HttpResponse.BodyHandlers.ofInputStream());

System.out.println("\nHttpResponse.BodyHandlers.ofInputStream():");
System.out.println("Status code: " 
  + responseOfInputStream.statusCode());

byte[] allBytes;
try (InputStream fromIs = responseOfInputStream.body()) {
  allBytes = fromIs.readAllBytes();
}

System.out.println("Body: "
  + new String(allBytes, StandardCharsets.UTF_8));
```

# 处理响应身体作为字符串流

可以使用`BodyHandlers.ofLines()`来完成作为字符串流的处理身体响应，如以下代码片段中所示：

```
HttpResponse<Stream<String>> responseOfLines = client.send(
  request, HttpResponse.BodyHandlers.ofLines());

System.out.println("Status code: " + responseOfLines.statusCode());
System.out.println("Body: " 
  + responseOfLines.body().collect(toList()));
```

# 263.获取，更新和保存 JSON

在以前的问题中，我们将 JSON 数据操作为明文（字符串）。 HTTP 客户端 API 无法为 JSON 数据提供特殊或专用支持，并将这种数据视为任何其他字符串。

然而，我们用于将 JSON 数据表示为 Java 对象（PO​​JOS），并在需要时依赖 JSON 和 Java 之间的转换。 我们可以在不涉及 HTTP 客户端 API 的情况下为我们的问题提供解决方案。 但是，我们还可以使用依赖于 JSON 解析器的自定义实现来编写一个解决方案，以将响应转换为 Java 对象。 例如，我们可以依赖于 JSON-B（在[中引入第 6 章](06.html)， *Java I / O 路径，文件，缓冲区，扫描和格式*）。

实现`HttpResponse.BodyHandler`界面意味着覆盖`apply(HttpResponse.ResponseInfo responseInfo)`方法。 使用此方法，我们可以从响应中获取字节并将其转换为 Java 对象。 代码如下：

```
public class JsonBodyHandler<T> 
    implements HttpResponse.BodyHandler<T> {

  private final Jsonb jsonb;
  private final Class<T> type;

  private JsonBodyHandler(Jsonb jsonb, Class<T> type) {
    this.jsonb = jsonb;
    this.type = type;
  }

  public static <T> JsonBodyHandler<T> 
      jsonBodyHandler(Class<T> type) {
    return jsonBodyHandler(JsonbBuilder.create(), type);
  }

  public static <T> JsonBodyHandler<T> jsonBodyHandler(
      Jsonb jsonb, Class<T> type) {
    return new JsonBodyHandler<>(jsonb, type);
  }

  @Override
  public HttpResponse.BodySubscriber<T> apply(
    HttpResponse.ResponseInfo responseInfo) {

    return BodySubscribers.mapping(BodySubscribers.ofByteArray(),
      byteArray -> this.jsonb.fromJson(
        new ByteArrayInputStream(byteArray), this.type));
  }
}
```

让我们假设我们想要操纵的 JSON 看起来如下所示（这是服务器的响应）：

```
{
  "data": {
    "id": 2,
    "email": "janet.weaver@reqres.in",
    "first_name": "Janet",
    "last_name": "Weaver",
    "avatar": "https://s3.amazonaws.com/..."
  }
}
```

表示此 JSON 的 Java 对象如下：

```
public class User {

  private Data data;
  private String updatedAt;

  // getters, setters and toString()
}

public class Data {

  private Integer id;
  private String email;

  @JsonbProperty("first_name")
  private String firstName;

  @JsonbProperty("last_name")
  private String lastName;

  private String avatar;

  // getters, setters and toString()
}
```

现在，让我们看看我们如何在请求和响应中操纵 JSON。

# json 对用户的回应

以下解决方案触发 A `GET`请求并将返回的 JSON 响应转换为`User`：

```
Jsonb jsonb = JsonbBuilder.create();
HttpClient client = HttpClient.newHttpClient();

HttpRequest requestGet = HttpRequest.newBuilder()
  .uri(URI.create("https://reqres.in/api/users/2"))
  .build();

HttpResponse<User> responseGet = client.send(
  requestGet, JsonBodyHandler.jsonBodyHandler(jsonb, User.class));

User user = responseGet.body();
```

# 更新用户到 JSON 请求

以下解决方案更新了我们在前一个子部分中获取的用户的电子邮件地址：

```
user.getData().setEmail("newemail@gmail.com");

HttpRequest requestPut = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .uri(URI.create("https://reqres.in/api/users"))
  .PUT(HttpRequest.BodyPublishers.ofString(jsonb.toJson(user)))
  .build();

HttpResponse<User> responsePut = client.send(
  requestPut, JsonBodyHandler.jsonBodyHandler(jsonb, User.class));

User updatedUser = responsePut.body();
```

# 新用户到 JSON 请求

以下解决方案创建一个新用户（响应状态代码应该是`201`）：

```
Data data = new Data();
data.setId(10);
data.setFirstName("John");
data.setLastName("Year");
data.setAvatar("https://johnyear.com/jy.png");

User newUser = new User();
newUser.setData(data);

HttpRequest requestPost = HttpRequest.newBuilder()
  .header("Content-Type", "application/json")
  .uri(URI.create("https://reqres.in/api/users"))
  .POST(HttpRequest.BodyPublishers.ofString(jsonb.toJson(user)))
  .build();

HttpResponse<Void> responsePost = client.send(
  requestPost, HttpResponse.BodyHandlers.discarding());

int sc = responsePost.statusCode(); // 201
```

请注意，我们通过`HttpResponse.BodyHandlers.discarding()`忽略任何响应正文。

# 264.压制

在服务器上启用`.gzip`压缩是一个常见的做法，这意味着显着提高了站点的负载时间。 但 JDK 11 的 HTTP 客户端 API 不利用`.gzip`压缩。 换句话说，HTTP 客户端 API 不需要压缩响应，并且不知道如何处理此类响应。

要请求压缩响应，我们必须使用`.gzip`值发送`Accept-Encoding`标题。 HTTP 客户端 API 未添加此标题，因此我们将添加如下：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .header("Accept-Encoding", "gzip")
  .uri(URI.create("https://davidwalsh.name"))
  .build();
```

这只是工作的一半。 到目前为止，如果在服务器上启用了`gzip`编码，则我们将收到压缩响应。 要检测是否压缩响应是否被压缩，我们必须检查`Encoding`标题，如下所示：

```
HttpResponse<InputStream> response = client.send(
  request, HttpResponse.BodyHandlers.ofInputStream());

String encoding = response.headers()
  .firstValue("Content-Encoding").orElse("");

if ("gzip".equals(encoding)) {
  String gzipAsString = gZipToString(response.body());
  System.out.println(gzipAsString);
} else {
  String isAsString = isToString(response.body());
  System.out.println(isAsString);
}
```

`gZipToString()`方法是一种辅助方法，其需要`InputStream`并将其视为`GZIPInputStream`。 换句话说，此方法从给定的输入流中读取字节，并使用它们创建字符串：

```
public static String gzipToString(InputStream gzip) 
    throws IOException {

  byte[] allBytes;
  try (InputStream fromIs = new GZIPInputStream(gzip)) {
    allBytes = fromIs.readAllBytes();
  }

  return new String(allBytes, StandardCharsets.UTF_8);
}
```

如果响应未被压缩，则`isToString()`是我们需要的辅助方法：

```
public static String isToString(InputStream is) throws IOException {

  byte[] allBytes;
  try (InputStream fromIs = is) {
    allBytes = fromIs.readAllBytes();
  }

  return new String(allBytes, StandardCharsets.UTF_8);
}
```

# 265.处理表单数据

JDK 11 的 HTTP 客户端 API 并没有内置支持，用于触发`x-www-form-urlencoded`的`POST`请求。 解决此问题的解决方案是依赖于自定义`BodyPublisher`类。

如果我们考虑以下内容，写一个自定义`BodyPublisher`类很简单：

*   数据表示为键值对
*   每对是`key = value`类型
*   通过`&`字符分离对
*   应正确编码键和值

由于数据表示为键值对，因此存储在`Map`中非常方便。 此外，我们只是循环这一个`Map`并应用前面的信息，如下所示：

```
public class FormBodyPublisher {

  public static HttpRequest.BodyPublisher ofForm(
      Map<Object, Object> data) {

    StringBuilder body = new StringBuilder();

    for (Object dataKey: data.keySet()) {
      if (body.length() > 0) {
        body.append("&");
      }

      body.append(encode(dataKey))
        .append("=")
        .append(encode(data.get(dataKey)));
    }

    return HttpRequest.BodyPublishers.ofString(body.toString());
  }

  private static String encode(Object obj) {
    return URLEncoder.encode(obj.toString(), StandardCharsets.UTF_8);
  }
}
```

依赖此解决方案，可以如下触发`POST`（`x-www-form-urlencoded`）请求：

```
Map<Object, Object> data = new HashMap<>();
data.put("firstname", "John");
data.put("lastname", "Year");
data.put("age", 54);
data.put("avatar", "https://avatars.com/johnyear");

HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .header("Content-Type", "application/x-www-form-urlencoded")
  .uri(URI.create("http://jkorpela.fi/cgi-bin/echo.cgi"))
  .POST(FormBodyPublisher.ofForm(data))
  .build();

HttpResponse<String> response = client.send(
  request, HttpResponse.BodyHandlers.ofString());
```

在这种情况下，响应只是发送数据的回声。 根据服务器的响应，应用程序需要处理它，如*处理响应正文类型*部分所示。

# 266.下载资源

正如我们在*中看到的，设置请求主体*和*处理响应正文类型*部分，HTTP 客户端 API 可以发送和接收文本和二进制数据（例如，图像，视频等 上）。

下载文件依赖于以下两个坐标：

*   发送`GET`请求
*   处理接收的字节（例如，通过`BodyHandlers.ofFile()`）

以下代码从项目类路径中的 Maven 存储库下载`hibernate-core-5.4.2.Final.jar`：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("http://.../hibernate-core-5.4.2.Final.jar"))
  .build();

HttpResponse<Path> response 
  = client.send(request, HttpResponse.BodyHandlers.ofFile(
    Path.of("hibernate-core-5.4.2.Final.jar")));
```

如果通过`Content-Disposition` HTTP 标头来提供下载资源，那么我们可以依赖于`BodyHandlers.ofFileDownload()`，如下例所示：

```
import static java.nio.file.StandardOpenOption.CREATE;
...
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("http://...downloadfile.php
    ?file=Hello.txt&cd=attachment+filename"))
  .build();

HttpResponse<Path> response = client.send(request,
  HttpResponse.BodyHandlers.ofFileDownload(Path.of(
    System.getProperty("user.dir")), CREATE));
```

这里可以使用的更多文件： [http://demo.borland.com/testsite/download_testpage.php](http://demo.borland.com/testsite/download_testpage.php) 。

# 267.上传用多部分

正如我们在*中看到的*设置请求主体*部分，我们可以通过`BodyPublishers.ofFile()`和`POST`请求向服务器发送文件（文本或二进制）。*

但是发送经典上载请求可能涉及用`Content-Type`作为`multipart/form-data`的多级形式`POST`。

在这种情况下，请求主体由边界分隔的部分制成，如下图所示（`--779d334bbfa...`是边界）：

![](img/9309ddab-3151-46f3-88d8-46a357b1e531.png)

但是，JDK 11 的 HTTP 客户端 API 并不提供用于构建此类请求主体的内置支持。 尽管如此，通过遵循前面的屏幕截图，我们可以定义自定义`BodyPublisher`，如下所示：

```
public class MultipartBodyPublisher {

  private static final String LINE_SEPARATOR = System.lineSeparator();

  public static HttpRequest.BodyPublisher ofMultipart(
    Map<Object, Object> data, String boundary) throws IOException {

    final byte[] separator = ("--" + boundary +
      LINE_SEPARATOR + "Content-Disposition: form-data;
      name = ").getBytes(StandardCharsets.UTF_8);

      final List<byte[] > body = new ArrayList<>();

      for (Object dataKey: data.keySet()) {

        body.add(separator);
        Object dataValue = data.get(dataKey);

        if (dataValue instanceof Path) {
          Path path = (Path) dataValue;
          String mimeType = fetchMimeType(path);

          body.add(("\"" + dataKey + "\"; filename=\"" +
            path.getFileName() + "\"" + LINE_SEPARATOR +
            "Content-Type: " + mimeType + LINE_SEPARATOR +
            LINE_SEPARATOR).getBytes(StandardCharsets.UTF_8));

          body.add(Files.readAllBytes(path));
          body.add(LINE_SEPARATOR.getBytes(StandardCharsets.UTF_8));
        } else {
          body.add(("\"" + dataKey + "\"" + LINE_SEPARATOR +
              LINE_SEPARATOR + dataValue + LINE_SEPARATOR)
                .getBytes(StandardCharsets.UTF_8));
        }
      }

      body.add(("--" + boundary 
        + "--").getBytes(StandardCharsets.UTF_8));

      return HttpRequest.BodyPublishers.ofByteArrays(body);
    }

    private static String fetchMimeType(
      Path filenamePath) throws IOException {

      String mimeType = Files.probeContentType(filenamePath);

      if (mimeType == null) {
        throw new IOException("Mime type could not be fetched");
      }

      return mimeType;
    }
  }
```

现在，我们可以创建多级请求，如下所示（我们尝试将一个名为`LoremIpsum.txt`的文本文件上传到简单地发送 RAW 表单数据的服务器）：

```
Map<Object, Object> data = new LinkedHashMap<>();
data.put("author", "Lorem Ipsum Generator");
data.put("filefield", Path.of("LoremIpsum.txt"));

String boundary = UUID.randomUUID().toString().replaceAll("-", "");

HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .header("Content-Type", "multipart/form-data;boundary=" + boundary)
  .POST(MultipartBodyPublisher.ofMultipart(data, boundary))
  .uri(URI.create("http://jkorpela.fi/cgi-bin/echoraw.cgi"))
  .build();

HttpResponse<String> response = client.send(
  request, HttpResponse.BodyHandlers.ofString());
```

响应应与以下相似（边界只是一个随机`UUID`）：

```
--7ea7a8311ada4804ab11d29bcdedcc55
Content-Disposition: form-data; name="author"
Lorem Ipsum Generator
--7ea7a8311ada4804ab11d29bcdedcc55
Content-Disposition: form-data; name="filefield"; filename="LoremIpsum.txt"
Content-Type: text/plain
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do 
eiusmod tempor incididunt ut labore et dolore magna aliqua.
--7ea7a8311ada4804ab11d29bcdedcc55--
```

# 268\. HTTP / 2 服务器推送

除了*复用*之外，HTTP / 2 的另一个强大功能是其*服务器推动*功能。

主要是，在传统方法（HTTP / 1.1）中，浏览器触发了获取 HTML 页面的请求并解析接收的标记以标识引用的资源（例如，JS，CSS，图像等）。 要获取这些资源，浏览器会发送其他请求（对每个引用的资源的一个请求）。 另一方面，http / 2 发送 HTML 页面和引用的资源，而不从浏览器中的明确请求。 因此，浏览器请求 HTML 页面并接收页面和显示页面所需的所有其他内容。

HTTP 客户端 API 通过`PushPromiseHandler`接口支持此 HTTP / 2 功能。 此接口的实现必须作为`send()`或`sendAsync()`方法的第三个参数给出。

`PushPromiseHandler`依赖于三个坐标，如下所示：

*   启动客户端发送请求（`initiatingRequest`）
*   合成推送请求（`pushPromiseRequest`）
*   Conceptor 函数，必须成功调用以接受推送承诺（接受者）

通过调用给定的受护者函数接受推送承诺。 Conceptor 函数必须传递非空`BodyHandler`，用于处理承诺的响应主体。 接受器函数将返回完成承诺的响应的`CompletableFuture`实例。

基于此信息，让我们来看看`PushPromiseHandler`的实现：

```
private static final List<CompletableFuture<Void>>
  asyncPushRequests = new CopyOnWriteArrayList<>();
...
private static HttpResponse.PushPromiseHandler<String>
  pushPromiseHandler() {

    return (HttpRequest initiatingRequest, 
      HttpRequest pushPromiseRequest,
      Function<HttpResponse.BodyHandler<String> ,
      CompletableFuture<HttpResponse<String>>> acceptor) -> {
      CompletableFuture<Void> pushcf =
      acceptor.apply(HttpResponse.BodyHandlers.ofString())
      .thenApply(HttpResponse::body)
      .thenAccept((b) -> System.out.println(
        "\nPushed resource body:\n " + b));

      asyncPushRequests.add(pushcf);

      System.out.println("\nJust got promise push number: " +
        asyncPushRequests.size());
      System.out.println("\nInitial push request: " +
        initiatingRequest.uri());
      System.out.println("Initial push headers: " +
        initiatingRequest.headers());
      System.out.println("Promise push request: " +
        pushPromiseRequest.uri());
      System.out.println("Promise push headers: " +
        pushPromiseRequest.headers());
    };
  }
```

现在，让我们触发请求并将`PushPromiseHandler`传递给`sendAsync()`：

```
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
  .uri(URI.create("https://http2.golang.org/serverpush"))
  .build();

client.sendAsync(request,
    HttpResponse.BodyHandlers.ofString(), pushPromiseHandler())
  .thenApply(HttpResponse::body)
  .thenAccept((b) -> System.out.println("\nMain resource:\n" + b))
  .join();

asyncPushRequests.forEach(CompletableFuture::join);

System.out.println("\nFetched a total of " +
  asyncPushRequests.size() + " push requests");
```

如果我们想返回一个累积推送承诺的推送承诺处理程序，以及他们的响应，在给定的地图中，那么我们可以依赖于`PushPromiseHandler.of()`方法，如下所示：

```
private static final ConcurrentMap<HttpRequest,
  CompletableFuture<HttpResponse<String>>> promisesMap 
    = new ConcurrentHashMap<>();

private static final Function<HttpRequest,
  HttpResponse.BodyHandler<String>> promiseHandler 
    = (HttpRequest req) -> HttpResponse.BodyHandlers.ofString();

public static void main(String[] args)
    throws IOException, InterruptedException {

  HttpClient client = HttpClient.newHttpClient();

  HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://http2.golang.org/serverpush"))
    .build();

  client.sendAsync(request,
      HttpResponse.BodyHandlers.ofString(), pushPromiseHandler())
    .thenApply(HttpResponse::body)
    .thenAccept((b) -> System.out.println("\nMain resource:\n" + b))
    .join();

  System.out.println("\nPush promises map size: " +
    promisesMap.size() + "\n");

  promisesMap.entrySet().forEach((entry) -> {
    System.out.println("Request = " + entry.getKey() +
      ", \nResponse = " + entry.getValue().join().body());
  });
}

private static HttpResponse.PushPromiseHandler<String>
  pushPromiseHandler() {

    return HttpResponse.PushPromiseHandler
      .of(promiseHandler, promisesMap);
  }
```

在前面解决方案的两种解决方案中，我们已经通过`ofString()`使用了`String`类型的`BodyHandler`。 如果服务器也推动二进制数据（例如，图像），这不是非常有用的。 因此，如果我们正在处理二进制数据，我们需要通过`ofByteArray()`切换到`byte[]`类型的`BodyHandler`。 或者，我们可以通过`ofFile()`将推送的资源发送到磁盘，如以下解决方案所示，这是前一个解决方案的适应版本：

```
private static final ConcurrentMap<HttpRequest,
  CompletableFuture<HttpResponse<Path>>>
    promisesMap = new ConcurrentHashMap<>();

private static final Function<HttpRequest,
  HttpResponse.BodyHandler<Path>> promiseHandler 
    = (HttpRequest req) -> HttpResponse.BodyHandlers.ofFile(
      Paths.get(req.uri().getPath()).getFileName());

public static void main(String[] args)
    throws IOException, InterruptedException {

  HttpClient client = HttpClient.newHttpClient();

  HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://http2.golang.org/serverpush"))
    .build();

  client.sendAsync(request, HttpResponse.BodyHandlers.ofFile(
      Path.of("index.html")), pushPromiseHandler())
    .thenApply(HttpResponse::body)
    .thenAccept((b) -> System.out.println("\nMain resource:\n" + b))
    .join();

  System.out.println("\nPush promises map size: " +
    promisesMap.size() + "\n");

  promisesMap.entrySet().forEach((entry) -> {
    System.out.println("Request = " + entry.getKey() +
      ", \nResponse = " + entry.getValue().join().body());
  });
}

private static HttpResponse.PushPromiseHandler<Path>
  pushPromiseHandler() {

    return HttpResponse.PushPromiseHandler
      .of(promiseHandler, promisesMap);
  }
```

前面的代码应该保存应用程序类路径中的推送的资源，如以下屏幕截图所示：

![](img/5b35d616-5dfb-4e6e-b004-92374daa4cb0.png)

# 269\. Websocket.

HTTP 客户端支持 WebSocket 协议。 在 API 术语中，实现的核心是`java.net.http.WebSocket`接口。 此接口公开了一套用于处理 WebSocket 通信的方法。

可以通过`HttpClient.newWebSocketBuilder().buildAsync()`异步构建`WebSocket`实例。

例如，我们可以连接到众所周知的 Meetup RSVP WebSocket 端点（`ws://stream.meetup.com/2/rsvps`），如下所示：

```
HttpClient client = HttpClient.newHttpClient();

WebSocket webSocket = client.newWebSocketBuilder()
  .buildAsync(URI.create("ws://stream.meetup.com/2/rsvps"), 
    wsListener).get(10, TimeUnit.SECONDS);
```

通过其性质，WebSocket 协议是双向的。 为了发送数据，我们可以依靠`sendText()`，`sendBinary()`，`sendPing()`和`sendPong()`。 Meetap RSVP 不会处理我们发送的消息，但只是为了有趣，我们可以发送短信，如下所示：

```
webSocket.sendText("I am an Meetup RSVP fan", true);
```

`boolean`参数用于标记消息的末尾。 如果此调用未完成，则消息通过`false`。

要关闭连接，我们需要使用`sendClose()`，如下所示：

```
webSocket.sendClose(WebSocket.NORMAL_CLOSURE, "ok");
```

最后，我们需要编写将处理传入消息的`WebSocket.Listener`。 这是一个接口，该接口包含具有默认实现的一系列方法。 以下代码只是覆盖`onOpen()`，`onText()`和`onClose()`。 胶合 WebSocket 侦听器和前面的代码将导致以下应用程序：

```
public class Main {

  public static void main(String[] args) throws 
      InterruptedException, ExecutionException, TimeoutException {

    Listener wsListener = new Listener() {

      @Override
      public CompletionStage<?> onText(WebSocket webSocket,
          CharSequence data, boolean last) {
        System.out.println("Received data: " + data);

        return Listener.super.onText(webSocket, data, last);
      }

      @Override
      public void onOpen(WebSocket webSocket) {
        System.out.println("Connection is open ...");
        Listener.super.onOpen(webSocket);
      }

      @Override
      public CompletionStage<? > onClose(WebSocket webSocket,
          int statusCode, String reason) {
        System.out.println("Closing connection: " +
          statusCode + " " + reason);

        return Listener.super.onClose(webSocket, statusCode, reason);
      }
    };

    HttpClient client = HttpClient.newHttpClient();

    WebSocket webSocket = client.newWebSocketBuilder()
      .buildAsync(URI.create(
        "ws://stream.meetup.com/2/rsvps"), wsListener)
      .get(10, TimeUnit.SECONDS);

    TimeUnit.SECONDS.sleep(10);

    webSocket.sendClose(WebSocket.NORMAL_CLOSURE, "ok");
  }
}
```

此应用程序将运行 10 秒钟，并将产生类似于以下内容的输出：

```
Connection is open ...

Received data: {"visibility":"public","response":"yes","guests":0,"member":{"member_id":267133566,"photo":"https:\/\/secure.meetupstatic.com\/photos\/member\/8\/7\/8\/a\/thumb_282154698.jpeg","member_name":"SANDRA MARTINEZ"},"rsvp_id":1781366945...

Received data: {"visibility":"public","response":"yes","guests":1,"member":{"member_id":51797722,...
...
```

10 秒后，应用程序与 WebSocket 端点断开连接。

# 概括

我们的工作完成了！ 这是本章的最后一个问题。 现在，我们已经到了本书的结尾。 它看起来像新的 HTTP 客户端和 WebSocket API 非常酷。 它们具有很大的灵活性和多功能性，它们非常直观，他们设法成功隐藏了许多我们不想在开发期间处理的痛苦细节。

从本章下载应用程序以查看结果和其他详细信息。