# 使用日期和时间

本章包括 20 个涉及日期和时间的问题。 这些问题旨在通过`Date`，`Calendar`，`LocalDate`，`LocalTime`，`LocalTime`，涵盖各种主题（转换，格式化，添加，减去，定义，定义，定义，持续，计算等时段/持续，计算等），`LocalTime`，[htg4 `ZoneDateTime`，`OffsetDateTime`，`OffsetTime`，`Instant`等。 到本章末尾，您将在整形日期和时间内没有问题，同时符合您的应用程序的需求。 本章中提出的基本问题对于获得关于日期时间 API 的更大的图景非常有用，并且将类似于需要拼凑在一起的拼图的棋子，以解决涉及日期和时间的复杂挑战。

# 问题

使用以下问题来测试您的日期和时间编程实力。 我强烈建议您在转向解决方案并下载示例程序之前尝试举出每个问题：

58.  **将字符串转换为日期和时间**：写一个程序，该程序举例说明字符串和日期/时间之间的转换。
59.  **格式化日期和时间**：解释日期和时间的格式模式。
60.  **在没有时间/日期**的情况下获取当前日期/时间：编写一个在没有时间或日期的时间或日期提取当前日期的程序。
61.  `LocalDateTime` **从** `LocalDate` **和** `LocalDate`：写一个从`LocalDate`对象和`LocalTime`构建`LocalDateTime`的程序。 它结合了单个`LocalDateTime`对象中的日期和时间。
62.  **通过** `Instant` **类** ：解释并展示`Instant` api 的示例。
63.  **使用基于日期的值（`Period`）和使用基于时间的值的持续时间（`Duration`）**：解释并举例说明 `Period`和`Duration` API 的使用。

64.  **获取日期和时间单位**：编写一个程序从代表日期时间的对象中提取日期和时间单位（例如，从年度，月，分钟等的日期提取）。
65.  **添加和减去日期时间**：写一个程序，该程序添加（并减去）到日期时对象的时间（例如，年，日，日或分钟）（例如 ，添加一个小时待日期，从`LocalDateTime`等中减去 2 天）。
66.  **通过 UTC 和 GMT** 获取所有时区：编写一个程序，该程序显示带 UTC 和 GMT 的所有可用时区。
67.  **在所有可用时区**中获取本地日期时间：写一个在所有可用时区中显示本地时间的程序。
68.  **显示有关航班的日期时间信息**：编写一个程序，该程序显示有关 6 小时和 30 分钟的计划飞行时间的信息。 更确切地说，从澳大利亚珀斯到布加勒斯特，欧洲的航班。
69.  **将 UNIX 时间戳转换为日期时间**：写一个将 UNIX 时间戳转换为`java.util.Date`和`java.time.LocalDateTime`的程序。
70.  **找到本月的第一个/最后一天**：编写一个通过 JDK 8，`TemporalAdjusters`找到一个月的第一个/最后一天的程序。
71.  **定义/提取区域偏移偏移**：写一个节目，该程序显示用于定义和提取区域偏移的不同技术。
72.  **在** `Date` **和** `Temporal`之间转换：写一个在`Date`和`Instant`，`LocalDate`，`LocalDateTime`等之间转换的程序。
73.  **迭代一系列日期**：编写一个程序，该程序迭代给定日期的范围，日复一日（有一天的步骤）。
74.  **计算年龄**：写一个计算人的年龄的程序。
75.  **开始和结束一天**：写一个返回一天的开始和结束时间的程序。
76.  **两个日期之间的差异：**编写一个程序，计算两个日期之间的时间，在几天内。
77.  **实现国际象棋时钟：**写入实现棋子时钟的程序。

# 解决方案

以下部分描述了前一个问题的解决方案。 请记住，几乎不是一个正确的方法来解决特定问题。 另外，请记住，这里所示的解释仅包括解决问题所需的最有趣和最重要的细节。 下载示例解决方案以查看其他详细信息，并在 [https://github.com/packtpublishing/java-coding-problems](https://github.com/PacktPublishing/Java-Coding-Problems) 上进行实验。

# 58.将字符串转换为日期和时间

将`String`转换或解析到日期和时间可以通过一组`parse()`方法来完成。 从日期和时间转换为`String`可以通过`toString()`或`format()`方法来完成。

# 在 JDK 8 之前

在 JDK 8 之前，此问题的典型解决方案依赖于 Abstract `DateFormat`类的主要扩展名为`SimpleDateFormat`（这不是线程安全类）。 在捆绑到本书的代码中，有几个例子如何使用此类。

# 从 JDK 8 开始

从 JDK 8 开始，`SimpleDateFormat`可以用新的类`DateTimeFormatter`替换。 这是一个不可变（因此，因此，线程安全）类，并且用于打印和解析日期时间对象。 此类支持来自预定义格式的所有内容（表示为常量，作为 ISO 本地日期，2011-12-03 为`ISO_LOCAL_DATE`）到用户定义的格式化器（依赖于用于编写自定义格式模式的一组符号）。

此外，除了`Date`类之外，JDK 8 附带了几个新类，致力于使用日期和时间。 这些类中的一些如下列表所示（这些类也被称为时间，因为它们实现了`Temporal`界面）：

*   `LocalDate`（日期没有时区的 ISO-8601 日历系统）
*   `LocalTime`（没有时区在 ISO-8601 日历系统中的时间）
*   `LocalDateTime`（没有 ISO-8601 日历系统中没有时区的日期时间）
*   `ZonedDateTime`（日期 - 时间区域在 ISO-8601 日历系统中的时区），等等
*   `OffsetDateTime`（在 ISO-8601 日历系统中的 UTC / GMT 偏移的日期时间）
*   `OffsetTime`（ISO-8601 日历系统中的 UTC / GMT 的偏移时间）

为了经由预定义格式化器将`String`转换为`LocalDate`，它应该尊重`DateTimeFormatter.ISO_LOCAL_DATE`模式，例如 2020-06-01。 `LocalDate`提供了可以使用如下所示的`parse()`方法：

```
// 06 is the month, 01 is the day
LocalDate localDate = LocalDate.parse("2020-06-01");
```

类似地，在`LocalTime`的情况下，字符串应尊重`DateTimeFormatter.ISO_LOCAL_TIME`模式; 例如，10:15:30，如以下代码片段所示：

```
LocalTime localTime = LocalTime.parse("12:23:44");
```

在`LocalDateTime`的情况下，字符串应尊重`DateTimeFormatter.ISO_LOCAL_DATE_TIME`模式; 例如，`2020-06-01T11:20:15`，如以下代码片段所示：

```
LocalDateTime localDateTime 
  = LocalDateTime.parse("2020-06-01T11:20:15");
```

而且，在`ZonedDateTime`的情况下，字符串必须尊重`DateTimeFormatter.ISO_ZONED_DATE_TIME`模式; 例如，`2020-06-01T10:15:30+09:00[Asia/Tokyo]`，如以下代码片段所示：

```
ZonedDateTime zonedDateTime 
  = ZonedDateTime.parse("2020-06-01T10:15:30+09:00[Asia/Tokyo]");
```

在`OffsetDateTime`的情况下，字符串必须尊重`DateTimeFormatter.ISO_OFFSET_DATE_TIME`模式; 例如，`2007-12-03T10:15:30+01:00`，如以下代码片段所示：

```
OffsetDateTime offsetDateTime 
  = OffsetDateTime.parse("2007-12-03T10:15:30+01:00");
```

最后，在`OffsetTime`的情况下，字符串必须尊重`DateTimeFormatter.ISO_OFFSET_TIME`模式; 例如，`10:15:30+01:00`，如以下代码片段所示：

```
OffsetTime offsetTime = OffsetTime.parse("10:15:30+01:00");
```

如果字符串不尊重任何预定义格式，则是通过自定义格式模式的用户定义格式化器的时间; 例如，字符串`01.06.2020`表示需要用户定义的格式化器的日期，如下所示：

```
DateTimeFormatter dateFormatter 
  = DateTimeFormatter.ofPattern("dd.MM.yyyy");
LocalDate localDateFormatted 
  = LocalDate.parse("01.06.2020", dateFormatter);
```

但是，诸如`12|23|44`之类的字符串需要用户定义的格式化器，如下所示：

```
DateTimeFormatter timeFormatter 
  = DateTimeFormatter.ofPattern("HH|mm|ss");
LocalTime localTimeFormatted 
  = LocalTime.parse("12|23|44", timeFormatter);
```

诸如`01.06.2020, 11:20:15`之类的字符串需要用户定义的格式化器，如下所示：

```
DateTimeFormatter dateTimeFormatter 
  = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm:ss");
LocalDateTime localDateTimeFormatted 
  = LocalDateTime.parse("01.06.2020, 11:20:15", dateTimeFormatter);
```

诸如`01.06.2020, 11:20:15+09:00 [Asia/Tokyo]`之类的字符串需要用户定义的格式化器，如下所示：

```
DateTimeFormatter zonedDateTimeFormatter 
  = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm:ssXXXXX '['VV']'");
ZonedDateTime zonedDateTimeFormatted 
  = ZonedDateTime.parse("01.06.2020, 11:20:15+09:00 [Asia/Tokyo]", 
    zonedDateTimeFormatter);
```

诸如`2007.12.03, 10:15:30, +01:00`之类的字符串需要用户定义的格式化器，如下所示：

```
DateTimeFormatter offsetDateTimeFormatter 
  = DateTimeFormatter.ofPattern("yyyy.MM.dd, HH:mm:ss, XXXXX");
OffsetDateTime offsetDateTimeFormatted 
  = OffsetDateTime.parse("2007.12.03, 10:15:30, +01:00", 
    offsetDateTimeFormatter);
```

最后，诸如`10 15 30 +01:00`之类的字符串需要用户定义的格式化器，如下所示：

```
DateTimeFormatter offsetTimeFormatter 
  = DateTimeFormatter.ofPattern("HH mm ss XXXXX");
OffsetTime offsetTimeFormatted 
  = OffsetTime.parse("10 15 30 +01:00", offsetTimeFormatter);
```

来自前面示例的每个`ofPattern()`方法也支持`Locale`。

从`LocalDate`，`LocalDateTime`或`ZonedDateTime`转换为`String`可以至少两种方式完成：

*   依赖于`LocalDate`，`LocalDateTime`或`ZonedDateTime.toString()`方法（自动或明确）。 请注意，依赖于`toString()`将始终通过相应的预定义格式化程序打印日期：

```
// 2020-06-01 results in ISO_LOCAL_DATE, 2020-06-01
String localDateAsString = localDate.toString();

// 01.06.2020 results in ISO_LOCAL_DATE, 2020-06-01
String localDateAsString = localDateFormatted.toString();

// 2020-06-01T11:20:15 results 
// in ISO_LOCAL_DATE_TIME, 2020-06-01T11:20:15
String localDateTimeAsString = localDateTime.toString();

// 01.06.2020, 11:20:15 results in 
// ISO_LOCAL_DATE_TIME, 2020-06-01T11:20:15
String localDateTimeAsString 
  = localDateTimeFormatted.toString();

// 2020-06-01T10:15:30+09:00[Asia/Tokyo] 
// results in ISO_ZONED_DATE_TIME,
// 2020-06-01T11:20:15+09:00[Asia/Tokyo]
String zonedDateTimeAsString = zonedDateTime.toString();

// 01.06.2020, 11:20:15+09:00 [Asia/Tokyo] 
// results in ISO_ZONED_DATE_TIME,
// 2020-06-01T11:20:15+09:00[Asia/Tokyo]
String zonedDateTimeAsString 
  = zonedDateTimeFormatted.toString();
```

*   依靠`DateTimeFormatter.format()`方法。 请注意，依赖于`DateTimeFormatter.format()`将始终使用指定的格式化器打印日期/时间（默认情况下，时区将是`null`），如下所示：

```
// 01.06.2020
String localDateAsFormattedString 
  = dateFormatter.format(localDateFormatted);

// 01.06.2020, 11:20:15
String localDateTimeAsFormattedString 
  = dateTimeFormatter.format(localDateTimeFormatted);

// 01.06.2020, 11:20:15+09:00 [Asia/Tokyo]
String zonedDateTimeAsFormattedString 
  = zonedDateTimeFormatted.format(zonedDateTimeFormatter);
```

将显式时区添加到讨论中可以如下所示：

```
DateTimeFormatter zonedDateTimeFormatter 
  = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm:ssXXXXX '['VV']'")
    .withZone(ZoneId.of("Europe/Paris"));
ZonedDateTime zonedDateTimeFormatted 
  = ZonedDateTime.parse("01.06.2020, 11:20:15+09:00 [Asia/Tokyo]", 
    zonedDateTimeFormatter);
```

这次，字符串表示欧洲/巴黎时区的日期/时间：

```
// 01.06.2020, 04:20:15+02:00 [Europe/Paris]
String zonedDateTimeAsFormattedString 
  = zonedDateTimeFormatted.format(zonedDateTimeFormatter);
```

# 59.格式化日期和时间

以前的问题包含通过`SimpleDateFormat.format()`和`DateTimeFormatter.format()`的一些格式化日期和时间的口味。 为了定义*格式模式，*开发人员必须了解格式模式语法。 换句话说，开发人员必须知道 Java Date-Time API 使用的一组符号，以识别有效的格式模式。

大多数符号对`SimpleDateFormat`（JDK 8 之前）和`DateTimeFormatter`是常见的，并且从 JDK 8 开始）。 下表列出了最常见的符号 - JDK 文档中可用的完整列表：

| **字母** | **含义** | **演示文稿** | **示例** |
| 和 | 年 | 年 | 1994; 94 |
| m | 一年的一个月 | 数字/文本 | 7; 07; 七月; 七月; j。 |
| 在 | 一周 | 数字 | 4 |
| 是 | 星期几 | 文本 | 星期二; 周二; T. |
| D. | 月份 | 数字 | 15 |
| H | 一天的一小时 | 数字 | 22 |
| m | 分钟 | 数字 | 34 |
| S. | 第二个分钟 | 数字 | 55 |
| S. | 一小部分 | 数字 | 345 |
| 从 | 时区名称 | 区域名称 | 太平洋标准时间; 太平洋标准时间 |
| 从 | 区域偏移 | 区域偏移 | -0800 |
| V. | 时区 ID（JDK 8） | 区域 ID | 美国/ Los_Angeles; Z; -08：30 |

以下表格中提供了一些格式模式示例：

| **模式** | **示例** |
| yyyy-mm-dd | 2019-02-24 |
| mm-dd-yyyy | 02-24-2019 |
| mmm-dd-yyyy | 2 月 24 日 |
| DD-mm-yy | 24-02-19 |
| dd.mm.yyyy | 24.02.2019 |
| YYYY-MM-DD HH：MM：SS | 2019-02-24 11:26:26 |
| YYYY-MM-DD HH：MM：SSSSSS | 2019-02-24 11:36:32743 |
| YYYY-MM-DD HH：MM：SSZ | 2019-02-24 11:40:35+0200 |
| YYYY-MM-DD HH：mm：ss z | 2019-02-24 11:45:03 吃 |
| E mmm yyyy hh：mm：ss.sssz | 2019 年 2 月 11 日：46：32.393 + 0200 |
| YYYY-MM-DD HH：MM：SS VV（JDK 8） | 2019-02-24 11:45:41 欧洲/雅典 |

在 JDK 8 之前，可以通过`SimpleDateFormat`应用格式模式：

```
// yyyy-MM-dd
Date date = new Date();
SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
String stringDate = formatter.format(date);
```

从 JDK 8 开始，可以通过`DateTimeFormatter`应用格式模式：

*   对于`LocalDate`（没有 ISO-8601 日历系统中没有时区的日期）：

```
// yyyy-MM-dd
LocalDate localDate = LocalDate.now();
DateTimeFormatter formatterLocalDate 
  = DateTimeFormatter.ofPattern("yyyy-MM-dd");
String stringLD = formatterLocalDate.format(localDate);

// or shortly
String stringLD = LocalDate.now()
  .format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
```

*   对于`LocalTime`（没有时区的时间在 ISO-8601 日历系统中）：

```
// HH:mm:ss
LocalTime localTime = LocalTime.now();
DateTimeFormatter formatterLocalTime 
  = DateTimeFormatter.ofPattern("HH:mm:ss");
String stringLT 
  = formatterLocalTime.format(localTime);

// or shortly
String stringLT = LocalTime.now()
  .format(DateTimeFormatter.ofPattern("HH:mm:ss"));
```

*   对于`LocalDateTime`（没有时区的日期时间，ISO-8601 日历系统）：

```
// yyyy-MM-dd HH:mm:ss
LocalDateTime localDateTime = LocalDateTime.now();
DateTimeFormatter formatterLocalDateTime 
  = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String stringLDT 
  = formatterLocalDateTime.format(localDateTime);

// or shortly
String stringLDT = LocalDateTime.now()
  .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
```

*   对于`ZonedDateTime`（日期 - 时间与 ISO-8601 日历系统中的时区）：

```
// E MMM yyyy HH:mm:ss.SSSZ
ZonedDateTime zonedDateTime = ZonedDateTime.now();
DateTimeFormatter formatterZonedDateTime 
  = DateTimeFormatter.ofPattern("E MMM yyyy HH:mm:ss.SSSZ");
String stringZDT 
  = formatterZonedDateTime.format(zonedDateTime);

// or shortly
String stringZDT = ZonedDateTime.now()
  .format(DateTimeFormatter
    .ofPattern("E MMM yyyy HH:mm:ss.SSSZ"));
```

*   对于`OffsetDateTime`（在 ISO-8601 日历系统中的 UTC / GMT 的偏移量的日期时间）：

```
// E MMM yyyy HH:mm:ss.SSSZ
OffsetDateTime offsetDateTime = OffsetDateTime.now();
DateTimeFormatter formatterOffsetDateTime 
  = DateTimeFormatter.ofPattern("E MMM yyyy HH:mm:ss.SSSZ");
String odt1 = formatterOffsetDateTime.format(offsetDateTime);

// or shortly
String odt2 = OffsetDateTime.now()
  .format(DateTimeFormatter
    .ofPattern("E MMM yyyy HH:mm:ss.SSSZ"));
```

*   对于`OffsetTime`（ISO-8601 日历系统中的 UTC / GMT 的偏移量）：

```
// HH:mm:ss,Z
OffsetTime offsetTime = OffsetTime.now();
DateTimeFormatter formatterOffsetTime 
  = DateTimeFormatter.ofPattern("HH:mm:ss,Z");
String ot1 = formatterOffsetTime.format(offsetTime);

// or shortly
String ot2 = OffsetTime.now()
  .format(DateTimeFormatter.ofPattern("HH:mm:ss,Z"));
```

# 60.在没有时间/日期的情况下获取当前日期/时间

在 JDK 8 之前，解决方案必须专注于`java.util.Date`类。 捆绑到本书的代码包含此解决方案。

从 JDK 8 开始，可以通过专用类`LocalDate`和`LocalTime`来获得日期和时间，从`java.time`包中获取：

```
// 2019-02-24
LocalDate onlyDate = LocalDate.now();

// 12:53:28.812637300
LocalTime onlyTime = LocalTime.now();
```

# 61.来自 LocalDate 和 LocalTime 的 LocalDateTime

`LocalDateTime`类公开了一系列可用于获取`LocalDateTime`的不同实例的`of()`方法。 例如，从年份，月，日，小时，分钟，第二个或纳秒为单位获得的`LocalDateTime`类如下所示：

```
LocalDateTime ldt = LocalDateTime.of​(2020, 4, 1, 12, 33, 21, 675);
```

因此，前面的代码将日期和时间与`of()`方法的参数相结合。 为了将日期和时间组合为对象，解决方案可以利用以下`of()`方法：

```
public static LocalDateTime of​(LocalDate date, LocalTime time)
```

这导致`LocalDate`和`LocalTime`如下所示：

```
LocalDate localDate = LocalDate.now(); // 2019-Feb-24
LocalTime localTime = LocalTime.now(); // 02:08:10 PM
```

它们可以在单个对象中组合`LocalDateTime`，如下：

```
LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);
```

格式化`LocalDateTime`显示日期和时间如下：

```
// 2019-Feb-24 02:08:10 PM
String localDateTimeAsString = localDateTime
  .format(DateTimeFormatter.ofPattern("yyyy-MMM-dd hh:mm:ss a"));
```

# 62.通过即时类机器时间

JDK 8 配有一个新的类，它被命名为`java.time.Instant`。 主要是，`Instant`类代表了时间表上的瞬时点，从 1970 年 1 月 1 日（时代）的第一个第二秒开始，在 UTC 时区，具有纳秒的分辨率。

Java 8 `Instant`类在概念中与`java.util.Date`相似。 两者都代表 UTC 中的时间线上的片刻。 虽然`Instant`具有最高纳秒的分辨率，但`java.util.Date`具有毫秒的分辨率。

此类非常方便地生成机器时间的时间戳。 为了获得这样的时间戳，只需呼叫`now()`方法，如下所示：

```
// 2019-02-24T15:05:21.781049600Z
Instant timestamp = Instant.now();
```

可以使用以下代码片段获得类似的输出：

```
OffsetDateTime now = OffsetDateTime.now(ZoneOffset.UTC);
```

或者，使用此代码片段：

```
Clock clock = Clock.systemUTC();
```

调用`Instant.toString()`产生遵循 ISO-8601 标准的输出，用于表示日期和时间。

# 将字符串转换为即时

遵循 ISO-8601 表示日期和时间的标准的字符串可以通过`Instant.parse()`方法轻松转换为`Instant`，如下例所示：

```
// 2019-02-24T14:31:33.197021300Z
Instant timestampFromString =
  Instant.parse("2019-02-24T14:31:33.197021300Z");
```

# 向瞬发添加或减去时间

对于添加时间，`Instant`具有一套方法。 例如，将 2 小时添加到当前时间戳可以完成如下：

```
Instant twoHourLater = Instant.now().plus(2, ChronoUnit.HOURS);
```

在减去时间，例如，10 分钟，使用以下代码片段：

```
Instant tenMinutesEarlier = Instant.now()
  .minus(10, ChronoUnit.MINUTES);
```

除了`plus()`方法旁边，`Instant`还包含`plusNanos()`，`plusMillis()`和`plusSeconds()`。 此外，除了`minus()`方法旁边，`Instant`还包含`minusNanos()`，`minusMillis()`和`minusSeconds()`。

# 比较即时对象

比较两个`Instant`对象可以通过`Instant.isAfter()`和`Instant.isBefore()`方法来完成。 例如，让我们看看以下两个`Instant`对象：

```
Instant timestamp1 = Instant.now();
Instant timestamp2 = timestamp1.plusSeconds(10);
```

检查`timestamp1`是否在`timestamp2`之后：

```
boolean isAfter = timestamp1.isAfter(timestamp2); // false
```

检查`timestamp1`是否在`timestamp2`之前：

```
boolean isBefore = timestamp1.isBefore(timestamp2); // true
```

可以通过`Instant.until()`方法计算两个`Instant`对象之间的时间差：

```
// 10 seconds
long difference = timestamp1.until(timestamp2, ChronoUnit.SECONDS);
```

# 在即时和 localDateTime，ZonedDateTime 和 offsetDatem 之间转换

这些常见转换可以如以下实施例中完成：

*   在`Instant`和`LocalDateTime` -since `LocalDateTime`之间的转换不知道时区，使用零偏移 utc + 0：

```
// 2019-02-24T15:27:13.990103700
LocalDateTime ldt = LocalDateTime.ofInstant(
  Instant.now(), ZoneOffset.UTC);

// 2019-02-24T17:27:14.013105Z
Instant instantLDT = LocalDateTime.now().toInstant(ZoneOffset.UTC);
```

*   在`Instant`和`ZonedDateTime`之间转换 - 将`Instant` UTC + 0 转换为 Paris `ZonedDateTime` UTC + 1：

```
// 2019-02-24T16:34:36.138393100+01:00[Europe/Paris]
ZonedDateTime zdt = Instant.now().atZone(ZoneId.of("Europe/Paris"));

// 2019-02-24T16:34:36.150393800Z
Instant instantZDT = LocalDateTime.now()
  .atZone(ZoneId.of("Europe/Paris")).toInstant();
```

*   在`Instant`和`OffsetDateTime`之间转换 - 指定 2 小时的偏移量：

```
// 2019-02-24T17:34:36.151393900+02:00
OffsetDateTime odt = Instant.now().atOffset(ZoneOffset.of("+02:00"));

// 2019-02-24T15:34:36.153394Z
Instant instantODT = LocalDateTime.now()
  .atOffset(ZoneOffset.of("+02:00")).toInstant();
```

# 63.使用基于日期的值和时间的持续时间定义一段时间，使用基于时间的值

JDK 8 附带两个名为`java.time.Period`和`java.time.Duration`的新类。 让我们在下一节中详细看看它们。

# 使用基于日期的值的时间段

`Period`类是指使用基于日期的值（年，月，几周和日期）表示时间。 这段时间可以以不同的方式获得。 例如，可以获得 120 天的时间：

```
Period fromDays = Period.ofDays(120); // P120D
```

在`ofDays()`方法旁边，`Period`类还具有`ofMonths()`，`ofWeeks()`和`ofYears()`。

或者，可以通过`of()`方法获得 2000 年，11 个月和 24 天，如下：

```
Period periodFromUnits = Period.of(2000, 11, 24); // P2000Y11M24D
```

`Period`也可以从`LocalDate`获得：

```
LocalDate localDate = LocalDate.now();
Period periodFromLocalDate = Period.of(localDate.getYear(),
  localDate.getMonthValue(), localDate.getDayOfMonth());
```

最后，可以从尊重 ISO-8601 周期格式`PnYnMnD`和`PnW`的`String`对象中获得`Period`。 例如，P2019Y2M25D 字符串代表 2019 年，2 个月和 25 天：

```
Period periodFromString = Period.parse("P2019Y2M25D");
```

呼叫`Period.toString()`将返回期间，同时也尊重 ISO-8601 周期格式，`PnYnMnD`和`PnW`（例如，P120D，P2000Y11M24D）。]

但是，当它用于表示两个日期之间的一段时间（例如，`LocalDate`）时，揭示了`Period`的实际功率。 2018 年 3 月 12 日至 2019 年 7 月 20 日之间的时间段可以表示如下：

```
LocalDate startLocalDate = LocalDate.of(2018, 3, 12);
LocalDate endLocalDate = LocalDate.of(2019, 7, 20);
Period periodBetween = Period.between(startLocalDate, endLocalDate);
```

可以通过`Period.getYears()`，`Period.getMonths()`和`Period.getDays()`获得多年来，月份和日期的时间量。 例如，以下辅助方法使用这些方法将时间量输出为字符串：

```
public static String periodToYMD(Period period) {

  StringBuilder sb = new StringBuilder();

  sb.append(period.getYears())
   .append("y:")
   .append(period.getMonths())
   .append("m:")
   .append(period.getDays())
   .append("d");

 return sb.toString();
}
```

让我们称之为`periodBetween`（差异为 1 年，4 个月，8 天）：

```
periodToYMD(periodBetween); // 1y:4m:8d
```

在确定特定日期是否早于另一个日期，`Period`类也很有用。 有一个标志方法，名为`isNegative()`。 具有`A`时段和`B`时段，施加`Period.between(A, B)`的结果如果`B`在`A`之前，或阳性如果`A`是阳性的，则可以是负的。 进一步拍摄此逻辑，`isNegative()`返回`true`如果`B`是`A`或`false`，如果`A`是在`B`之前，如下所示（基本上，该方法返回`false` 如果多年，几个月或几天是负面的）：

```
// returns false, since 12 March 2018 is earlier than 20 July 2019
periodBetween.isNegative();
```

最后，可以通过添加或减去一段时间来修改`Period`。 存在诸如`plusYears()`，`plusMonths()`，`plusDays()`，`minusYears()`，`minusMonths()`和`minusDays()`的方法。 例如，添加 1 年的`periodBetween`可以按如下方式进行：

```
Period periodBetweenPlus1Year = periodBetween.plusYears(1L);
```

可以通过`Period.plus()`方法来完成添加两个`Period`类，如下所示：

```
Period p1 = Period.ofDays(5);
Period p2 = Period.ofDays(20);
Period p1p2 = p1.plus(p2); // P25D
```

# 使用基于时间的值的时间持续时间

`Duration`类是指使用基于时间的值（小时，分钟，秒或纳秒）的时间量。 这种持续时间可以以不同的方式获得。 例如，可以获得 10 小时的持续时间如下：

```
Duration fromHours = Duration.ofHours(10); // PT10H
```

在`ofHours()`方法旁边，`Duration`类还具有`ofDays()`，`ofMillis()`，`ofMinutes()`，`ofSeconds()`和`ofNanos()`。

或者，可以通过`of()`方法获得 3 分钟的持续时间，如下：

```
Duration fromMinutes = Duration.of(3, ChronoUnit.MINUTES); // PT3M
```

`Duration`也可以从`LocalDateTime`获得：

```
LocalDateTime localDateTime 
  = LocalDateTime.of(2018, 3, 12, 4, 14, 20, 670);

// PT14M
Duration fromLocalDateTime 
  = Duration.ofMinutes(localDateTime.getMinute());
```

它也可以从`LocalTime`获得：

```
LocalTime localTime = LocalTime.of(4, 14, 20, 670);

// PT0.00000067S
Duration fromLocalTime = Duration.ofNanos(localTime.getNano());
```

最后，可以从尊重 ISO-8601 持续时间格式`PnDTnHnMn.nS`的`String`对象中获得`Duration`，日期被认为是完全 24 小时。 例如，`P2DT3H4M`字符串有 2 天，3 小时和 4 分钟：

```
Duration durationFromString = Duration.parse("P2DT3H4M");
```

调用`Duration.toString()`将返回尊重 ISO-8601 持续时间格式的持续时间`PnDTnHnMn.nS`（例如，`PT10H`，`PT3M`或`PT51H4M`）。

但是，如在`Period`的情况下，当它用于表示两次之间的时间段（例如，`Instant`）时，揭示了`Duration`的实际功率。 2015 年 11 月 3 日至 2016 年 12 月 6 日 12:11:30 之间的持续时间，2016 年 15:17:10，可以表示为两个`Instant`课程之间的差异，如下所示：

```
Instant startInstant = Instant.parse("2015-11-03T12:11:30.00Z");
Instant endInstant = Instant.parse("2016-12-06T15:17:10.00Z");

// PT10059H5M40S
Duration durationBetweenInstant 
  = Duration.between(startInstant, endInstant);
```

在几秒钟内，可以通过`Duration.getSeconds()`方法获得这种差异：

```
durationBetweenInstant.getSeconds(); // 36212740 seconds
```

或者，2018 年 3 月 12 日之间的时间为 04：14：20.000000670 和 2019 年 7 月 20 日，06：10：10.000000720 可以表示为两个`LocalDateTime`对象之间的差异，如下所示：

```
LocalDateTime startLocalDateTime 
  = LocalDateTime.of(2018, 3, 12, 4, 14, 20, 670);
LocalDateTime endLocalDateTime 
  = LocalDateTime.of(2019, 7, 20, 6, 10, 10, 720);
// PT11881H55M50.00000005S, or 42774950 seconds
Duration durationBetweenLDT 
  = Duration.between(startLocalDateTime, endLocalDateTime);
```

最后，04：14：20.0000670 和 06：10：10.000000720 之间的时间持续时间可以表示为两个`LocalTime`对象之间的差异，如下所示：

```
LocalTime startLocalTime = LocalTime.of(4, 14, 20, 670);
LocalTime endLocalTime = LocalTime.of(6, 10, 10, 720);

// PT1H55M50.00000005S, or 6950 seconds
Duration durationBetweenLT 
  = Duration.between(startLocalTime, endLocalTime);
```

在前面的示例中，通过`Duration.getSeconds()`方法以秒表示`Duration` - 这是`Duration`类中的秒数。 但是，`Duration`类包含一组专用于在其他时间单位中表达`Duration`的方法 - 通过`toDays()`，通过`toHours()`，在几分钟内通过`toMinutes()`，以毫秒为单位，通过`toMillis()`，并通过`toNanos()`纳秒。

从一个时间转换为另一个单位的时间可能导致残余。 例如，从秒到分钟转换可能导致秒的残余（例如，65 秒是 1 分钟，5 秒（5 秒是残余物））。 可以通过以下方法 - 通过`toDaysPart()`，通过`toHoursPart()`，通过`toHoursPart()`的数小时，通过`toMinutesPart()`，在几分钟内，通过`toMinutesPart()`，在几小时内，通过`toHoursPart()`，通过`toMinutesPart()`，在几分钟内进行残余物。

让我们假设差异应该显示为天：小时：分钟：秒：纳米（例如，9d：2h：15m：20s：230n）。 在帮助方法中加入`to*Foo()*`和`to*Foo*Part()`方法的力将导致以下代码：

```
public static String durationToDHMSN(Duration duration) {

  StringBuilder sb = new StringBuilder();
  sb.append(duration.toDays())
    .append("d:")
    .append(duration.toHoursPart())
    .append("h:")
    .append(duration.toMinutesPart())
    .append("m:")
    .append(duration.toSecondsPart())
    .append("s:")
    .append(duration.toNanosPart())
    .append("n");

  return sb.toString();
}
```

让我们召唤这种方法`durationBetweenLDT`（差异是 495 天，1 小时，55 分，50 秒和 50 纳秒）：

```
// 495d:1h:55m:50s:50n
durationToDHMSN(durationBetweenLDT);
```

与`Period`类相同，`Duration`类具有名为`isNegative()`的标志方法。 在确定特定时间是否早于另一个时间时，该方法非常有用。 持续时间`A`和持续时间`B`，施加`Duration.between(A, B)`的结果如果`B`在`A`之前，或者在`A`之前是阳性的，则可以是负的。 进一步播放逻辑，`isNegative()`返回`true`如果`B`是`A`，或`false`如果`A`在`B`之前，如以下情况：

```
durationBetweenLT.isNegative(); // false
```

最后，可以通过添加或减去持续时间来修改`Duration`。 存在诸如`plusDays()`，`plusHours()`，`plusMinutes()`，`plusMillis()`，`minusDays()`，`minusDays()`，`plusDays()`，`minusMillis()`和`minusNanos()`的方法来执行这一点。 例如，添加 5 小时至`durationBetweenLT`可以如下进行：

```
Duration durationBetweenPlus5Hours = durationBetweenLT.plusHours(5);
```

可以通过`Duration.plus()`方法来完成添加两个`Duration`类，如下所示：

```
Duration d1 = Duration.ofMinutes(20);
Duration d2 = Duration.ofHours(2);

Duration d1d2 = d1.plus(d2);

System.out.println(d1 + "+" + d2 + "=" + d1d2); // PT2H20M
```

# 64.获取日期和时间单位

对于`Date`对象，解决方案可以依赖于`Calendar`实例。 捆绑到本书的代码包含此解决方案。

对于 JDK 8 类，Java 提供专用`get*Foo*()`方法和`get​(TemporalField field)`方法。 例如，让我们假设以下`LocalDateTime`对象：

```
LocalDateTime ldt = LocalDateTime.now();
```

依赖于`get*Foo*()`方法，我们收到以下代码：

```
int year = ldt.getYear();
int month = ldt.getMonthValue();
int day = ldt.getDayOfMonth();
int hour = ldt.getHour();
int minute = ldt.getMinute();
int second = ldt.getSecond();
int nano = ldt.getNano();
```

或者，依赖于`get​(TemporalField field)`结果如下：

```
int yearLDT = ldt.get(ChronoField.YEAR);
int monthLDT = ldt.get(ChronoField.MONTH_OF_YEAR);
int dayLDT = ldt.get(ChronoField.DAY_OF_MONTH);
int hourLDT = ldt.get(ChronoField.HOUR_OF_DAY);
int minuteLDT = ldt.get(ChronoField.MINUTE_OF_HOUR);
int secondLDT = ldt.get(ChronoField.SECOND_OF_MINUTE);
int nanoLDT = ldt.get(ChronoField.NANO_OF_SECOND);
```

请注意，该月份从 1 月份计算的月份。

例如，可以将`LocalDateTime`对象的`2019-02-25T12:58:13.109389100`对象切割成日期时间单位，从而导致以下内容：

```
Year: 2019 Month: 2 Day: 25 Hour: 12 Minute: 58 Second: 13 Nano: 109389100
```

通过一点直觉和文档，非常容易适应`LocalDate`，`LocalTime`，`ZonedDateTime`和其他示例。

# 65.添加和减少到日期时间

此问题的解决方案依赖于专用于操作日期和时间的 Java API。 让我们在下一节看看它们。

# 与日期合作

对于`Date`对象，解决方案可以依赖于`Calendar`实例。 捆绑到本书的代码包含此解决方案。

# 使用 localDateTime

跳到 JDK 8，焦点在`LocalDate`，`LocalTime`，`LocalDateTime`，`Instant`等等。 新的 Java Date-Time API 具有专用于添加或减去时间的方法。 `LocalDate`，`LocalTime`，`LocalDateTime`，`ZonedDateTime`，`OffsetDateTime`，`Instant`，`Period`，`Duration`，以及许多其他方法与诸如`plus*Foo*()`和`minus*Foo*()`，其中 *`Foo` `Foo`可以用时间为单位（例如，`plusYears()`，`plusMinutes()`，`minusHours()`，`minusSeconds()`等）替换。*

让我们假设以下`LocalDateTime`：

```
// 2019-02-25T14:55:06.651155500
LocalDateTime ldt = LocalDateTime.now();
```

加入 10 分钟可以轻松呼叫`LocalDateTime.plusMinutes(long minutes)`，同时减去 10 分钟同步呼叫`LocalDateTime.minusMinutes(long minutes)`：

```
LocalDateTime ldtAfterAddingMinutes = ldt.plusMinutes(10);
LocalDateTime ldtAfterSubtractingMinutes = ldt.minusMinutes(10);
```

该输出将显示以下日期：

```
After adding 10 minutes: 2019-02-25T15:05:06.651155500
After subtracting 10 minutes: 2019-02-25T14:45:06.651155500
```

除了每个时间单位专用的方法旁边，这些类还支持`plus/minus(TemporalAmount amountToAdd)`和`plus/minus(long amountToAdd, TemporalUnit unit)`。

现在，让我们专注于`Instant`课程。 除了`plus/minusSeconds()`，`plus/minusMillis()`和`plus/minusNanos()`之外，`Instant`类还提供了`plus/minus(TemporalAmount amountToAdd)`方法。

为了举例说明此方法，让我们假设以下`Instant`：

```
// 2019-02-25T12:55:06.654155700Z
Instant timestamp = Instant.now();
```

现在，让我们添加并减去 5 小时：

```
Instant timestampAfterAddingHours 
  = timestamp.plus(5, ChronoUnit.HOURS);
Instant timestampAfterSubtractingHours 
  = timestamp.minus(5, ChronoUnit.HOURS);
```

输出将显示以下`Instant`：

```
After adding 5 hours: 2019-02-25T17:55:06.654155700Z
After subtracting 5 hours: 2019-02-25T07:55:06.654155700Z
```

# 66.通过 UTC 和 GMT 获取所有时区

UTC 和 GMT 被认可为处理日期和时间的标准参考。 如今，UTC 是首选方法，但 UTC 和 GMT 在大多数情况下都应该返回相同的结果。

为了使所有带有 UTC 和 GMT 的时区，解决方案应该专注于 JDK 8 之前和之后的实现。因此，让我们从 JDK 8 之前有用的解决方案开始。

# 在 JDK 8 之前

解决方案需要提取可用时区 ID（非洲/巴马科，欧洲/贝尔格莱德等）。 此外，每个时区 ID 应用于创建`TimeZone`对象。 最后，解决方案需要提取每个时区特定的偏移量，考虑到夏令时。 捆绑到本书的代码包含此解决方案。

# 从 JDK 8 开始

新的 Java Date-Time API 提供了解决此问题的新杠杆。

在第一步中，可以通过`ZoneId`类获得可用时区 ID，如下所示：

```
Set<String> zoneIds = ZoneId.getAvailableZoneIds();
```

在第二步，每个时区 ID 应用于创建`ZoneId`实例。 这可以通过`ZoneId.of(String zoneId)`方法来实现：

```
ZoneId zoneid = ZoneId.of(*current_zone_Id*);
```

在第三步，每个`ZoneId`可用于获得特定于所识别的区域的时间。 这意味着需要“实验室大鼠”参考日期 - 时间。 通过`LocalDateTime.atZone()`将此参考日期（没有时区，`LocalDateTime.now()`）与给定的时区（`ZoneId`）组合，以获取`ZoneDateTime`（是时区的日期时间） 知道的）：

```
LocalDateTime now = LocalDateTime.now();
ZonedDateTime zdt = now.atZone(ZoneId.of(*zone_id_instance*));
```

考虑到时区规则，`atZone()`方法尽可能地与日期时间相匹配，例如夏令时。

在第四步，代码可以利用`ZonedDateTime`以便提取 UTC 偏移量（例如，对于 Europe / Bucharest，UTC 偏移量为+02：00）：

```
String utcOffset = zdt.getOffset().getId().replace("Z", "+00:00");
```

`getId()`方法返回归一化区域偏移 ID。 +00：00 偏移作为`Z`字符返回; 因此，代码需要快速替换+00：00 的`Z`，以便与其他偏移量对齐，这尊重格式+ hh：mm 或+ hh：mm：ss。

现在，让我们将这些步骤加入辅助方法：

```
public static List<String> fetchTimeZones(OffsetType type) {

  List<String> timezones = new ArrayList<>();
  Set<String> zoneIds = ZoneId.getAvailableZoneIds();
  LocalDateTime now = LocalDateTime.now();

  zoneIds.forEach((zoneId) -> {
    timezones.add("(" + type + now.atZone(ZoneId.of(zoneId))
      .getOffset().getId().replace("Z", "+00:00") + ") " + zoneId);
  });

  return timezones;
}
```

假设此方法生存在`DateTimes`类中，获得以下代码：

```
List<String> timezones 
  = DateTimes.fetchTimeZones(DateTimes.OffsetType.GMT);
Collections.sort(timezones); // optional sort
timezones.forEach(System.out::println);
```

此外，显示了输出快照，如下所示：

```
(GMT+00:00) Africa/Abidjan
(GMT+00:00) Africa/Accra
(GMT+00:00) Africa/Bamako
...
(GMT+11:00) Australia/Tasmania
(GMT+11:00) Australia/Victoria
...
```

# 67.在所有可用时区获取本地日期时间

可以通过以下步骤获得此问题的解决方案：

1.  获取本地日期时间。
2.  获取可用时区。
3.  在 JDK 8 之前，使用`SimpleDateFormat` `setTimeZone()`方法。
4.  从 JDK 8 开始，使用`ZonedDateTime`。

# 在 JDK 8 之前

在 JDK 8 之前，快速解决当前的本地日期时间是调用`Date`空构造函数。 此外，使用`Date`在所有可用时区中显示它，可以通过`TimeZone`类获得。 捆绑到本书的代码包含此解决方案。

# 从 JDK 8 开始

从 JDK 8 开始，一个方便的解决方案来获取默认时区中当前的本地日期时间是调用`ZonedDateTime.now()`方法：

```
ZonedDateTime zlt = ZonedDateTime.now();
```

因此，这是默认时区中的当前日期。 此外，此日期应显示在通过`ZoneId`类中获得的所有可用时区：

```
Set<String> zoneIds = ZoneId.getAvailableZoneIds();
```

最后，代码可以循环`zoneIds`，并且对于每个区域 ID，它可以调用`ZonedDateTime.withZoneSameInstant(ZoneId zone)`方法。 此方法返回与不同时区的此日期时间的副本，保留即时：

```
public static List<String> localTimeToAllTimeZones() {

  List<String> result = new ArrayList<>();
  Set<String> zoneIds = ZoneId.getAvailableZoneIds();
  DateTimeFormatter formatter 
    = DateTimeFormatter.ofPattern("yyyy-MMM-dd'T'HH:mm:ss a Z");
  ZonedDateTime zlt = ZonedDateTime.now();

  zoneIds.forEach((zoneId) -> {
    result.add(zlt.format(formatter) + " in " + zoneId + " is "
      + zlt.withZoneSameInstant(ZoneId.of(zoneId))
        .format(formatter));
  });

  return result;
}
```

此方法的输出快照可以如下：

```
2019-Feb-26T14:26:30 PM +0200 in Africa/Nairobi 
  is 2019-Feb-26T15:26:30 PM +0300
2019-Feb-26T14:26:30 PM +0200 in America/Marigot 
  is 2019-Feb-26T08:26:30 AM -0400
...
2019-Feb-26T14:26:30 PM +0200 in Pacific/Samoa 
  is 2019-Feb-26T01:26:30 AM -1100
```

# 68.显示有关飞行的日期时间信息

本节中提出的解决方案将显示下列信息，其中包括从澳大利亚珀斯到布加勒斯特，欧洲的 15 小时和 30 分钟的航班：

*   UTC 日期时间在出发和抵达时
*   珀斯日期时间在出发和抵达布加勒斯特
*   布加勒斯特日期 - 时间在出发和抵达时

让我们假设珀斯的参考出发日期时间是 2019 年 2 月 26 日，16:00（或下午 4:00）：

```
LocalDateTime ldt = LocalDateTime.of(
  2019, Month.FEBRUARY, 26, 16, 00);
```

首先，让我们将这个日期与澳大利亚/珀斯（+08：00）相结合。 这将导致特定于澳大利亚/珀斯的`ZonedDateTime`对象（这是珀斯在出发时的时钟日期和时间）：

```
// 04:00 PM, Feb 26, 2019 +0800 Australia/Perth
ZonedDateTime auPerthDepart 
  = ldt.atZone(ZoneId.of("Australia/Perth"));
```

此外，让我们加 15 小时 30 分钟到`ZonedDateTime`。 由此产生的`ZonedDateTime`代表珀斯的日期时间（这是抵达布加勒斯特时的时钟日期和时间）：

```
// 07:30 AM, Feb 27, 2019 +0800 Australia/Perth
ZonedDateTime auPerthArrive 
  = auPerthDepart.plusHours(15).plusMinutes(30);
```

现在，让我们在珀斯的出发日期时间计算布加勒斯特的日期时间。 基本上，以下代码表达了来自布加勒斯特时区的珀斯时区的出发日期时间：

```
// 10:00 AM, Feb 26, 2019 +0200 Europe/Bucharest
ZonedDateTime euBucharestDepart 
  = auPerthDepart.withZoneSameInstant(ZoneId.of("Europe/Bucharest"));
```

最后，让我们在抵达时计算布加勒斯特的日期时间。 以下代码表示来自布加勒斯特时区的珀斯时区的到达日期 - 时间：

```
// 01:30 AM, Feb 27, 2019 +0200 Europe/Bucharest
ZonedDateTime euBucharestArrive 
  = auPerthArrive.withZoneSameInstant(ZoneId.of("Europe/Bucharest"));
```

如下图所示，距离珀斯出发的 UTC 时间是上午 8:00，而 UTC 时间抵达布加勒斯特是 11:30 PM：

![](img/09ecaf27-f809-42b1-8858-ecf44aa33d5f.png)

这些时间可以很容易地提取为`OffsetDateTime`，如下所示：

```
// 08:00 AM, Feb 26, 2019
OffsetDateTime utcAtDepart = auPerthDepart.withZoneSameInstant(
  ZoneId.of("UTC")).toOffsetDateTime();

// 11:30 PM, Feb 26, 2019
OffsetDateTime utcAtArrive = auPerthArrive.withZoneSameInstant(
  ZoneId.of("UTC")).toOffsetDateTime();
```

# 69.将 UNIX 时间戳转换为日期时间

对于此解决方案，假设以下 UNIX 时间戳-1573768800。 此时间戳相当于以下内容：

*   11/14/2019 @ 10:00（UTC）
*   ISO-8601 中的 2019-11-14T22：00：00 + 00：00
*   您，2019 年 11 月 14 日 22:00:00 +0000 在 COFC 822,1036,1123,282
*   星期四，14-11 月 19 日 - 19:00:00 UTC 在 RFC 2822
*   2019-11-14T22：00：00 + 00：00 在 RFC 3339 中

为了将 UNIX 时间戳转换为日期时间，重要的是要知道 UNIX 时间戳分辨率是否有关秒，而`java.util.Date`需要毫秒。 因此，通过将 UNIX 时间戳乘以 1,000，通过将 UNIX 时间戳乘以 1,000，解决从 UNIX 时间戳获取`Date`对象的解决方案需要转换从秒到毫秒为 1,000 示例：

```
long unixTimestamp = 1573768800;

// Fri Nov 15 00:00:00 EET 2019 - in the default time zone
Date date = new Date(unixTimestamp * 1000L);

// Fri Nov 15 00:00:00 EET 2019 - in the default time zone
Date date = new Date(TimeUnit.MILLISECONDS
  .convert(unixTimestamp, TimeUnit.SECONDS));
```

从 JDK 8 开始，`Date`类使用`from(Instant instant)`方法。 此外，`Instant`类附带了`ofEpochSecond(long epochSecond)`方法，它返回`Instant`的实例，使用 1970-01-01T00：00：00z：00：00z：

```
// 2019-11-14T22:00:00Z in UTC
Instant instant = Instant.ofEpochSecond(unixTimestamp);

// Fri Nov 15 00:00:00 EET 2019 - in the default time zone
Date date = Date.from(instant);
```

如前一个示例中获得的即时可用于创建`LocalDateTime`或`ZonedDateTime`，如下所示：

```
// 2019-11-15T06:00
LocalDateTime date = LocalDateTime
  .ofInstant(instant, ZoneId.of("Australia/Perth"));

// 2019-Nov-15 00:00:00 +0200 Europe/Bucharest
ZonedDateTime date = ZonedDateTime
  .ofInstant(instant, ZoneId.of("Europe/Bucharest"));
```

# 70.找到本月的第一个/最后一天

此问题的正确解决方案将依赖于 JDK 8，`Temporal`和`TemporalAdjuster`接口。

`Temporal`界面坐在日期时间的表示背后。 换句话说，表示日期和/或时间实现此接口的类。 例如，以下类只是实现此界面的一些类：

*   `LocalDate`（日期没有时区的 ISO-8601 日历系统）
*   `LocalTime`（没有时区在 ISO-8601 日历系统中的时间）
*   `LocalDateTime`（没有 ISO-8601 日历系统中没有时区的日期时间）
*   `ZonedDateTime`（日期 - 时间区域在 ISO-8601 日历系统中的时区），等等
*   `OffsetDateTime`（在 ISO-8601 日历系统中的 UTC / Greenwich 的偏移日期时间）
*   `HijrahDate`（日历系统的日期）

`TemporalAdjuster`类是一个功能界面，定义可用于调整`Temporal`对象的策略。 除了定义自定义策略的可能性之外，`TemporalAdjuster`类提供了几种预定义的策略，如下所示（文档包含整个列表，这非常令人印象深刻）：

*   `firstDayOfMonth()`（返回当月的第一天）
*   `lastDayOfMonth()`（返回当月的最后一天）
*   `firstDayOfNextMonth()`（返回下个月的第一天）
*   `firstDayOfNextYear()`（返回明年的第一天）

请注意，前面列表中的前两个调节器正是此问题所需的。

考虑一个修复 - `LocalDate`：

```
LocalDate date = LocalDate.of(2019, Month.FEBRUARY, 27);
```

而且，让我们看看 2 月的第一个/最后几天是：

```
// 2019-02-01
LocalDate firstDayOfFeb 
  = date.with(TemporalAdjusters.firstDayOfMonth());

// 2019-02-28
LocalDate lastDayOfFeb 
  = date.with(TemporalAdjusters.lastDayOfMonth());
```

看起来依靠预定义的策略非常简单。 但是，让我们假设问题请求您在 2019 年 3 月 20 日之后找到 21 天的日期，这是 2019 年 3 月 20 日。对于此问题，没有预定义的策略，因此需要自定义策略。 解决此问题的解决方案可以依赖于 Lambda 表达式，如以下辅助方法所示：

```
public static LocalDate getDayAfterDays(
    LocalDate startDate, int days) {

  Period period = Period.ofDays(days);
  TemporalAdjuster ta = p -> p.plus(period);
  LocalDate endDate = startDate.with(ta);

  return endDate;
}
```

如果此方法生存在名为`DateTimes`的类中，则以下调用将返回预期结果：

```
// 2019-03-20
LocalDate datePlus21Days = DateTimes.getDayAfterDays(date, 21);
```

遵循相同的技术，但依赖于`static`工厂方法`ofDateAdjuster()`，以下代码片段定义了一个静态调整器，返回星期六下降的下一个日期：

```
static TemporalAdjuster NEXT_SATURDAY 
    = TemporalAdjusters.ofDateAdjuster(today -> {

  DayOfWeek dayOfWeek = today.getDayOfWeek();

  if (dayOfWeek == DayOfWeek.SATURDAY) {
    return today;
  }

  if (dayOfWeek == DayOfWeek.SUNDAY) {
    return today.plusDays(6);
  }

  return today.plusDays(6 - dayOfWeek.getValue());
});
```

让我们在 2019 年 2 月 27 日（下一个星期六是 2019 年 3 月 2 日）拨打这种方法：

```
// 2019-03-02
LocalDate nextSaturday = date.with(NEXT_SATURDAY);
```

最后，此功能界面定义了名为`adjustInto()`的`abstract`方法。 通过将`Temporal`对象传递给它，可以在自定义实现中覆盖此方法，如下所示：

```
public class NextSaturdayAdjuster implements TemporalAdjuster {

  @Override
  public Temporal adjustInto(Temporal temporal) {

    DayOfWeek dayOfWeek = DayOfWeek
      .of(temporal.get(ChronoField.DAY_OF_WEEK));

    if (dayOfWeek == DayOfWeek.SATURDAY) {
      return temporal;
    }

    if (dayOfWeek == DayOfWeek.SUNDAY) {
      return temporal.plus(6, ChronoUnit.DAYS);
    }

    return temporal.plus(6 - dayOfWeek.getValue(), ChronoUnit.DAYS);
  }
}
```

这是使用示例：

```
NextSaturdayAdjuster nsa = new NextSaturdayAdjuster();

// 2019-03-02
LocalDate nextSaturday = date.with(nsa);
```

# 71.定义/提取区域偏移

通过*偏移*，了解从 GMT / UTC 时间添加/减去所需的时间量，以便获得全球特定区域的日期时间（例如，澳大利亚珀斯 ）。 通常，将区域偏移印刷为固定的小时数和分钟：+02：00，-08：30，+0400，UTC + 01：00 等。

因此，简而言之，区域偏移是时区与 GMT / UTC 不同的时间量。

# 在 JDK 8 之前

在 JDK 8 之前，可以通过`java.util.TimeZone`来定义时区。 通过此时区，代码可以通过`TimeZone.getRawOffset()`方法（*原始*部分来自此方法未考虑夏令时的事实）获取区域偏移量。 捆绑到本书的代码包含此解决方案。

# 从 JDK 8 开始

从 JDK 8 开始，有两种课程负责处理时区表示。 首先，存在`java.time.ZoneId`，它代表了一个时区，如雅典，欧洲和第二个存在`java.time.ZoneOffset`（扩展`ZoneId`），它表示具有 GMT 指定时区的固定时间（偏移量） /世界标准时间。

新的 Java Date-Time API 默认处理夏令时; 因此，具有夏季冬季的区域，使用夏令时的冬季周期将具有两个`ZoneOffset`类。

可以轻松获得 UTC 区域偏移，如下所示（这是+00：00，在 Java 中表示`Z`字符）：

```
// Z
ZoneOffset zoneOffsetUTC = ZoneOffset.UTC;
```

系统默认时区也可以通过`ZoneOffset`类获取：

```
// Europe/Athens
ZoneId defaultZoneId = ZoneOffset.systemDefault();
```

为了将区域偏移与夏令时，代码需要与它关联日期时间。 例如，关联 A `LocalDateTime`类（也可以使用`Instant`），如下所示：

```
// by default it deals with the Daylight Saving Times
LocalDateTime ldt = LocalDateTime.of(2019, 6, 15, 0, 0);
ZoneId zoneId = ZoneId.of("Europe/Bucharest");

// +03:00
ZoneOffset zoneOffset = zoneId.getRules().getOffset(ldt);
```

区域偏移也可以从字符串获得。 例如，以下代码获取+02：00 的区域偏移：

```
ZoneOffset zoneOffsetFromString = ZoneOffset.of("+02:00");
```

这是一种非常方便的方法，可以快速添加到支持区域偏移的`Temporal`对象的区域偏移量。 例如，使用它将区域偏移到`OffsetTime`和`OffsetDateTime`（方便的方法，用于在数据库中存储日期，或通过电线发送）：

```
OffsetTime offsetTime = OffsetTime.now(zoneOffsetFromString);
OffsetDateTime offsetDateTime 
  = OffsetDateTime.now(zoneOffsetFromString);
```

我们问题的另一种解决方案是依赖于定义`ZoneOffset`从小时，分钟和秒。 `ZoneOffset`的一个帮助方法是专用于此：

```
// +08:30 (this was obtained from 8 hours and 30 minutes)
ZoneOffset zoneOffsetFromHoursMinutes 
  = ZoneOffset.ofHoursMinutes(8, 30);
```

在`ZoneOffset.ofHoursMinutes()`旁边，存在`ZoneOffset.ofHours()`，`ofHoursMinutesSeconds()`和`ofTotalSeconds()`。

最后，每个支持区域偏移的对象都提供了一个方便的`getOffset()`方法。 例如，以下代码从前面的`offsetDateTime`对象中获取区域偏移量：

```
// +02:00
ZoneOffset zoneOffsetFromOdt = offsetDateTime.getOffset();
```

# 72.在日期和时间之间转换

此处介绍的解决方案将涵盖以下`Temporal`类`Instant`，`LocalDate`，`LocalDateTime`，`ZonedDateTime`，`OffsetDateTime`，`LocalTime`和`OffsetTime`。

# 日期 - 瞬发

为了从`Date`转换为`Instant`，解决方案可以依赖于`Date.toInstant()`方法。 反向可以通过`Date.from(Instant instant)`方法来完成：

*   `Date`可以这样完成`Instant`：

```
Date date = new Date();

// e.g., 2019-02-27T12:02:49.369Z, UTC
Instant instantFromDate = date.toInstant();
```

*   `Instant`可以这样完成`Date`：

```
Instant instant = Instant.now();

// Wed Feb 27 14:02:49 EET 2019, default system time zone
Date dateFromInstant = Date.from(instant);
```

请记住，`Date`不是时区感知，但它显示在系统默认时区（例如，通过`toString()`）。 `Instant`具有 UTC 时区。

让我们在两个实用程序方法中快速包装这些代码片段，在实用程序类 - `DateConverters`中定义：

```
public static Instant dateToInstant(Date date) {

  return date.toInstant();
}

public static Date instantToDate(Instant instant) {

  return Date.from(instant);
}
```

此外，让我们使用以下屏幕截图的方法丰富此类：

![](img/ae07c212-3c31-4d8f-91b1-b494d5b9d393.png)

从屏幕截图`DEFAULT_TIME_ZONE`的常数是系统默认时区：

```
public static final ZoneId DEFAULT_TIME_ZONE = ZoneId.systemDefault();
```

# 日期 - LocalDate.

可以通过`Instant`对象将`Date`对象转换为`LocalDate`。 一旦我们从给定的`Date`对象获得了`Instant`对象，解决方案可以应用于系统默认时区，并调用`toLocaleDate()`方法：

```
// e.g., 2019-03-01
public static LocalDate dateToLocalDate(Date date) {

  return dateToInstant(date).atZone(DEFAULT_TIME_ZONE).toLocalDate();
}
```

从`LocalDate`转换为`Date`应考虑到`LocalDate`不包含作为`Date`的时间分量，因此解决方案必须向一天开始时提供时间分量（更多细节可以是 发现在 S *挞和一天结束*问题）：

```
// e.g., Fri Mar 01 00:00:00 EET 2019
public static Date localDateToDate(LocalDate localDate) {

  return Date.from(localDate.atStartOfDay(
    DEFAULT_TIME_ZONE).toInstant());
}
```

# 数据 - Olocaltime.

从`Date`转换为`DateLocalTime`与从`Date`转换为`LocalDate`的情况相同，除了解决方案应调用`toLocalDateTime()`方法如下：

```
// e.g., 2019-03-01T07:25:25.624
public static LocalDateTime dateToLocalDateTime(Date date) {

  return dateToInstant(date).atZone(
    DEFAULT_TIME_ZONE).toLocalDateTime();
}
```

从`LocalDateTime`转换为`Date`是简单的。 只需应用系统默认时区并调用`toInstant()`：

```
// e.g., Fri Mar 01 07:25:25 EET 2019
public static Date localDateTimeToDate(LocalDateTime localDateTime) {

  return Date.from(localDateTime.atZone(
    DEFAULT_TIME_ZONE).toInstant());
}
```

# 日期 - ZonedDatetime.

将`Date`转换为`ZonedDateTime`可以通过从给定`Date`对象和系统默认时区获得的`Instant`对象来完成：

```
// e.g., 2019-03-01T07:25:25.624+02:00[Europe/Athens]
public static ZonedDateTime dateToZonedDateTime(Date date) {

  return dateToInstant(date).atZone(DEFAULT_TIME_ZONE);
}
```

将`ZonedDateTime`转换为`Date`只是将`ZonedDateTime`转换为`Instant`：

```
// e.g., Fri Mar 01 07:25:25 EET 2019
public static Date zonedDateTimeToDate(ZonedDateTime zonedDateTime) {

  return Date.from(zonedDateTime.toInstant());
}
```

# 日期 - offsetDateTime.

从`Date`转换为`OffsetDateTime`依赖于`toOffsetDateTime()`方法：

```
// e.g., 2019-03-01T07:25:25.624+02:00
public static OffsetDateTime dateToOffsetDateTime(Date date) {

  return dateToInstant(date).atZone(
    DEFAULT_TIME_ZONE).toOffsetDateTime();
}
```

从`OffsetDateTime`到`Date`转换的方法需要两个步骤。 首先，将`OffsetDateTime`转换为`LocalDateTime`。 其次，使用相应的偏移将`LocalDateTime`转换为`Instant`：

```
// e.g., Fri Mar 01 07:55:49 EET 2019
public static Date offsetDateTimeToDate(
    OffsetDateTime offsetDateTime) {

  return Date.from(offsetDateTime.toLocalDateTime()
    .toInstant(ZoneOffset.of(offsetDateTime.getOffset().getId())));
}
```

# 日期 - localtime.

将`Date`转换为`LocalTime`可以依赖于`LocalTime.toInstant()`方法，如下所示：

```
// e.g., 08:03:20.336
public static LocalTime dateToLocalTime(Date date) {

  return LocalTime.ofInstant(dateToInstant(date), DEFAULT_TIME_ZONE);
}
```

将`LocalTime`转换为`Date`应考虑到`LocalTime`没有日期组件。 这意味着该解决方案应在 1970 年 1 月 1 日，纪要地区设定日期：

```
// e.g., Thu Jan 01 08:03:20 EET 1970
public static Date localTimeToDate(LocalTime localTime) {

  return Date.from(localTime.atDate(LocalDate.EPOCH)
    .toInstant(DEFAULT_TIME_ZONE.getRules()
      .getOffset(Instant.now())));
}
```

# 日期 - offsettime.

将`Date`转换为`OffsetTime`可以依赖于`OffsetTime.toInstant()`方法，如下所示：

```
// e.g., 08:03:20.336+02:00
public static OffsetTime dateToOffsetTime(Date date) {

  return OffsetTime.ofInstant(dateToInstant(date), DEFAULT_TIME_ZONE);
}
```

将`OffsetTime`转换为`Date`应考虑到`OffsetTime`没有日期组件。 这意味着该解决方案应在 1970 年 1 月 1 日，SEMOCH 设定日期：

```
// e.g., Thu Jan 01 08:03:20 EET 1970
public static Date offsetTimeToDate(OffsetTime offsetTime) {

  return Date.from(offsetTime.atDate(LocalDate.EPOCH).toInstant());
}
```

# 73.迭代一系列日期

让我们假设该范围由开始日期，2019 年 2 月 1 日和结束日期，2019 年 2 月 21 日。该问题的解决方案应循环[2019 年 2 月 1 日，2019 年 2 月 21 日 2 月 21 日 2 月 21 日 2 月 21 日）间隔及一天的步骤 打印屏幕上的每个日期。 基本上，有两个主要问题可以解决：

*   一旦开始日期与结束日期相等，停止循环。
*   将开始日期一天增加至结束日期。

# 在 JDK 8 之前

在 JDK 8 之前，解决方案可以依赖于`Calendar`实用类。 捆绑到本书的代码包含此解决方案。

# 从 JDK 8 开始

首先，从 JDK 8 开始，日期可以很容易地定义为`LocalDate`，而无需`Calendar`：

```
LocalDate startLocalDate = LocalDate.of(2019, 2, 1);
LocalDate endLocalDate = LocalDate.of(2019, 2, 21);
```

一旦开始日期与结束日期相等，我们通过`LocalDate.isBefore(ChronoLocalDate other)`方法停止循环。 此标志方法检查此日期是否在给定日期之前。

每天增加开始日期，直到最终日期可以使用`LocalDate.plusDays(long daysToAdd)`方法完成。 在`for`循环中使用这两种方法导致以下代码：

```
for (LocalDate date = startLocalDate; 
       date.isBefore(endLocalDate); date = date.plusDays(1)) {

  // do something with this day
  System.out.println(date);
}
```

输出的快照应如下：

```
2019-02-01
2019-02-02
2019-02-03
...
2019-02-20
```

# 从 JDK 9 开始

JDK 9 可以使用单行代码来解决此问题。 由于新的`LocalDate.datesUntil(LocalDate endExclusive)`方法，这是可能的。 此方法以一天的增量步骤返回`Stream<LocalDate>`：

```
startLocalDate.datesUntil(endLocalDate).forEach(System.out::println);
```

如果增量步骤应该在日期，数周，月或几年中表达，那么依靠`LocalDate.datesUntil(LocalDate endExclusive, Period step)`。 例如，1 周的增量步骤可以指定如下：

```
startLocalDate.datesUntil(endLocalDate, Period.ofWeeks(1)).forEach(System.out::println);
```

输出应（周 1-8,8-15 周）如下：

```
2019-02-01
2019-02-08
2019-02-15
```

# 74.计算年龄

可能是两个日期之间最常用的差异情况是关于计算一个人的年龄。 通常，一个人的年龄是多年的，但有时应该提供几个月，甚至几天。

# 在 JDK 8 之前

在 JDK 8 之前，尝试提供良好的解决方案可以依赖于`Calendar`和/或`SimpleDateFormat`。 捆绑到本书的代码包含这样的解决方案。

# 从 JDK 8 开始

更好的想法是升级到 JDK 8，并依赖于以下代码的简单片段：

```
LocalDate startLocalDate = LocalDate.of(1977, 11, 2);
LocalDate endLocalDate = LocalDate.now();

long years = ChronoUnit.YEARS.between(startLocalDate, endLocalDate);
```

由于`Period`课程，增加了几个月和结果的结果也很容易完成：

```
Period periodBetween = Period.between(startLocalDate, endLocalDate);
```

现在，通过`periodBetween.getYears()`，`periodBetween.getMonths()`和`periodBetween.getDays()`可以获得多年来的年龄，月和日。

例如，在目前的日期，2019 年 2 月 28 日和 1977 年 11 月 2 日之间，我们有 41 岁，3 个月和 26 天。

# 75.一天开始和结束

在 JDK 8 中，试图找到一天的开始/结束，可以通过几种方式完成。

让我们考虑一下通过`LocalDate`表示的一天：

```
LocalDate localDate = LocalDate.of(2019, 2, 28);
```

找到 2019 年 2 月 28 日开始的解决方案依赖于名为`atStartOfDay()`的方法。 此方法在午夜 00:00 的时间返回`LocalDateTime`：

```
// 2019-02-28T00:00
LocalDateTime ldDayStart = localDate.atStartOfDay();
```

或者，解决方案可以使用`of(LocalDate date, LocalTime time)`方法。 该方法将给定日期和时间组合到`LocalDateTime`中。 所以，如果通过的时间是`LocalTime.MIN`（在一天开始时午夜的时间）那么结果将如下：

```
// 2019-02-28T00:00
LocalDateTime ldDayStart = LocalDateTime.of(localDate, LocalTime.MIN);
```

可以使用至少两个解决方案获得`LocalDate`对象的日期结束。 一种解决方案包括依赖于`LocalDate.atTime(LocalTime time)`。 结果`LocalDateTime`可以代表本日期的组合与一天结束，如果解决方案通过作为参数，`LocalTime.MAX`（在一天结束时午夜之前的时间）：

```
// 2019-02-28T23:59:59.999999999
LocalDateTime ldDayEnd = localDate.atTime(LocalTime.MAX);
```

或者，通过`atDate(LocalDate date)`方法，解决方案可以将`LocalTime.MAX`与给定日期组合：

```
// 2019-02-28T23:59:59.999999999
LocalDateTime ldDayEnd = LocalTime.MAX.atDate(localDate);
```

由于`LocalDate`没有时区的概念，前面的示例容易出现由不同的角落情况引起的问题，例如，夏令时。 一些夏令时期在午夜（00:00 变为 01:00 AM）时施加了一个小时的变化，这意味着当天的开始是在 01:00:00，而不是 00:00:00。 为了缓解这些问题，请考虑将前面的示例扩展到使用`ZonedDateTime`的以下示例，这是夏令时感知：

```
// 2019-02-28T00:00+08:00[Australia/Perth]
ZonedDateTime ldDayStartZone 
  = localDate.atStartOfDay(ZoneId.of("Australia/Perth"));

// 2019-02-28T00:00+08:00[Australia/Perth]
ZonedDateTime ldDayStartZone = LocalDateTime
  .of(localDate, LocalTime.MIN).atZone(ZoneId.of("Australia/Perth"));

// 2019-02-28T23:59:59.999999999+08:00[Australia/Perth]
ZonedDateTime ldDayEndZone = localDate.atTime(LocalTime.MAX)
  .atZone(ZoneId.of("Australia/Perth"));

// 2019-02-28T23:59:59.999999999+08:00[Australia/Perth]
ZonedDateTime ldDayEndZone = LocalTime.MAX.atDate(localDate)
  .atZone(ZoneId.of("Australia/Perth"));
```

现在，让我们考虑以下 - `LocalDateTime`，2019 年 2 月 28 日，18:00:00：

```
LocalDateTime localDateTime = LocalDateTime.of(2019, 2, 28, 18, 0, 0);
```

显而易见的解决方案是从`LocalDateTime`中提取`LocalDate`并应用先前的方法。 另一种解决方案依赖于`Temporal`接口（包括`LocalDate`）的每个实现都可以利用`with(TemporalField field, long newValue)`方法。 主要是，`with()`方法将此日期的副本与指定的字段`ChronoField`返回，设置为`newValue`。 因此，如果解决方案设置`ChronoField.NANO_OF_DAY`（一天的纳秒）作为`LocalTime.MIN`，那么结果将是一天的开始。 这里的诀窍是通过`toNanoOfDay()`将`LocalTime.MIN`转换为纳秒，如下所示：

```
// 2019-02-28T00:00
LocalDateTime ldtDayStart = localDateTime
  .with(ChronoField.NANO_OF_DAY, LocalTime.MIN.toNanoOfDay());
```

这相当于以下内容：

```
LocalDateTime ldtDayStart 
   = localDateTime.with(ChronoField.HOUR_OF_DAY, 0);
```

一天结束很相似。 刚刚通过`LocalTime.MAX`而不是`MIN`：

```
// 2019-02-28T23:59:59.999999999
LocalDateTime ldtDayEnd = localDateTime
  .with(ChronoField.NANO_OF_DAY, LocalTime.MAX.toNanoOfDay());
```

这相当于以下内容：

```
LocalDateTime ldtDayEnd = localDateTime.with(
  ChronoField.NANO_OF_DAY, 86399999999999L);
```

与`LocalDate`一样，`LocalDateTime`对象不知道时区。 在这种情况下，`ZonedDateTime`可以帮助：

```
// 2019-02-28T00:00+08:00[Australia/Perth]
ZonedDateTime ldtDayStartZone = localDateTime
  .with(ChronoField.NANO_OF_DAY, LocalTime.MIN.toNanoOfDay())
  .atZone(ZoneId.of("Australia/Perth"));

// 2019-02-28T23:59:59.999999999+08:00[Australia/Perth]
ZonedDateTime ldtDayEndZone = localDateTime
  .with(ChronoField.NANO_OF_DAY, LocalTime.MAX.toNanoOfDay())
  .atZone(ZoneId.of("Australia/Perth"));
```

作为这里的奖励，让我们看看与 UTC 的一天开始/结束。 除了依赖于`with()`方法的解决方案旁边，另一种解决方案可以依赖于`toLocalDate()`，如下所示：

```
// e.g., 2019-02-28T09:23:10.603572Z
ZonedDateTime zdt = ZonedDateTime.now(ZoneOffset.UTC);

// 2019-02-28T00:00Z
ZonedDateTime dayStartZdt 
  = zdt.toLocalDate().atStartOfDay(zdt.getZone());

// 2019-02-28T23:59:59.999999999Z
ZonedDateTime dayEndZdt = zdt.toLocalDate()
  .atTime(LocalTime.MAX).atZone(zdt.getZone());
```

由于`java.util.Date`和`Calendar`的许多问题，建议避免尝试与它们的解决方案来实现解决这个问题。

# 76.两个日期之间的差异

计算两个日期之间的差异是一个非常常见的任务（例如，请参见*计算年龄*部分）。 让我们看一下可以用于在毫秒，秒，小时等的两个日期之间获得差异的其他方法。

# 在 JDK 8 之前

推荐的方式来表示日期时间信息是通过`java.util.Date`和`Calendar`类。 计算计算的最简单差异是以毫秒表示的。 捆绑到本书的代码包含这样的解决方案。

# 从 JDK 8 开始

从 JDK 8 开始，推荐的表示日期时间信息是通过`Temporal`（例如，`DateTime`，`DateLocalTime`，`ZonedDateTime`等）。

让我们假设以下两个`LocalDate`对象，2018 年 1 月 1 日和 2019 年 3 月 1 日：

```
LocalDate ld1 = LocalDate.of(2018, 1, 1);
LocalDate ld2 = LocalDate.of(2019, 3, 1);
```

计算这两个`Temporal`对象之间的差异的最简单方法是通过`ChronoUnit`类。 除了代表标准的日期期间单位（HTG2]的标准集合中，有几种方便方法，包括`between(Temporal t1Inclusive, Temporal t2Exclusive)`。 随着其名称表明，`between()`方法计算两个`Temporal`对象之间的时间量。 让我们在工作中看到它来计算`ld1`和`ld2`之间的差异在几天，月份和年份：

```
// 424
long betweenInDays = Math.abs(ChronoUnit.DAYS.between(ld1, ld2));

// 14
long betweenInMonths = Math.abs(ChronoUnit.MONTHS.between(ld1, ld2));

// 1
long betweenInYears = Math.abs(ChronoUnit.YEARS.between(ld1, ld2));
```

或者，每个`Temporal`都公开了一个名为`until()`的方法。 实际上，`LocalDate`有两个，一个返回`Period`作为两个日期之间的差异，另一个返回`long`作为指定时间单位中的两个日期之间的差异。 使用返回`Period`的那个如下所示：

```
Period period = ld1.until(ld2);

// Difference as Period: 1y2m0d
System.out.println("Difference as Period: " + period.getYears() + "y" 
  + period.getMonths() + "m" + period.getDays() + "d");
```

使用允许我们指定时间单元的那个如下所示：

```
// 424
long untilInDays = Math.abs(ld1.until(ld2, ChronoUnit.DAYS));

// 14
long untilInMonths = Math.abs(ld1.until(ld2, ChronoUnit.MONTHS));

// 1
long untilInYears = Math.abs(ld1.until(ld2, ChronoUnit.YEARS));
```

`ChronoUnit.convert()`方法在`LocalDateTime`的情况下也是有用的。 让我们考虑以下两个`LocalDateTime`对象 - 2018 年 1 月 1 日 22:15:15，以及 2019 年 3 月 1 日 23:15:15：

```
LocalDateTime ldt1 = LocalDateTime.of(2018, 1, 1, 22, 15, 15);
LocalDateTime ldt2 = LocalDateTime.of(2018, 1, 1, 23, 15, 15);
```

现在，让我们看看`ldt1`和`ldt2`之间的区别，在几分钟内表示：

```
// 60
long betweenInMinutesWithoutZone 
  = Math.abs(ChronoUnit.MINUTES.between(ldt1, ldt2));
```

并且，通过`LocalDateTime.until()`方法在数小时表达时的差异：

```
// 1
long untilInMinutesWithoutZone 
  = Math.abs(ldt1.until(ldt2, ChronoUnit.HOURS));
```

但是，关于`ChronoUnit.between()`和`until()`的真实令人敬畏的事情是他们与`ZonedDateTime`一起使用的事实。 例如，让我们考虑欧洲/布加勒斯特时区和澳大利亚/珀斯时区的`ldt1`，加一小时：

```
ZonedDateTime zdt1 = ldt1.atZone(ZoneId.of("Europe/Bucharest"));
ZonedDateTime zdt2 = zdt1.withZoneSameInstant(
  ZoneId.of("Australia/Perth")).plusHours(1);
```

现在，让我们使用`ChronoUnit.between()`在分钟内表达`zdt1`和`zdt2`之间的差异，而`ZonedDateTime.until()`以在小时内表达`zdt1`和`zdt2`之间的差异：

```
// 60
long betweenInMinutesWithZone 
  = Math.abs(ChronoUnit.MINUTES.between(zdt1, zdt2));

// 1
long untilInHoursWithZone 
  = Math.abs(zdt1.until(zdt2, ChronoUnit.HOURS));
```

最后，让我们重复这种技术，但是对于两个独立的`ZonedDateTime`对象; 获得`ldt1`的一个，一个用于`ldt2`：

```
ZonedDateTime zdt1 = ldt1.atZone(ZoneId.of("Europe/Bucharest"));
ZonedDateTime zdt2 = ldt2.atZone(ZoneId.of("Australia/Perth"));

// 300
long betweenInMinutesWithZone 
  = Math.abs(ChronoUnit.MINUTES.between(zdt1, zdt2));

// 5
long untilInHoursWithZone 
  = Math.abs(zdt1.until(zdt2, ChronoUnit.HOURS));
```

# 77.实施国际象棋时钟

从 JDK 8 开始，`java.time`包具有一个名为`Clock`的抽象类。 此类的主要目的是允许我们在需要时插入不同的时钟（例如，用于测试目的）。 默认情况下，Java 提供了四个实现：`SystemClock`，`OffsetClock`，`TickClock`和`FixedClock`。 对于这些实现中的每一个，`Clock`类中存在`static`方法。 例如，以下代码创建`FixedClock`（始终返回相同的时钟`Instant`）：

```
Clock fixedClock = Clock.fixed(Instant.now(), ZoneOffset.UTC);
```

还有`TickClock`，返回当前`Instant`在给定的时间表的整个秒数滴答：

```
Clock tickClock = Clock.tickSeconds(ZoneId.of("Europe/Bucharest"));
```

还有一种方法可以用来在整个分钟内勾选`tickMinutes()`和通用一个`tick()`，它允许我们指定`Duration`。

A `Clock`类也可能支持时区和偏移，但`Clock`类的最重要方法是`instant()`。 此方法返回`Clock`的即时：

```
// 2019-03-01T13:29:34Z
System.out.println(tickClock.instant());
```

还有`millis()`方法，它以毫秒为单位返回时钟的当前瞬间。

让我们假设我们想要实现一个充当国际象棋时钟的时钟：

![](img/ad6496ac-4425-407c-9a5f-c922283d6bcb.png)

要实现`Clock`类，有几个步骤遵循：

1.  扩展`Clock`类。
2.  实现`Serializable`。
3.  至少从`Clock`继承的抽象方法覆盖。

`Clock`类的骨架如下：

```
public class ChessClock extends Clock implements Serializable {

  @Override
  public ZoneId getZone() {
    ...
  }

  @Override
  public Clock withZone(ZoneId zone) {
    ...
  }

  @Override
  public Instant instant() {
    ...
  }
}
```

我们的`ChessClock`只能与 UTC 一起使用; 将支持其他时间区。 这意味着`getZone()`和`withZone()`方法可以如下实现（当然，这可以在将来修改）：

```
@Override
public ZoneId getZone() {
  return ZoneOffset.UTC;
}

@Override
public Clock withZone(ZoneId zone) {
  throw new UnsupportedOperationException(
    "The ChessClock works only in UTC time zone");
}
```

我们实现的高潮是`instant()`方法。 难度在于管理两个`Instant`，一个用于左侧的播放器，一个用于右侧的播放器（`instantRight`）。 我们可以将每一个调用`instant()`方法相关联，因为当前播放器已经执行了移动，现在是另一个玩家的转弯。 所以，基本上，这个逻辑表明同一个球员不能调用`instant()`两次。 实现此逻辑，`instant()`方法如下：

```
public class ChessClock extends Clock implements Serializable {

  public enum Player {
    LEFT,
    RIGHT
  }

  private static final long serialVersionUID = 1L;

  private Instant instantStart;
  private Instant instantLeft;
  private Instant instantRight;
  private long timeLeft;
  private long timeRight;
  private Player player;

  public ChessClock(Player player) {
    this.player = player;
  }

  public Instant gameStart() {

    if (this.instantStart == null) {
      this.timeLeft = 0;
      this.timeRight = 0;
      this.instantStart = Instant.now();
      this.instantLeft = instantStart;
      this.instantRight = instantStart;
      return instantStart;
    }

    throw new IllegalStateException(
      "Game already started. Stop it and try again.");
  }

  public Instant gameEnd() {

    if (this.instantStart != null) {
      instantStart = null;
      return Instant.now();
    }

    throw new IllegalStateException("Game was not started.");
  }

  @Override
  public ZoneId getZone() {
    return ZoneOffset.UTC;
  }

  @Override
  public Clock withZone(ZoneId zone) {
    throw new UnsupportedOperationException(
      "The ChessClock works only in UTC time zone");
  }

  @Override
  public Instant instant() {

    if (this.instantStart != null) {
      if (player == Player.LEFT) {
        player = Player.RIGHT;

        long secondsLeft = Instant.now().getEpochSecond() 
          - instantRight.getEpochSecond();
        instantLeft = instantLeft.plusSeconds(
          secondsLeft - timeLeft);
        timeLeft = secondsLeft;

        return instantLeft;
      } else {
        player = Player.LEFT;

        long secondsRight = Instant.now().getEpochSecond() 
          - instantLeft.getEpochSecond();
        instantRight = instantRight.plusSeconds(
          secondsRight - timeRight);
        timeRight = secondsRight;

        return instantRight;
      }
    }

    throw new IllegalStateException("Game was not started.");
  }
}
```

因此，根据哪个玩家调用`instant()`方法，代码计算该玩家思考的秒数，直到她/他执行了移动。 此外，代码切换播放器，因此`instant()`的下一个调用将处理其他播放器。

让我们考虑在`2019-03-01T14:02:46.309459Z`开始的国际象棋游戏：

```
ChessClock chessClock = new ChessClock(Player.LEFT);

// 2019-03-01T14:02:46.309459Z
Instant start = chessClock.gameStart();
```

此外，玩家在右翼赢得游戏的播放器之前执行以下动作顺序：

```
Left moved first after 2 seconds: 2019-03-01T14:02:48.309459Z
Right moved after 5 seconds: 2019-03-01T14:02:51.309459Z
Left moved after 6 seconds: 2019-03-01T14:02:54.309459Z
Right moved after 1 second: 2019-03-01T14:02:52.309459Z
Left moved after 2 second: 2019-03-01T14:02:56.309459Z
Right moved after 3 seconds: 2019-03-01T14:02:55.309459Z
Left moved after 10 seconds: 2019-03-01T14:03:06.309459Z
Right moved after 11 seconds and win: 2019-03-01T14:03:06.309459Z
```

看起来时钟已正确注册了玩家的动作。

最后，游戏在 40 秒后结束：

```
Game ended:2019-03-01T14:03:26.350749300Z
Instant end = chessClock.gameEnd();

Game duration: 40 seconds
// Duration.between(start, end).getSeconds();
```

# 概括

任务完成！ 本章提供了与日期和时间信息一起工作的全面概述。 广泛的应用程序必须操纵此类信息。 因此，在工具带下的这些问题上具有解决方案不是可选的。 从`Date`和`Calendar`到`LocalDate`，`LocalTime`，`LocalDateTime`，`ZoneDateTime`，`ZoneDateTime`，`OffsetTime`和`Instant`，以及它们在涉及的日常任务中都很重要，非常有用 日期和时间。

从本章下载应用程序以查看结果并查看其他详细信息。