# 并发 - 深度潜水

本章包括 13 个问题，涉及 Java 并发性，覆盖诸如 Fork / Join Framework，`CompletableFuture`，`ReentrantLock`，`ReentrantReadWriteLock`，`StampedLock`，原子变量，任务取消，可中断方法，线程，以及线程，以及 死锁。 并发是任何开发人员所需的主题之一，在求职面试时不能忽视。 这就是为什么本章和最后一个是如此重要。 在完成本章时，您将对每一个 Java 开发人员所需的并发有相当大的了解。

# 问题

使用以下问题测试您的并发规划实力。 我强烈建议您在转向解决方案并下载示例程序之前尝试举出每个问题：

213.  **可中断方法**：写一个程序，该程序举例说明了处理可中断方法的最佳方法。
214.  **fork / join framework** ：写一个依赖于 fork / join 框架的程序来和列表的元素。 编写依赖于叉/加入框架的程序以在给定位置计算 FibonAcci 号码（例如，f <sub>12</sub> = 144）。 此外，写入一个程序，该程序举例说明了`CountedCompleter`的使用。
215.  **fork /加入框架和`compareAndSetForkJoinTaskTag()` `compareAndSetForkJoinTaskTag()` 在*任务 c* 和*任务 b* ，但*任务 c* 取决于*任务 b* ;因此，*任务 b* 必须只执行一次，而不是两次）。**

216.  **`CompletableFuture`** ：写几个代码片段以通过`CompletableFuture`举例说明异步代码。
217.  **组合多个`CompletableFuture`** **对象**：写几个代码片段以举例说明将多个`CompletableFuture`对象组合在一起的不同解决方案。
218.  **优化繁忙等待**：写下概念证明，以举例说明通过`onSpinWait()`的*忙等待*技术的优化。
219.  **任务取消**：写一个概念证明，该概念证明了用于保持过程的取消状态的`volatile`变量的使用。
220.  `ThreadLocal`：写下概念证明，例证了`ThreadLocal`的使用情况。
221.  **原子变量**：写一个程序，使用多线程应用程序（`Runnable`）计算从 1 到 1,000,000 的整数。
222.  **`ReentrantLock`** ：编写一个程序，使用`ReentrantLock`将整数递增 1 到 1,000,000。
223.  **`ReentrantReadWriteLock`** ：编写一个程序，该程序通过`ReentrantReadWriteLock`模拟读写过程的编排。
224.  **`StampedLock`** ：编写一个程序，该程序通过`StampedLock`模拟读写过程的编排。
225.  **死锁（餐饮哲学家）**：写一个揭示和解决死锁（*循环等待*或*致命的拥抱*）的程序，这可能发生在着名的餐饮哲学家问题中。

# 解决方案

以下部分描述了前一个问题的解决方案。 请记住，几乎不是一个正确的方法来解决特定问题。 此外，请记住，这里所示的解释仅包括解决问题所需的最有趣和重要的细节。 下载示例解决方案以查看其他详细信息，并在 [https://github.com/packtpublishing/java-coding-problems](https://github.com/PacktPublishing/Java-Coding-Problems) 上进行实验。

# 213.中断的方法

通过可中断的方法，我们表示可以抛出`InterruptedException`的阻塞方法，例如`Thread.sleep()`，`BlockingQueue.take()`，`BlockingQueue.poll(long timeout, TimeUnit unit)`等。 阻塞线程通常在**被阻塞**，**等待**，或 **timed_waiting** 状态，如果它被中断，则该方法尝试抛出`InterruptedException`作为 尽快。

由于`InterruptedException`是一份检查的异常，我们必须抓住它和/或抛出它。 换句话说，如果我们的方法调用抛出`InterruptedException`的方法，那么我们必须准备好处理此异常。 如果我们可以抛出它（传播到呼叫者的例外），那么它不是我们的工作了。 来电者必须进一步处理它。 所以，让我们专注于我们必须抓住它的情况。 当我们的代码在`Runnable`内运行时，可能会发生这种情况，这不能抛出异常。

让我们从一个简单的例子开始。 试图通过`poll(long timeout, TimeUnit unit)`从`BlockingQueue`从`poll(long timeout, TimeUnit unit)`中获取元素可以写入如下：

```
try {
  queue.poll(3000, TimeUnit.MILLISECONDS);
} catch (InterruptedException ex) {
  ...
  logger.info(() -> "Thread is interrupted? "
    + Thread.currentThread().isInterrupted());
}
```

尝试轮询来自队列的元素可能导致`InterruptedException`。 有 3,000 毫秒的窗口，其中线程可以中断。 如果发生中断（例如，`Thread.interrupt()`），我们可能会想到认为`catch`块中的调用`Thread.currentThread().isInterrupted()`将返回`true`。 毕竟，我们在一个`InterruptedException catch`块中，所以相信这是有意义的。 实际上，它将返回`false`，答案是在列出的`poll(long timeout, TimeUnit unit)`方法的源代码中如下：

```
1: public E poll(long timeout, TimeUnit unit) 
       throws InterruptedException {
2:   E e = xfer(null, false, TIMED, unit.toNanos(timeout));
3:   if (e != null || !Thread.interrupted())
4:     return e;
5:   throw new InterruptedException();
6: }
```

更确切地说，答案是第 3 行。如果线程被中断，则`Thread.interrupted()`将返回`true`，将导致第 5 行（`throw new InterruptedException()`）。 但是除了测试旁边，如果当前线程中断，`Thread.interrupted()`清除线程的中断状态。 查看以下呼叫继电器的中断线程：

```
Thread.currentThread().isInterrupted(); // true
Thread.interrupted() // true
Thread.currentThread().isInterrupted(); // false
Thread.interrupted() // false
```

请注意，`Thread.currentThread().isInterrupted()`测试此线程是否已被中断而不会影响中断状态。

现在，让我们回到我们的案件。 因此，我们知道线程被中断，因为我们捕获了`InterruptedException`，但是`Thread.interrupted()`清除了中断的状态。 这也意味着我们代码的来电者也不会意识到中断。

我们有责任是良好的公民，并通过调用`interrupt()`方法来恢复中断。 这样，我们的代码的来电者可以看到中断发出并相应行动。 正确的代码可以如下：

```
try {
  queue.poll(3000, TimeUnit.MILLISECONDS);
} catch (InterruptedException ex) {
  ...
  Thread.currentThread().interrupt(); // restore interrupt
}
```

作为一个经验的规则，捕获`InterruptedException`后，不要忘记通过调用`Thread.currentThread().interrupt()`来恢复中断。

让我们解决一个问题，突出了忘记恢复中断的情况。 假设只要当前线程未被中断（例如，`while (!Thread.currentThread().isInterrupted()) { ... }`），那么假设运行的`Runnable`。

在每次迭代时，如果当前线程中断状态为`false`，则尝试从`BlockingQueue`中获取一个元素。

以下代码是实现：

```
Thread thread = new Thread(() -> {

  // some dummy queue
  TransferQueue<String> queue = new LinkedTransferQueue<>();

  while (!Thread.currentThread().isInterrupted()) {
    try {
      logger.info(() -> "For 3 seconds the thread " 
        + Thread.currentThread().getName() 
        + " will try to poll an element from queue ...");

      queue.poll(3000, TimeUnit.MILLISECONDS);
    } catch (InterruptedException ex) {
      logger.severe(() -> "InterruptedException! The thread "
        + Thread.currentThread().getName() + " was interrupted!");
      Thread.currentThread().interrupt();
    }
  }

  logger.info(() -> "The execution was stopped!");
});
```

作为一个来电者（另一个线程），我们开始上面的线程，睡眠 1.5 秒，只是为了在`poll()`方法中的时间进入这个线程，并中断它。 这在以下代码中显示：

```
thread.start();
Thread.sleep(1500);
thread.interrupt();
```

这将导致`InterruptedException`。

记录异常并恢复中断。

在下一步，`while`将`Thread.currentThread().isInterrupted()`评估为`false`并退出。

结果，输出将如下：

```
[18:02:43] [INFO] For 3 seconds the thread Thread-0
                  will try to poll an element from queue ...

[18:02:44] [SEVERE] InterruptedException!
                    The thread Thread-0 was interrupted!

[18:02:45] [INFO] The execution was stopped!
```

现在，让我们评论恢复中断的行：

```
...
} catch (InterruptedException ex) {
  logger.severe(() -> "InterruptedException! The thread " 
    + Thread.currentThread().getName() + " was interrupted!");

  // notice that the below line is commented
  // Thread.currentThread().interrupt();
}
...
```

这次，`while`块将永远运行，因为它的保护条件始终被评估为`true`。

代码不能对中断行动，因此输出将如下：

```
[18:05:47] [INFO] For 3 seconds the thread Thread-0
                  will try to poll an element from queue ...

[18:05:48] [SEVERE] InterruptedException!
                    The thread Thread-0 was interrupted!

[18:05:48] [INFO] For 3 seconds the thread Thread-0
                  will try to poll an element from queue ...
...
```

作为经验的规则，唯一可接受的情况，我们可以吞下中断（未恢复中断）是当我们可以控制整个呼叫堆栈（例如，`extend Thread`）时。

否则，捕获`InterruptedException`也应包含`Thread.currentThread().interrupt()`。

# 214.叉/加入框架

我们已经在*工作窃取线程池*部分中对 Fork / Join Framework 进行了介绍。

主要是，叉/加入框架旨在采取大任务（通常，大量的大量数据）并递归地将（叉）拆分为可以并行执行的较小任务（子组织）。 最后，在完成所有子任务之后，它们的结果在单个结果中组合（加入）。

下图是 Fork-Join Flow 的视觉表示：

![](img/ed4a0d31-b2a0-47cb-bb15-2f7a04f4c2cd.png)

在 API 术语中，可以通过`java.util.concurrent.ForkJoinPool`创建 Fork / Join。

在 JDK 8 之前，建议的方法依赖于`public static`变量，如下所示：

```
public static ForkJoinPool forkJoinPool = new ForkJoinPool();
```

从 JDK 8 开始，我们可以如下所述：

```
ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();
```

两种方法都避免了在单个 JVM 上具有太多池线程的令人不愉快的情况，由创建自己的池的并行操作引起。

对于自定义`ForkJoinPool`，依赖于此类的构造函数。 迄今为止，JDK 9 增加了最全面的（文档中提供的详细信息）。

a `ForkJoinPool`对象操纵任务。 在`ForkJoinPool`中执行的基本类型是`ForkJoinTask<V>`。 更确切地说，执行以下任务：

*   `RecursiveAction`为`void`任务
*   `RecursiveTask<V>`用于返回值的任务
*   `CountedCompleter<T>`对于需要记住待定任务计数的任务

所有三种类型的任务都有一个名为`compute()`的`abstract`方法，其中任务的逻辑被塑造。

可以通过以下方式完成向`ForkJoinPool`提交任务：

*   `execute()`和`submit()`
*   `invoke()`用于分叉任务并等待结果
*   `invokeAll()`用于叉发一堆任务（例如，集合）
*   `fork()`为了排列以异步在池中执行此任务，以及`join()`，用于返回完成计算结果

让我们从通过`RecursiveTask`解决的问题开始。

# 通过计算的 RecursiveTask 总和

为了演示框架的分叉行为，让我们假设我们有一个数字列表，我们希望计算这些数字的总和。 为此，我们递归地拆分（Fork）此列表，只要使用`createSubtasks()`方法大于指定的`THRESHOLD`。 每个任务都将添加到`List<SumRecursiveTask>`中。 最后，该列表通过`invokeAll​(Collection<T> tasks)`方法提交给`ForkJoinPool`。 这是使用以下代码完成的：

```
public class SumRecursiveTask extends RecursiveTask<Integer> {

  private static final Logger logger 
    = Logger.getLogger(SumRecursiveTask.class.getName());
  private static final int THRESHOLD = 10;

  private final List<Integer> worklist;

  public SumRecursiveTask(List<Integer> worklist) {
    this.worklist = worklist;
  }

  @Override
  protected Integer compute() {
    if (worklist.size() <= THRESHOLD) {
      return partialSum(worklist);
    }

    return ForkJoinTask.invokeAll(createSubtasks())
      .stream()
      .mapToInt(ForkJoinTask::join)
      .sum();
  }

  private List<SumRecursiveTask> createSubtasks() {

    List<SumRecursiveTask> subtasks = new ArrayList<>();
    int size = worklist.size();

    List<Integer> worklistLeft 
      = worklist.subList(0, (size + 1) / 2);
    List<Integer> worklistRight 
      = worklist.subList((size + 1) / 2, size);

    subtasks.add(new SumRecursiveTask(worklistLeft));
    subtasks.add(new SumRecursiveTask(worklistRight));

    return subtasks;
  }

  private Integer partialSum(List<Integer> worklist) {

    int sum = worklist.stream()
      .mapToInt(e -> e)
      .sum();

    logger.info(() -> "Partial sum: " + worklist + " = "
      + sum + "\tThread: " + Thread.currentThread().getName());

    return sum;
  }
}
```

为了测试它，我们需要一个列表和`ForkJoinPool`，如下所示：

```
ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();

Random rnd = new Random();
List<Integer> list = new ArrayList<>();

for (int i = 0; i < 200; i++) {
  list.add(1 + rnd.nextInt(10));
}

SumRecursiveTask sumRecursiveTask = new SumRecursiveTask(list);
Integer sumAll = forkJoinPool.invoke(sumRecursiveTask);

logger.info(() -> "Final sum: " + sumAll);
```

可能的输出将是以下内容：

```
...
[15:17:06] Partial sum: [1, 3, 6, 6, 2, 5, 9] = 32
ForkJoinPool.commonPool-worker-9
...
[15:17:06] Partial sum: [1, 9, 9, 8, 9, 5] = 41
ForkJoinPool.commonPool-worker-7
[15:17:06] Final sum: 1084
```

# 通过 cursivetaction 计算纤维组件

通常表示为 *f <sub>n</sub>* ，fibonacci 数字是尊重以下公式的序列：

*f <sub>0</sub> = 0，f <sub>1</sub> = 1，... f <sub>n</sub> = f <sub>n-1</sub> + f <sub>n-2</sub> （n > 1）*

Fibonacci 数字的快照是：

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...

通过`RecursiveAction`实现 Fibonacci 号码可以如下完成：

```
public class FibonacciRecursiveAction extends RecursiveAction {

  private static final Logger logger =
    Logger.getLogger(FibonacciRecursiveAction.class.getName());
  private static final long THRESHOLD = 5;

  private long nr;

  public FibonacciRecursiveAction(long nr) {
    this.nr = nr;
  }

  @Override
  protected void compute() {

    final long n = nr;

    if (n <= THRESHOLD) {
      nr = fibonacci(n);
    } else {
      nr = ForkJoinTask.invokeAll(createSubtasks(n))
        .stream()
        .mapToLong(x -> x.fibonacciNumber())
        .sum();
    }
  }

  private List<FibonacciRecursiveAction> createSubtasks(long n) {

    List<FibonacciRecursiveAction> subtasks = new ArrayList<>();

    FibonacciRecursiveAction fibonacciMinusOne
      = new FibonacciRecursiveAction(n - 1);
    FibonacciRecursiveAction fibonacciMinusTwo
      = new FibonacciRecursiveAction(n - 2);

    subtasks.add(fibonacciMinusOne);
    subtasks.add(fibonacciMinusTwo);

    return subtasks;
  }

  private long fibonacci(long n) {
    logger.info(() -> "Number: " + n 
      + " Thread: " + Thread.currentThread().getName());

    if (n <= 1) {
      return n;
    }

    return fibonacci(n - 1) + fibonacci(n - 2);
  }

  public long fibonacciNumber() {
    return nr;
  }
}
```

为了测试它，我们需要以下`ForkJoinPool`对象：

```
ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();

FibonacciRecursiveAction fibonacciRecursiveAction
  = new FibonacciRecursiveAction(12);
forkJoinPool.invoke(fibonacciRecursiveAction);

logger.info(() -> "Fibonacci: "
  + fibonacciRecursiveAction.fibonacciNumber());
```

*F <sub>12</sub>* 的输出如下：

```
[15:40:46] Number: 5 Thread: ForkJoinPool.commonPool-worker-3
[15:40:46] Number: 5 Thread: ForkJoinPool.commonPool-worker-13
[15:40:46] Number: 4 Thread: ForkJoinPool.commonPool-worker-3
[15:40:46] Number: 4 Thread: ForkJoinPool.commonPool-worker-9
...
[15:40:49] Number: 0 Thread: ForkJoinPool.commonPool-worker-7
[15:40:49] Fibonacci: 144
```

# 使用计数计算器

`CountedCompleter`是 JDK 8 中添加的`ForkJoinTask`的类型。

`CountedCompleter`的工作是记住待定的任务数（没有什么比这更少的了解）。 我们可以通过`setPendingCount()`设置待处理计数或通过`addToPendingCount​(int delta)`将其递增，并通过显式`delta`。 通常，我们在分叉前立即召唤这些方法（例如，如果我们叉两次，那么我们调用`addToPendingCount(2)`或`setPendingCount(2)`，具体取决于案例）。

在`compute()`方法中，我们通过`tryComplete()`或`propagateCompletion()`减少待处理计数。 当调用`tryComplete()`方法时，使用零计数或未调用无条件`complete()`方法，调用`onCompletion()`方法。 `propagateCompletion()`方法与`tryComplete()`类似，但它不会调用`onCompletion()`。

`CountedCompleter`可选地返回计算值。 为此，我们必须覆盖`getRawResult()`方法以返回值。

以下代码通过`CountedCompleter` uc up 列表的所有值：

```
public class SumCountedCompleter extends CountedCompleter<Long> {

  private static final Logger logger 
    = Logger.getLogger(SumCountedCompleter.class.getName());
  private static final int THRESHOLD = 10;
  private static final LongAdder sumAll = new LongAdder();

  private final List<Integer> worklist;

  public SumCountedCompleter(
    CountedCompleter<Long> c, List<Integer> worklist) {
    super(c);
    this.worklist = worklist;
  }

  @Override
  public void compute() {
    if (worklist.size() <= THRESHOLD) {
      partialSum(worklist);
    } else {
      int size = worklist.size();

      List<Integer> worklistLeft 
        = worklist.subList(0, (size + 1) / 2);
      List<Integer> worklistRight 
        = worklist.subList((size + 1) / 2, size);

      addToPendingCount(2);
      SumCountedCompleter leftTask
        = new SumCountedCompleter(this, worklistLeft);
      SumCountedCompleter rightTask
        = new SumCountedCompleter(this, worklistRight);

      leftTask.fork();
      rightTask.fork();
    }

    tryComplete();
  }

  @Override
  public void onCompletion(CountedCompleter<?> caller) {
    logger.info(() -> "Thread complete: " 
      + Thread.currentThread().getName());
  }

  @Override
  public Long getRawResult() {
    return sumAll.sum();
  }

  private Integer partialSum(List<Integer> worklist) {
    int sum = worklist.stream()
      .mapToInt(e -> e)
      .sum();

    sumAll.add(sum);

    logger.info(() -> "Partial sum: " + worklist + " = "
      + sum + "\tThread: " + Thread.currentThread().getName());

    return sum;
  }
}
```

现在，让我们看看潜在的呼叫和输出：

```
ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();
Random rnd = new Random();
List<Integer> list = new ArrayList<>();

for (int i = 0; i < 200; i++) {
  list.add(1 + rnd.nextInt(10));
}

SumCountedCompleter sumCountedCompleter
  = new SumCountedCompleter(null, list);
forkJoinPool.invoke(sumCountedCompleter);

logger.info(() -> "Done! Result: "
  + sumCountedCompleter.getRawResult());
```

输出将如下：

```
[11:11:07] Partial sum: [7, 7, 8, 5, 6, 10] = 43
  ForkJoinPool.commonPool-worker-7
[11:11:07] Partial sum: [9, 1, 1, 6, 1, 2] = 20
  ForkJoinPool.commonPool-worker-3
...
[11:11:07] Thread complete: ForkJoinPool.commonPool-worker-15
[11:11:07] Done! Result: 1159
```

# 215\. fork /加入框架和 compareandsetforkjointasktag（）

现在，我们熟悉叉/加入框架，让我们看看另一个问题。 这次让我们假设我们有一套是相互依存的`ForkJoinTask`对象。 下图可以被视为用例：

![](img/9940750d-4790-4d22-afe8-d0e7c5ddd2fa.png)

以下是前图的描述：

*   **taskd** 有三个依赖性： **taska** ， **taskb** 和 **taskc** 。
*   **taskc** 有两个依赖性： **taska** 和 **taskb** 。
*   **taskb** 有一个依赖性： **taska** 。
*   **taska** 没有依赖关系。

在代码行中，我们将塑造如下：

```
ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();

Task taskA = new Task("Task-A", new Adder(1));

Task taskB = new Task("Task-B", new Adder(2), taskA);

Task taskC = new Task("Task-C", new Adder(3), taskA, taskB);

Task taskD = new Task("Task-D", new Adder(4), taskA, taskB, taskC);

forkJoinPool.invoke(taskD);
```

`Adder`是一个简单的`Callable`，只有每个任务只执行一次（所以，对于 **taskd** ， **taskc** ， **taskb** ，以及 **taska** ）。 `Adder`在以下代码中启动：

```
private static class Adder implements Callable {

  private static final AtomicInteger result = new AtomicInteger();

  private Integer nr;

  public Adder(Integer nr) {
    this.nr = nr;
  }

  @Override
  public Integer call() {
    logger.info(() -> "Adding number: " + nr
      + " by thread:" + Thread.currentThread().getName());

    return result.addAndGet(nr);
  }
}
```

我们已经知道如何使用 acclic 和/或不可重复的任务使用 fork /加入框架（或者我们不关心他们重复）完成依赖。 但是，如果我们以这种方式实现它，那么每项任务将多次被称为`Callable`。 例如， **taska** 显示为三个其他任务的依赖项，因此`Callable`将被调用三次。 我们只想要一次。

在 JDK 8 中添加的`ForkJoinPool`的一个非常方便的功能包括以`short`值的原子标记：

*   `short getForkJoinTaskTag()`：返回此任务的标记。
*   `short setForkJoinTaskTag​(short newValue)`：原子地设置此任务的标签值并返回旧值。
*   `boolean compareAndSetForkJoinTaskTag​(short expect, short update)`：返回`true`如果当前值等于`expect`并更改为`update`。

换句话说，`compareAndSetForkJoinTaskTag()`允许我们将任务标记为`VISITED`。 一旦标记为`VISITED`，它将不会被执行。 让我们在以下代码线中查看它：

```
public class Task<Integer> extends RecursiveTask<Integer> {

  private static final Logger logger 
    = Logger.getLogger(Task.class.getName());
  private static final short UNVISITED = 0;
  private static final short VISITED = 1;

  private Set<Task<Integer>> dependencies = new HashSet<>();

  private final String name;
  private final Callable<Integer> callable;

  public Task(String name, Callable<Integer> callable,
      Task<Integer> ...dependencies) {
    this.name = name;
    this.callable = callable;
    this.dependencies = Set.of(dependencies);
  }

  @Override
  protected Integer compute() {
    dependencies.stream()
      .filter((task) -> (task.updateTaskAsVisited()))
      .forEachOrdered((task) -> {
        logger.info(() -> "Tagged: " + task + "("
          + task.getForkJoinTaskTag() + ")");

        task.fork();
      });

    for (Task task: dependencies) {
      task.join();
    }

    try {
      return callable.call();
    } catch (Exception ex) {
      logger.severe(() -> "Exception: " + ex);
    }

    return null;
  }

  public boolean updateTaskAsVisited() {
    return compareAndSetForkJoinTaskTag(UNVISITED, VISITED);
  }

  @Override
  public String toString() {
    return name + " | dependencies=" + dependencies + "}";
  }
}
```

并且，可能的输出可能如下：

```
[10:30:53] [INFO] Tagged: Task-B(1)
[10:30:53] [INFO] Tagged: Task-C(1)
[10:30:53] [INFO] Tagged: Task-A(1)
[10:30:53] [INFO] Adding number: 1 
                   by thread:ForkJoinPool.commonPool-worker-3
[10:30:53] [INFO] Adding number: 2 
                   by thread:ForkJoinPool.commonPool-worker-3
[10:30:53] [INFO] Adding number: 3 
                   by thread:ForkJoinPool.commonPool-worker-5
[10:30:53] [INFO] Adding number: 4 
                   by thread:main
[10:30:53] [INFO] Result: 10
```

# 216.完善的

JDK 8 通过使用`CompletableFuture`通过增强`Future`，在异步编程中向前迈出了重要的一步。 `Future`的主要局限性是：

*   它无法明确完成。
*   它不支持对结果执行操作的回调。
*   它们不能被链接或组合用于获得复杂的异步管道。
*   它不提供异常处理。

a `CompletableFuture`没有这些限制。 简单但无用的`CompletableFuture`可以写如下：

```
CompletableFuture<Integer> completableFuture 
  = new CompletableFuture<>();
```

结果可以通过阻塞`get()`方法获得：

```
completableFuture.get();
```

除此之外，让我们在电子商务平台的上下文中查看运行异步任务的几个示例。 我们在命名为`CustomerAsyncs`的辅助类中添加这些示例。

# 运行异步任务并返回 void

用户问题：*打印某些客户订单。*

由于打印是一种不需要返回结果的过程，因此这是`runAsync()`的作业。 此方法可以异步运行任务，不会返回结果。 换句话说，它需要一个`Runnable`对象并返回`CompletableFuture<Void>`; 这在以下代码中显示：

```
public static void printOrder() {

  CompletableFuture<Void> cfPrintOrder 
      = CompletableFuture.runAsync(new Runnable() {

    @Override
    public void run() {
      logger.info(() -> "Order is printed by: "
        + Thread.currentThread().getName());
      Thread.sleep(500);
    }
  });

  cfPrintOrder.get(); // block until the order is printed
  logger.info("Customer order was printed ...\n");
}
```

或者，我们可以使用 lambda 写它：

```
public static void printOrder() {

  CompletableFuture<Void> cfPrintOrder 
      = CompletableFuture.runAsync(() -> {

    logger.info(() -> "Order is printed by: "
      + Thread.currentThread().getName());
    Thread.sleep(500);
  });

  cfPrintOrder.get(); // block until the order is printed
  logger.info("Customer order was printed ...\n");
}
```

# 运行异步任务并返回结果

用户问题：*获取某个客户的订单摘要。*

这次，异步任务必须返回结果，因此`runAsync()`无用。 这是`supplyAsync()`的工作。 它需要`Supplier<T>`并返回`CompletableFuture<T>`。 `T`是通过`get()`方法从该供应商获得的结果的类型。 在代码行中，我们可以解决此问题，如下所示：

```
public static void fetchOrderSummary() {

  CompletableFuture<String> cfOrderSummary 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Fetch order summary by: "
      + Thread.currentThread().getName());
    Thread.sleep(500);

    return "Order Summary #93443";
  });

  // wait for summary to be available, this is blocking
  String summary = cfOrderSummary.get();
  logger.info(() -> "Order summary: " + summary + "\n");
}
```

# 运行异步任务并通过显式线程池返回结果

用户问题：*获取某个客户的订单摘要。*

默认情况下，如在前面的示例中，异步任务在从全局`ForkJoinPool.commonPool()`获得的线程中执行。 通过简单地记录`Thread.currentThread().getName()`，我们看到了一些`ForkJoinPool.commonPool-worker-3`。

但我们还可以使用显式`Executor`自定义线程池。 所有能够运行异步任务的`CompletableFuture`方法提供了 vish 的味道`Executor`。

以下是使用单个线程池的示例：

```
public static void fetchOrderSummaryExecutor() {

  ExecutorService executor = Executors.newSingleThreadExecutor();

  CompletableFuture<String> cfOrderSummary 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Fetch order summary by: "
      + Thread.currentThread().getName());
    Thread.sleep(500);

    return "Order Summary #91022";
  }, executor);

  // wait for summary to be available, this is blocking
  String summary = cfOrderSummary.get();
  logger.info(() -> "Order summary: " + summary + "\n");
  executor.shutdownNow();
}
```

# 附加回调处理异步任务结果并返回结果

用户问题：*获取某个客户的订单发票，然后计算总计并签名。*

依赖于阻止`get()`对这些问题并不是很有用。 我们所需要的是一个回调方法，当`CompletableFuture`的结果可用时将自动调用。

所以，我们不想等待结果。 当发票准备就绪时（这是`CompletableFuture`的结果），回调方法应计算总值，然后，此后，另一个回调应签署。 这可以通过`thenApply()`方法来实现。

`thenApply()`方法对于处理和转换它到达时的结果是有用的。 它需要`Function<T, R>`作为一个论点。 让我们在工作中看到它：

```
public static void fetchInvoiceTotalSign() {

  CompletableFuture<String> cfFetchInvoice 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Fetch invoice by: "
      + Thread.currentThread().getName());
    Thread.sleep(500);

    return "Invoice #3344";
  });

  CompletableFuture<String> cfTotalSign = cfFetchInvoice
    .thenApply(o -> o + " Total: $145")
    .thenApply(o -> o + " Signed");

  String result = cfTotalSign.get();
  logger.info(() -> "Invoice: " + result + "\n");
}
```

或者，我们可以将其连锁如下：

```
public static void fetchInvoiceTotalSign() {

  CompletableFuture<String> cfTotalSign 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Fetch invoice by: "
      + Thread.currentThread().getName());
    Thread.sleep(500);

    return "Invoice #3344";
  }).thenApply(o -> o + " Total: $145")
    .thenApply(o -> o + " Signed");

  String result = cfTotalSign.get();
  logger.info(() -> "Invoice: " + result + "\n");
}
```

检查`applyToEither()`和`applyToEitherAsync()`。 当其或其他给定阶段以正常方式完成时，这两种方法返回一个新的完成阶段，该阶段被结果执行作为提供的函数的参数。

# 附加回调，处理异步任务结果并返回 void

用户问题：*获取某个客户的顺序并打印它。*

通常，不会返回结果的回调充当异步管道的终端动作。

可以通过`thenAccept()`方法获得此行为。 它需要`Consumer<T>`并返回`CompletableFuture<Void>`。 此方法可以处理和转换`CompletableFuture`的结果，但不会返回结果。 因此，它可以花序，这是`CompletableFuture`的结果，并将其打印，如以下代码片段中所示：

```
public static void fetchAndPrintOrder() {

  CompletableFuture<String> cfFetchOrder 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Fetch order by: "
      + Thread.currentThread().getName());
    Thread.sleep(500);

    return "Order #1024";
  });

  CompletableFuture<Void> cfPrintOrder = cfFetchOrder.thenAccept(
    o -> logger.info(() -> "Printing order " + o +
      " by: " + Thread.currentThread().getName()));

  cfPrintOrder.get();
  logger.info("Order was fetched and printed \n");
}
```

或者，它可以更紧凑如下：

```
public static void fetchAndPrintOrder() {

  CompletableFuture<Void> cfFetchAndPrintOrder 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Fetch order by: "
      + Thread.currentThread().getName());
    Thread.sleep(500);

    return "Order #1024";
  }).thenAccept(
      o -> logger.info(() -> "Printing order " + o + " by: "
        + Thread.currentThread().getName()));

  cfFetchAndPrintOrder.get();
  logger.info("Order was fetched and printed \n");
}
```

检查`acceptEither()`和`acceptEitherAsync()`。

# 在异步任务后运行的回调并返回 void

用户问题：*提供订单并通知客户。*

通知客户应在提供订单后完成。 这只是*尊敬的客户的短信，您的订单今天已经交付*类型，因此通知任务不需要了解订单的任何内容。 这些任务可以通过`thenRun()`来实现。 此方法需要`Runnable`并返回`CompletableFuture<Void>`。 让我们在工作中看到它：

```
public static void deliverOrderNotifyCustomer() {

  CompletableFuture<Void> cfDeliverOrder 
      = CompletableFuture.runAsync(() -> {

    logger.info(() -> "Order was delivered by: "
      + Thread.currentThread().getName());
    Thread.sleep(500);
  });

  CompletableFuture<Void> cfNotifyCustomer 
      = cfDeliverOrder.thenRun(() -> logger.info(
        () -> "Dear customer, your order has been delivered today by:"
          + Thread.currentThread().getName()));

  cfNotifyCustomer.get();
  logger.info(() -> "Order was delivered 
                       and customer was notified \n");
}
```

对于进一步并行化，`thenApply()`，`thenAccept()`和`thenRun()`伴随着`thenApplyAsync()`，`thenAcceptAsync()`和`thenRunAsync()`。 这些中的每一个都可以依赖于全局`ForkJoinPool.commonPool()`或自定义线程池（`Executor`）。 虽然`thenApply` / `Accept` / `Run()`在与`CompletableFuture`任务中执行（或在主线程）之前执行，但是可以执行`thenApplyAsync` / `AcceptAsync` / `RunAsync()` 一个不同的线程（来自`ForkJoinPool.commonPool()`或自定义线程池（`Executor`））。

# 通过异常处理异步任务的异常（）

用户问题：*计算订单的总数。 如果出现问题，则抛出* `IllegalStateException` *。*

以下屏幕截图示例了如何在异步管道中传播异常; 当在该点发生异常时，不会执行矩形中的代码：

![](img/d2d74cb2-cfce-4b19-be2e-ccbc96b566f0.png)

以下屏幕截图显示`thenApply()`和`thenAccept()`中的例外：

![](img/d301cd32-8885-4e5b-bc16-c09c8a197d2c.png)

因此，在`supplyAsync()`中，如果发生异常，则将调用以下任何回调。 此外，未来将通过此例外解决。 每个回调都适用相同的规则。 如果在第一个`thenApply()`中发生异常，则不会调用以下`thenApply()`和`thenAccept()`。

如果我们试图计算总数的顺序最终在`IllegalStateException`中，我们可以依赖于`exceptionally()`回调，这让我们有机会恢复。 此方法采用`Function<Throwable,​? extends T>`并返回`CompletionStage<T>`，因此，`CompletableFuture`。 让我们在工作中看到它：

```
public static void fetchOrderTotalException() {

  CompletableFuture<Integer> cfTotalOrder 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Compute total: "
      + Thread.currentThread().getName());

    int surrogate = new Random().nextInt(1000);
    if (surrogate < 500) {
      throw new IllegalStateException(
        "Invoice service is not responding");
    }

    return 1000;
  }).exceptionally(ex -> {
    logger.severe(() -> "Exception: " + ex
      + " Thread: " + Thread.currentThread().getName());

    return 0;
  });

  int result = cfTotalOrder.get();
  logger.info(() -> "Total: " + result + "\n");
}
```

在例外情况下，输出将如下：

```
Compute total: ForkJoinPool.commonPool-worker-3
Exception: java.lang.IllegalStateException: Invoice service
           is not responding Thread: ForkJoinPool.commonPool-worker-3
Total: 0
```

让我们来看看另一个问题。

用户问题：*获取发票，计算总数，符号。 如果出现问题，则抛出* `IllegalStateException` *并停止过程。*

如果我们使用`supplyAsync()`获取发票，请使用`thenApply()`计算总数并使用另一个`thenApply()`，然后我们可能认为正确的实现如下：

```
public static void fetchInvoiceTotalSignChainOfException()
throws InterruptedException, ExecutionException {

  CompletableFuture<String> cfFetchInvoice 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Fetch invoice by: "
      + Thread.currentThread().getName());

    int surrogate = new Random().nextInt(1000);
    if (surrogate < 500) {
      throw new IllegalStateException(
        "Invoice service is not responding");
    }

    return "Invoice #3344";
  }).exceptionally(ex -> {
    logger.severe(() -> "Exception: " + ex
      + " Thread: " + Thread.currentThread().getName());

    return "[Invoice-Exception]";
  }).thenApply(o -> {
      logger.info(() -> "Compute total by: "
        + Thread.currentThread().getName());

    int surrogate = new Random().nextInt(1000);
    if (surrogate < 500) {
      throw new IllegalStateException(
        "Total service is not responding");
    }

    return o + " Total: $145";
  }).exceptionally(ex -> {
    logger.severe(() -> "Exception: " + ex
      + " Thread: " + Thread.currentThread().getName());

    return "[Total-Exception]";
  }).thenApply(o -> {
    logger.info(() -> "Sign invoice by: "
      + Thread.currentThread().getName());

    int surrogate = new Random().nextInt(1000);
    if (surrogate < 500) {
      throw new IllegalStateException(
        "Signing service is not responding");
    }

    return o + " Signed";
  }).exceptionally(ex -> {
    logger.severe(() -> "Exception: " + ex
      + " Thread: " + Thread.currentThread().getName());

    return "[Sign-Exception]";
  });

  String result = cfFetchInvoice.get();
  logger.info(() -> "Result: " + result + "\n");
}
```

嗯，这里的问题是我们可能面临如下的产出：

```
[INFO] Fetch invoice by: ForkJoinPool.commonPool-worker-3
[SEVERE] Exception: java.lang.IllegalStateException: Invoice service
         is not responding Thread: ForkJoinPool.commonPool-worker-3
[INFO] Compute total by: ForkJoinPool.commonPool-worker-3
[INFO] Sign invoice by: ForkJoinPool.commonPool-worker-3
[SEVERE] Exception: java.lang.IllegalStateException: Signing service
         is not responding Thread: ForkJoinPool.commonPool-worker-3
[INFO] Result: [Sign-Exception]
```

即使无法获取发票，我们也会继续计算总数并签署。 显然，这没有意义。 如果无法获取发票，或者无法计算总数，则我们希望中止该过程。 虽然当我们能够恢复并继续时，这种实现可能是一个很好的契合，但它绝对对我们的情景不利。 对于我们的方案，需要以下实现：

```
public static void fetchInvoiceTotalSignException()
throws InterruptedException, ExecutionException {

  CompletableFuture<String> cfFetchInvoice 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Fetch invoice by: "
      + Thread.currentThread().getName());

    int surrogate = new Random().nextInt(1000);
    if (surrogate < 500) {
      throw new IllegalStateException(
        "Invoice service is not responding");
    }

    return "Invoice #3344";
  }).thenApply(o -> {
      logger.info(() -> "Compute total by: "
        + Thread.currentThread().getName());

    int surrogate = new Random().nextInt(1000);
    if (surrogate < 500) {
      throw new IllegalStateException(
        "Total service is not responding");
    }

    return o + " Total: $145";
  }).thenApply(o -> {
      logger.info(() -> "Sign invoice by: "
        + Thread.currentThread().getName());

    int surrogate = new Random().nextInt(1000);
    if (surrogate < 500) {
      throw new IllegalStateException(
        "Signing service is not responding");
    }

    return o + " Signed";
  }).exceptionally(ex -> {
    logger.severe(() -> "Exception: " + ex
      + " Thread: " + Thread.currentThread().getName());

    return "[No-Invoice-Exception]";
  });

  String result = cfFetchInvoice.get();
  logger.info(() -> "Result: " + result + "\n");
}
```

这次，在任何隐含的`CompletableFuture`中发生的异常将停止该过程。 以下是一种可能的输出：

```
[INFO ] Fetch invoice by: ForkJoinPool.commonPool-worker-3
[SEVERE] Exception: java.lang.IllegalStateException: Invoice service
         is not responding Thread: ForkJoinPool.commonPool-worker-3
[INFO ] Result: [No-Invoice-Exception]
```

从 JDK 12 开始，卓越的情况可以通过`exceptionallyAsync()`进一步并行化，该方法可以使用与导致给定线程池中导致异常或线程的代码相同的线程（`Executor`）。 这是一个例子：

```
public static void fetchOrderTotalExceptionAsync() {

  ExecutorService executor = Executors.newSingleThreadExecutor();

  CompletableFuture<Integer> totalOrder 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Compute total by: "
      + Thread.currentThread().getName());

    int surrogate = new Random().nextInt(1000);
    if (surrogate < 500) {
      throw new IllegalStateException(
        "Computing service is not responding");
    }

    return 1000;
  }).exceptionallyAsync(ex -> {
    logger.severe(() -> "Exception: " + ex 
      + " Thread: " + Thread.currentThread().getName());

    return 0;
  }, executor);

  int result = totalOrder.get();
  logger.info(() -> "Total: " + result + "\n");
  executor.shutdownNow();
}
```

输出显示，导致异常的代码由名为`ForkJoinPool.commonPool-worker-3`的线程执行，而卓越的代码由名为`pool-1-thread-1`的给定线程池的线程执行：

```
Compute total by: ForkJoinPool.commonPool-worker-3
Exception: java.lang.IllegalStateException: Computing service is
           not responding Thread: pool-1-thread-1
Total: 0
```

# JDK 12 异常 Composp（）

用户问题：*通过打印服务或回退到备份打印机 IP。 或者，一般而言，当* *这个阶段非常完全完成，应该使用应用于本阶段的例外*的所提供函数的结果来组成。

我们有`CompletableFuture`，它获取由打印服务管理的打印机的 IP。 如果服务没有响应，那么它会抛出一个例外，如下所示：

```
CompletableFuture<String> cfServicePrinterIp 
    = CompletableFuture.supplyAsync(() -> {

  int surrogate = new Random().nextInt(1000);
  if (surrogate < 500) {
    throw new IllegalStateException(
      "Printing service is not responding");
  }

  return "192.168.1.0";
});
```

我们还有`CompletableFuture`，它获取备份打印机的 IP：

```
CompletableFuture<String> cfBackupPrinterIp 
    = CompletableFuture.supplyAsync(() -> {

  return "192.192.192.192";
});
```

现在，如果打印服务不可用，那么我们应该依赖备份打印机。 这可以通过 JDK 12 `exceptionallyCompose()`完成如下：

```
CompletableFuture<Void> printInvoice 
    = cfServicePrinterIp.exceptionallyCompose(th -> {

  logger.severe(() -> "Exception: " + th
    + " Thread: " + Thread.currentThread().getName());

  return cfBackupPrinterIp;
}).thenAccept((ip) -> logger.info(() -> "Printing at: " + ip));
```

调用`printInvoice.get()`可能会显示以下结果之一：

*   如果打印服务可用：

```
[INFO] Printing at: 192.168.1.0
```

*   如果不可用打印服务：

```
[SEVERE] Exception: java.util.concurrent.CompletionException ...
[INFO] Printing at: 192.192.192.192
```

对于进一步的并行化，我们可以依赖于`exceptionallyComposeAsync()`。

# 通过句柄处理异步任务的异常（）

用户问题：*计算订单的总数。 如果出现问题，则抛出* `IllegalStateException` *。*

即使没有发生异常，我们希望执行一个异常的代码块。 与`try` - `catch`块的`finally`条款相似。 使用`handle()`回调可以实现这一点。 此方法称为是否发生异常，并且不知何时像一个`catch` + `finally`。 它需要一个用于计算返回`CompletionStage, BiFunction<? super T,​Throwable,​? extends U>`的值的函数，并返回`CompletionStage<U>`（`U`是函数的返回类型）。

让我们在工作中看到它：

```
public static void fetchOrderTotalHandle() {

  CompletableFuture<Integer> totalOrder 
      = CompletableFuture.supplyAsync(() -> {

    logger.info(() -> "Compute total by: "
      + Thread.currentThread().getName());

    int surrogate = new Random().nextInt(1000);
    if (surrogate < 500) {
      throw new IllegalStateException(
        "Computing service is not responding");
    }

    return 1000;
  }).handle((res, ex) -> {
    if (ex != null) {
      logger.severe(() -> "Exception: " + ex
        + " Thread: " + Thread.currentThread().getName());

      return 0;
    }

    if (res != null) {
      int vat = res * 24 / 100;
      res += vat;
    }

    return res;
  });

  int result = totalOrder.get();
  logger.info(() -> "Total: " + result + "\n");
}
```

请注意，`res`将是`null`; 否则，如果发生异常，`ex`将是`null`。

如果我们需要完整的例外，那么我们可以通过`completeExceptionally()`继续如以下示例：

```
CompletableFuture<Integer> cf = new CompletableFuture<>();
...
cf.completeExceptionally(new RuntimeException("Ops!"));
...
cf.get(); // ExecutionException : RuntimeException
```

取消执行和抛出`CancellationException`可以通过`cancel()`方法来完成：

```
CompletableFuture<Integer> cf = new CompletableFuture<>();
...
// is not important if the argument is set to true or false
cf.cancel(true/false);
...
cf.get(); // CancellationException
```

# 明确完成一个完整的文件

可以使用`complete​(T value)`，`completeAsync​(Supplier<? extends T> supplier)`和`completeAsync​(Supplier<? extends T> supplier, Executor executor)`明确地完成`CompletableFuture`。 `T`是`get()`返回的值。 在这里，它是一种创建`CompletableFuture`的方法，并立即返回它。 另一个线程负责执行某些税收计算并使用相应的结果完成`CompletableFuture`：

```
public static CompletableFuture<Integer> taxes() {

  CompletableFuture<Integer> completableFuture 
    = new CompletableFuture<>();

  new Thread(() -> {
    int result = new Random().nextInt(100);
    Thread.sleep(10);

    completableFuture.complete(result);
  }).start();

  return completableFuture;
}
```

而且，让我们调用此方法：

```
logger.info("Computing taxes ...");

CompletableFuture<Integer> cfTaxes = CustomerAsyncs.taxes();

while (!cfTaxes.isDone()) {
  logger.info("Still computing ...");
}

int result = cfTaxes.get();
logger.info(() -> "Result: " + result);
```

可能的输出将是以下内容：

```
[14:09:40] [INFO ] Computing taxes ...
[14:09:40] [INFO ] Still computing ...
[14:09:40] [INFO ] Still computing ...
...
[14:09:40] [INFO ] Still computing ...
[14:09:40] [INFO ] Result: 17
```

如果我们已经知道`CompletableFuture`的结果，那么我们可以调用`completedFuture​(U value)`如下例所示：

```
CompletableFuture<String> completableFuture 
  = CompletableFuture.completedFuture("How are you?");

String result = completableFuture.get();
logger.info(() -> "Result: " + result); // Result: How are you?
```

此外，检查`whenComplete()`和`whenCompleteAsync()`的文档。

# 217.结合多个完全的实例

在大多数情况下，组合`CompletableFuture`实例可以使用以下内容完成：

*   `thenCompose()`
*   `thenCombine()`
*   `allOf()`
*   `anyOf()`

通过组合`CompletableFuture`实例，我们可以塑造复杂的异步解决方案。 这样，多个`CompletableFuture`实例可以将其功率组合起来达到共同目标。

# 通过 thencompose（）结合

让我们假设我们在命名为`CustomerAsyncs`的辅助类中有以下两个`CompletableFuture`实例：

```
private static CompletableFuture<String> 
    fetchOrder(String customerId) {

  return CompletableFuture.supplyAsync(() -> {
    return "Order of " + customerId;
  });
}

private static CompletableFuture<Integer> computeTotal(String order) {

  return CompletableFuture.supplyAsync(() -> {
    return order.length() + new Random().nextInt(1000);
  });
}
```

现在，我们想获取某个客户的顺序，并且一旦订单可用，我们就想要计算此订单的总数。 这意味着我们需要调用`fetchOrder()`和之后`computeTotal()`。 我们可以通过`thenApply()`来完成这一点：

```
CompletableFuture<CompletableFuture<Integer>> cfTotal 
  = fetchOrder(customerId).thenApply(o -> computeTotal(o));

int total = cfTotal.get().get();
```

显然，这不是一个方便的解决方案，因为结果是`CompletableFuture<CompletableFuture<Integer>>`类型。 为了避免嵌套`CompletableFuture`实例，我们可以依靠`thenCompose()`如下：

```
CompletableFuture<Integer> cfTotal 
  = fetchOrder(customerId).thenCompose(o -> computeTotal(o));

int total = cfTotal.get();

// e.g., Total: 734
logger.info(() -> "Total: " + total);
```

每当我们需要从`CompletableFuture`实例中获得扁平的结果时，我们可以使用`thenCompose()`。 这样，我们避免了`CompletableFuture`实例的嵌套示例。

可以使用`thenComposeAsync()`获得进一步的并行化。

# 通过 thencombine（）结合

虽然`thenCompose()`对链两个依赖的`CompletableFuture`实例有用，但是`thenCombine()`是可用于链的两个独立的`CompletableFuture`的实例。 当`CompletableFuture`实例完成时，我们可以继续。

让我们假设我们有以下两个`CompletableFuture`实例：

```
private static CompletableFuture<Integer> computeTotal(String order) {

  return CompletableFuture.supplyAsync(() -> {
    return order.length() + new Random().nextInt(1000);
  });
}

private static CompletableFuture<String> packProducts(String order) {

  return CompletableFuture.supplyAsync(() -> {
    return "Order: " + order 
      + " | Product 1, Product 2, Product 3, ... ";
  });
}
```

为了提供客户订单，我们需要计算总数（用于发出发票）并打包订购产品。 这两个动作可以并行完成。 最后，我们提供包含订购产品和发票的包裹。 通过`thenCombine()`实现这一目标可以如下所示：

```
CompletableFuture<String> cfParcel = computeTotal(order)
  .thenCombine(packProducts(order), (total, products) -> {
    return "Parcel-[" + products + " Invoice: $" + total + "]";
  });

String parcel = cfParcel.get();

// e.g. Delivering: Parcel-[Order: #332 | Product 1, Product 2,
// Product 3, ... Invoice: $314]
logger.info(() -> "Delivering: " + parcel);
```

在`CompletableFuture`实例完成后，将调用给`thenCombine()`给出的回调函数。

如果我们所需要的只是做某事，当两个`CompletableFuture`实例正常完成时（这个和另一个），那么我们可以依靠`thenAcceptBoth()`。 此方法返回一个新的`CompletableFuture`，该结果与两个结果作为参数执行为提供的动作。 这两种结果是这个，另一个给定的阶段（他们必须正常完成）。 这是一个例子：

```
CompletableFuture<Void> voidResult = CompletableFuture
  .supplyAsync(() -> "Pick")
  .thenAcceptBoth(CompletableFuture.supplyAsync(() -> " me"),
    (pick, me) -> System.out.println(pick + me));
```

如果不需要这两个`CompletableFuture`实例的结果，则`runAfterBoth()`是更优选的。

# 通过 allof（）结合

让我们假设我们要下载以下发票列表：

```
List<String> invoices = Arrays.asList("#2334", "#122", "#55");
```

这可以看作是一堆可以并行完成的独立任务，因此我们可以使用`CompletableFuture`如下：

```
public static CompletableFuture<String> 
    downloadInvoices(String invoice) {

  return CompletableFuture.supplyAsync(() -> {
    logger.info(() -> "Downloading invoice: " + invoice);

    return "Downloaded invoice: " + invoice;
  });
}

CompletableFuture<String> [] cfInvoices = invoices.stream()
  .map(CustomerAsyncs::downloadInvoices)
  .toArray(CompletableFuture[]::new);
```

此时，我们有一个`CompletableFuture`实例的数组，因此，异步计算数组。 此外，我们希望并行运行所有这些。 这可以使用`allOf​(CompletableFuture<?>... cfs)`方法来完成。 结果由`CompletableFuture<Void>`组成，如下：

```
CompletableFuture<Void> cfDownloaded 
  = CompletableFuture.allOf(cfInvoices);
cfDownloaded.get();
```

显然，`allOf()`的结果不是很有用。 我们可以用`CompletableFuture<Void>`做什么？ 当我们需要在该并行化中涉及的每个计算结果时肯定存在许多问题，因此我们需要一个解决方案来获取结果而不是依赖于`CompletableFuture<Void>`。

我们可以通过`thenApply()`来解决这个问题，如下所示：

```
List<String> results = cfDownloaded.thenApply(e -> {
  List<String> downloaded = new ArrayList<>();

  for (CompletableFuture<String> cfInvoice: cfInvoices) {
    downloaded.add(cfInvoice.join());
  }

  return downloaded;
}).get();
```

`join()`方法类似于`get()`，但是，如果底层`CompletableFuture`完全完成，则它会抛出未经检查的异常。

由于我们在所有涉及的`CompletableFuture`完成后呼叫`join()`，因此没有阻挡点。

返回的`List<String>`包含通过调用`downloadInvoices()`方法如下所获得的结果：

```
Downloaded invoice: #2334

Downloaded invoice: #122

Downloaded invoice: #55
```

# 通过 AnyOf（）结合

让我们假设我们要为客户组织抽奖服务：

```
List<String> customers = Arrays.asList(
  "#1", "#4", "#2", "#7", "#6", "#5"
);
```

我们可以通过定义以下简单方法来开始解决这个问题：

```
public static CompletableFuture<String> raffle(String customerId) {

  return CompletableFuture.supplyAsync(() -> {
    Thread.sleep(new Random().nextInt(5000));

    return customerId;
  });
}
```

现在，我们可以创建一个`CompletableFuture<String>`实例的数组，如下所示：

```
CompletableFuture<String>[] cfCustomers = customers.stream()
  .map(CustomerAsyncs::raffle)
  .toArray(CompletableFuture[]::new);
```

要找到抽奖的获胜者，我们希望并行运行`cfCustomers`，并且完成的第一个`CompletableFuture`是赢家。 由于`raffle()`方法块随机数秒，因此将随机选择获胜者。 我们对`CompletableFuture`实例的其余部分不感兴趣，因此应在选择获奖者后立即完成。

这是`anyOf​(CompletableFuture<?>... cfs)`的工作。 它返回一个新的`CompletableFuture`，当任何涉及的`CompletableFuture`实例完成时完成。 让我们在工作中看到它：

```
CompletableFuture<Object> cfWinner 
  = CompletableFuture.anyOf(cfCustomers);

Object winner = cfWinner.get();

// e.g., Winner: #2
logger.info(() -> "Winner: " + winner);
```

注意依赖于`CompletableFuture`的场景，返回不同类型的结果。 由于`anyOf()`返回`CompletableFuture<Object>`，很难知道首先完成的`CompletableFuture`类型。

# 218.优化忙碌等待

*忙等待*技术（也称为*忙循环*或*旋转*）包括检查条件（通常，标志条件）的循环。 例如，以下循环等待服务开始：

```
private volatile boolean serviceAvailable;
...
while (!serviceAvailable) {}
```

Java 9 介绍了`Thread.onSpinWait()`方法。 这是一个热点，它给出了 JVM 一个提示以下代码处于旋转循环：

```
while (!serviceAvailable) {
  Thread.onSpinWait();
}
```

Intel SSE2 暂停指令是恰恰为此提供的。 有关更多详细信息，请参阅英特尔官方文档。 还看看这个链接： [https://software.intel.com/en-us/articles/benefitting-power-andperformance-sleep-loops](https://software.intel.com/en-us/articles/benefitting-power-and-performance-sleep-loops) 。

如果我们在上下文中添加此`while`循环，则获取以下类：

```
public class StartService implements Runnable {

  private volatile boolean serviceAvailable;

  @Override
  public void run() {
    System.out.println("Wait for service to be available ...");

    while (!serviceAvailable) {
      // Use a spin-wait hint (ask the processor to
      // optimize the resource)
      // This should perform better if the underlying
      // hardware supports the hint
      Thread.onSpinWait();
    }

    serviceRun();
  }

  public void serviceRun() {
    System.out.println("Service is running ...");
  }

  public void setServiceAvailable(boolean serviceAvailable) {
    this.serviceAvailable = serviceAvailable;
  }
}
```

并且，我们可以轻松测试（不要指望看到`onSpinWait()`的效果）：

```
StartService startService = new StartService();
new Thread(startService).start();

Thread.sleep(5000);

startService.setServiceAvailable(true);
```

# 219.任务取消

取消是一种用于强制停止或完成当前正在运行的任务的常用技术。 取消的任务将无法自然地完成。 取消对已经完成的任务没有影响。 将其视为 GUI 的**取消**按钮。

Java 不提供用于停止线程的抢先方法。 因此，为了取消任务，常识是依赖于使用标志条件的循环。 任务责任是定期检查此标志，并且当它找到标志集时，那么它应该尽可能快地停止。 以下代码是其中的示例：

```
public class RandomList implements Runnable {
  private volatile boolean cancelled;
  private final List<Integer> randoms = new CopyOnWriteArrayList<>();
  private final Random rnd = new Random();

  @Override
  public void run() {
    while (!cancelled) {
      randoms.add(rnd.nextInt(100));
    }
  }

  public void cancel() {
    cancelled = true;
  }

  public List<Integer> getRandoms() {
    return randoms;
  }
}
```

这里的焦点位于`canceled`变量上。 请注意，此变量声明为`volatile`（也称为较轻的同步机制）。 是一个`volatile`变量，它不受线程和操作的缓存，它不会在内存中重新排序; 因此，线程无法看到旧值。 任何读取`volatile`字段的线程将看到最近的写入值。 这正是我们所需要的，以便将取消操作传达给对此操作感兴趣的所有运行线程。 下图描绘了`volatile`和非`volatile`工作：

![](img/d2cedc7f-38c9-46e4-9d8b-701345f4643e.png)

请注意，`volatile`变量不适合读取修改写入方案。 对于这种情况，我们将依赖于原子变量（例如，`AtomicBoolean`，`AtomicInteger`，`AtomicReference`等）。

现在，让我们提供一个简单的代码片段，用于取消`RandomList`中实现的任务：

```
RandomList rl = new RandomList();

ExecutorService executor = Executors.newFixedThreadPool(10);

for (int i = 0; i < 100; i++) {
  executor.execute(rl);
}

Thread.sleep(100);

rl.cancel();

System.out.println(rl.getRandoms());
```

# 220\. Threadlocal.

Java 线程共享相同的内存，但有时我们需要为每个线程具有专用内存。 Java 提供`ThreadLocal`作为用于单独存储和检索每个线程的值的方法。 单个`ThreadLocal`的一个实例可以存储和检索多个线程的值。 如果线程`A`存储`x`值和线程`B`将`y`存储在`ThreadLocal`的同一实例中，稍后，线程`A`检索`x`值和线程`B` 检索`y`值。

Java `ThreadLocal`通常用于以下两种情况：

*   用于提供每线程实例（线程安全和内存效率）

*   用于提供每线程上下文

让我们来看看下一节中每个场景的问题。

# 每个线程实例

假设我们有一个单线程应用程序，它使用`StringBuilder`类型的全局变量。 为了将应用程序转换为多线程应用程序，我们必须处理`StringBuilder`，这不是线程安全的。 基本上，我们有几种方法，如同步和`StringBuffer`或其他方法。 但是，我们也可以使用`ThreadLocal`。 这里的主要思想是为每个线程提供单独的`StringBuilder`。 使用`ThreadLocal`，我们可以按如下方式执行以下操作：

```
private static final ThreadLocal<StringBuilder> 
    threadLocal = new ThreadLocal<>() {

  @Override
  protected StringBuilder initialValue() {
    return new StringBuilder("ThreadSafe ");
  }
};
```

当前线程的*初始值*通过`initialValue()`方法设置。 在 Java 8 中，可以通过`withInitial()`重写，如下所示：

```
private static final ThreadLocal<StringBuilder> threadLocal 
    = ThreadLocal.<StringBuilder> withInitial(() -> {

  return new StringBuilder("Thread-safe ");
});
```

使用`ThreadLocal`使用`get()`和`set()`使用。 `set()`的每个呼叫将给定值存储在仅当前线程可以访问的存储区域中。 稍后，调用`get()`将从该区域中检索该区域的值。 此外，一旦作业完成，建议通过在`ThreadLocal`实例上调用`remove()`或`set(null)`方法来避免内存泄漏。

让我们使用 A `Runnable`在工作中查看`ThreadLocal`：

```
public class ThreadSafeStringBuilder implements Runnable {

  private static final Logger logger =
    Logger.getLogger(ThreadSafeStringBuilder.class.getName());
  private static final Random rnd = new Random();

  private static final ThreadLocal<StringBuilder> threadLocal 
      = ThreadLocal.<StringBuilder> withInitial(() -> {

    return new StringBuilder("Thread-safe ");
  });

  @Override
  public void run() {
    logger.info(() -> "-> " + Thread.currentThread().getName() 
      + " [" + threadLocal.get() + "]");

    Thread.sleep(rnd.nextInt(2000));

    // threadLocal.set(new StringBuilder(
    // Thread.currentThread().getName()));
    threadLocal.get().append(Thread.currentThread().getName());

    logger.info(() -> "-> " + Thread.currentThread().getName() 
      + " [" + threadLocal.get() + "]");

    threadLocal.set(null);
    // threadLocal.remove();

    logger.info(() -> "-> " + Thread.currentThread().getName() 
      + " [" + threadLocal.get() + "]");
  }
}
```

并且，让我们使用多个线程测试它：

```
ThreadSafeStringBuilder threadSafe = new ThreadSafeStringBuilder();

for (int i = 0; i < 3; i++) {
  new Thread(threadSafe, "thread-" + i).start();
}
```

输出显示每个线程访问其自己的`StringBuilder`：

```
[14:26:39] [INFO] -> thread-1 [Thread-safe ]
[14:26:39] [INFO] -> thread-0 [Thread-safe ]
[14:26:39] [INFO] -> thread-2 [Thread-safe ]
[14:26:40] [INFO] -> thread-0 [Thread-safe thread-0]
[14:26:40] [INFO] -> thread-0 [null]
[14:26:41] [INFO] -> thread-1 [Thread-safe thread-1]
[14:26:41] [INFO] -> thread-1 [null]
[14:26:41] [INFO] -> thread-2 [Thread-safe thread-2]
[14:26:41] [INFO] -> thread-2 [null]
```

在诸如之前的场景中，也可以使用`ExecutorService`。

这是另一个代码代码，为每个线程提供 JDBC `Connection`：

```
private static final ThreadLocal<Connection> connections 
    = ThreadLocal.<Connection> withInitial(() -> {

  try {
    return DriverManager.getConnection("jdbc:mysql://...");
  } catch (SQLException ex) {
    throw new RuntimeException("Connection acquisition failed!", ex);
  }
});

public static Connection getConnection() {
  return connections.get();
}
```

# 每线程上下文

让我们假设我们有以下`Order`类：

```
public class Order {

  private final int customerId;

  public Order(int customerId) {
    this.customerId = customerId;
  }

  // getter and toString() omitted for brevity
}
```

而且，我们写下`CustomerOrder`如下：

```
public class CustomerOrder implements Runnable {

  private static final Logger logger
    = Logger.getLogger(CustomerOrder.class.getName());
  private static final Random rnd = new Random();

  private static final ThreadLocal<Order> 
    customerOrder = new ThreadLocal<>();

  private final int customerId;

  public CustomerOrder(int customerId) {
    this.customerId = customerId;
  }

  @Override
  public void run() {
    logger.info(() -> "Given customer id: " + customerId 
      + " | " + customerOrder.get() 
      + " | " + Thread.currentThread().getName());

    customerOrder.set(new Order(customerId));

    try {
      Thread.sleep(rnd.nextInt(2000));
    } catch (InterruptedException ex) {
      Thread.currentThread().interrupt();
      logger.severe(() -> "Exception: " + ex);
    }

    logger.info(() -> "Given customer id: " + customerId 
      + " | " + customerOrder.get() 
      + " | " + Thread.currentThread().getName());

    customerOrder.remove();
  }
}
```

对于每个`customerId`，我们有一个我们控制的专用线程：

```
CustomerOrder co1 = new CustomerOrder(1);
CustomerOrder co2 = new CustomerOrder(2);
CustomerOrder co3 = new CustomerOrder(3);

new Thread(co1).start();
new Thread(co2).start();
new Thread(co3).start();
```

因此，每个线程修改了`CustomerOrder`的某个实例（每个实例都有特定的线程）。

`run()`方法获取给定`customerId`的顺序，并使用`set()`方法将其存储在`ThreadLocal`变量中。

可能的输出将如下：

```
[14:48:20] [INFO] 
  Given customer id: 3 | null | Thread-2
[14:48:20] [INFO] 
  Given customer id: 2 | null | Thread-1
[14:48:20] [INFO] 
  Given customer id: 1 | null | Thread-0

[14:48:20] [INFO] 
  Given customer id: 2 | Order{customerId=2} | Thread-1
[14:48:21] [INFO] 
  Given customer id: 3 | Order{customerId=3} | Thread-2
[14:48:21] [INFO] 
  Given customer id: 1 | Order{customerId=1} | Thread-0
```

在类似于前一的场景中，避免使用`ExecutorService`。 无法保证每个`Runnable`（给定的`customerId`）将由每个执行时的相同线程处理。 这可能导致奇怪的结果。

# 221.原子变量

通过`Runnable`将所有数字计数为 1 至 1,000,000 的天真方法可能如下：

```
public class Incrementator implements Runnable {

  public [static] int count = 0;

  @Override
  public void run() {
    count++;
  }

  public int getCount() {
    return count;
  }
}
```

并且，让我们旋转五个线程，它将同时增加`count`变量：

```
Incrementator nonAtomicInc = new Incrementator();
ExecutorService executor = Executors.newFixedThreadPool(5);

for (int i = 0; i < 1 _000_000; i++) {
  executor.execute(nonAtomicInc);
}
```

但是，如果我们多次运行此代码，我们会得到不同的结果，如下所示：

```
997776, 997122, 997681 ...
```

那么，为什么我们没有获得预期的结果，1,000,000？ 原因是因为`count++`不是原子操作/动作。 它由三个原子字节码说明组成：

```
iload_1
iinc 1, 1
istore_1
```

在一个线程期间，读取`count`值并递增一个，另一个线程读取导致错误结果的旧值。 在多线程应用程序中，调度器可以停止在这些字节码指令中的每一个之间的当前线程的执行，并启动一个新的线程，它适用于相同的变量。 我们可以通过同步或更好地通过原子变量来解决问题。

`java.util.concurrent.atomic`中提供原子变量类。 它们是包装课程，将争用范围限制为单个变量; 它们比 Java 同步更轻，并且基于 **CAS** （**比较和交换**：现代 CPU 支持这种技术，其中它将给定内存位置的内容与 a 比较 如果当前值等于预期值，则给定值并将其更新为新值）。 主要是，这些是以与`volatile`相似的无锁的方式影响单个值的原子复合作用。 最常用的原子变量是标量：

*   `AtomicInteger`
*   `AtomicLong`
*   `AtomicBoolean`
*   `AtomicReference`

并且，以下是阵列：

*   `AtomicIntegerArray`
*   `AtomicLongArray`
*   `AtomicReferenceArray`

让我们通过`AtomicInteger`重写我们的示例：

```
public class AtomicIncrementator implements Runnable {

  public static AtomicInteger count = new AtomicInteger();

  @Override
  public void run() {
    count.incrementAndGet();
  }

  public int getCount() {
    return count.get();
  }
}
```

请注意，我们写道`count.incrementAndGet()`而不是`count++`。 这只是`AtomicInteger`提供的方法之一。 此方法原子上递增变量并返回新值。 这一次，`count`将是 1,000,000。

下表包含了常用的几种`AtomicInteger`的方法。 左列包含方法，而右图包含非原子含义：

```
AtomicInteger ai = new AtomicInteger(0); // atomic
int i = 0; // non-atomic

// and
int q = 5;
int r;

// and
int e = 0;
boolean b;
```

| **原子操作** | **非原子对应物** |
| `r = ai.get();` | `r = i;` |
| `ai.set(q);` | `i = q;` |
| `r = ai.incrementAndGet();` | `r = ++i;` |
| `r = ai.getAndIncrement();` | `r = i++;` |
| `r = ai.decrementAndGet();` | `r = --i;` |
| `r = ai.getAndDecrement();` | `r = i--;` |
| `r = ai.addAndGet(q);` | `i = i + q; r = i;` |
| `r = ai.getAndAdd(q);` | `r = i; i = i + q;` |
| `r = ai.getAndSet(q);` | `r = i; i = q;` |
| `b = ai.compareAndSet(e, q);` | `if (i == e) { i = q; return true; } else { return false; }` |

让我们通过原子操作解决几个问题：

*   通过`updateAndGet​(IntUnaryOperator updateFunction)`更新阵列的元素：

```
// [9, 16, 4, 25]
AtomicIntegerArray atomicArray
  = new AtomicIntegerArray(new int[] {3, 4, 2, 5});

for (int i = 0; i < atomicArray.length(); i++) {
  atomicArray.updateAndGet(i, elem -> elem * elem);
}
```

*   通过`updateAndGet​(IntUnaryOperator updateFunction)`更新单个整数：

```
// 15
AtomicInteger nr = new AtomicInteger(3);
int result = nr.updateAndGet(x -> 5 * x);
```

*   通过`accumulateAndGet​(int x, IntBinaryOperator accumulatorFunction)`更新单个整数：

```
// 15
AtomicInteger nr = new AtomicInteger(3);
// x = 3, y = 5
int result = nr.accumulateAndGet(5, (x, y) -> x * y);
```

*   通过`addAndGet​(int delta)`更新单个整数：

```
// 7
AtomicInteger nr = new AtomicInteger(3);
int result = nr.addAndGet(4);
```

*   通过`compareAndSet​(int expectedValue, int newValue)`更新单个整数：

```
// 5, true
AtomicInteger nr = new AtomicInteger(3);
boolean wasSet = nr.compareAndSet(3, 5);
```

从 JDK 9 开始，已经丰富了原子变量类，其中几种方法（如`get` / `setPlain()`，`get` / `setOpaque()`，`getAcquire()`及其同伴）。 为了了解这些方法，请使用 JDK 9 Memory Order Modes 通过 Doug Lea 查看，可在 [http://gee.cs.oswego.edu/dl/html/j9mm .html，](http://gee.cs.oswego.edu/dl/html/j9mm.html)在撰写本文时。

# 加法器和累加器

在 Java API 文档之后，在多线程应用程序的情况下频繁更新但较少频繁地阅读，建议依赖于`LongAdder`，`DoubleAdder`，`LongAccumulator`和`DoubleAccumulator`，而不是`Atomic*Foo*`类。 对于这种情况，这些类旨在优化线程的使用。

这意味着，我们可以使用`LongAdder`来计算整数，而不是使用`AtomicInteger`，而不是使用`AtomicInteger`，如下所示：

```
public class AtomicAdder implements Runnable {

  public static LongAdder count = new LongAdder();

  @Override
  public void run() {

    count.add(1);
  }

  public long getCount() {

    return count.sum();
  }
}
```

或者，我们可以使用`LongAccumulator`如下：

```
public class AtomicAccumulator implements Runnable {

  public static LongAccumulator count
    = new LongAccumulator(Long::sum, 0);

  @Override
  public void run() {

    count.accumulate(1);
  }

  public long getCount() {

    return count.get();
  }
}
```

`LongAdder`和`DoubleAdder`是暗示附加（另一个特定操作的操作）的方案，而`LongAccumulator`和`DoubleAccumulator`是正确的，用于依赖于给定函数组合值的情况。

# 222.重新结合

`Lock`接口包含一组锁定操作，可以明确地用于微调锁定过程（它提供比内在锁定更多的控制）。 其中，我们调查的，无条件的，定时和中断获取锁。 基本上，`Lock`将`synchronized`关键字的期货与其他功能暴露。 `Lock`接口如下代码所示：

```
public interface Lock {
  void lock();
  void lockInterruptibly() throws InterruptedException;
  boolean tryLock();
  boolean tryLock(long timeout, TimeUnit unit)
  throws InterruptedException;
  void unlock();
  Condition newCondition();
}
```

`Lock`的实现之一是`ReentrantLock`。 a *reentrant* 锁定如下：当线程首次进入锁定时，保持计数被设置为一个。 在解锁之前，线程可以重新输入锁，导致每个条目递增一个保持计数。 每个解锁请求递减一个，并且当保持计数为零时，打开锁定资源。

具有与`synchronized`关键字相同的坐标，`ReentrantLock`遵循以下奇偶实现：

```
Lock / ReentrantLock lock = new ReentrantLock();
...
lock.lock();

try {
  ...
} finally {
  lock.unlock();
}
```

在非公平锁的情况下，授予访问权限的顺序是未指定的。 如果锁应该是公平的（优先考虑已经等待最长的线程），那么使用`ReentrantLock​(boolean fair)`构造函数。

通过`ReentrantLock`将以 1 到 1,000,000 的整数总成，可以如下完成：

```
public class CounterWithLock {

  private static final Lock lock = new ReentrantLock();

  private static int count;

  public void counter() {
    lock.lock();

    try {
      count++;
    } finally {
      lock.unlock();
    }
  }
}
```

并且，让我们通过多个线程使用它：

```
CounterWithLock counterWithLock = new CounterWithLock();
Runnable task = () -> {
  counterWithLock.counter();
};

ExecutorService executor = Executors.newFixedThreadPool(8);
for (int i = 0; i < 1 _000_000; i++) {
  executor.execute(task);
}
```

完毕！

作为奖励，以下代码表示基于`ReentrantLock.lockInterruptibly()`解决问题的成语。 捆绑到本书的代码随着使用`lockInterruptibly()`的示例：

```
Lock / ReentrantLock lock = new ReentrantLock();
public void execute() throws InterruptedException {
  lock.lockInterruptibly();

  try {
    // do something
  } finally {
    lock.unlock();
  }
}
```

如果包含该锁的线程被中断，则抛出`InterruptedException`。 使用`lock()`代替`lockInterruptibly()`不会接受中断。

此外，以下代码表示使用`ReentrantLock.tryLock(long timeout, TimeUnit unit) throws InterruptedException`的成语。 捆绑到本书的代码以及一个例子：

```
Lock / ReentrantLock lock = new ReentrantLock();

public boolean execute() throws InterruptedException {

  if (!lock.tryLock(n, TimeUnit.SECONDS)) {
    return false;
  }

  try {
    // do something
  } finally {
    lock.unlock();
  }

  return true;
}
```

请注意，`tryLock()`试图为指定时间获取锁定。 如果这次经过时间，那么线程将不会获取锁定。 它不会自动重试。 如果在尝试获取锁时线程中断，则将抛出`InterruptedException`。

最后，捆绑到本书的代码随着使用`ReentrantLock.newCondition()`的示例。 idiom 在下一个屏幕截图：

![](img/1bb55dfb-35d8-4092-9924-66c157844a72.png)

# 223\. reentrantreadWriteLock.

通常，应基于两个语句完成读写串联（例如，读写文件）：

*   只要没有作家（共享悲观锁定），读者可以同时阅读。

*   单个作家一次可以写一次（独家/悲观锁定）。

下图描绘了左侧左侧的读者和右侧的作家：

![](img/1f47d8ce-a71c-44d7-b085-f26ad399d4ea.png)

主要是，`ReentrantReadWriteLock`实现以下行为：

*   为两个锁提供悲观锁定语义（读写锁定）。

*   如果有些读者持有读锁和写入器想要写入锁，则允许更多读取器获取读取锁定，直到写入器释放写入锁定。

*   作者可以获取读锁，但读者无法获取写入锁定。

在非公平锁的情况下，授予权限的线程的顺序是未指定的。 如果锁应该是公平的（优先考虑一直在等待最长的线程），那么使用`ReentrantReadWriteLock​(boolean fair)`构造函数。

使用`ReentrantReadWriteLock`的成语如下所示：

```
ReadWriteLock / ReentrantReadWriteLock lock 
  = new ReentrantReadWriteLock();
...
lock.readLock() / writeLock().lock();
try {
  ...
} finally {
  lock.readLock() / writeLock().unlock();
}
```

以下代码表示`ReentrantReadWriteLock`使用情况读取和写入整数变量：

```
public class ReadWriteWithLock {

  private static final Logger logger
    = Logger.getLogger(ReadWriteWithLock.class.getName());
  private static final Random rnd = new Random();

  private static final ReentrantReadWriteLock lock
    = new ReentrantReadWriteLock(true);

  private static final Reader reader = new Reader();
  private static final Writer writer = new Writer();

  private static int amount;

  private static class Reader implements Runnable {

    @Override
    public void run() {
      if (lock.isWriteLocked()) {
        logger.warning(() -> Thread.currentThread().getName() 
          + " reports that the lock is hold by a writer ...");
      }

      lock.readLock().lock();

      try {
        logger.info(() -> "Read amount: " + amount 
          + " by " + Thread.currentThread().getName());
      } finally {
        lock.readLock().unlock();
      }
    }
  }

  private static class Writer implements Runnable {

    @Override
    public void run() {
        lock.writeLock().lock();
        try {
          Thread.sleep(rnd.nextInt(2000));
          logger.info(() -> "Increase amount with 10 by " 
            + Thread.currentThread().getName());

          amount += 10;
        } catch (InterruptedException ex) {
          Thread.currentThread().interrupt();
          logger.severe(() -> "Exception: " + ex);
        } finally {
          lock.writeLock().unlock();
        }
      }
      ...
  }
```

并且，让我们执行 10 个阅读和 10 个写入读者和四个作家：

```
ExecutorService readerService = Executors.newFixedThreadPool(2);
ExecutorService writerService = Executors.newFixedThreadPool(4);

for (int i = 0; i < 10; i++) {
  readerService.execute(reader);
  writerService.execute(writer);
}
```

可能的输出将如下：

```
[09:09:25] [INFO] Read amount: 0 by pool-1-thread-1
[09:09:25] [INFO] Read amount: 0 by pool-1-thread-2
[09:09:26] [INFO] Increase amount with 10 by pool-2-thread-1
[09:09:27] [INFO] Increase amount with 10 by pool-2-thread-2
[09:09:28] [INFO] Increase amount with 10 by pool-2-thread-4
[09:09:29] [INFO] Increase amount with 10 by pool-2-thread-3
[09:09:29] [INFO] Read amount: 40 by pool-1-thread-2
[09:09:29] [INFO] Read amount: 40 by pool-1-thread-1
[09:09:31] [INFO] Increase amount with 10 by pool-2-thread-1
...
```

在决定依赖`ReentrantReadWriteLock`之前，请考虑它可能遭受饥饿（例如，当作家提供优先权时，读者可能会饿死）。 此外，我们无法将读锁升级到写入锁（可能从编写器到读取器的降级是可能的），并且没有支持乐观读取。 如果您的任何事项，那么请考虑`StampedLock`，我们将在下一个问题中查看。

# 224\. Stampedlock.

简而言之，`StampedLock`执行比`ReentrantReadWriteLock`更好，并支持乐观读取。 它不像*重圈;* 因此，它易于死锁。 主要是，锁定采集返回标记（A `long`值），用于解锁`finally`块中使用。 每次尝试在新戳中获取锁定结果，如果没有可用锁定，则可能会阻止直到可用。 换句话说，如果当前线程保持锁定，并且尝试再次获取锁定，则可能导致死锁。

通过多种方法实现`StampedLock`读/写作编程过程，如下所示：

*   `readLock()`：非专门获取锁，必要时阻止锁定，直到可用。 为了获取读锁的非阻塞尝试，我们必须`tryReadLock()`。 对于超时阻止，我们有`tryReadLock​(long time, TimeUnit unit)`。 返回的邮票用于`unlockRead()`。

*   `writeLock()`：专门获取锁，如果需要，可在可用之前堵塞。 对于未阻止尝试获取写入锁定，我们有`tryWriteLock()`。 对于超时阻止，我们有`tryWriteLock​(long time, TimeUnit unit)`。 返回的邮票用于`unlockWrite()`。

*   `tryOptimisticRead()`：这是为`StampedLock`添加大加上的方法。 此方法返回应通过`validate​()`标志方法验证的标记。 如果锁当前未以写模式保持，则返回的标记仅为零。

`readLock()`和`writeLock()`的习语非常简单：

```
StampedLock lock = new StampedLock();
...
long stamp = lock.readLock() / writeLock();

try {
  ...
} finally {
  lock.unlockRead(stamp) / unlockWrite(stamp);
}
```

尝试为`tryOptimisticRead()`提供成语，可以导致以下内容：

```
StampedLock lock = new StampedLock();

int x; // a writer-thread can modify x
...
long stamp = lock.tryOptimisticRead();
int thex = x;

if (!lock.validate(stamp)) {
  stamp = lock.readLock();

  try {
    thex = x;
  } finally {
    lock.unlockRead(stamp);
  }
}

return thex;
```

在此习语中，请注意，在获取乐观读锁后，请注意初始值（`x`）分配给`thex`变量。 然后，使用`validate()`标志方法来验证由于给定邮票的发射率未被完全获取冲压锁。 如果`validate()`返回`false`（则当获取乐观锁定之后通过线程获取写入锁定的事实），则通过阻塞`readLock()`和值（`x`）获取读锁定（`x`） 再次分配。 请记住，如果有任何写入锁，则读锁可能会阻止。 获取乐观锁允许我们读取值，然后验证这些值是否有任何变化。 只有在存在时，我们才能通过阻止读锁定。

以下代码表示`StampedLock`使用情况读取和写入整数变量。 基本上，我们通过乐观读取重申了先前问题的解决方案：

```
public class ReadWriteWithStampedLock {

  private static final Logger logger
    = Logger.getLogger(ReadWriteWithStampedLock.class.getName());
  private static final Random rnd = new Random();

  private static final StampedLock lock = new StampedLock();

  private static final OptimisticReader optimisticReader
    = new OptimisticReader();
  private static final Writer writer = new Writer();

  private static int amount;

  private static class OptimisticReader implements Runnable {

    @Override
    public void run() {
      long stamp = lock.tryOptimisticRead();

      // if the stamp for tryOptimisticRead() is not valid
      // then the thread attempts to acquire a read lock
      if (!lock.validate(stamp)) {
        stamp = lock.readLock();
        try {
          logger.info(() -> "Read amount (read lock): " + amount 
            + " by " + Thread.currentThread().getName());
        } finally {
          lock.unlockRead(stamp);
        }
      } else {
        logger.info(() -> "Read amount (optimistic read): " + amount 
          + " by " + Thread.currentThread().getName());
      }
    }
  }

  private static class Writer implements Runnable {

    @Override
    public void run() {

      long stamp = lock.writeLock();

      try {
        Thread.sleep(rnd.nextInt(2000));
        logger.info(() -> "Increase amount with 10 by " 
          + Thread.currentThread().getName());

        amount += 10;
      } catch (InterruptedException ex) {
        Thread.currentThread().interrupt();
        logger.severe(() -> "Exception: " + ex);
      } finally {
        lock.unlockWrite(stamp);
      }
    }
  }
  ...
}
```

并且，让我们执行 10 个阅读和 10 个写入读者和四个作家：

```
ExecutorService readerService = Executors.newFixedThreadPool(2);
ExecutorService writerService = Executors.newFixedThreadPool(4);

for (int i = 0; i < 10; i++) {
  readerService.execute(optimisticReader);
  writerService.execute(writer);
}
```

可能的输出将是以下内容：

```
...
[12:12:07] [INFO] Increase amount with 10 by pool-2-thread-4
[12:12:07] [INFO] Read amount (read lock): 90 by pool-1-thread-2
[12:12:07] [INFO] Read amount (optimistic read): 90 by pool-1-thread-2
[12:12:07] [INFO] Increase amount with 10 by pool-2-thread-1
...
```

从 JDK 10 开始，我们可以使用`isWriteLockStamp()`，`isReadLockStamp()`，`isLockStamp()`和`isOptimisticReadStamp()`查询戳记类型。 基于该类型，我们可以决定正确的解锁方法，例如，如下：

```
if (StampedLock.isReadLockStamp(stamp))
  lock.unlockRead(stamp);
}
```

在本书捆绑到本书的代码中，还有一个应用程序，以举例说明`tryConvertToWriteLock​()`方法。 此外，您可能有兴趣开发使用`tryConvertToReadLock​()`和`tryConvertToOptimisticRead()`的应用程序。

# 225.僵局（用餐哲学家）

什么是僵局？ 互联网上的着名笑话解释如下：

*面试官：*向我们解释，我们会雇用你！

*我：*雇用我，我会向你解释...

可以将简单的死锁作为`A`锁定`A`锁定，并尝试获取`P `锁定，同时有一个`B`螺纹，锁定`P`锁定并尝试 获取`L`锁定。 这种僵局被称为 **c** **incluclay 等待**。 Java 没有死锁检测和解析机制（随着数据库），因此僵局对应用程序非常尴尬。 僵局可以完全或部分阻止应用程序，可能会导致严重的性能惩罚，奇怪的行为等。 通常，死锁很难调试，解决死锁的唯一方法包括重新启动应用程序并希望最佳。

餐饮哲学家是用于说明僵局的着名问题。 这个问题说五个哲学家坐在一张桌子周围。 他们中的每一个都交替思考和吃东西。 为了吃，哲学家在他的手中需要两个叉子 - 从他的左侧和叉子的叉子叉。 只有五叉的事实施加了困难。 进食后，哲学家将两个叉子放回桌子上，然后可以被另一个重复同一周期的哲学家拿起。 当哲学家不吃时，他/她在思考。 下图说明了此方案：

![](img/f543b24b-a620-426e-be6d-a9e1416ca9a7.png)

主要任务是找到解决这个问题的解决方案，让哲学家以这样的方式思考和吃，以免饿死。

在代码中，我们可以将每个哲学家视为`Runnable`实例。 存在`Runnable`实例，我们可以在单独的线程中执行它们。 每个哲学家都可以拿起左右放置的两个叉子。 如果我们代表叉子作为`String`，那么我们可以使用以下代码：

```
public class Philosopher implements Runnable {

  private final String leftFork;
  private final String rightFork;

  public Philosopher(String leftFork, String rightFork) {
    this.leftFork = leftFork;
    this.rightFork = rightFork;
  }

  @Override
  public void run() {
    // implemented below
  }
}
```

因此，哲学家可以挑选`leftFork`和`rightFork`。 但由于哲学家分享这些叉子，哲学家必须在这两个叉上获得独家锁。 在`leftFork`上具有独家锁定，并在`rightFork`上的独家锁定相当于手中有两个叉子。 在`leftFork`和`rightFork`上具有独占锁相当于哲学家饮食。 释放两个独家锁相当于哲学家不吃和思考。

可以通过`synchronized`关键字实现锁定，如下`run()`方法：

```
@Override
public void run() {

  while (true) {
    logger.info(() -> Thread.currentThread().getName() 
      + ": thinking");
    doIt();

    synchronized(leftFork) {
      logger.info(() -> Thread.currentThread().getName() 
        + ": took the left fork (" + leftFork + ")");
      doIt();

      synchronized(rightFork) {
        logger.info(() -> Thread.currentThread().getName() 
          + ": took the right fork (" + rightFork + ") and eating");
        doIt();

        logger.info(() -> Thread.currentThread().getName() 
          + ": put the right fork ( " + rightFork 
          + ") on the table");
        doIt();
      }

      logger.info(() -> Thread.currentThread().getName() 
        + ": put the left fork (" + leftFork 
        + ") on the table and thinking");
      doIt();
    }
  }
}
```

哲学家通过思考而开始。 经过一段时间，他饿了，所以他试图拿起左右叉子。 如果成功，他会吃一会儿。 之后，他把叉子放在桌子上，继续思考，直到他饿了。 与此同时，另一个哲学家会吃。

`doIt()`方法通过随机睡眠模拟所涉及的动作（思考，进食，挑选和叉子）。 这可以在代码中看到如下：

```
private static void doIt() {
  try {
    Thread.sleep(rnd.nextInt(2000));
  } catch (InterruptedException ex) {
    Thread.currentThread().interrupt();
    logger.severe(() -> "Exception: " + ex);
  }
}
```

最后，我们需要叉子和哲学家，请参阅以下代码：

```
String[] forks = {
  "Fork-1", "Fork-2", "Fork-3", "Fork-4", "Fork-5"
};

Philosopher[] philosophers = {
  new Philosopher(forks[0], forks[1]),
  new Philosopher(forks[1], forks[2]),
  new Philosopher(forks[2], forks[3]),
  new Philosopher(forks[3], forks[4]),
  new Philosopher(forks[4], forks[0])
};
```

每个哲学家都将在一个线程中运行，如下所示：

```
Thread threadPhilosopher1 
  = new Thread(philosophers[0], "Philosopher-1");
...
Thread threadPhilosopher5 
  = new Thread(philosophers[4], "Philosopher-5");

threadPhilosopher1.start();
...
threadPhilosopher5.start();
```

这种实现似乎是可以的，甚至可能会很好努力。 但是，此实施块迟早，输出如下：

```
[17:29:21] [INFO] Philosopher-5: took the left fork (Fork-5)
...
// nothing happens
```

这是一个僵局！ 每位哲学家都有他的左叉（独家锁定），等待正确的叉子在桌子上（锁是释放的）。 显然，这种预期不能满足，因为只有五个叉子，每个哲学家都有一个手。

为了避免这种僵局，解决方案很简单。 我们只强制其中一个哲学家首先拿起正确的叉子。 在成功挑选正确的叉子之后，他可以尝试挑选左边。 在代码中，这是对以下行的快速修改：

```
// the original line
new Philosopher(forks[4], forks[0])

// the modified line that eliminates the deadlock
new Philosopher(forks[0], forks[4])
```

这次我们可以在没有死锁的情况下运行应用程序。

# 概括

好吧，就是这样！ 本章介绍了关于 Fork / Join Framework，`CompletableFuture`，`ReentrantLock`，`ReentrantReadWriteLock`，`StampedLock`，原子变量，任务取消，可中断方法，线程本地和死锁的问题。

从本章下载应用程序以查看结果并查看其他详细信息。