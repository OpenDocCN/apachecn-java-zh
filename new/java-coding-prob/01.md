# 字符串，数字和数学

本章包括 39 个涉及字符串，数字和数学操作的问题。 我们将首先查看一堆古典问题，以便诸如计数重复的串，反转字符串和删除白色空间。 然后，我们将研究专用于数字和数学操作的问题，例如求解两个大数字和操作溢出，比较两个无符号数，并计算分割和模数的底板。 每个问题通过多种解决方案，包括 Java 8 的功能样式。 此外，我们将涵盖关注 JDK 9,10,11 和 12 的问题。

到本章末尾，您将知道如何使用一堆技术，以便您可以操纵字符串并应用，调整，调整它们到许多其他问题。 您还将知道如何解决可能导致奇怪和不可预测的结果的数学角案例。

# 问题

使用以下问题来测试您的字符串操作和数学角案例编程 prowess。 我强烈建议您在转向解决方案并下载示例程序之前尝试举出每个问题：

1.  **计数重复字符**：写入从给定字符串计算重复字符的程序。
2.  **找到第一个非重复字符**：写一个程序，该程序从给定字符串返回第一个非重复字符。
3.  **反转字母和单词**：编写一个程序，该程序反转每个单词的字母和一个程序，该程序逆转每个单词和单词本身的字母。
4.  **检查字符串是否仅包含位数**：编写一个检查给定字符串仅包含数字的程序。

5.  **计数元音和辅音**：写一个计算给定字符串中的元音和辅音的数量的程序。 为英语进行这件事，其中有五个元音（A，E，I，O 和 U）。
6.  **计数某个字符**的出现：写一个计算给定字符串中某个字符的发生的程序。
7.  **将`String`转换为`int`，`long`，`float`或`double`** ：写一个将给定`String`对象（表示一个数字）转换为`int`的程序，`long`，`float`，或`double`。
8.  **从 String** 删除白色空格：写一个程序，该程序从给定字符串中删除所有白色空间。
9.  **使用分隔符**加入多个字符串：写一个通过给定分隔符连接给定字符串的程序。
10.  **生成所有排列**：写一个生成给定字符串的所有排列的程序。
11.  **检查字符串是否是 palindrome** ：编写一个程序，该程序确定给定字符串是否为 palindrome。
12.  **删除重复字符**：写一个删除给定字符串的重复字符的程序。
13.  **删除给定字符**：写一个从给定字符串中删除给定字符的程序。
14.  **找到具有最多的出现**的字符：写一个节目，该程序在给定字符串中具有最多的展示。
15.  **按长度对字符串数组进行排序**：写一个按照给定的字符串数组的长度排序的程序。
16.  **检查字符串包含子字符串**：写一个检查给定字符串是否包含给定的子字符串的程序。
17.  **计数子字符串出现字符串**：写入一个程序，该程序在另一个给定字符串中计算给定字符串的出现。
18.  **检查两个字符串是否是字谜**：写一个检查两个字符串是否是字符串的程序。 考虑一个字符串的字符形是通过忽略大写和白色空间来对该字符串的置换。
19.  **声明多行字符串（文本块）**：写一个声明多行字符串或文本块的程序。
20.  **连接相同的字符串 *n* times** ：写一个将相同的字符串连接到给定次数的程序。
21.  **删除前导和尾随空格**：写一个删除给定字符串的前导空间的程序。

22.  **找到最长的常见前缀**：写一个找到给定字符串最长常见前缀的程序。
23.  **应用缩进**：写几个代码片段以将缩进应用于给定文本。
24.  **转换字符串**：写几个代码片段以将字符串转换为另一个字符串。
25.  **计算最小值和最多两个数字**：写一个返回最小值和最大两个数字的程序。
26.  **求和两个大`int` / `long`数字和操作溢出**：写一个节目，该程序和两个大`int` / `long`数字一起划分，并在操作溢出的情况下抛出算术例外。
27.  **字符串作为基数**中的无符号号：写一个程序将给定字符串解析为给定的基数中的无符号数（`int`或`long`）。
28.  **通过无符号转换**将其转换为数字：写一个通过无符号转换将给定`int`编号转换为`long`的程序。
29.  **比较两个无符号数字**：写一个比较给定的两个数字作为无符号的程序。
30.  **unsigned 值的划分和模数**：编写一个计算给定无符号值的划分和模的程序。
31.  **`double` / `float`是一个有限浮点值**：写一个节目，该程序确定给定`double` / `float`值是有限浮点值。
32.  **将逻辑和/或/ xor 应用于两个布尔表达式**：写一个将逻辑和/或/ xor 应用于两个布尔表达式的程序。
33.  **将** `BigInteger` **转换为原始类型**：写一个程序从给定`BigInteger`中提取基元类型值。
34.  **将`long`转换为`int`** ：写一个将`long`转换为`int`的程序。
35.  **计算分部和模数**的地板：写一个计算给定分红的楼层分割和落地模量（ *x* ）和除数（ *y* ）。
36.  **下一个浮点值**：写一个程序，返回与给定`float` / `double`值相邻的下一个浮点，在正极和负无穷大的方向上。
37.  **乘以两个大`int` / `long`值和操作溢出**：写一个乘以两个大`int` / `long`值的程序，并在操作溢出的情况下抛出算术例外。

38.  **熔融乘法添加**（ **fma** ）：写一个需要三个`float` / `double`值的程序（ *a* ， *b* ， *C* ）以有效的方式计算 *A * B + C* 。
39.  **紧凑型格式**：写一个程序格式化 1,000,000 到 1 米（美国地区环境）和 1 MLN（意大利地区）的程序。 另外，将 1M 和 1 MLN 从弦中解析成一个数字。

# 解决方案

以下部分描述了前一个问题的解决方案。 请记住，几乎不是一个正确的方法来解决特定问题。 此外，请记住，这里所示的解释仅包括解决问题所需的最有趣和重要的细节。 您可以下载示例解决方案，以查看其他详细信息，并在 [https://github.com/packtpublishing/java-coding-problems 上的程序](https://github.com/PacktPublishing/Java-Coding-Problems)。

# 1.计算重复的字符

将字符串中的字符（包括＃，$和％）计算字符串的解决方案意味着每个角色并将其与其余部分进行比较。 在比较期间，通过每次找到当前角色时，通过数字计数器维护计数状态。

这个问题有两个解决方案。

第一个解决方案迭代字符串字符并使用`Map`将字符存储为键，并且出现的数量作为值。 如果从未添加到`Map`中的当前字符，则将其添加为`(character, 1)`。 如果当前字符存在于`Map`中，则只需将其出现增加 1，例如`(character, occurrences+1)`。 这在以下代码中显示：

```
public Map<Character, Integer> countDuplicateCharacters(String str) {

  Map<Character, Integer> result = new HashMap<>();

  // or use for(char ch: str.toCharArray()) { ... }
  for (int i = 0; i<str.length(); i++) {
    char ch = str.charAt(i); 

    result.compute(ch, (k, v) -> (v == null) ? 1 : ++v);
  }

  return result;
}
```

另一种解决方案依赖于 Java 8 的流功能。 该解决方案有三个步骤。 前两个步骤旨在将给定字符串转换为`Stream<Character>`，而最后一步是负责分组和计数字符。 以下是步骤：

1.  在原始字符串上调用`String.chars()`方法。 这将返回`IntStream`。 此`IntStream`包含来自给定字符串的字符的整数表示。
2.  通过`mapToObj()`方法将`IntStream`转换为字符流（将整数表示转换为人友好的字符形式）。
3.  最后，将字符（`Collectors.groupingBy()`）进行组并计算它们（`Collectors.counting()`）。

以下代码片段将这三个步骤胶合成一个方法：

```
public Map<Character, Long> countDuplicateCharacters(String str) {

  Map<Character, Long> result = str.chars()
    .mapToObj(c -> (char) c)
    .collect(Collectors.groupingBy(c -> c, Collectors.counting()));

  return result;
}
```

# unicode 字符呢？

我们非常熟悉 ASCII 字符。 我们在 32-127 之间的 0-31，可打印字符之间具有未打印的控制代码，并在 128-255 之间的扩展 ASCII 代码。 但 Unicode 字符呢？ 考虑每个要求我们操纵 Unicode 字符的问题的本节。

因此，在简而言之，早期的 Unicode 版本包含具有小于 65,535（0xFFFF）的值的字符。 Java 表示使用 16 位`char`数据类型的这些字符。 只要 *`i`* 不超过 65,535，呼叫`charAt(i)`工作正常工作。 但随着时间的推移，Unicode 增加了更多的字符，最大值已达到 1,114,111（0x10FFFF）。 这些字符不适合 16 位，因此考虑了 UTF-32 编码方案的 32 位值（称为*代码点*）。

不幸的是，Java 不支持 UTF-32！ 尽管如此，Unicode 已经提出了一个解决方案，仍然使用 16 位来表示这些字符。 此解决方案暗示以下内容：

*   16 位*高代理*：1,024 值（U + D800 至 U + DBFF）
*   16 位*低代理*：1,024 值（U + DC00 至 U + DFFF）

现在，一个高代理，然后是低代理定义了所谓的**代理对**。 代理对表示 65,536（0x10000）和 1,114,111（0x10FFFF）之间的值。 因此，某些字符，称为 Unicode 补充字符，表示为 Unicode 代理对（一个字符（符号）在一个字符的空间中合并到单个代码点中。 Java 利用此表示，通过诸如`codePointAt()`，`codePoints()`，`codePointCount()`和`offsetByCodePoints()`的方法套件公开它（查看 Java 文档以获取详细信息）。 调用`codePointAt()`而不是`charAt()`，`codePoints()`而不是`chars()`，依此类推，帮助我们编写覆盖 ASCII 和 Unicode 字符的解决方案。

例如，众所周知的两颗心符号是 Unicode 代理对，其可以表示为包含两个值的`char[]`：`\uD83D`和`\uDC95`。 此符号的代码点是`128149`。 要从此代码点获取`String`对象，请调用`String str = String.valueOf(Character.toChars(128149))`。 计算`str`中的代码点可以通过调用`str.codePointCount(0, str.length())`来完成，即使`str`长度为 2，返回 1。呼叫`str.codePointAt(0)`返回`128149`并调用`str.codePointAt(1)`返回`56469`。 呼叫`Character.toChars(128149)`返回 2，因为需要两个字符来表示此代码点是 unicode 代理对。 对于 ASCII 和 Unicode 16 位字符，它将返回 1。

所以，如果我们尝试重写第一个解决方案（迭代字符串字符并使用`Map`将字符存储为键和作为值的出现次数），以支持 ASCII 和 Unicode（包括代理对），我们获取以下内容 代码：

```
public static Map<String, Integer> 
    countDuplicateCharacters(String str) {

  Map<String, Integer> result = new HashMap<>();

  for (int i = 0; i < str.length(); i++) {
 int cp = str.codePointAt(i);
 String ch = String.valueOf(Character.toChars(cp));
 if(Character.charCount(cp) == 2) { // 2 means a surrogate pair
 i++;
 }

    result.compute(ch, (k, v) -> (v == null) ? 1 : ++v);
  }

  return result;
}
```

突出显示的代码也可以如下写入：

```
String ch = String.valueOf(Character.toChars(str.codePointAt(i)));
if (i < str.length() - 1 && str.codePointCount(i, i + 2) == 1) {
  i++;
}
```

最后，尝试重写 Java 8 功能样式解决方案以覆盖 Unicode 代理对可以如下完成：

```
public static Map<String, Long> countDuplicateCharacters(String str) { 

  Map<String, Long> result = str.codePoints()
    .mapToObj(c -> String.valueOf(Character.toChars(c)))
    .collect(Collectors.groupingBy(c -> c, Collectors.counting()));

  return result;
}
```

对于第三方图书馆支持，请考虑 Guava：`Multiset<String>`。

以下一些问题将提供覆盖 ASCII，16 位 Unicode 和 Unicode 代理对的解决方案。 它们已被任意选择，因此，通过依靠这些解决方案，您可以轻松地编写解决方案的解决方案，以解决不提供此类解决方案的问题。

# 2.找到第一个不复用的角色

有不同的解决方案来查找字符串中的第一个非重复字符。 主要是，问题可以在字符串的单个遍历中或更完整/部分遍历中解决问题。

在单个遍历方法中，我们填充了一个旨在存储在字符串中完全一切显示的所有字符的索引的数组。 使用此数组，只需返回包含非重复字符的最小索引：

```
private static final int EXTENDED_ASCII_CODES = 256;
...
public char firstNonRepeatedCharacter(String str) {

  int[] flags = new int[EXTENDED_ASCII_CODES];

  for (int i = 0; i < flags.length; i++) {
    flags[i] = -1;
  }

  for (int i = 0; i < str.length(); i++) {
    char ch = str.charAt(i);
    if (flags[ch] == -1) {
      flags[ch] = i;
    } else {
      flags[ch] = -2;
    }
  }

  int position = Integer.MAX_VALUE;

  for (int i = 0; i < EXTENDED_ASCII_CODES; i++) {
    if (flags[i] >= 0) {
      position = Math.min(position, flags[i]);
    }
  }

  return position == Integer.MAX_VALUE ?
    Character.MIN_VALUE : str.charAt(position);
}
```

此解决方案假定来自字符串的每个字符都是扩展 ASCII 表（256 个代码）的一部分。 具有大于 256 的代码要求我们相应地增加阵列的大小（ [http://www.alansofficespace.com/unicode/unicd99.htm](http://www.alansofficespace.com/unicode/unicd99.htm) ）。 解决方案将工作只要阵列大小未延伸超过`char`类型的最大值，这是`Character.MAX_VALUE`，即 65,535。 另一方面，`Character.MAX_CODE_POINT`返回 Unicode 代码点的最大值，1,114,111。 要涵盖此范围，我们需要基于`codePointAt()`和`codePoints()`的另一个实现。

由于单一的遍历方法，这很快。 另一个解决方案包括为每个字符循环字符串并计算出现的次数。 每秒发生（重复）只是打破循环，跳转到下一个字符，并重复算法。 如果达到字符串的末尾，则它将当前字符返回为第一个不可重复的字符。 此解决方案可在本书捆绑的代码中提供。

此处呈现的另一种解决方案依赖于`LinkedHashMap`。 此 Java Map 是*插入顺序*映射（它将键插入地图中的顺序维护），并且对此解决方案非常方便。 `LinkedHashMap`用字符作为键填充，并且出现的数量为值。 一旦`LinkedHashMap`完成，它将返回一个值等于 1 的第一键。由于*插入顺序*功能，这是字符串中的第一个不可重复的字符：

```
public char firstNonRepeatedCharacter(String str) {

  Map<Character, Integer> chars = new LinkedHashMap<>();

  // or use for(char ch: str.toCharArray()) { ... }
  for (int i = 0; i < str.length(); i++) {
    char ch = str.charAt(i);

    chars.compute(ch, (k, v) -> (v == null) ? 1 : ++v);
  }

  for (Map.Entry<Character, Integer> entry: chars.entrySet()) {
    if (entry.getValue() == 1) {
      return entry.getKey();
    }
  }

  return Character.MIN_VALUE;
}
```

在与本书捆绑的代码中，上述解决方案已用 Java 8 功能风格编写。 此外，用于支持 ASCII，16 位 Unicode 和 Unicode 代理对的功能样式解决方案如下：

```
public static String firstNonRepeatedCharacter(String str) {

  Map<Integer, Long> chs = str.codePoints()
    .mapToObj(cp -> cp)
    .collect(Collectors.groupingBy(Function.identity(),
      LinkedHashMap::new, Collectors.counting()));

  int cp = chs.entrySet().stream()
   .filter(e -> e.getValue() == 1L)
   .findFirst()
   .map(Map.Entry::getKey)
   .orElse(Integer.valueOf(Character.MIN_VALUE));

  return String.valueOf(Character.toChars(cp));
}
```

要更详细地了解此代码，请考虑 *unicode 字符呢？* 计数*计数重复字符*部分。

# 3.扭转字母和单词

首先，让我们只反转每个单词的字母。 解决此问题的解决方案可以利用`StringBuilder`类。 第一步包括使用白色空间作为分隔符将字符串拆分为单词数组（`Spring.split(" ")`）。 此外，我们使用相应的 ASCII 代码撤消每个单词，并将结果附加到`StringBuilder`。 首先，我们按空间拆分给定的字符串。 然后，我们通过以相反的顺序通过`charAt()`来循环获得的单词数组并反转每个单词：

```
private static final String WHITESPACE = " ";
...
public String reverseWords(String str) {

 String[] words = str.split(WHITESPACE);
 StringBuilder reversedString = new StringBuilder();

 for (String word: words) {
   StringBuilder reverseWord = new StringBuilder();

   for (int i = word.length() - 1; i >= 0; i--) {
     reverseWord.append(word.charAt(i));
   }

   reversedString.append(reverseWord).append(WHITESPACE);
 }

 return reversedString.toString();
}
```

获得 Java 8 功能样式的相同结果可以如下所示：

```
private static final Pattern PATTERN = Pattern.compile(" +");
...
public static String reverseWords(String str) {

  return PATTERN.splitAsStream(str)
    .map(w -> new StringBuilder(w).reverse())
    .collect(Collectors.joining(" "));
}
```

请注意，前面的两种方法返回一个字符串，其中包含每个单词的字母反转，但单词本身是相同的初始订单。 现在，让我们考虑另一种方法，可以反转每个单词和单词本身的字母。 由于内置的​​`StringBuilder.reverse()`方法，这很容易完成：

```
public String reverse(String str) {

  return new StringBuilder(str).reverse().toString();
}
```

对于第三方图书馆支持，请考虑 Apache Commons Lang，`StringUtils.reverse()`。

# 4.检查字符串是否仅包含数字

解决此问题的解决方案依赖于`Character.isDigit()`或`String.matches()`方法。

依赖于`Character.isDigit()`的解决方案非常简单，快速循环字符串字符，如果此方法返回`false`，则打破循环：

```
public static boolean containsOnlyDigits(String str) {

  for (int i = 0; i < str.length(); i++) {
    if (!Character.isDigit(str.charAt(i))) {
      return false;
    }
  }

  return true;
}
```

在 Java 8 功能样式中，可以使用`anyMatch()`重写前面的代码：

```
public static boolean containsOnlyDigits(String str) {

  return !str.chars()
    .anyMatch(n -> !Character.isDigit(n));
}
```

另一种解决方案依赖于`String.matches()`。 此方法返回`boolean`值，指示此字符串是否与给定的正则表达式匹配：

```
public static boolean containsOnlyDigits(String str) {

  return str.matches("[0-9]+");
}
```

请注意，Java 8 功能样式和基于常规表达式的解决方案通常很慢，因此如果速度是必需的，那么最好使用`Character.isDigit()`依赖第一个解决方案。

避免通过`parseInt()`或`parseLong()`解决此问题。 首先，捕获`NumberFormatException`并在`catch`块中采取业务逻辑决策是不好的。 其次，这些方法验证字符串是否是有效的数字，而不是它是否仅包含位数（例如，-4 是有效的）。
对于第三方图书馆支持，请考虑 Apache Commons Lang，`StringUtils.isNumeric()`。

# 5.计算元音和辅音

以下代码适用于英语，但根据您覆盖的语言有多少，元音和辅音的数量可能会有所不同，并且应相应地调整代码。

此问题的第一个解决方案需要遍历字符串字符并执行以下操作：

1.  我们需要检查当前的角色是元音是否是元音（这方便，因为我们只有五个英语纯元音;其他语言有更多的元音，但数字仍然很小）。
2.  如果当前字符不是元音，则检查它是否坐在`'a'`和`'z'`之间（这意味着当前字符是辅音）。

请注意，最初，给定的`String`对象将转换为小写。 这对于避免使用大写字符进行比较是有用的。 例如，对比较仅针对`'a'`而不是`'A'`和`'a'`完成。

此解决方案的代码如下：

```
private static final Set<Character> allVowels
            = new HashSet(Arrays.asList('a', 'e', 'i', 'o', 'u'));

public static Pair<Integer, Integer> 
    countVowelsAndConsonants(String str) {

  str = str.toLowerCase();
  int vowels = 0;
  int consonants = 0;

  for (int i = 0; i < str.length(); i++) {
    char ch = str.charAt(i);
    if (allVowels.contains(ch)) {
      vowels++;
    } else if ((ch >= 'a' && ch <= 'z')) {
      consonants++;
    }
  }

  return Pair.of(vowels, consonants);
}
```

在 Java 8 功能风格中，可以使用`chars()`和`filter()`重写此代码：

```
private static final Set<Character> allVowels
            = new HashSet(Arrays.asList('a', 'e', 'i', 'o', 'u'));

public static Pair<Long, Long> countVowelsAndConsonants(String str) {

  str = str.toLowerCase();

  long vowels = str.chars()
    .filter(c -> allVowels.contains((char) c))
    .count();

  long consonants = str.chars()
    .filter(c -> !allVowels.contains((char) c))
    .filter(ch -> (ch >= 'a' && ch<= 'z'))
    .count();

  return Pair.of(vowels, consonants);
}
```

相应地筛选给定的字符串，`count()`终端操作返回结果。 依赖于`partitioningBy()`将减少代码，如下所示：

```
Map<Boolean, Long> result = str.chars()
  .mapToObj(c -> (char) c)
  .filter(ch -> (ch >= 'a' && ch <= 'z'))
  .collect(partitioningBy(c -> allVowels.contains(c), counting()));

return Pair.of(result.get(true), result.get(false));
```

完毕！ 现在，让我们看看我们如何在字符串中计算某个字符的出现。

# 6.计算某个角色的发生

对此问题的简单解决方案包括以下两个步骤：

1.  用`""`替换给定字符串中的每次发生字符（基本上，这就像在给定字符串中删除此字符的所有发生）。
2.  从初始字符串的长度中减去第一步中获得的字符串的长度。

此方法的代码如下：

```
public static int countOccurrencesOfACertainCharacter(
    String str, char ch) {

  return str.length() - str.replace(String.valueOf(ch), "").length();
}
```

以下解决方案涵盖 Unicode 代理对：

```
public static int countOccurrencesOfACertainCharacter(
    String str, String ch) { 

  if (ch.codePointCount(0, ch.length()) > 1) {
    // there is more than 1 Unicode character in the given String
    return -1; 
  }

  int result = str.length() - str.replace(ch, "").length();

  // if ch.length() return 2 then this is a Unicode surrogate pair
  return ch.length() == 2 ? result / 2 : result;
}
```

另一个易于实现和快速解决方案包括循环字符串字符（单个遍历）并将每个字符与给定字符进行比较。 每场比赛增加一个柜台：

```
public static int countOccurrencesOfACertainCharacter(
    String str, char ch) {

  int count = 0;

  for (int i = 0; i < str.length(); i++) {
    if (str.charAt(i) == ch) {
      count++;
    }
  }

  return count;
}
```

涵盖 Unicode 代理对的解决方案是与本书捆绑的代码中。 在 Java 8 功能风格中，一个解决方案包括使用`filter()`或`reduce()`。 例如，使用`filter()`将导致以下代码：

```
public static long countOccurrencesOfACertainCharacter(
    String str, char ch) {

  return str.chars()
    .filter(c -> c == ch)
    .count();
}
```

涵盖 Unicode 代理对的解决方案是与本书捆绑的代码中。

对于第三方图书馆支持，请考虑 Apache Commons Lang，`StringUtils.countMatches()`，Spring Framework，`StringUtils.countOccurrencesOf()`和 Guava，`CharMatcher.is().countIn()`。

# 7.将字符串转换为 int，long，float 或 double

让我们考虑以下字符串（也可以使用否定）：

```
private static final String TO_INT = "453"; 
private static final String TO_LONG = "45234223233"; 
private static final String TO_FLOAT = "45.823F";
private static final String TO_DOUBLE = "13.83423D";
```

将`String`转换为`int`，`long`，`float`或`double`的适当解决方案包括使用`Integer`，`Long`，`Float`和`Double`的 Java 方法。 类`parseInt()`，`parseLong()`，`parseFloat()`和`parseDouble()`：

```
int toInt = Integer.parseInt(TO_INT);
long toLong = Long.parseLong(TO_LONG);
float toFloat = Float.parseFloat(TO_FLOAT);
double toDouble = Double.parseDouble(TO_DOUBLE);
```

将`String`转换为`Integer`，`Long`，`Float`或`Double`对象可以通过以下 Java 方法 - `Integer.valueOf()`，`Long.valueOf()`，`Float.valueOf()`和`Double.valueOf()`来完成：

```
Integer toInt = Integer.valueOf(TO_INT);
Long toLong = Long.valueOf(TO_LONG);
Float toFloat = Float.valueOf(TO_FLOAT);
Double toDouble = Double.valueOf(TO_DOUBLE);
```

当一个`String`无法成功转换时，Java 抛出了`NumberFormatException`异常。 以下代码本身表示：

```
private static final String WRONG_NUMBER = "452w";

try {
  Integer toIntWrong1 = Integer.valueOf(WRONG_NUMBER);
} catch (NumberFormatException e) {
  System.err.println(e);
  // handle exception
}

try {
  int toIntWrong2 = Integer.parseInt(WRONG_NUMBER);
} catch (NumberFormatException e) {
  System.err.println(e);
  // handle exception
}
```

对于第三方图书馆支持，请考虑 apache commons beanutils：`IntegerConverter`，`LongConverter`，`FloatConverter`和`DoubleConverter`。

# 8.从字符串中删除白色空格

解决此问题的解决方案包括使用`String.replaceAll()`方法与`\s`正则表达式。 主要是，`\s`去除所有白色空间，包括不可见的空间，例如`\t`，`\n`和`\r`：

```
public static String removeWhitespaces(String str) {
  return str.replaceAll("\\s", "");
}
```

从 JDK 11 开始，`String.isBlank()`检查字符串是否为空或仅包含空白空间代码点。 对于第三方图书馆支持，请考虑 Apache Commons Lang，`StringUtils.deleteWhitespace()`和 Spring Framework `StringUtils.trimAllWhitespace()`。

# 9.使用分隔符加入多个字符串

有几种解决方案适合良好并解决这个问题。 在 Java 8 之前，方便的方法依赖于`StringBuilder`，如下所示：

```
public static String joinByDelimiter(char delimiter, String...args) {

  StringBuilder result = new StringBuilder();

  int i = 0;
  for (i = 0; i < args.length - 1; i++) {
    result.append(args[i]).append(delimiter);
  }
  result.append(args[i]);

  return result.toString();
}
```

从 Java 8 开始，这个问题至少有三个解决方案。 其中一个解决方案依赖于`StringJoiner`效用类。 此类可用于构造由分隔符分隔的字符序列（例如，逗号）。

它支持可选的前缀和后缀（忽略此处）：

```
public static String joinByDelimiter(char delimiter, String...args) {
  StringJoiner joiner = new StringJoiner(String.valueOf(delimiter));

  for (String arg: args) {
    joiner.add(arg);
  }

  return joiner.toString();
}
```

另一种解决方案依赖于`String.join()`方法。 该方法在 Java 8 中引入，并有两种口味：

```
String join​(CharSequence delimiter, CharSequence... elems)
String join​(CharSequence delimiter,
  Iterable<? extends CharSequence> elems)
```

连接几个由空间分隔的字符串的示例如下：

```
String result = String.join(" ", "how", "are", "you"); // how are you
```

更进一步地，Java 8 流和`Collectors.joining()`也可以有用：

```
public static String joinByDelimiter(char delimiter, String...args) {
  return Arrays.stream(args, 0, args.length)
    .collect(Collectors.joining(String.valueOf(delimiter)));
}
```

通过`+=`操作员和`concat()`和`String.format()`方法关注连接字符串。 这些可以用来加入多个字符串，但它们易于表现惩罚。 例如，以下代码依赖于`+=`，而不是依赖于`StringBuilder`：

htg17]
`+=`将附加到字符串并重建一个新的字符串，并且成本时间。

对于第三方图书馆支持，请考虑 Apache Commons Lang，`StringUtils.join()`和 Guava，`Joiner`。

# 10.产生所有排列

涉及排列的问题通常涉及*递归*。 基本上，递归定义为给出一些初始状态并且每个*连续状态*定义在前面的状态方面定义。

在我们的情况下，状态可以通过给定字符串的字母来实现。 初始状态包含初始字符串，每个连续状态都可以通过以下公式计算 - 字符串的每个字母将成为字符串的第一个字母（交换位置），然后使用递归调用释放所有剩余的字母。 虽然存在非递归或其他递归解决方案，但这是对此问题的经典解决方案。

代表字符串的此解决方案`ABC`，可以如此进行（请注意，如何完成禁止）：

![](img/64849bb0-4ed5-4534-abfc-dff0fbe86514.png)

编码此算法将导致以下内容：

```
public static void permuteAndPrint(String str) {

  permuteAndPrint("", str);
}

private static void permuteAndPrint(String prefix, String str) {

  int n = str.length();

  if (n == 0) {
    System.out.print(prefix + " ");
  } else {
    for (int i = 0; i < n; i++) {
      permuteAndPrint(prefix + str.charAt(i),
        str.substring(i + 1, n) + str.substring(0, i));
    }
  }
}
```

最初，前缀应该是空字符串`""`。 在每次迭代时，前缀将从字符串中绑定（修复）下一个字母。 剩余的字母再次通过该方法。

让我们假设此方法生活在名为`Strings`的实用程序类中。 你可以称它为：

```
Strings.permuteAndStore("ABC");
```

这将产生以下输出：

```
ABC ACB BCA BAC CAB CBA
```

请注意，此解决方案在屏幕上打印结果。 存储结果意味着将`Set`添加到实现中。 它优选使用`Set`，因为它消除了重复项：

```
public static Set<String> permuteAndStore(String str) {

  return permuteAndStore("", str);
}

private static Set<String> 
    permuteAndStore(String prefix, String str) {

  Set<String> permutations = new HashSet<>();
  int n = str.length();

  if (n == 0) {
    permutations.add(prefix);
  } else {
    for (int i = 0; i < n; i++) {
      permutations.addAll(permuteAndStore(prefix + str.charAt(i),
        str.substring(i + 1, n) + str.substring(0, i)));
    }
  }

  return permutations;
}
```

例如，如果传递的字符串是`TEST`，则`Set`将导致以下输出（这些都是唯一的置换）：

```
ETST SETT TEST TTSE STTE STET TETS TSTE TSET TTES ESTT ETTS
```

使用`List`而不是`Set`将导致以下输出（注意重复值）：

```
TEST TETS TSTE TSET TTES TTSE ESTT ESTT ETTS ETST ETST ETTS STTE STET STET STTE SETT SETT TTES TTSE TEST TETS TSTE TSET
```

有 24 条排列。 通过计算 *n* 阶段（ *n！*），易于确定产生的置换次数。 对于 *n = 4* （字符串的长度）， *4！ = 1 x 2 x 3 x 4 = 24* 。 在递归风格中表达时，这是 *n！ = n x（n-1）！* 。

自 *n！* 导致高数非常快（例如， *10！= 3628800* ），建议避免储存结果。 对于一个 10 个字符的绳子，如直升机，有 3,628,800 个排列！

试图在 Java 8 中实现此解决方案，将导致以下内容如下：

```
private static void permuteAndPrintStream(String prefix, String str) {

  int n = str.length();

  if (n == 0) {
    System.out.print(prefix + " ");
  } else {
    IntStream.range(0, n)
      .parallel()
      .forEach(i -> permuteAndPrintStream(prefix + str.charAt(i),
        str.substring(i + 1, n) + str.substring(0, i)));
  }
}
```

作为奖金，返回`Stream<String>`的解决方案可在与本书捆绑在一起的代码中。

# 11.检查字符串是否是回文

就像一个快速提醒，一个 *parindrome* （字符串或数字）在颠倒时看起来不变。 这意味着处理（读取）可以从两个方向完成回文，并获得相同的结果（例如，单词*是一个回文，而词*夫人*是 不是）。*

易于实现的解决方案包括比较*遇到中间*方法中给定字符串的字母。 基本上，该解决方案将第一个字符与最后一个，第二个字符与最后一个字符进行比较，依此类推，直到达到字符串的中间。 实施依赖于`while`声明：

```
public static boolean isPalindrome(String str) {

  int left = 0;
  int right = str.length() - 1;

  while (right > left) {
    if (str.charAt(left) != str.charAt(right)) {
      return false;
    }

    left++;
    right--;
  }
  return true;
}
```

以更简洁的方法重写前面的解决方案将由依赖于`for`语句而不是`while`语句，如下所示：

```
public static boolean isPalindrome(String str) {

  int n = str.length();

  for (int i = 0; i < n / 2; i++) {
    if (str.charAt(i) != str.charAt(n - i - 1)) {
      return false;
    }
  }
  return true;
}
```

但是，这种解决方案可以减少到单行代码吗？ 答案是肯定的。

Java API 提供了使用`reverse()`方法的`StringBuilder`类。 当其名称建议时，`reverse()`方法返回反向给定的字符串。 在 Parindrome 的情况下，给定的字符串应等于其反向版本：

```
public static boolean isPalindrome(String str) {

  return str.equals(new StringBuilder(str).reverse().toString());
}
```

在 Java 8 功能风格中，也有一个单一的代码。 简单地定义`IntStream`范围从 0 到给定的字符串的 0 到一半，并使用`noneMatch()` *短路*终端操作，谓词通过遵循 *in-the-the-the-the- 中间*方法：

```
public static boolean isPalindrome(String str) {

  return IntStream.range(0, str.length() / 2)
    .noneMatch(p -> str.charAt(p) != 
      str.charAt(str.length() - p - 1));
}
```

现在，让我们谈谈从给定字符串中删除重复字符。

# 12.删除重复的字符

让我们从解决这个问题开始依赖于`StringBuilder`。 主要是，解决方案应该循环给定字符串的字符并构建包含唯一字符的新字符串（由于在 Java 中，java 是不可能的，因此无法从给定字符串中删除字符。

`StringBuilder`类公开了一个名为`indexOf()`的方法，该方法返回给定字符串的索引，指定子字符串的第一次出现（在我们的情况下，指定的字符）。 因此，对此问题的潜在解决方案是循环给定字符串的字符，并每次应用于当前字符的`indexOf()`方法返回-1 时逐个将它们添加一个（此负面意味着`StringBuilder`不包含当前字符）：

```
public static String removeDuplicates(String str) {

  char[] chArray = str.toCharArray(); // or, use charAt(i)
  StringBuilder sb = new StringBuilder();

  for (char ch : chArray) {
    if (sb.indexOf(String.valueOf(ch)) == -1) {
      sb.append(ch);
    }
  }
  return sb.toString();
}
```

下一个解决方案依赖于`HashSet`和`StringBuilder`之间的协作。 主要是，`HashSet`确保消除重复项，而`StringBuilder`存储所得到的串。 如果`HashSet.add()`返回`true`，那么我们也在`StringBuilder`中添加了字符：

```
public static String removeDuplicates(String str) {

  char[] chArray = str.toCharArray();
  StringBuilder sb = new StringBuilder();
  Set<Character> chHashSet = new HashSet<>();

  for (char c: chArray) {
    if (chHashSet.add(c)) {
      sb.append(c);
    }
  }
  return sb.toString();
}
```

我们介绍的解决方案到目前为止使用`toCharArray()`方法将给定字符串转换为`char[]`。 或者，两种解决方案也可以使用`str.charAt(position)`。

第三种解决方案依赖于 Java 8 功能风格：

```
public static String removeDuplicates(String str) {

  return Arrays.asList(str.split("")).stream()
    .distinct()
    .collect(Collectors.joining());
}
```

首先，解决方案将给定字符串转换为`Stream<String>`，其中每个条目实际上是一个字符。 此外，该解决方案应用有状态中间操作`distinct()`。 此操作将消除流中的重复项，因此它无需重复返回流。 最后，解决方案调用`collect()`终端操作并依赖于`Collectors.joining()`，其简单地将字符连接到遇到的顺序中的字符串中。

# 13.删除给定的角色

依赖于 JDK 支持的解决方案可以利用`String.replaceAll()`方法。 此方法将每个子字符串（在我们的情况下，每个字符）与给定的正则表达式匹配（在我们的情况下，正则表达式是字符本身）与给定的替换（在我们的情况下，替换是空的 字符串`""`）：

```
public static String removeCharacter(String str, char ch) {

  return str.replaceAll(Pattern.quote(String.valueOf(ch)), "");
}
```

请注意，正则表达式在`Pattern.quote()`方法中包装。 这是需要转义<，（，[，\，^， - ，=，$，|，]，]，]，]，]，]，]，]，]，]，>。 主要是，此方法返回指定字符串的文字模式字符串。

现在，让我们来看看一个避免正则表达式的解决方案。 这次，解决方案依赖于`StringBuilder`。 基本上，解决方案循环给定字符串的字符，并将每个字符与字符进行比较以删除。 每次当前字符与要删除的字符不同时，当前字符都在`StringBuilder`中附加：

```
public static String removeCharacter(String str, char ch) {

  StringBuilder sb = new StringBuilder();
  char[] chArray = str.toCharArray();

  for (char c : chArray) {
    if (c != ch) {
      sb.append(c);
    }
  }

  return sb.toString();
}
```

最后，让我们专注于 Java 8 功能样式方法。 这是一项四步方法：

1.  通过`String.chars()`方法将字符串转换为`IntStream`
2.  过滤`IntStream`以消除重复
3.  将生成的`IntStream`映射到`Stream<String>`
4.  从此流加入字符串并将其作为单个字符串收集

此解决方案的代码可以如下写入：

```
public static String removeCharacter(String str, char ch) {

  return str.chars()
    .filter(c -> c != ch)
    .mapToObj(c -> String.valueOf((char) c))
    .collect(Collectors.joining());
}
```

或者，如果我们想删除 Unicode 代理对，那么我们可以依赖于`codePointAt()`和`codePoints()`，如下所示：

```
public static String removeCharacter(String str, String ch) {

   int codePoint = ch.codePointAt(0);

   return str.codePoints()
     .filter(c -> c != codePoint)
     .mapToObj(c -> String.valueOf(Character.toChars(c)))
     .collect(Collectors.joining());
 }
```

对于第三方图书馆支持，请考虑 Apache Commons Lang，`StringUtils.remove()`。

现在，让我们谈谈如何找到最大的出场的角色。

# 14.找到最大的出场的角色

非常简单的解决方案依赖于`HashMap`。 此解决方案包含三个步骤：

1.  首先，循环给定字符串的字符并将键位于当前字符的`HashMap`中的键值对放置对的对，并且该值是当前的出现数
2.  其次，计算`HashMap`中的最大值（例如，使用`Collections.max()`）表示最大出现数
3.  最后，通过循环`HashMap`条目集获取具有最大出现次数的字符

实用程序方法返回包含具有大多数外表的字符的`Pair<Character, Integer>`和出现的次数（注意白色空间被忽略的注意）。 如果您不喜欢拥有此额外的类，那就是`Pair`，那么依靠`Map.Entry<K, V>`：

```
public static Pair<Character, Integer> maxOccurenceCharacter(
  String str) {

  Map<Character, Integer> counter = new HashMap<>();
  char[] chStr = str.toCharArray();

  for (int i = 0; i < chStr.length; i++) {
    char currentCh = chStr[i];
    if (!Character.isWhitespace(currentCh)) { // ignore spaces
      Integer noCh = counter.get(currentCh);
      if (noCh == null) {
        counter.put(currentCh, 1);
      } else {
        counter.put(currentCh, ++noCh);
      }
    }
  }

  int maxOccurrences = Collections.max(counter.values());
  char maxCharacter = Character.MIN_VALUE;

  for (Entry<Character, Integer> entry: counter.entrySet()) {
    if (entry.getValue() == maxOccurrences) {
      maxCharacter = entry.getKey();
    }
  }

  return Pair.of(maxCharacter, maxOccurrences);
}
```

如果使用`HashMap`看起来很麻烦，那么另一个解决方案（即速度稍得多一点）包括依赖 ASCII 代码。 该解决方案以 256 个索引的空阵列开始（256 是扩展 ASCII 表码的最大数量;在*中可以找到更多信息，找到第一个非重复字符*部分）。 此外，此解决方案循环给定字符串的字符，并通过增加此阵列中的相应索引来跟踪每个字符的显示数量：

```
private static final int EXTENDED_ASCII_CODES = 256;
...
public static Pair<Character, Integer> maxOccurenceCharacter(
  String str) {

  int maxOccurrences = -1;
  char maxCharacter = Character.MIN_VALUE;
  char[] chStr = str.toCharArray();
  int[] asciiCodes = new int[EXTENDED_ASCII_CODES];

  for (int i = 0; i < chStr.length; i++) {
    char currentCh = chStr[i];
    if (!Character.isWhitespace(currentCh)) { // ignoring space
      int code = (int) currentCh;
      asciiCodes[code]++;
      if (asciiCodes[code] > maxOccurrences) {
        maxOccurrences = asciiCodes[code];
        maxCharacter = currentCh;
      }
    }
  }

  return Pair.of(maxCharacter, maxOccurrences);
}
```

我们将讨论的最后一个解决方案依赖于 Java 8 功能样式：

```
public static Pair<Character, Long> 
    maxOccurenceCharacter(String str) {

  return str.chars()
    .filter(c -> Character.isWhitespace(c) == false) // ignoring space
    .mapToObj(c -> (char) c)
    .collect(groupingBy(c -> c, counting()))
    .entrySet()
    .stream()
    .max(comparingByValue())
    .map(p -> Pair.of(p.getKey(), p.getValue()))
    .orElse(Pair.of(Character.MIN_VALUE, -1L));
}
```

要启动，此解决方案将不同的字符收集为`Map`中的键，以及它们的出现次数为值。 此外，它使用 Java 8 `Map.Entry.comparingByValue()`和`max()`终端操作来确定具有最高值的地图中的条目（最高出现数量）。 由于`max()`是终端操作，解决方案可能返回`Optional<Entry<Character, Long>>`，但该解决方案增加了额外的步骤并将此条目映射到`Pair<Character, Long>`。

# 15.按长度排序字符串数组

排序时，在分拣是使用比较器时的第一件事。

在这种情况下，解决方案应该比较字符串的长度，因此通过在给定阵列中的每个字符串呼叫`String.length()`来返回整数。 因此，如果整数被排序（升序或降序），则字符串将被排序。

Java `Arrays`类已经提供了一个`sort()`方法，它将阵列排序和比较器。 在这种情况下，`Comparator<String>`应该做这项工作。

在 Java 7 之前，在`compareTo()`方法上依赖于实现比较器的代码。 这种方法的常见用法是计算 *X1* - *X2* 类型的差异，但是该计算可能导致溢出。 这使得`compareTo()`相当乏味。 从 Java 7 开始，`Integer.compare()`是去的方式（没有溢出风险）。

以下是通过依赖于`Arrays.sort()`方法对给定数组进行排序的方法：

```
public static void sortArrayByLength(String[] strs, Sort direction) {
  if (direction.equals(Sort.ASC)) {
    Arrays.sort(strs, (String s1, String s2) 
      -> Integer.compare(s1.length(), s2.length()));
  } else {
    Arrays.sort(strs, (String s1, String s2) 
      -> (-1) * Integer.compare(s1.length(), s2.length()));
  }
}
```

每个原始数字类型的包装器具有`compare()`方法。

从 Java 8 开始，`Comparator`接口丰富了大量有用方法。 其中一个方法是`comparingInt()`，它采用从通用类型中提取`int`排序键的函数，并返回与该排序键进行比较的`Comparator<T>`值。 另一种有用的方法是`reversed()`，其反转当前的`Comparator`值。

根据这两种方法，我们可以授权`Arrays.sort()`如下：

```
public static void sortArrayByLength(String[] strs, Sort direction) {
  if (direction.equals(Sort.ASC)) {
    Arrays.sort(strs, Comparator.comparingInt(String::length));
  } else {
    Arrays.sort(strs, 
      Comparator.comparingInt(String::length).reversed());
  }
}
```

比较器可以用`thenComparing()`方法链接。

我们在此呈现的解决方案返回`void`，这意味着它们对给定的数组进行排序。 要返回新的排序阵列而不更改给定数组，我们可以使用 Java 8 功能样式，如以下代码片段所示：

```
public static String[] sortArrayByLength(String[] strs, 
    Sort direction) {

  if (direction.equals(Sort.ASC)) {
    return Arrays.stream(strs)
      .sorted(Comparator.comparingInt(String::length))
      .toArray(String[]::new);
  } else {
    return Arrays.stream(strs)
      .sorted(Comparator.comparingInt(String::length).reversed())
      .toArray(String[]::new);
  }
}
```

因此，代码从给定阵列创建流，通过`sorted()`状态中间操作对其进行排序，并在另一个阵列中收集结果。

# 16.检查字符串包含子字符串

一个非常简单的一行代码解决方案依赖于`String.contains()`方法。

此方法返回一个`boolean`值，指示给定的子字符串是否存在于字符串中：

```
String text = "hello world!";
String subtext = "orl";

// pay attention that this will return true for subtext=""
boolean contains = text.contains(subtext);
```

或者，可以通过依赖于`String.indexOf()`（或`String.lastIndexOf()`）来实现解决方案，如下：

```
public static boolean contains(String text, String subtext) {

  return text.indexOf(subtext) != -1; // or lastIndexOf()
}
```

可以基于正则表达式实现另一种解决方案，如下所示：

```
public static boolean contains(String text, String subtext) {

  return text.matches("(?i).*" + Pattern.quote(subtext) + ".*");
}
```

请注意，正则表达式在`Pattern.quote()`方法中包装。 这是需要转义<（[{\ ^ - = $！|]}）等特殊字符？* +。 >在给定的子字符串中。

对于第三方图书馆支持，请考虑 Apache Commons Lang，`StringUtils.containsIgnoreCase()`。

# 17.计算字符串中的子字符串出现

计算另一个字符串中的字符串的出现次数是一个可能具有至少两个解释的问题：

*   111 在 111 中发生 1 次
*   111 在 111 中发生 2 次

在第一种情况下（111 中 111 中的 11 次发生），溶液可以依赖于`String.indexOf()`方法。 该方法的一个口味允许我们在该字符串中获取指定子字符串的第一次出现的索引，从指定的索引（或-1，如果没有这样的发生）。 基于此方法，解决方案可以简单地遍历给定的字符串并计算给定的子字符串出现。 遍历从位置 0 开始，并继续直到找不到子字符串：

```
public static int countStringInString(String string, String toFind) {

  int position = 0;
  int count = 0;
  int n = toFind.length();

  while ((position = string.indexOf(toFind, position)) != -1) {
    position = position + n;
    count++;
  }

  return count;
}
```

或者，解决方案可以使用`String.split()`方法。 基本上，解决方案可以使用给定的子字符串作为分隔符将给定字符串拆分。 生成的`String[]`阵列的长度应等于预期出现的数量：

```
public static int countStringInString(String string, String toFind) {

  int result = string.split(Pattern.quote(toFind), -1).length - 1;

  return result < 0 ? 0 : result;
}
```

在第二种情况下（111 中的 111 中出现 2 次），解决方案可以依赖于简单实现中的`Pattern`和`Matcher`类，如下所示：

```
public static int countStringInString(String string, String toFind) {

  Pattern pattern = Pattern.compile(Pattern.quote(toFind));
  Matcher matcher = pattern.matcher(string);

  int position = 0;
  int count = 0;

  while (matcher.find(position)) {

    position = matcher.start() + 1;
    count++;
  }

  return count;
}
```

好的！ 让我们继续使用字符串的另一个问题。

# 18.检查两个字符串是否是字谜

具有相同字符的两个字符串，但符合不同的顺序，是字谜。 一些定义施加了一个不敏感的字谜和/或应该忽略白色空间（空白）。

因此，独立于应用算法，解决方案必须将给定字符串转换为小写并删除白色空格（空白）。 除此之外，我们提到的第一个解决方案通过`Arrays.sort()`对数组进行了分类，并通过`Arrays.equals()`来检查其平等。

一旦他们被排序，如果他们是字谜，它们将是平等的（下图显示了一个是 Anagrams 的两个词）：

![](img/ebed6c7d-49fc-4c77-b4cf-f97de703e88e.png)

本书捆绑在本书中的代码中提供此解决方案（包括其 Java 8 功能样式版本）。 这两个解决方案的主要缺点由分拣部分表示。 以下解决方案消除了此步骤并依赖于空阵列（最初包含仅 0）的 256 索引（即将在*中找到第一个非重复字符*部分中找到更多信息的扩展 ASCII 表码。 ）。

算法非常简单：

*   对于来自第一个字符串的每个字符，该解决方案将该阵列中的值增加到 ASCII 代码 1
*   对于来自第二个字符串的每个字符，该解决方案将与 ASCII 代码相对应的此数组中的值降低 1

代码如下：

```
private static final int EXTENDED_ASCII_CODES = 256;
...
public static boolean isAnagram(String str1, String str2) {

  int[] chCounts = new int[EXTENDED_ASCII_CODES];
  char[] chStr1 = str1.replaceAll("\\s", 
    "").toLowerCase().toCharArray();
  char[] chStr2 = str2.replaceAll("\\s", 
    "").toLowerCase().toCharArray();

  if (chStr1.length != chStr2.length) {
    return false;
  }

  for (int i = 0; i < chStr1.length; i++) {
    chCounts[chStr1[i]]++;
    chCounts[chStr2[i]]--;
  }

  for (int i = 0; i < chCounts.length; i++) {
    if (chCounts[i] != 0) {
      return false;
    }
  }

  return true;
}
```

在此遍历的末尾，如果给定的字符串是字谜，则此阵列仅包含 0。

# 19.声明多行字符串（文本块）

在撰写本书时，JDK 12 有一个提案，用于添加已知为 *JEP 326：RAW 字符串文字*。 但这在最后一分钟下降了。

从 JDK 13 开始，该想法被重新考虑，与拒绝的原始字符串文字不同，文本块被三个双引号包围，`"""`，如下：

```
String text = """My high school,
the Illinois Mathematics and Science Academy,
showed me that anything is possible
and that you're never too young to think big.""";
```

文本块对于使用 Polyglot 语言等编写多行 SQL 语句非常有用，依此类推。 更多详细信息可以在 [https://openjdk.java.net/jeps/355](https://openjdk.java.net/jeps/355) 找到。

尽管如此，有几种可以在 JDK 13 之前使用的代理解决方案。这些解决方案具有常用点 - 使用线路分离器：

```
private static final String LS = System.lineSeparator();
```

从 JDK 8 开始，解决方案可能依赖于`String.join()`，如下：

```
String text = String.join(LS,
  "My high school, ",
  "the Illinois Mathematics and Science Academy,",
  "showed me that anything is possible ",
  "and that you're never too young to think big.");
```

在 JDK 8 之前，优雅的解决方案可能依赖于`StringBuilder`。 此解决方案可在本书捆绑的代码中提供。

虽然前面的解决方案很好，但对于相对较大的字符串，如果我们只有几个字符串，以下两个是可以的。 第一个使用`+`运算符：

```
String text = "My high school, " + LS +
  "the Illinois Mathematics and Science Academy," + LS +
  "showed me that anything is possible " + LS +
  "and that you're never too young to think big.";
```

第二个用途`String.format()`：

```
String text = String.format("%s" + LS + "%s" + LS + "%s" + LS + "%s",
  "My high school, ",
  "the Illinois Mathematics and Science Academy,",
  "showed me that anything is possible ",
  "and that you're never too young to think big.");
```

我们如何处理多行字符串的每一行？ 嗯，快速方法需要 JDK 11，它随附`String.lines()`方法。 该方法通过线路分离器（支持`\n`，`\r`和`\r\n`）来拆分给定的字符串并将其转换为`Stream<String>`。 或者，也可以使用`String.split()`方法（这从 JDK 1.4 开始时可用）。 如果字符串的数量变得显着，建议将它们放入文件中并逐个读/处理它们（例如，通过`getResourceAsStream()`方法）。 其他方法依赖于`StringWriter`或`BufferedWriter.newLine()`。

对于第三方图书馆支持，请考虑 Apache Commons Lang，`StringUtils.join()`，Guava，`Joiner`和自定义注释`@Multiline`。

# 20.连接相同的字符串 n 次

在 JDK 11 之前，可以通过`StringBuilder`快速提供解决方案，如下所示：

```
public static String concatRepeat(String str, int n) {

  StringBuilder sb = new StringBuilder(str.length() * n);

  for (int i = 1; i <= n; i++) {
    sb.append(str);
  }

  return sb.toString();
}
```

从 JDK 11 开始，解决方案依赖于`String.repeat(int count)`方法。 此方法返回由连接此字符串`count`次产生的字符串。 在幕后，此方法使用`System.arraycopy()`，这使得这非常快：

```
String result = "hello".repeat(5);
```

可以在不同场景中融合的其他解决方案如下所示：

*   以下是`String.join()`的解决方案：

```
String result = String.join("", Collections.nCopies(5, TEXT));
```

*   以下是`Stream.generate()`的解决方案：

```
String result = Stream.generate(() -> TEXT)
  .limit(5)
  .collect(joining());
```

*   以下是`String.format()`的解决方案：

```
String result = String.format("%0" + 5 + "d", 0)
  .replace("0", TEXT);
```

*   以下是基于`char[]`的解决方案：

```
String result = new String(new char[5]).replace("\0", TEXT);
```

对于第三方图书馆支持，请考虑 Apache Commons Lang，`StringUtils.repeat()`和 Guava，`Strings.repeat()`。

要检查字符串是否是相同子字符串的序列，请依赖于以下方法：

```
public static boolean hasOnlySubstrings(String str) {

  StringBuilder sb = new StringBuilder();

  for (int i = 0; i < str.length() / 2; i++) {
    sb.append(str.charAt(i));
    String resultStr = str.replaceAll(sb.toString(), "");
    if (resultStr.length() == 0) {
      return true;
    }
  }

  return false;
}
```

解决方案循环给定的字符串的一半，通过在按`StringBuilder`中的原始字符串，字符中附加原始字符串，逐步将其与`""`，子字符串构建替换。 如果这些替换导致空字符串，则意味着给定的字符串是相同子字符串的序列。

# 21.删除前导和尾随空格

此问题的最快解决方法可能依赖于`String.trim()`方法。 该方法能够删除所有前导和尾随空格，即代码点小于或等于 U + 0020 或 32（空格字符）的任何字符：

```
String text = "\n \n\n hello \t \n \r";
String trimmed = text.trim();
```

前面的代码片段将按预期工作。 修剪的字符串将是`hello`。 这仅适用于所使用的所有白色空间都小于 U + 0020 或 32（空间字符）。 有 25 个字符（ [https://en.wikipedia.org/wiki/whiteSpace_characteramunicode](https://en.wikipedia.org/wiki/Whitespace_character#Unicode) ）定义为白色空间，`trim()`只覆盖它们的一部分（简而言之，`trim()`不是 Unicode 意识到）。 让我们考虑以下字符串：

```
char space = '\u2002';
String text = space + "\n \n\n hello \t \n \r" + space;
```

`\u2002`是另一种类型的白色空间，`trim()`无法识别（`\u2002`高于`\u0020`）。 这意味着，在这种情况下，`trim()`将无法按预期工作。 从 JDK 11 开始，这个问题有一个名为`strip()`的解决方案。 该方法将`trim()`的功率扩展到 Unicode 的 Land：

```
String stripped = text.strip();
```

这次，所有领先和尾随的白色空间都被删除。

此外，JDK 11 具有两个味道`strip()`，仅用于移除前导（`stripLeading()`）或仅尾随（`stripTrailing()`）白色空间。 `trim()`方法没有这些味道。

# 22.找到最长的常见前缀

让我们考虑以下阵列：

```
String[] texts = {"abc", "abcd", "abcde", "ab", "abcd", "abcdef"};
```

现在，让我们将这些字符串放在另一个下方，如下所示：

```
abc
abcd
abcde
ab abcd
abcdef
```

这些字符串的简单比较揭示了`ab`是最长的常见前缀。 现在，让我们潜入解决这个问题的解决方案。 我们在此呈现的解决方案依赖于直接的比较。 此解决方案从数组中获取第一个字符串，并将其其余字符串中的每个字符进行比较。 如果发生以下任一情况，则该算法停止：

*   第一个字符串的长度大于任何其他字符串的长度
*   第一个字符串的当前字符与任何其他字符串的当前字符不同

如果算法由于前面方案之一强制停止，则最长的公共前缀是从 0 到第一个字符串的当前字符的索引的子字符串。 否则，最长的公共前缀是来自数组的第一个字符串。 此解决方案的代码如下：

```
public static String longestCommonPrefix(String[] strs) {

  if (strs.length == 1) {
    return strs[0];
  }

  int firstLen = strs[0].length();

  for (int prefixLen = 0; prefixLen < firstLen; prefixLen++) {
    char ch = strs[0].charAt(prefixLen);
    for (int i = 1; i < strs.length; i++) {
      if (prefixLen >= strs[i].length() 
         || strs[i].charAt(prefixLen) != ch) {
          return strs[i].substring(0, prefixLen);
      }
    }
  }

  return strs[0];
}
```

此问题的其他解决方案使用众所周知的算法，例如**二进制搜索**或 **TRIE** 。 在伴随本书的源代码中，还存在基于二进制搜索的解决方案。

# 23.申请缩进

从 JDK 12 开始，我们可以通过`String.indent(int n)`方法缩进文本。

让我们假设我们有以下`String`值：

```
String days = "Sunday\n" 
  + "Monday\n" 
  + "Tuesday\n" 
  + "Wednesday\n" 
  + "Thursday\n" 
  + "Friday\n" 
  + "Saturday";
```

使用 10 个空格的缩进打印此`String`值可以如下进行：

```
System.out.print(days.indent(10));
```

输出将如下：

![](img/3c34fd48-6ec4-427d-a0cd-3037407f6bc8.png)

现在，让我们尝试级联缩进：

```
List<String> days = Arrays.asList("Sunday", "Monday", "Tuesday",
  "Wednesday", "Thursday", "Friday", "Saturday");

for (int i = 0; i < days.size(); i++) {
  System.out.print(days.get(i).indent(i));
}
```

输出将如下：

![](img/e9d00aa3-22ae-4c73-b34d-d3f2cf66e702.png)

现在，让我们根据`String`值的长度来缩进：

```
days.stream()
  .forEachOrdered(d -> System.out.print(d.indent(d.length())));
```

输出将如下：

![](img/342a0e70-c60d-4f4d-95c1-2de21e6a0d8e.png)

如何缩进一块 HTML 代码？ 让我们来看看：

```
String html = "<html>";
String body = "<body>";
String h2 = "<h2>";
String text = "Hello world!";
String closeH2 = "</h2>";
String closeBody = "</body>";
String closeHtml = "</html>";

System.out.println(html.indent(0) + body.indent(4) + h2.indent(8) 
  + text.indent(12) + closeH2.indent(8) + closeBody.indent(4)
  + closeHtml.indent(0));
```

输出将如下：

![](img/db341df1-83f8-438d-992e-8a62408fc196.png)

# 24.改变字符串

让我们假设我们有一个字符串，我们希望将其转换为另一个字符串（例如，将其转换为大写）。 我们可以通过应用诸如`Function<? super String,​ ? extends R>`等函数来执行此操作。

在 JDK 8 中，我们可以通过`map()`来完成此操作，如以下两个简单示例所示：

```
// hello world
String resultMap = Stream.of("hello")
  .map(s -> s + " world")
  .findFirst()
  .get();

// GOOOOOOOOOOOOOOOOL! GOOOOOOOOOOOOOOOOL!
String resultMap = Stream.of("gooool! ")
  .map(String::toUpperCase)
  .map(s -> s.repeat(2))
  .map(s -> s.replaceAll("O", "OOOO"))
  .findFirst()
  .get();
```

从 JDK 12 开始，我们可以依赖于名为`transform​(Function<? super String, ​? extends R> f)`的新方法。 让我们通过`transform()`重写前面的代码片段：

```
// hello world
String result = "hello".transform(s -> s + " world");

// GOOOOOOOOOOOOOOOOL! GOOOOOOOOOOOOOOOOL!
String result = "gooool! ".transform(String::toUpperCase)
  .transform(s -> s.repeat(2))
  .transform(s -> s.replaceAll("O", "OOOO"));
```

虽然`map()`更普遍，`transform()`专用于将函数应用于字符串并返回生成的字符串。

# 25.计算最小和最多两个数字

在 JDK 8 之前，可能的解决方案是依赖于`Math.min()`和`Math.max()`方法，如下所示：

```
int i1 = -45;
int i2 = -15;
int min = Math.min(i1, i2);
int max = Math.max(i1, i2);
```

`Math`类为每个原始数字类型（`int`，`long`，`float`和`double`）提供`min()`和`max()`方法。

从 JDK 8 开始，每个包装器类的原始数字类型（`Integer`，`Long`，`Float`和`Double`）配有专用的`min()`和`max()`方法，并且在这些方法后面，存在 从`Math`课程中的记者调用。 请参阅以下示例（这有点表达）：

```
double d1 = 0.023844D;
double d2 = 0.35468856D;
double min = Double.min(d1, d2);
double max = Double.max(d1, d2);
```

在功能样式上下文中，潜在的解决方案将依赖于`BinaryOperator`功能界面。 此接口具有两种方法，`minBy()`和`maxBy()`：

```
float f1 = 33.34F;
final float f2 = 33.213F;
float min = BinaryOperator.minBy(Float::compare).apply(f1, f2);
float max = BinaryOperator.maxBy(Float::compare).apply(f1, f2);
```

这两种方法能够根据指定的比较器返回两个元素的最小（分别为最大值）。

# 26.求解两个大型 int / long 值和操作溢出

让我们通过以`+`操作员开始潜入解决方案，如下例所示：

```
int x = 2;
int y = 7;
int z = x + y; // 9
```

这是一种非常简单的方法，适用于涉及`int`，`long`，`float`和`double`的大多数计算。

现在，让我们在以下两个大数字上应用此运算符（Sum 2,147,483,647 本身）：

```
int x = Integer.MAX_VALUE;
int y = Integer.MAX_VALUE;
int z = x + y; // -2
```

这次，`z`将等于-2，这不是预期的结果，即 4,294,967,294。 从`int`只改变`z` to to `long`不会有所帮助。 但是，将`int`和`y`的类型从`int`更改为`long` *将*有帮助：

```
long x = Integer.MAX_VALUE;
long y = Integer.MAX_VALUE;
long z = x + y; // 4294967294
```

但问题将重新出现，而不是`Integer.MAX_VALUE`，有`Long.MAX_VALUE`：

```
long x = Long.MAX_VALUE;
long y = Long.MAX_VALUE;
long z = x + y; // -2
```

从 JDK 8 开始，通过原始数字类型的每个包装器以更快递的方式包裹`+`操作员。 因此，`Integer`，`Long`，`Float`和`Double`类具有`sum()`方法：

```
long z = Long.sum(); // -2
```

在幕后，`sum()`方法也使用`+`运算符，因此它们只是产生相同的结果。

而且还从 JDK 8 开始，`Math`类富含两个[​​HTG1]方法。 有一个`addExact()`用于求和两个`int`变量，一个用于求解两个`long`变量。 如果结果容易溢出`int`或`long`，则这些方法非常有用，如前面的情况所示。 在这种情况下，这些方法抛出`ArithmeticException`而不是返回误导性结果，如下例所示：

```
int z = Math.addExact(x, y); // throw ArithmeticException
```

代码将抛出异常，例如`java.lang.ArithmeticException: integer overflow`。 这是有用的，因为它允许我们避免在进一步的计算中引入误导性结果（例如，之前，-2 可以静默输入进一步的计算）。

在功能样式上下文中，潜在的解决方案将依赖于`BinaryOperator`功能界面，如下所示（简单地定义了相同类型的两个操作数的操作）：

```
BinaryOperator<Integer> operator = Math::addExact;
int z = operator.apply(x, y);
```

除了`addExact()`，`Math`具有`multiplyExact()`，`substractExact()`和`negateExact()`。 此外，可以通过`incrementExact()`和`decrementExact()`方法（例如，`Math.incrementExact(i)`）来控制众所周知的增量和递减表达`i++`和`i--`，用于溢出其域和`decrementExact()`方法。 请注意，这些方法仅适用于`int`和`long`。

在使用大量工作时，还专注于`BigInteger`（不可变的任意精度整数）和`BigDecimal`（不可变，任意精度签名的十进制数）类。

# 27.字符串作为基数中的未签名号码

从版本 8 开始向 Java 添加对无符号算术的支持。`Byte`，`Short`，`Short`和`Long`类受到此添加的影响。

在 Java 中，表示正数的字符串可以通过`parseUnsignedInt()`和`parseUnsignedLong()` JDK 8 方法被解析为无符号`int`和`long`类型。 例如，让我们将以下整数视为字符串：

```
String nri = "255500";
```

将其解析为 36 的基数（最大接受的基数）中的无符号`int`值的解决方案如下所示：

```
int result = Integer.parseUnsignedInt(nri, Character.MAX_RADIX);
```

第一个参数是数字，而第二个参数是基数。 基数应在[2,36]或`[Character.MIN_RADIX, Character.MAX_RADIX]`范围内。

使用 10 的基数可以很容易地完成如下（默认情况下，此方法应用 10 的 10）：

```
int result = Integer.parseUnsignedInt(nri);
```

从 JDK 9 开始，`parseUnsignedInt()`有新的味道。 除了字符串和基数之外，该方法是否接受了`[beginIndex, endIndex]`类型的范围。 这次，解析在该范围内完成。 例如，指定范围[1,3]可以如下完成：

```
int result = Integer.parseUnsignedInt(nri, 1, 4, Character.MAX_RADIX);
```

`parseUnsignedInt()`方法可以解析表示大于`Integer.MAX_VALUE`的字符串（试图通过`Integer.parseInt()`来完成此操作将抛出`java.lang.NumberFormatException`异常）：

```
// Integer.MAX_VALUE + 1 = 2147483647 + 1 = 2147483648
int maxValuePlus1 = Integer.parseUnsignedInt("2147483648");
```

在`Long`类中的长号存在相同的方法（例如，`parseUnsignedLong()`）。

# 28.通过无符号转换转换为一个数字

问题要求我们通过无符号转换将给定的符号`int`转换为`long`。 所以，让我们考虑签名`Integer.MIN_VALUE`，即-2,147,483,648。

在 JDK 8 中，通过使用`Integer.toUnsignedLong()`方法，转换将如下（结果为 2,147,483,648）：

```
long result = Integer.toUnsignedLong(Integer.MIN_VALUE);
```

这是另一个示例，将符号的`Short.MIN_VALUE`和`Short.MAX_VALUE`转换为无符号整数：

```
int result1 = Short.toUnsignedInt(Short.MIN_VALUE);
int result2 = Short.toUnsignedInt(Short.MAX_VALUE);
```

来自相同类别的其他方法是`Integer.toUnsignedString()`，`Long.toUnsignedString()`，`Byte.toUnsignedInt()`，`Byte.toUnsignedLong()`，`Short.toUnsignedInt()`和`Short.toUnsignedLong()`。

# 29.比较两个无符号数

让我们考虑两个符号整数，`Integer.MIN_VALUE`（-2,147,483,648）和`Integer.MAX_VALUE`（2,147,483,647）。 比较这些整数（签名值）将导致-2,147,483,648 小于 2,147,483,647：

```
// resultSigned is equal to -1 indicating that
// MIN_VALUE is smaller than MAX_VALUE
int resultSigned = Integer.compare(Integer.MIN_VALUE, 
  Integer.MAX_VALUE);
```

在 JDK 8 中，可以通过`Integer.compareUnsigned()`方法将这两个整数与无符号值进行比较（这是无符号值的`Integer.compare()`）。 主要是，该方法忽略了*符号位*的概念，而且最左右的位被认为是最重要的位。 在无符号值 umbrella 下，如果比较的数字相等，则该方法返回 0，如果第一个无符号值小于第二，则值小于 0，如果第一无符号值大于第二则大于 0 的值大于 0。

以下比较返回 1，表明`Integer.MIN_VALUE`的无符号值大于`Integer.MAX_VALUE`的无符号值：

```
// resultSigned is equal to 1 indicating that
// MIN_VALUE is greater than MAX_VALUE
int resultUnsigned 
  = Integer.compareUnsigned(Integer.MIN_VALUE, Integer.MAX_VALUE);
```

`compareUnsigned()`方法在 JDK 8 开始的`Integer`和`Long`类中可用，并以 JDK 9 开始的`Byte`和`Short`类。

# 30.未签名价值的划分和模态

通过`divideUnsigned()`和`remainderUnsigned()`方法，JDK 8 Unsigned 算术 API 支持由两种无符号值的划分产生的未符号的商和余量。

让我们考虑`Interger.MIN_VALUE`和`Integer.MAX_VALUE`签名号码，让我们申请部门和模数。 这里没有什么新鲜事：

```
// signed division
// -1
int divisionSignedMinMax = Integer.MIN_VALUE / Integer.MAX_VALUE; 

// 0
int divisionSignedMaxMin = Integer.MAX_VALUE / Integer.MIN_VALUE;

// signed modulo
// -1
int moduloSignedMinMax = Integer.MIN_VALUE % Integer.MAX_VALUE; 

// 2147483647
int moduloSignedMaxMin = Integer.MAX_VALUE % Integer.MIN_VALUE; 
```

现在，让我们将`Integer.MIN_VALUE`和`Integer.MAX_VALUE`视为无符号值，让我们应用`divideUnsigned()`和`remainderUnsigned()`：

```
// division unsigned
int divisionUnsignedMinMax = Integer.divideUnsigned(
  Integer.MIN_VALUE, Integer.MAX_VALUE); // 1
int divisionUnsignedMaxMin = Integer.divideUnsigned(
  Integer.MAX_VALUE, Integer.MIN_VALUE); // 0

// modulo unsigned
int moduloUnsignedMinMax = Integer.remainderUnsigned(
  Integer.MIN_VALUE, Integer.MAX_VALUE); // 1
int moduloUnsignedMaxMin = Integer.remainderUnsigned(
  Integer.MAX_VALUE, Integer.MIN_VALUE); // 2147483647
```

请注意它们与比较操作的相似性。 这两个操作都是未签名的划分和未签名的模数，将所有位解释为*值比特*并忽略*符号位*。

`divideUnsigned()` and `remainderUnsigned()` are present in the `Integer` and `Long` classes, respectively.

# 31.双/浮子是有限浮点值

此问题出现了一些浮点方法和操作产生`Infinity`或`NaN`作为结果而不是抛出异常。

检查给定`float` / `double`是否是有限浮点值的解决方案依赖于以下条件 - 给定`float` / `double`值的绝对值不得超过最大的正有限值 `float` / `double`类型：

```
// for float
Math.abs(f) <= Float.MAX_VALUE;

// for double
Math.abs(d) <= Double.MAX_VALUE
```

从 Java 8 开始，前面的条件通过两个专用标志 - 方法，`Float.isFinite()`和`Double.isFinite()`暴露。 因此，以下示例是有限浮点值的有效测试用例：

```
Float f1 = 4.5f;
boolean f1f = Float.isFinite(f1); // f1 = 4.5, is finite

Float f2 = f1 / 0;
boolean f2f = Float.isFinite(f2); // f2 = Infinity, is not finite

Float f3 = 0f / 0f;
boolean f3f = Float.isFinite(f3); // f3 = NaN, is not finite

Double d1 = 0.000333411333d;
boolean d1f = Double.isFinite(d1); // d1 = 3.33411333E-4,is finite

Double d2 = d1 / 0;
boolean d2f = Double.isFinite(d2); // d2 = Infinity, is not finite

Double d3 = Double.POSITIVE_INFINITY * 0;
boolean d3f = Double.isFinite(d3); // d3 = NaN, is not finite
```

这些方法在诸如以下条件下方便：

```
if (Float.isFinite(d1)) {
  // do a computation with d1 finite floating-point value
} else {
  // d1 cannot enter in further computations
}
```

# 32.将逻辑和/或/ xor 应用于两个布尔表达式

基本逻辑操作（**和**，**或**和 **XOR** ）的真实表如下：

![](img/482c6d19-72f9-41a3-9590-52cde694d0a0.png)

在 Java 中，逻辑**和**操作员表示为`&&`，逻辑**或**操作员表示为`||`，逻辑 **XOR** 操作员表示 作为`^`。 从 JDK 8 开始，这些运算符适用于两个布尔值，并在三个`static`方法 - `Boolean.logicalAnd()`，`Boolean.logicalOr()`和`Boolean.logicalXor()`中包装：

```
int s = 10;
int m = 21;

// if (s > m && m < 50) { } else { }
if (Boolean.logicalAnd(s > m, m < 50)) {} else {}

// if (s > m || m < 50) { } else { }
if (Boolean.logicalOr(s > m, m < 50)) {} else {}

// if (s > m ^ m < 50) { } else { }
if (Boolean.logicalXor(s > m, m < 50)) {} else {}
```

使用这些方法的组合也是可能的：

```
if (Boolean.logicalAnd(
    Boolean.logicalOr(s > m, m < 50),
    Boolean.logicalOr(s <= m, m > 50))) {} else {}
```

# 33.将 Biginteger 转换为原始类型

`BigInteger`类是一个非常方便的工具，用于表示不可变的任意精度整数。

此类还包含用于将`BigInteger`转换为原始类型的方法（源自`java.lang.Number`），例如`byte`，`long`或`double`。 但是，这些方法可以产生意外的结果和混乱。 例如，让我们假设我们有`BigInteger`，它包装`Long.MAX_VALUE`：

```
BigInteger nr = BigInteger.valueOf(Long.MAX_VALUE);
```

让我们通过`BigInteger.longValue()`方法将此`BigInteger`转换为原始的：

```
long nrLong = nr.longValue();
```

到目前为止，由于`Long.MAX_VALUE`为 9,223,372,036,854,775,807 和`nrLong`原始变量，一切都在预期工作了。

现在，让我们尝试通过`BigInteger.intValue()`方法将此`BigInteger`类转换为原始`int`值：

```
int nrInt = nr.intValue();
```

这次，`nrInt`原始变量将具有-1 的值（相同的结果将产生`shortValue()`和`byteValue()`）。 符合文档，如果`BigInteger`的值太大而无法符合指定的原始类型，返回低阶*比特（ *n* 取决于指定的 原始类型）。 但是如果代码不知道此语句，那么它将在进一步计算中将值推为-1，这将导致混淆。*

但是，从 JDK 8 开始，添加了一组新的方法。 这些方法致力于识别在从`BigInteger`转换为指定的原始类型期间丢失的信息。 如果检测到一段丢失的信息，将抛出`ArithmeticException`。 这样，代码信号将转换遇到一些问题并防止这种令人不快的情况。

这些方法是`longValueExact()`，`intValueExact()`，`shortValueExact()`和`byteValueExact()`：

```
long nrExactLong = nr.longValueExact(); // works as expected
int nrExactInt = nr.intValueExact();    // throws ArithmeticException
```

请注意，`intValueExact()`没有返回-1 作为`intValue()`。 这一次，通过将最大`long`值转换为`int`的尝试引起的丢失信息通过`ArithmeticException`类型来发出信号。

# 34.将 LONG 转化为 INT

将`long`值转换为`int`值似乎是一个简单的作业。 例如，潜在的解决方案可以依赖于铸造以下内容：

```
long nr = Integer.MAX_VALUE;
int intNrCast = (int) nr;
```

或者，它可以依赖于`Long.intValue()`，如下：

```
int intNrValue = Long.valueOf(nrLong).intValue();
```

两种方法都很好。 现在，让我们假设我们有以下`long`值：

```
long nrMaxLong = Long.MAX_VALUE;
```

这次，这两种方法都将返回-1。 为了避免这样的结果，建议依赖于 JDK 8，即`Math.toIntExact()`。 此方法获取`long`类型的参数，并尝试将其转换为`int`。 如果获得的值溢出`int`，则此方法将投掷`ArithmeticException`：

```
// throws ArithmeticException
int intNrMaxExact = Math.toIntExact(nrMaxLong); 
```

在幕后，`toIntExact()`依赖于`((int)value != value)`条件。

# 35.计算分部和模量的地板

让我们假设我们有以下部门：

```
double z = (double)222/14;
```

这将初始化`z`的结果，即 15.85，但我们的问题请求该划分的地板，这是 15（这是至少或等于代数商的最大整数值）。 获得该所需结果的解决方案将包括应用`Math.floor(15.85)`，即 15。

但是，222 和 14 是整数，所以前面的划分如下所写：

```
int z = 222/14;
```

这次，`z`将等于 15，这正是预期结果（`/`运算符返回最接近零的整数）。 无需应用`Math.floor(z)`。 此外，如果除数是 0，那么 222/0 将投掷`ArithmeticException`。

到目前为止，结论是，可以通过`/`操作员获得具有相同符号（两者是正或负）的两个整数的划分的地板。

好的，到目前为止，这么好，但让我们假设我们有以下两个整数（相反的迹象;股息是负面的，除数是积极的，反之亦然）：

```
double z = (double) -222/14;
```

这次，`z`将等于-15.85。 同样，通过应用`Math.floor(z)`，结果将是-16，这是正确的（这是最大的整数值小于或等于代数商）。

让我们再次使用`int`来跳转相同的问题：

```
int z = -222/14;
```

这次，`z`将等于-15。 这是不正确的，在这种情况下，`Math.floor(-15)`是-15 的情况，`Math.floor(z)`不会帮助我们。 因此，这是一个应该考虑的问题。

从 JDK 8 向前，通过`Math.floorDiv()`方法覆盖和暴露所有这些情况。 此方法将表示股息和除数的整数作为参数，并返回小于或等于代数商的最大（最接近的正无穷大）`int`值：

```
int x = -222;
int y = 14;

// x is the dividend, y is the divisor
int z = Math.floorDiv(x, y); // -16
```

`Math.floorDiv()`方法有三种口味：`floorDiv(int x, int y)`，`floorDiv(long x, int y)`和`floorDiv(long x, long y)`。

在`Math.floorDiv()`之后，JDK 8 附带`Math.floorMod()`，返回给定参数的楼层模数。 这是根据`x - (floorDiv(x, y) * y)`的结果计算的，因此它将与`%`运算符返回与具有相同符号的参数的参数以及没有相同符号的参数的不同结果。

舍入划分两个正整数的结果（`a` / `b`）可以快速完成如下：

```
long result = (a + b - 1) / b;
```

以下是其中的一个示例（我们有 *4/3 = 1.33* ，我们想要 2）：

```
long result = (4 + 3 - 1) / 3; // 2
```

以下是另一个示例（我们有 *17/7 = 2.42* ，我们想要 3）：

```
long result = (17 + 7 - 1) / 7; // 3
```

如果整数不是正面，那么我们可以依赖`Math.ceil()`：

```
long result = (long) Math.ceil((double) a/b);
```

# 36.下一个浮点值

具有诸如 10 的整数值使我们非常容易获得下一个整数点值，例如 10 + 1（在正无穷大的方向上）或 10-1（在负无穷大的方向上）。 尝试为`float`或`double`实现同样的事情并不容易，因为它是整数的。

从 JDK 6 开始，`Math`类已经丰富了`nextAfter()`方法。 该方法采用两个参数 - 初始数字（`float`或`double`）和方向（`Float` / `Double.NEGATIVE` / `POSITIVE_INFINITY`） - 返回下一个浮点值。 在这里，在负无穷大的方向上将下一个浮点返回到 0.1 附近的下一个浮点是一种味道：

```
float f = 0.1f;

// 0.099999994
float nextf = Math.nextAfter(f, Float.NEGATIVE_INFINITY);
```

从 JDK 8 开始，`Math`类已经丰富了两种方法，该方法充当`nextAfter()`的快捷方式，并且更快。 这些方法是`nextDown()`和`nextUp()`：

```
float f = 0.1f;

float nextdownf = Math.nextDown(f); // 0.099999994
float nextupf = Math.nextUp(f); // 0.10000001

double d = 0.1d;

double nextdownd = Math.nextDown(d); // 0.09999999999999999
double nextupd = Math.nextUp(d); // 0.10000000000000002
```

因此，在负无穷大的方向上可通过`Math.nextDown()`和`nextAfter()`在阳性无穷大的方向上获得`nextAfter()`，这通过`Math.nextUp()`可用。

# 37.乘以两个大型 int / long 值和操作溢出

让我们从`*`操作员开始进入解决方案，如下例所示：

```
int x = 10;
int y = 5;
int z = x * y; // 50
```

这是一个非常简单的方法，并且对于涉及`int`，`long`，`float`和`double`的大多数计算，也适用于罚款。

现在，让我们将这个运算符应用于以下两个大数字（乘以 2,147,483,647 自身）：

```
int x = Integer.MAX_VALUE;
int y = Integer.MAX_VALUE;
int z = x * y; // 1
```

这次，`z`将等于 1，这不是预期结果，即 4,611,686,014,132,420,609。 从`int`只改变`z` to to `long`不会有所帮助。 但是，将`x`和`y`的类型从`int`改变为`long`将：

```
long x = Integer.MAX_VALUE;
long y = Integer.MAX_VALUE;
long z = x * y; // 4611686014132420609
```

但如果我们有`Long.MAX_VALUE`而不是`Integer.MAX_VALUE`，问题将重新出现问题：

```
long x = Long.MAX_VALUE;
long y = Long.MAX_VALUE;
long z = x * y; // 1
```

因此，遍布域并依赖于`*`运算符的计算将最终误导结果。

而不是在进一步计算中使用这些结果，而是最好在发生溢出操作时按时通知。 JDK 8 附带`Math.multiplyExact()`方法。 此方法尝试乘以两个整数。 如果结果溢出，`int`只会投掷`ArithmeticException`：

```
int x = Integer.MAX_VALUE;
int y = Integer.MAX_VALUE;
int z = Math.multiplyExact(x, y); // throw ArithmeticException
```

在 JDK 8 中，`Math.muliplyExact(int x, int y)`返回`int`和`Math.muliplyExact(long x, long y)`返回`long`。 在 JDK 9 中，还添加了`Math.muliplyExact(long, int y)` `long`。

JDK 9 附带`Math.multiplyFull(int x, int y)`返回`long`值。 该方法对于获得两个整数的精确数学乘积是非常有用的，如`long`，如下所示：

```
int x = Integer.MAX_VALUE;
int y = Integer.MAX_VALUE;
long z = Math.multiplyFull(x, y); // 4611686014132420609
```

只需记录，JDK 9 也附带了一个名为`Math.muliptlyHigh(long x, long y)`的方法返回`long`。 此方法返回的`long`值表示两个 64 位因素的 128 位产品的最高 64 位：

```
long x = Long.MAX_VALUE;
long y = Long.MAX_VALUE;
// 9223372036854775807 * 9223372036854775807 = 4611686018427387903
long z = Math.multiplyHigh(x, y);
```

在功能样式上下文中，潜在的解决方案将依赖于`BinaryOperator`功能界面，如下所示（简单地定义了相同类型的两个操作数的操作）：

```
int x = Integer.MAX_VALUE;
int y = Integer.MAX_VALUE;
BinaryOperator<Integer> operator = Math::multiplyExact;
int z = operator.apply(x, y); // throw ArithmeticException
```

为了使用大量工作，还专注于`BigInteger`（不变的任意精度整数）和`BigDecimal`（不可变，任意精度签署的十进制数）类。

# 38.融合乘以补充

数学计算*（a * b）+ c* 在矩阵乘法中大量利用，它们经常用于**高性能计算**（ **HPC** ），AI 应用 ，机器学习，深度学习，神经网络等。

实现此计算的最简单方法直接依赖于`*`和`+`运算符，如下所示：

```
double x = 49.29d;
double y = -28.58d;
double z = 33.63d;
double q = (x * y) + z;
```

该实现的主要问题包括两个舍入误差引起的低精度和性能（一个用于乘法操作，一个用于添加操作）。

但由于 Intel AVX 的说明执行 SIMD 操作和 JDK 9，其中添加了`Math.fma()`方法，可以提高该计算。 通过依赖于`Math.fma()`，仅使用圆形到最接近的舍入模式进行一次完成舍入：

```
double fma = Math.fma(x, y, z);
```

请注意，现代英特尔处理器可提供此改进，因此它不足以让 JDK 9 到位。

# 39.紧凑号格式

从 JDK 12 开始，添加了一个用于紧凑型格式的新类。 此类名为`java.text.CompactNumberFormat`。 此类的主要目标是扩展现有的 Java 编号格式 API，支持对语言环境和压缩。

可以将数字格式化为短样式（例如， *1000* 变为 *1K* ）或者长时间（例如， *1000* 变为 *1 千*）。 这两种样式被分组为`Style`枚举和`SHORT`和`LONG`。

除了`CompactNumberFormat`构造函数之外，可以通过添加到`NumberFormat`类的两个`static`方法创建`CompactNumberFormat`。

*   第一种是带有`NumberFormat.Style.SHORT`的默认区域设置的紧凑号格式：

```
public static NumberFormat getCompactNumberInstance()
```

*   第二个是具有`NumberFormat.Style`指定语言环境的紧凑号格式：

```
public static NumberFormat getCompactNumberInstance​(
    Locale locale, NumberFormat.Style formatStyle)
```

让我们仔细看看格式化和解析。

# 格式化

默认情况下，使用`RoundingMode.HALF_EVEN`格式化一个数字。 但是，我们可以通过`NumberFormat.setRoundingMode()`明确地确定舍入模式。

尝试将此信息与命名为`NumberFormatters`的实用程序类，可以如下实现：

```
public static String forLocale(Locale locale, double number) {

  return format(locale, Style.SHORT, null, number);
}

public static String forLocaleStyle(
  Locale locale, Style style, double number) {

  return format(locale, style, null, number);
}

public static String forLocaleStyleRound(
  Locale locale, Style style, RoundingMode mode, double number) {

  return format(locale, style, mode, number);
}

private static String format(
  Locale locale, Style style, RoundingMode mode, double number) {

  if (locale == null || style == null) {
    return String.valueOf(number); // or use a default format
  }

  NumberFormat nf = NumberFormat.getCompactNumberInstance(locale,
     style);

  if (mode != null) {
    nf.setRoundingMode(mode);
  }

  return nf.format(number);
}
```

现在，让我们使用`US`语言环境，`SHORT`样式和默认舍入模式格式化数字 *1000* ，， *1000000* 和 *1000000000* ：

```
// 1K
NumberFormatters.forLocaleStyle(Locale.US, Style.SHORT, 1_000);

// 1M
NumberFormatters.forLocaleStyle(Locale.US, Style.SHORT, 1_000_000);

```

```
// 1B
NumberFormatters.forLocaleStyle(Locale.US, Style.SHORT, 
  1_000_000_000);
```

我们可以与`LONG`风格相同：

```
// 1thousand
NumberFormatters.forLocaleStyle(Locale.US, Style.LONG, 1_000);

// 1million
NumberFormatters.forLocaleStyle(Locale.US, Style.LONG, 1_000_000);

// 1billion
NumberFormatters.forLocaleStyle(Locale.US, Style.LONG, 1_000_000_000);
```

我们还可以使用`ITALIAN` locale 和`SHORT` style：

```
// 1.000
NumberFormatters.forLocaleStyle(Locale.ITALIAN, Style.SHORT, 
  1_000);

// 1 Mln
NumberFormatters.forLocaleStyle(Locale.ITALIAN, Style.SHORT, 
  1_000_000);

// 1 Mld
NumberFormatters.forLocaleStyle(Locale.ITALIAN, Style.SHORT, 
  1_000_000_000);
```

最后，我们还可以使用`ITALIAN`语言环境和`LONG`样式：

```
// 1 mille
NumberFormatters.forLocaleStyle(Locale.ITALIAN, Style.LONG, 
  1_000);

// 1 milione
NumberFormatters.forLocaleStyle(Locale.ITALIAN, Style.LONG, 
  1_000_000);

// 1 miliardo
NumberFormatters.forLocaleStyle(Locale.ITALIAN, Style.LONG, 
  1_000_000_000);
```

现在，让我们假设我们有两个数字： *1200* 和 *1600* 。

从舍入模式的角度来看，它们分别将分别舍入 *1000* 和 *2000* 。 默认的舍入模式`HALF_EVEN`将圆形 *1200* 为 *1000* 和 *1600* 2000 *2000* 。 但如果我们想要 *1200* 成为 *2000* 和 *1600* 变为 *1000 *，我们需要明确地设置舍入模式如下 ：**

```
// 2000 (2 thousand)
NumberFormatters.forLocaleStyleRound(
  Locale.US, Style.LONG, RoundingMode.UP, 1_200);

// 1000 (1 thousand)
NumberFormatters.forLocaleStyleRound(
  Locale.US, Style.LONG, RoundingMode.DOWN, 1_600);
```

# 解析

解析是格式化的反向过程。 我们有一个给定的字符串并尝试将其解析为一个数字。 这可以通过`NumberFormat.parse()`方法来完成。 默认情况下，解析不利用分组（例如，不分组， *5,50k* 被解析为 *5* ;分组， *5,50k* 被解析为 *550000* ）。

如果我们将此信息集中在一组辅助方法中，那么我们获取以下输出：

```
public static Number parseLocale(Locale locale, String number) 
    throws ParseException {

  return parse(locale, Style.SHORT, false, number);
}

public static Number parseLocaleStyle(
  Locale locale, Style style, String number) throws ParseException {

  return parse(locale, style, false, number);
}

public static Number parseLocaleStyleRound(
  Locale locale, Style style, boolean grouping, String number)
    throws ParseException {

  return parse(locale, style, grouping, number);
}

private static Number parse(
  Locale locale, Style style, boolean grouping, String number)
    throws ParseException {

  if (locale == null || style == null || number == null) {
    throw new IllegalArgumentException(
      "Locale/style/number cannot be null");
  }

  NumberFormat nf = NumberFormat.getCompactNumberInstance(locale, 
    style);
  nf.setGroupingUsed(grouping);

  return nf.parse(number);
}
```

让我们解析 *5k* 和 *5,000* 在没有显式分组的情况下进入 *5000* ：

```
// 5000
NumberFormatters.parseLocaleStyle(Locale.US, Style.SHORT, "5K");

// 5000
NumberFormatters.parseLocaleStyle(Locale.US, Style.LONG, "5 thousand");
```

现在，让我们用显式分组解析 *5,50K* 和 *550000* 550000 ：

```
// 550000
NumberFormatters.parseLocaleStyleRound(
  Locale.US, Style.SHORT, true, "5,50K");

// 550000
NumberFormatters.parseLocaleStyleRound(
  Locale.US, Style.LONG, true, "5,50 thousand");
```

可以通过`setCurrency​()`，`setParseIntegerOnly()`，`setMaximumIntegerDigits()`，`setMinimumIntegerDigits()`，`setMinimumIntegerDigits()`和`setMaximumFractionDigits()`方法获得更多调谐。

# 概括

本章收集了一堆涉及字符串和数字的最常见问题。 显然，有很多这样的问题，并试图涵盖所有这些都是超出任何书籍的范围。 但是，了解如何解决本章中提供的问题，为您提供了一个坚实的基础，用于自己解决许多其他相关问题。

从本章下载应用程序以查看结果和其他详细信息。