# 字符串，输入/输出和文件

在本章中，将更详细地将读取读取器呈现`String`类方法。 我们还将从标准库和 Apache Commons 项目中讨论流行的字符串实用程序。 Java 输入/输出流和`java.io`包的相关类概述将跟随`org.apache.commons.io`包的某些类。 文件管理类及其方法将在专用部分中介绍。

本章将介绍以下主题：

*   字符串处理
*   I / O 流
*   文件管理
*   Apache Commons 实用程序`FileUtils`和`IOUtils`

# 字符串处理

在主流编程中，`String`可能是最受欢迎的课程。 在[第 1 章](01.html)中，*使用 java 12* 开始，我们已经了解了这个类，它的文字及其特定的特征，称为**字符串不可变形**。 在本节中，我们将解释如何使用来自标准库的`String`类方法和实用程序以及从`org.apache.commons.lang3`包中的`StringUtils`类进行处理的字符串。

# 类串的方法

`String`类具有 70 多种方法，可实现分析，修改，比较字符串和将数字文字转换为相应的字符串文字。 要查看`String`类的所有方法，请在 [https://docs.oracle.com/en/java/javase](https://docs.oracle.com/en/java/javase) 在线在线引用 Java API。

# 字符串分析

`length()`方法返回字符串中的字符数，如以下代码所示：

```
String s7 = "42";
System.out.println(s7.length());    //prints: 2
System.out.println("0 0".length()); //prints: 3

```

以下`isEmpty()`方法当字符串长度（字符数）为`0`时返回 true：

```
System.out.println("".isEmpty());   //prints: true
System.out.println(" ".isEmpty());  //prints: false

```

`indexOf()`和`lastIndexOf()`方法在此代码片段中显示的字符串中返回指定子字符串的位置：

```
String s6 = "abc42t%";
System.out.println(s6.indexOf(s7));            //prints: 3
System.out.println(s6.indexOf("a"));           //prints: 0
System.out.println(s6.indexOf("xyz"));         //prints: -1
System.out.println("ababa".lastIndexOf("ba")); //prints: 3
```

如您所见，字符串中的第一个字符具有位置（索引）`0`，并且缺少指定的子字符串导致索引`-1`。

`matches()`方法将正则表达式（传递为参数传递）到字符串，如下所示：

```
System.out.println("abc".matches("[a-z]+"));   //prints: true
System.out.println("ab1".matches("[a-z]+"));   //prints: false

```

正则表达式在本书的范围之外。 您可以在 [https://www.regular-expressions.info](https://www.regular-expressions.info) 中了解它们。 在前面的示例中，表达式`[a-z]+`仅匹配一个或多个字母。

# 字符串比较

在[第 3 章](03.html)， *java 基本上*，我们已经谈到了返回`true`的方法，只有在两个`String`对象或文字拼写完全相同的方式时才会返回`true`。 以下代码段演示了它的工作原理：

```
String s1 = "abc";
String s2 = "abc";
String s3 = "acb";
System.out.println(s1.equals(s2));     //prints: true
System.out.println(s1.equals(s3));     //prints: false
System.out.println("abc".equals(s2));  //prints: true
System.out.println("abc".equals(s3));  //prints: false

```

另一个`String` class `equalsIgnoreCase()`方法是一个类似的作业，但忽略了字符的差异，如下所示：

```
String s4 = "aBc";
String s5 = "Abc";
System.out.println(s4.equals(s5));           //prints: false
System.out.println(s4.equalsIgnoreCase(s5)); //prints: true

```

`contentEquals()`方法类似于此处显示的`equals()`方法：

```
String s1 = "abc";
String s2 = "abc";
System.out.println(s1.contentEquals(s2));    //prints: true
System.out.println("abc".contentEquals(s2)); //prints: true 
```

不同之处在于`equals()`方法检查两个值是否由`String`类，
表示`contentEquals()`，而`contentEquals()`仅比较字符序列的字符（内容）。 字符序列可以由`String`，`StringBuilder`，`StringBuffer`，`CharBuffer`或实现`CharSequence`接口的任何其他类表示。 尽管如此，如果两个序列包含相同的字符，则`contentEquals()`方法将返回`true`，而`equals()`方法将返回`false`如果`String`类未创建其中一个序列。

如果`string`包含某个子字符串，则返回`contains()`方法返回`true`，如下所示：

```
String s6 = "abc42t%";
String s7 = "42";
String s8 = "xyz";
System.out.println(s6.contains(s7));    //prints: true
System.out.println(s6.contains(s8));    //prints: false

```

`startsWith()`和`endsWith()`方法执行类似的检查，但仅在字符串的开始时或在字符串值的末尾，如以下代码所示：

```
String s6 = "abc42t%";
String s7 = "42";

System.out.println(s6.startsWith(s7));      //prints: false
System.out.println(s6.startsWith("ab"));    //prints: true
System.out.println(s6.startsWith("42", 3)); //prints: true

System.out.println(s6.endsWith(s7));        //prints: false
System.out.println(s6.endsWith("t%"));      //prints: true
```

`compareTo()`和`compareToIgnoreCase()`方法基于字符串中每个字符的 Unicode 值进行比较字符串。 如果字符串相等，则返回值`0`，如果第一个字符串比第二字符串比第二字符串较少（具有较小的 Unicode 值），则负整数值，如果第一个字符串是大于的 第二个字符串（具有更大的 Unicode 值）。 例如：

```
String s4 = "aBc";
String s5 = "Abc";
System.out.println(s4.compareTo(s5));             //prints: 32
System.out.println(s4.compareToIgnoreCase(s5));   //prints: 0
System.out.println(s4.codePointAt(0));            //prints: 97
System.out.println(s5.codePointAt(0));            //prints: 65

```

根据此代码片段，您可以看到`compareTo()`和`compareToIgnoreCase()`方法基于构成字符串的字符的代码点。 Tring `s4`的原因是`32`大于 String `s5`，因为字符`a`（`97`（`97`）的代码点大于字符的代码点`A`（`65` ）通过`32`。

给定的示例还示出了`codePointAt()`方法在指定位置返回位于串中的字符的代码点。 代码点在[第 1 章](01.html)，*的*第 1 章*中，使用 Java 12* 中描述了代码点。

# 字符串转型

`substring()`方法以指定的位置（索引）返回 Substring，如下所示：

```
System.out.println("42".substring(0));   //prints: 42
System.out.println("42".substring(1));   //prints: 2
System.out.println("42".substring(2));   //prints:
System.out.println("42".substring(3));   //error: index out of range: -1
String s6 = "abc42t%";
System.out.println(s6.substring(3));     //prints: 42t%
System.out.println(s6.substring(3, 5));  //prints: 42
```

`format()`方法使用传递的第一参数作为模板，并顺序地将模板的相应位置中的其他参数插入。 以下代码示例打印句子，“*嘿，尼克！给我 2 个苹果，请！*”三次：

```
String t = "Hey, %s! Give me %d apples, please!";
System.out.println(String.format(t, "Nick", 2));

String t1 = String.format(t, "Nick", 2);
System.out.println(t1);

System.out.println(String
          .format("Hey, %s! Give me %d apples, please!", "Nick", 2));

```

`%s`和`%d`符号称为**格式说明符**。 有许多说明符和各种标志，允许程序员微量控制结果。 您可以在`java.util.Formatter`类的 API 中读取它们。

`concat()`方法与算术运算符（`+`）相同，如图所示：

```
String s7 = "42";
String s8 = "xyz";
String newStr1 = s7.concat(s8);
System.out.println(newStr1);    //prints: 42xyz

String newStr2 = s7 + s8;
System.out.println(newStr2);    //prints: 42xyz
```

以下`join()`方法同样起作用，但允许添加分隔符：

```
String newStr1 = String.join(",", "abc", "xyz");
System.out.println(newStr1);        //prints: abc,xyz

List<String> list = List.of("abc","xyz");
String newStr2 = String.join(",", list);
System.out.println(newStr2);        //prints: abc,xyz

```

以下组`replace()`，`replaceFirst()`和`replaceAll()`方法替换带有提供的字符串中的某些字符：

```
System.out.println("abcbc".replace("bc", "42"));         //prints: a4242
System.out.println("abcbc".replaceFirst("bc", "42"));    //prints: a42bc
System.out.println("ab11bcd".replaceAll("[a-z]+", "42"));//prints: 421142

```

前面代码的第一行用`"42"`替换了`"bc"`的所有实例。 第二个用`"42"`仅替换`"bc"`的第一个实例。 并且最后一个替换与`"42"`匹配的所有子字符串与提供的正则表达式匹配。

`toLowerCase()`和`toUpperCase()`方法更改整个字符串的情况，如下所示：

```
System.out.println("aBc".toLowerCase());   //prints: abc
System.out.println("aBc".toUpperCase());   //prints: ABC

```

`split()`方法将字符串中断到子串中，使用提供的字符作为分隔符如下：

```
String[] arr = "abcbc".split("b");
System.out.println(arr[0]);   //prints: a
System.out.println(arr[1]);   //prints: c
System.out.println(arr[2]);   //prints: c
```

有几种`valueOf()`方法将原始类型的值转换为`String`类型。 例如：

```
float f = 23.42f;
String sf = String.valueOf(f);
System.out.println(sf);         //prints: 23.42

```

还有`()`和`getChars()`方法将字符串转换为相应类型的数组，而`chars()`方法创建一个字符的`IntStream`（其代码点）。 我们将讨论[第 14 章](14.html)， *Java 标准流*中的 Stream。

# 使用 Java 11 添加的方法

Java 11 在`String`类中引入了几种新方法。

`repeat()`方法允许您根据以下代码中显示的相同字符串的多个连接来创建新的字符串值：

```
System.out.println("ab".repeat(3)); //prints: ababab
System.out.println("ab".repeat(1)); //prints: ab
System.out.println("ab".repeat(0)); //prints:

```

如果字符串长度`0`或仅由白色空格组成，则`isBlank()`方法返回 true。 例如：

```
System.out.println("".isBlank());     //prints: true
System.out.println("   ".isBlank());  //prints: true
System.out.println(" a ".isBlank());  //prints: false

```

`stripLeading()`方法从字符串中删除前导白空间，`stripTrailing()`方法删除尾随白色空间，`strip()`方法删除两者，如下所示：

```
String sp = "   abc   ";
System.out.println("'" + sp + "'");                 //prints: '   abc   '
System.out.println("'" + sp.stripLeading() + "'");  //prints: 'abc   '
System.out.println("'" + sp.stripTrailing() + "'"); //prints: '  abc'
System.out.println("'" + sp.strip() + "'");         //prints: 'abc'

```

最后，`lines()`方法按行终端器打破字符串并返回结果线的`Stream<String>`。 线终端器是逃生序列线 Feed `\n`（`\u000a`），或返回返回`\r`（`\u000d`），或者通过线馈送立即返回返回返回`\r\n`（`\u000d\u000a`）。 例如：

```
String line = "Line 1\nLine 2\rLine 3\r\nLine 4";
line.lines().forEach(System.out::println); 
```

前面代码的输出如下：

![](img/0c968570-7ace-4243-87b1-bdaaecf16775.png)

我们将讨论[第 14 章](14.html)， *Java 标准流*中的 Streams。

# 字符串实用程序

除了`String`类之外，还有许多其他类具有处理`String`值的方法。 其中最有用的是`StringUtils`包从一个名为 **apache commons** 的项目中的`org.apache.commons.lang3`封装，由名为 **apache 软件 foundation** 的开源社区维护。 我们将在 [第 7 章](07.html)， *Java 标准和外部库*中更多地讨论此项目及其库及其库。 要在项目中使用它，请在`pom.xml`文件中添加以下依赖项：

```
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.8.1</version>
</dependency>
```

`StringUtils`类是许多程序员的最爱。 它通过提供以下零安全操作来补充`String`类的方法：

*   `isBlank(CharSequence cs)`：返回`true`如果输入值是空白空间，则为空（`""`），或`null`
*   `isNotBlank(CharSequence cs)`：在前面的方法返回`true`时返回`false`
*   `isEmpty(CharSequence cs)`：返回`true`如果输入值为空（`""`）或`null`
*   `isNotEmpty(CharSequence cs)`：在前面的方法返回`true`时返回`false`
*   `trim(String str)`：从输入值中删除前导和尾随的空白空间，流程`null`，空（`""`）和白色空间，如下所示：

```
System.out.println("'" + StringUtils.trim(" x ") + "'"); //prints: 'x'
System.out.println(StringUtils.trim(null));              //prints: null
System.out.println("'" + StringUtils.trim("") + "'");    //prints: ''
System.out.println("'" + StringUtils.trim("   ") + "'"); //prints: ''

```

*   `trimToNull(String str)`：从输入值中删除前导和尾随的空白空间，流程`null`，空（`""`）和白色空间，如下所示：

```
System.out.println("'" + StringUtils.trimToNull(" x ") + "'");  // 'x'
System.out.println(StringUtils.trimToNull(null));        //prints: null
System.out.println(StringUtils.trimToNull(""));          //prints: null
System.out.println(StringUtils.trimToNull("   "));       //prints: null
```

*   `trimToEmpty(String str)`：从输入值中删除前导和尾随的空白空间，流程`null`，空（`""`）和白色空间，如下所示：

```
System.out.println("'" + StringUtils.trimToEmpty(" x ") + "'");   // 'x'
System.out.println("'" + StringUtils.trimToEmpty(null) + "'");    // ''
System.out.println("'" + StringUtils.trimToEmpty("") + "'");      // ''
System.out.println("'" + StringUtils.trimToEmpty("   ") + "'");   // ''
```

*   `strip(String str)`，`stripToNull(String str)`，`stripToEmpty(String str)`：产生与前面的`trim*(String str)`方法相同的结果，但使用更广泛的空白定义（基于`Character.isWhitespace(int codepoint)`），从而将与`trim*(String str)`一起删除相同的字符 ， 和更多

*   `strip(String str, String stripChars)`，`stripAccents(String input)`，`stripAll(String... strs)`，`stripAll(String[] strs, String stripChars)`，`stripEnd(String str, String stripChars)`，`stripEnd(String str, String stripChars)`：从`String`或`String[]`数组元素的特定部分中删除特定字符
*   `startsWith(CharSequence str, CharSequence prefix)`，`startsWithAny(CharSequence string, CharSequence... searchStrings)`，`startsWithIgnoreCase(CharSequence str, CharSequence prefix)`和类似`endsWith*()`方法：检查`String`值是否以某个前缀（或后缀）开始（或结束）
*   `indexOf`，`lastIndexOf`，`contains`：以零安全的方式检查索引
*   `indexOfAny`，`lastIndexOfAny`，`indexOfAnyBut`，`lastIndexOfAnyBut`：返回指数
*   `containsOnly`，`containsNone`，`containsAny`：检查值是否包含某些字符
*   `substring`，`left`，`right`，`mid`：以零安全的方式返回子字符串
*   `substringBefore`，`substringAfter`，`substringBetween`：从相对位置返回子字符串
*   `split`，`join`：分割或加入值（相应的）
*   `remove`，`delete`：消除子字符串
*   `replace`，`overlay`：替换值
*   `chomp`，`chop`：删除结束
*   `appendIfMissing`：如果不存在，则添加值
*   `prependIfMissing`：如果不存在，则将前缀添加到`String`值的开始
*   `leftPad`，`rightPad`，`center`，`repeat`：添加填充
*   `upperCase`，`lowerCase`，`swapCase`，`capitalize`，`uncapitalize`：改变案例

*   `countMatches`：返回子字符串出现的数量
*   `isWhitespace`，`isAsciiPrintable`，`isNumeric`，`isNumericSpace`，`isAlpha`，`isAlphaNumeric`，`isAlphaNumeric`，`isAlphaSpace`，`isAlphaNumericSpace`：检查某些类型的字符的存在
*   `isAllLowerCase`，`isAllUpperCase`：检查案例
*   `defaultString`，`defaultIfBlank`，`defaultIfEmpty`：如果`null`如果`null`返回默认值
*   `rotate`：使用圆形偏移旋转字符
*   `reverse`，`reverseDelimited`：反向字符或分隔的字符组
*   `abbreviate`，`abbreviateMiddle`：使用省略号或其他值缩写值
*   `difference`：返回值的差异
*   `getLevenshteinDistance`：返回将一个值转换为另一个值所需的更改次数

正如您所看到的，`StringUtils`类具有非常丰富的（我们尚未列出所有内容）符合`String`类方法的字符串分析，比较和转换的方法。

# I / O 流

任何软件系统都必须接收并产生某种数据，可以组织为一组隔离的输入/输出或作为数据流。 流可以限制或无穷无尽。 可以从流中读取程序（然后它被称为**输入流**），或者写入流（然后它被称为**输出流**）。 Java I / O 流是基于字节的或基于字符的，这意味着其数据被解释为原始字节或作为字符。

`java.io`包包含支持许多但不是全部可能的数据源的类。 它是基于来自文件，网络流和内部存储器缓冲区的输入周围的大部分。 它不包含网络通信所需的许多课程。 它们属于`java.net`，`javax.net`和 Java 网络 API 的其他包。 仅在建立联网源或目的地之后（例如，网络套接字），程序可以使用`InputStream`包的`InputStream`和`OutputStream`类读取和写入数据。

`java.nio`包的类与`java.io`包的类相同的功能。 但是，除此之外，它们可以在*中工作，无阻塞*模式，这可以大大提高某些情况下的性能。 我们将讨论第 15 章*反应性编程*中的非阻塞处理。

# 流数据

程序理解的数据必须在 0s 和 1s 中二进制表达。 可以一次读取或写入一个字节或一次几个字节数的数据。 这些字节可以保持二进制文件，也可以被解释为字符。

在第一种情况下，它们可以通过`InputStream`和`OutputStream`类的后代读为字节或字节阵列。 例如（我们省略了包名，如果类属于`java.io`包）：`ByteArrayInputStream`，`ByteArrayOutputStream`，`FileInputStream`，`FileOutputStream`，`ObjectInputStream`，`ObjectOutputStream`，`ObjectOutputStream`，`javax.sound.sampled.AudioInputStream`和`org.omg.CORBA.portable.OutputStream`; 哪一个要使用取决于数据的源或目的地。 `InputStream`和`OutputStream`课程本身是抽象的，无法实例化。

在第二种情况下，可以解释为字符的数据称为**文本数据**，并且基于`Reader`和`Writer`有面向角色的读写类，这也是抽象类 。 它们的子类的实例是：`CharArrayReader`，`CharArrayWriter`，`InputStreamReader`，`OutputStreamWriter`，`PipedReader`，`PipedWriter`，`StringReader`和`StringWriter`。

您可能已经注意到我们成对列出了类。 但不是每个输入类都有一个匹配的输出专业化。 例如，存在支持输出到打印设备的`PrintStream`和`PrintWriter`类，但没有相应的输入伙伴，而不是至少由名称。 但是，存在以已知格式解析输入文本的`java.util.Scanner`类。

还有一组配备了一组配备的类，有助于一次通过读取或一次读取或写入更大的数据，尤其是在访问源或目的地的情况下需要很长时间的情况。

在本节的其余部分，我们将审核`java.io`包和其他包中的一些流行相关类的类。

# Class InputStream 及其子类

在 Java 类库中，`InputStream`抽象类具有以下直接实现：`ByteArrayInputStream`，`FileInputStream`，`ObjectInputStream`，`PipedInputStream`，`SequenceInputStream`，`FilterInputStream`和`javax.sound.sampled.AudioInputStream`。

所有这些都使用原样或覆盖`InputStream`类的以下方法：

*   `int available()`：返回可用于阅读的字节数
*   `void close()`：关闭流并释放资源
*   `void mark(int readlimit)`：标记流中的位置并定义可以读取多少字节
*   `boolean markSupported()`：返回`true`如果支持标记
*   `static InputStream nullInputStream()`：创建一个空的流
*   `abstract int read()`：读取流中的下一个字节
*   `int read(byte[] b)`：将流从流中的数据读入`b`缓冲区
*   `int read(byte[] b, int off, int len)`：从流中读取`len`或更少字节，进入`b`缓冲区
*   `byte[] readAllBytes()`：从流中读取所有剩余的字节
*   `int readNBytes(byte[] b, int off, int len)`：在`off`偏移量的`b`缓冲器中读取`len`或更少字节
*   `byte[] readNBytes(int len)`：将`len`或更少的字节读入`b`缓冲区
*   `void reset()`：将读取位置重置为上次调用`mark()`方法的位置
*   `long skip(long n)`：跳过`n`或更少的流字节; 返回跳过的实际字节数
*   `long transferTo(OutputStream out)`：从输入流读取，并将向提供的输出流字节写入 byte; 返回转移的实际字节数

`abstract int read()`是必须实现的唯一方法，但此类的大多数后代也覆盖了许多其他方法。

# bytearrayinputstream.

`ByteArrayInputStream`类允许读取字节数组作为输入流。 它具有以下两个构造函数，该构造函数创建类的对象，并定义用于读取输入字节流的缓冲区：

*   `ByteArrayInputStream(byte[] buffer)`
*   `ByteArrayInputStream(byte[] buffer, int offset, int length)`

除缓冲区外，第二构造函数还允许设置缓冲区的偏移和长度。 让我们来看看这个例子，看看如何使用该类。 我们假设`byte[]`数组有数据：

```
byte[] bytesSource(){
    return new byte[]{42, 43, 44};
}
```

然后我们可以写下列：

```
byte[] buffer = bytesSource();
try(ByteArrayInputStream bais = new ByteArrayInputStream(buffer)){
    int data = bais.read();
    while(data != -1) {
        System.out.print(data + " ");   //prints: 42 43 44
        data = bais.read();
    }
} catch (Exception ex){
    ex.printStackTrace();
}
```

`bytesSource()`方法生成填充将缓冲区填充到`ByteArrayInputStream`类的缓冲区作为参数的缓冲区。 然后，使用`read()`方法将所得流读取字节，直到达到流的末尾（和`read()`方法返回`-1`）。 每个新字节都打印出（没有换行和白色空间，因此所有读取字节都显示在白色空间分隔的一行中）。

前面的代码通常以更紧凑的形式表达，如下所示：

```
byte[] buffer = bytesSource();
try(ByteArrayInputStream bais = new ByteArrayInputStream(buffer)){
    int data;
    while ((data = bais.read()) != -1) {
        System.out.print(data + " ");   //prints: 42 43 44
    }
} catch (Exception ex){
    ex.printStackTrace();
}
```

它们可以以必要的任何其他方式处理它们，而不是打印字节，而不是将其解释为字符。 例如：

```
byte[] buffer = bytesSource();
try(ByteArrayInputStream bais = new ByteArrayInputStream(buffer)){
    int data;
    while ((data = bais.read()) != -1) {
        System.out.print(((char)data) + " ");   //prints: * + ,
    }
} catch (Exception ex){
    ex.printStackTrace();
}
```

但在这种情况下，最好使用专门用于字符处理的`Reader`类之一。 我们将在*读者和写作者及其子类*部分中讨论它们。

# fileInputStream.

例如，`FileInputStream`类从文件系统中的文件中获取数据，例如图像的原始字节。 它有以下三个构造函数：

*   `FileInputStream(File file)`
*   `FileInputStream(String name)`
*   `FileInputStream(FileDescriptor fdObj)`

每个构造函数打开指定为参数的文件。 第一个构造函数接受`File`对象，第二个构造函数，其中文件系统中文件的路径，以及表示与文件系统中实际文件的现有连接的文件描述符对象。 让我们来看看以下例子：

```
String filePath = "src/main/resources/hello.txt";
try(FileInputStream fis=new FileInputStream(filePath)){
    int data;
    while ((data = fis.read()) != -1) {
        System.out.print(((char)data) + " ");   //prints: H e l l o !
    }
} catch (Exception ex){
    ex.printStackTrace();
}
```

在`src/main/resources`文件夹中，我们创建了在 IT-`Hello!`中只有一行的`hello.txt`文件。 前面示例的输出如下所示：

![](img/1b619c0b-eec8-4bf9-acaf-422301cf45d1.png)

由于我们在 IDE 中运行此示例，因此它在项目根目录中执行。 要找到执行代码的位置，您可以始终将其打印出：

```
File f = new File(".");                //points to the current directory
System.out.println(f.getAbsolutePath()); //prints the directory path
```

从`hello.txt`文件中读取字节后，我们决定用于演示目的，将每个`byte`投递给`char`，因此您可以看到我们的代码从指定的文件中读取，但`FileReader`类是 文本文件处理的更好选择（我们将很快讨论）。 没有演员，结果将是以下内容：

```
System.out.print((data) + " ");   //prints: 72 101 108 108 111 33
```

顺便说一下，因为在类路径上由 IDE（使用 Maven）放置了`src/main/resources`文件夹，也可以通过 ClassLoader 访问它的文件，该文件也可以使用自己的`InputStream`实现来创建流：

```
try(InputStream is = InputOutputStream.class.getResourceAsStream("/hello.txt")){
    int data;
    while ((data = is.read()) != -1) {
        System.out.print((data) + " ");   //prints: 72 101 108 108 111 33
    }
} catch (Exception ex){
    ex.printStackTrace();
}
```

前面示例中的`InputOutputStream`类不是来自某些库的类。 它只是我们用于运行该示例的主类。 `InputOutputStream.class.getResourceAsStream()`构造允许使用已加载`InputOutputStream`类的相同的类加载器，以便在类路径上查找文件并创建包含其内容的流。 在*文件管理*部分中，我们将介绍其他读取文件的方法。

# ObjectInputStream.

`ObjectInputStream`类的一组方法比任何其他`InputStream`实现的一组方法大得多。 原因是它围绕读取可以具有各种类型的对象字段的值。 为了使`ObjectInputStream`能够从输入数据流构造一个对象，对象必须是 *deserializable* ，这意味着它必须在第一个中是序列化的 放置 - 即将转换为字节流。 通常，它是为了通过网络传输对象的目的。 在目的地，序列化对象被反序列化，恢复原始对象的值。

原始类型和大多数 Java 类（包括`String`类和原始类型包装器）是序列化的。 如果类具有自定义类型的字段，则必须通过实现`java.io.Serizalizable`来序列化。 如何做到这本书的范围。 目前，我们将仅使用可序列化类型。 我们来看看这个课程：

```
class SomeClass implements Serializable {
    private int field1 = 42;
    private String field2 = "abc";
}
```

我们必须告诉编译器它是可序列化的。 否则，汇编将失败。 它是为了确保，在说明该类是可序列化之前，程序员要么审阅所有字段，请确保它们是序列化的，也可以实现序列化所需的方法。

在我们可以创建输入流之前并使用`ObjectInputStream`进行反序列化，我们需要先序列化对象。 这就是我们首次使用`ObjectOutputStream`和`FileOutputStream`序列化对象并将其写入`someClass.bin`文件中的原因。 我们将在 *Class OutputStream 及其子类*部分中更多地讨论它们。 然后我们使用`FileInputStream`从文件读取，并使用`ObjectInputStream`将文件内容反序列：

```
String fileName = "someClass.bin";
try (ObjectOutputStream objectOutputStream =
             new ObjectOutputStream(new FileOutputStream(fileName));
     ObjectInputStream objectInputStream =
              new ObjectInputStream(new FileInputStream(fileName))){
    SomeClass obj = new SomeClass();
    objectOutputStream.writeObject(obj);
    SomeClass objRead = (SomeClass) objectInputStream.readObject();
    System.out.println(objRead.field1);  //prints: 42
    System.out.println(objRead.field2);  //prints: abc
} catch (Exception ex){
    ex.printStackTrace();
}
```

请注意，必须在运行前面的代码之前先首先创建该文件。 我们将展示如何在*创建文件和目录*部分中完成。 并提醒您，我们使用了尝试 - 资源语句，因为`InputStream`和`OutputStream`都实现了`Closeable`接口。

# PipedInputstream.

管道输入流具有非常特别的专业化; 它被用作线程之间的通信机制之一。 从`PipedInputStream`对象中读取一个线程，并将数据传递给将数据写入`PipedOutputStream`对象的另一个线程。 这是一个例子：

```
PipedInputStream pis = new PipedInputStream();
PipedOutputStream pos = new PipedOutputStream(pis);

```

或者，当从`PipedOutputStream`对象读取时，数据可以沿相反方向移动，并且另一个线程写入`PipedInputStream`对象，如下所示：

```
PipedOutputStream pos = new PipedOutputStream();
PipedInputStream pis = new PipedInputStream(pos);

```

那些在这个区域工作的人熟悉该消息，“*破管* ，这意味着提供数据管道流已停止工作。

也可以在没有任何连接的情况下创建管道流，并以稍后如下所示：

```
PipedInputStream pis = new PipedInputStream();
PipedOutputStream pos = new PipedOutputStream();
pos.connect(pis); 
```

例如，这里有两个类将由不同的线程执行。 首先，`PipedOutputWorker`课程如下：

```
class PipedOutputWorker implements Runnable{
    private PipedOutputStream pos;
    public PipedOutputWorker(PipedOutputStream pos) {
        this.pos = pos;
    }
    @Override
    public void run() {
        try {
            for(int i = 1; i < 4; i++){
                pos.write(i);
            }
            pos.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
```

`PipedOutputWorker`类具有`run()`方法（因为它实现了写入流中的`Runnable`接口，将三个数字`1`，`2`和`3`，然后关闭。 现在让我们看看`PipedInputWorker`课程如下所示：

```
class PipedInputWorker implements Runnable{
    private PipedInputStream pis;
    public PipedInputWorker(PipedInputStream pis) {
        this.pis = pis;
    }
    @Override
    public void run() {
        try {
            int i;
            while((i = pis.read()) > -1){
                System.out.print(i + " ");  
            }
            pis.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
```

它还具有`run()`方法（因为它实现了从流读取的`Runnable`接口，并在流结束之前打印出每个字节（由`-1`指示）。 现在让我们连接这些管道并执行这些类的`run()`方法：

```
PipedOutputStream pos = new PipedOutputStream();
PipedInputStream pis = new PipedInputStream();
try {
    pos.connect(pis);
    new Thread(new PipedOutputWorker(pos)).start();
    new Thread(new PipedInputWorker(pis)).start(); //prints: 1 2 3
} catch (Exception ex) {
    ex.printStackTrace();
}
```

如您所见，工人的对象被传递到`Thread`类的构造函数中。 `Thread`对象的`start()`方法执行`Runnable`的`run()`方法。 我们看到了我们预期的结果; `PipedInputWorker`打印`PipedOutputWorker`将写入管道流写入的所有字节。 我们将在[第 8 章](08.html)，*多线程和并发处理中进行有关线程的更多详细信息。*

# sequentInputstream.

`SequenceInputStream`类连接到以下构造函数之一作为参数的输入流：

*   `SequenceInputStream(InputStream s1, InputStream s2)`
*   `SequenceInputStream(Enumeration<InputStream> e)`

**枚举**是在角括号中指示的类型的对象集合，称为**泛型** *，*含有 t 的*。 `SequenceInputStream`类从第一个输入字符串读取，直到它结束，从而从第二个输入读取，依此类推，直到最后一个流的结尾。 例如，让我们在`hello.txt`文件旁边的`resources`文件夹中创建`howAreYou.txt`文件（使用 text `How are you?`）。 然后可以使用`SequenceInputStream`类如下：*

```
try(FileInputStream fis1 = 
                    new FileInputStream("src/main/resources/hello.txt");
    FileInputStream fis2 = 
                new FileInputStream("src/main/resources/howAreYou.txt");
    SequenceInputStream sis=new SequenceInputStream(fis1, fis2)){
    int i;
    while((i = sis.read()) > -1){
        System.out.print((char)i);       //prints: Hello!How are you?
    }
} catch (Exception ex) {
    ex.printStackTrace();
}
```

类似地，当输入流的枚举被传递时，读取每个流（并在我们的情况下打印）直到结束。

# filterInputStream.

`FilterInputStream`类是`InputStream`对象周围的包装器传递为构造函数中的参数。 以下是`FilterInputStream`类的构造函数和两个`read()`方法：

```
protected volatile InputStream in;
protected FilterInputStream(InputStream in) { this.in = in; }
public int read() throws IOException { return in.read(); }
public int read(byte b[]) throws IOException { 
    return read(b, 0, b.length);
}

```

`InputStream`类的所有其他方法都类似地覆盖; 该函数委派给分配给`in`属性的对象。

正如您所看到的，构造函数受到保护，这意味着只有孩子可以访问它。 这种设计从客户端隐藏了流的实际源并强制程序员使用`FilterInputStream`级扩展之一：`BufferedInputStream`，`CheckedInputStream`，`DataInputStream`，`PushbackInputStream`，`javax.crypto.CipherInputStream`，[htg6 `java.util.zip.InflaterInputStream`，`java.security.DigestInputStream`，或`javax.swing.ProgressMonitorInputStream`。 或者，可以创建自定义扩展名。 但是，在创建自己的扩展之前，请查看列出的类，看看其中一个是否适合您的需求。 以下是使用`BufferedInputStream`类的示例：

```
try(FileInputStream  fis = 
        new FileInputStream("src/main/resources/hello.txt");
    FilterInputStream filter = new BufferedInputStream(fis)){
    int i;
    while((i = filter.read()) > -1){
        System.out.print((char)i);     //prints: Hello!
    }
} catch (Exception ex) {
    ex.printStackTrace();
}
```

`BufferedInputStream`类使用缓冲区来提高性能。 当跳过或读取流的字节时，内部缓冲区自动从包含的输入流时根据需要使用尽可能多的字节重新填充。

`CheckedInputStream`类添加了读取的数据校验和，允许使用`getChecksum()`方法验证输入数据的完整性。

`DataInputStream`类以无关的方式读取并将输入数据作为原始 Java 数据类型读取。

`PushbackInputStream`类增加了使用`unread()`方法推回读取数据的能力。 当代码具有分析刚读取数据并决定未读取的逻辑时，它在情况下很有用，因此可以在下一步重新读取它。

`javax.crypto.CipherInputStream`类将`Cipher`添加到`read()`方法中。 如果初始化`Cipher`以进行解密，则`javax.crypto.CipherInputStream`将尝试在返回之前解密数据。

`java.util.zip.DeflaterInputStream`类压缩了缩小压缩格式的数据。

`java.util.zip.InflaterInputStream`类将数据解压缩以缩小压缩格式。

`java.security.DigestInputStream`类使用通过流的位更新关联的消息摘要。 `on (boolean on)`方法打开或关闭摘要函数。 可以使用`getMessageDigest()`方法检索计算的摘要。

`javax.swing.ProgressMonitorInputStream`类提供了从`InputStream`的读数进度的监视器。 可以使用`getProgressMonitor()`方法访问监视器对象。

# javax.Sound.Sampled.AudioInputStream.

`AudioInputStream`类表示具有指定音频格式和长度的输入流。 它有以下两个构造函数：

*   `AudioInputStream (InputStream stream, AudioFormat format, long length)`：接受音频数据流，请求的格式和样本帧中的长度
*   `AudioInputStream (TargetDataLine line)`：接受指示的目标数据线

`javax.sound.sampled.AudioFormat`类描述了音频格式属性，如通道，编码，帧速率和类似。 `javax.sound.sampled.TargetDataLine`类具有`open()`方法，该方法打开具有指定格式的线路和`read()`方法，该方法从数据线的输入缓冲区读取音频数据。

还有`javax.sound.sampled.AudioSystem`类及其方法处理`AudioInputStream`对象。 它们可用于从音频文件，流或 URL 读取，并写入音频文件。 它们还可用于将音频流转换为另一种音频格式。

# Class OutputStream 及其子类

`OutputStream`类是对`InputStream`类的对等体，用于写入数据而不是读数。 它是一个抽象类，在 **java 类库**中有以下直接实现（ **jcl** ）：`ByteArrayOutputStream`，`FilterOutputStream`，`ObjectOutputStream`，`PipedOutputStream`和`FileOutputStream`。

`FileOutputStream`类具有以下直接扩展：`BufferedOutputStream`，`CheckedOutputStream`，`DataOutputStream`，`PrintStream`，`javax.crypto.CipherOutputStream`，`java.util.zip.DeflaterOutputStream`，`java.util.zip.DeflaterOutputStream`和`java.util.zip.InflaterOutputStream`。

所有这些都使用原样或覆盖`OutputStream`类的以下方法：

*   `void close()`：关闭流并释放资源
*   `void flush()`：强制写出剩余的字节
*   `static OutputStream nullOutputStream()`：创建一个新的`OutputStream`，它没有
*   `void write(byte[] b)`：将提供的字节数组写入输出流
*   `void write(byte[] b, int off, int len)`：将提供的字节数组的`len`字节写入`off`偏移量到输出流
*   `abstract void write(int b)`：将提供的字节写入输出流

必须实现的唯一方法是`abstract void write(int b)`，但`OutputStream`类的大多数后代也覆盖了许多其他方法。

在了解 *InputStream 及其子类*部分中的输入流之后，除了`PrintStream`类之外的所有`OutputStream`实现，应直观地熟悉您。 所以，我们将在这里讨论`PrintStream`课程。

# 打印流

`PrintStream`类将另一个输出流添加为将数据作为字符打印。 我们实际上已经多次使用它。 `System`类具有`PrintStream`类设置为`System.out` public static 属性。 这意味着每次使用使用`System.out`打印某些东西时，我们都使用`PrintStream`类：

```
System.out.println("Printing a line");
```

让我们来看看`PrintStream`类用法的另一个例子：

```
String fileName = "output.txt";
try(FileOutputStream  fos = new FileOutputStream(fileName);
    PrintStream ps = new PrintStream(fos)){
    ps.println("Hi there!");
} catch (Exception ex) {
    ex.printStackTrace();
}
```

如您所见，`PrintStream`类占用`FileOutputStream`对象并打印由它生成的字符。 在这种情况下，它将`FileOutputStream`写入文件的所有字节打印出来。 顺便说一下，无需明确创建目标文件。 如果不存在，它将在`FileOutputStream`构造函数内自动创建。 如果我们在运行前面的代码后打开文件，我们将看到其中的一行：`"Hi there!"`。

或者，可以使用具有`File`对象的另一个`PrintStream`构造函数来实现相同的结果，如下所示：

```
String fileName = "output.txt";
File file = new File(fileName);
try(PrintStream ps = new PrintStream(file)){
    ps.println("Hi there!");
} catch (Exception ex) {
    ex.printStackTrace();
}
```

可以使用将文件名作为参数的`PrintStream`构造函数的第三个变体创建更简单的解决方案：

```
String fileName = "output.txt";
try(PrintStream ps = new PrintStream(fileName)){
    ps.println("Hi there!");
} catch (Exception ex) {
    ex.printStackTrace();
}
```

前面两个前面的示例是可能的，因为`PrintStream`构造函数在幕后使用`FileOutputStream`类，正如我们在`PrintStream`类使用的第一个例子中所做的那样。 因此，`PrintStream`类只为方便起见，但所有的所有构造函数都基本上具有相同的功能：

*   `PrintStream(File file)`
*   `PrintStream(File file, String csn)`
*   `PrintStream(File file, Charset charset)`
*   `PrintStream(String fileName)`
*   `PrintStream(String fileName, String csn)`
*   `PrintStream(String fileName, Charset charset)`
*   `PrintStream(OutputStream out)`
*   `PrintStream(OutputStream out, boolean autoFlush)`
*   `PrintStream(OutputStream out, boolean autoFlush, String encoding)`
*   `PrintStream(OutputStream out, boolean autoFlush, Charset charset)`

一些构造函数也采用`Charset`实例或只是其名称（`String csn`），其允许在十六位 Unicode 代码单元和字节序列之间应用不同的映射。 只需在此显示的情况下，您可以看到所有可用的 Charsets：

```
for (String chs : Charset.availableCharsets().keySet()) {
    System.out.println(chs);
}
```

其他构造函数将`boolean autoFlush`作为参数。 此参数表示（当`true`）当遇到阵列或遇到符号端时应自动刷新输出缓冲区。

一旦创建了`PrintStream`的对象，它提供了以下列出的各种方法：

*   `void print(T value)`：打印任何`T`原始类型的值，而不移动到另一行
*   `void print(Object obj)`：在传递的对象上调用`toString()`方法，并在不移动到另一行的情况下打印结果; 如果传递的对象是`null`并打印`null`，则不会生成`NullPointerException`

*   `void println(T value)`：打印任何`T`原始类型传递的值并移动到另一行
*   `void println(Object obj)`：在传递的对象上调用`toString()`方法，打印结果，然后移动到另一行; 如果传递的对象是`null`并打印`null`，则不会生成`NullPointerException`
*   `void println()`：刚进入另一行
*   `PrintStream printf(String format, Object... values)`：使用提供的`values`替换提供的`format`字符串中的占位符，并将结果写入流中
*   `PrintStream printf(Locale l, String format, Object... args)`：与前面的方法相同，但使用提供的`Local`对象应用本地化; 如果提供的`Local`对象是`null`，则不应用本地化，此方法的行为与前一体相似
*   `PrintStream format(String format, Object... args)`和`PrintStream format(Locale l, String format, Object... args)`：表现与`PrintStream printf(String format, Object... values)`和`PrintStream printf(Locale l, String format, Object... args)`相同的方式（列表中已经描述）例如：

```
System.out.printf("Hi, %s!%n", "dear reader"); //prints: Hi, dear reader!
System.out.format("Hi, %s!%n", "dear reader"); //prints: Hi, dear reader!

```

在前面的示例中，（`%`）表示格式化规则。 以下符号（`s`）表示`String`值。 该位置中的其他可能符号可以是（`d`）（十进制），（`f`）（浮点）等。 符号（`n`）表示新行（与（`\n`）转义字符）相同。 有许多格式化规则。 所有这些都在`java.util.Formatter`类文档中描述。

*   `PrintStream append(char c)`，`PrintStream append(CharSequence c)`，`PrintStream append(CharSequence c, int start, int end)`：将提供的字符附加到流中。 例如：

```
System.out.printf("Hi %s", "there").append("!\n");  //prints: Hi there!
System.out.printf("Hi ")
               .append("one there!\n two", 4, 11);  //prints: Hi there!

```

有了这个，我们得出对`OutputStream`子类的讨论，现在将我们注意另一个类层次结构 - `Reader`和`Writer`类及其从 JCL 的子类。

# 课程读者和作家及其子类

正如我们已经提到的多次，`Reader`和`Writer`类在它们的函数中与`InputStream`和`OutputStream`类非常相似，但专门从事处理文本。 它们将流字节作为字符解释为字符，并具有自己的独立`InputStream`和`OutputStream`类层次结构。 可以将流字节作为没有`Reader`和`Writer`的字符或其子类中的任何一个。 我们在描述`InputStream`和`OutputStream`类中的前一节中看到了这样的示例。 但是，使用`Reader`和`Writer`类使文本处理更简单，代码更容易读取。

# 读者及其子类

类`Reader`是一个抽象类，读取流为字符。 它是一个模拟到`InputStream`，并具有以下方法：

*   `abstract void close()`：关闭流和其他使用的资源
*   `void mark(int readAheadLimit)`：标记流中的当前位置
*   `boolean markSupported()`：返回`true`如果流支持`mark()`操作
*   `static Reader nullReader()`：创建一个空读取器，读取没有字符
*   `int read()`：读一个角色
*   `int read(char[] buf)`：将字符读入提供的`buf`数组并返回读取字符的计数
*   `abstract int read(char[] buf, int off, int len)`：从`off`索引开始的`len`字符到数组中
*   `int read(CharBuffer target)`：尝试将字符读入提供的`target`缓冲区
*   `boolean ready()`：返回`true`当流准备好读取时
*   `void reset()`：重置标记; 但是，并非所有流都支持此操作，而一些支持它，但不支持设置标记

*   `long skip(long n)`：尝试跳过`n`字符; 返回跳过的字符的计数
*   `long transferTo(Writer out)`：从此阅读器中读取所有字符，并将字符写入提供的`Writer`对象

如您所见，需要实现的唯一方法是两个抽象`read()`和`close()`方法。 尽管如此，这个课堂的许多孩子也覆盖了其他方法，有时以获得更好的性能或不同的功能。 JCL 中的`Reader`子类是：`CharArrayReader`，`InputStreamReader`，`PipedReader`，`StringReader`，`BufferedReader`和`FilterReader`。 `BufferedReader`类具有`LineNumberReader`子类，`FilterReader`类具有`PushbackReader`子类。

# 作家及其子类

Abstract `Writer`类写入字符流。 它是一个模拟到`OutputStream`，并具有以下方法：

*   `Writer append(char c)`：将提供的字符附加到流中
*   `Writer append(CharSequence c)`：将提供的字符序列附加到流中
*   `Writer append(CharSequence c, int start, int end)`：将提供的字符序列的子序列附加到流中
*   `abstract void close()`：刷新并关闭流和相关系统资源
*   `abstract void flush()`：冲洗流
*   `static Writer nullWriter()`：创建一个丢弃所有字符的新`Writer`对象
*   `void write(char[] c)`：写入`c`字符数组
*   `abstract void write(char[] c, int off, int len)`：从`off`索引开始，写入`c`字符数组的元素
*   `void write(int c)`：写一个角色
*   `void write(String str)`：写下提供的字符串
*   `void write(String str, int off, int len)`：从提供的`str`字符串从`off`索引开始，写入`len`长度的子字符串

如您所见，这三种抽象方法：`write(char[], int, int)`，`flush()`和`close()`必须由本类的子项实现。 它们通常也覆盖其他方法。

JCL 中的`Writer`子类是：`CharArrayWriter`，`OutputStreamWriter`，`PipedWriter`，`StringWriter`，`BufferedWriter`，`FilterWriter`和`PrintWriter`。 `OutputStreamWriter`类具有`FileWriter`子类。

# 其他类的 java.io 包

`java.io`包的其他类包括以下内容：

*   `Console`：允许与与当前 JVM 实例相关联的基于字符的控制台设备进行交互
*   `StreamTokenizer`：拍摄输入流并将其解析为`tokens`
*   `ObjectStreamClass`：序列化的类描述符
*   `ObjectStreamField`：从序列化类的序列化字段的描述
*   `RandomAccessFile`：允许随机访问从文件中读取和写入文件，但其讨论超出了本书的范围
*   `File`：允许创建和管理文件和目录; *文件管理*部分中描述

# 安慰

有几种方法可以创建和运行执行应用程序的 **java 虚拟机**（ **jvm** ）实例。 如果从命令行开始 JVM，则会自动打开控制台窗口。 它允许在键盘上键入显示器上的显示; 但是，JVM 也可以通过背景过程开始。 在这种情况下，未创建控制台。

要以编程方式检查如果控制台存在，可以调用`System.console()`静态方法。 如果没有可用控制台设备，则该方法的调用将返回`null`。 否则，它将返回允许与控制台设备和应用程序用户交互的`Console`类的对象。

让我们创建以下`ConsoleDemo`类：

```
package com.packt.learnjava.ch05_stringsIoStreams;
import java.io.Console;
public class ConsoleDemo {
    public static void main(String... args)  {
        Console console = System.console();
        System.out.println(console);
    }
}
```

如果我们从 IDE 中运行它，我们通常这样做，结果将如下：

![](img/ebc1dbfe-424f-47b1-bef6-6321d235dd9f.png)

这是因为 JVM 不会从命令行启动。 要执行此操作，让我们编译我们的应用程序并通过在项目的根目录中执行`mvn clean package` maven 命令来创建`.jar`文件。 它将删除`target`文件夹，然后重新创建它，并将所有`.java`文件编译到`target`文件夹中的相应`.class`文件，然后将它们存档在`.jar`文件`learnjava-1.0-SNAPSHOT.jar`中。

现在我们可以使用以下命令从同一项目根目录启动`ConsoleDemo`应用程序：

```
java -cp ./target/learnjava-1.0-SNAPSHOT.jar 
 com.packt.learnjava.ch05_stringsIoStreams.ConsoleDemo
```

前面的命令以两行显示，因为页面宽度无法容纳它。 但如果你想运行它，请确保将它作为一行。 结果将如下：

![](img/8585c838-8837-4601-9064-8d13f2c249f8.png)

它告诉我们我们现在拥有`Console`类对象。 让我们看看我们能做什么。 该类具有以下方法：

*   `String readLine()`：等待在用户命中键*之前输入*并从控制台读取文本行
*   `String readLine(String format, Object... args)`：显示提示（提供的格式后生成的消息让占有者替换为提供的参数），等待，直到用户命中键*输入*，并从控制台读取文本行; 如果没有提供参数`args`，请将格式显示为提示

*   `char[] readPassword()`：执行与`readLine()`功能相同的函数，但不应回应键入的字符
*   `char[] readPassword(String format, Object... args)`：执行与`readLine(String format, Object... args)`的函数相同，但不应回应键入的字符

让我们通过以下示例演示上述方法：

```
Console console = System.console();

String line = console.readLine();
System.out.println("Entered 1: " + line);
line = console.readLine("Enter something 2: ");
System.out.println("Entered 2: " + line);
line = console.readLine("Enter some%s", "thing 3: ");
System.out.println("Entered 3: " + line);

char[] password = console.readPassword();
System.out.println("Entered 4: " + new String(password));
password = console.readPassword("Enter password 5: ");
System.out.println("Entered 5: " + new String(password));
password = console.readPassword("Enter pass%s", "word 6: ");
System.out.println("Entered 6: " + new String(password));
```

前述示例的结果如下：

![](img/c7751f80-9a56-4beb-9603-7c6614aec5ad.png)

另一组`Console`类方法可以与刚刚演示的方法一起使用：

*   `Console format(String format, Object... args)`：使用提供的`args`值替换提供的`format`字符串中的占位符，并显示结果
*   `Console printf(String format, Object... args)`：表现与`format()`方法相同的方式

例如，查看以下行：

```
String line = console.format("Enter some%s", "thing:").readLine();

```

它会产生与此行相同的结果：

```
String line = console.readLine("Enter some%s", "thing:");

```

最后，控制台类的最后三种方法如下：

*   `PrintWriter writer()`：创建与此控制台关联的`PrintWriter`对象，该对象可用于生成输出字符流
*   `Reader reader()`：创建与此控制台关联的`Reader`对象，该对象可用于将输入读取为字符流
*   `void flush()`：冲洗控制台并强制立即写入任何缓冲的输出

这是他们使用的例子：

```
try (Reader reader = console.reader()){
    char[] chars = new char[10];
    System.out.print("Enter something: ");
    reader.read(chars);
    System.out.print("Entered: " + new String(chars));
} catch (IOException e) {
    e.printStackTrace();
}

PrintWriter out = console.writer();
out.println("Hello!");

console.flush();

```

前面代码的结果如下所示：

![](img/93bcad35-3e24-47ad-b9f6-baddd6fe10ff.png)

`Reader`和`PrintWriter`也可用于创建其他`Input`和`Output`我们在本节中谈论的流。

# StreamTokenizer

`StreamTokenizer`类解析输入流并生成令牌。 其`StreamTokenizer(Reader r)`构造函数接受一个是令牌源的`Reader`对象。 每次调用`StreamTokenizer`对象上的`int nextToken()`方法时，会发生以下情况：

1.  下一个令牌被解析了
2.  `StreamTokenizer`实例字段`ttype`被指示令牌类型的值填充：
    *   `ttype`值可以是以下整数常量：`TT_WORD`，`TT_NUMBER`，`TT_EOL`（终点），或`TT_EOF`（流结束）
    *   如果`ttype`值为`TT_WORD`，则`StreamTokenizer`实例`sval`字段由令牌的`String`值填充
    *   如果`ttype`值为`TT_NUMBER`，则令牌的`double`值填充`StreamTokenizer`实例字段`nval`
3.  `lineno()`实例的`lineno()`方法返回当前行号

在谈论`StreamTokenizer`类的其他方法之前，让我们来看看一个例子。 让我们假设在“项目`resources`文件夹中，有一个`tokens.txt`文件，其中包含以下四行文本：

```
There
happened
42
events.
```

以下代码将读取该文件并授予其内容：

```
String filePath = "src/main/resources/tokens.txt";
try(FileReader fr = new FileReader(filePath);
 BufferedReader br = new BufferedReader(fr)){
 StreamTokenizer st = new StreamTokenizer(br);
    st.eolIsSignificant(true);
    st.commentChar('e');
    System.out.println("Line " + st.lineno() + ":");
    int i;
    while ((i = st.nextToken()) != StreamTokenizer.TT_EOF) {
        switch (i) {
            case StreamTokenizer.TT_EOL:
                System.out.println("\nLine " + st.lineno() + ":");
                break;
            case StreamTokenizer.TT_WORD:
                System.out.println("TT_WORD => " + st.sval);
                break;
            case StreamTokenizer.TT_NUMBER:
                System.out.println("TT_NUMBER => " + st.nval);
                break;
            default:
                System.out.println("Unexpected => " + st.ttype);
        }
    }         
} catch (Exception ex){
    ex.printStackTrace();
}
```

如果我们运行此代码，结果将如下：

![](img/a8321bb4-1929-415d-8d37-dc72e6edd773.png)

我们使用了`BufferedReader`课程，这是一个良好的效率实践，但在我们的情况下，我们可以轻松避免这样做：

```
 FileReader fr = new FileReader(filePath);
 StreamTokenizer st = new StreamTokenizer(fr);

```

结果不会改变。 我们还使用以下三种方法尚未描述：

*   `void eolIsSignificant(boolean flag)`：指示线端是否应被视为令牌
*   `void commentChar(int ch)`：表示哪个字符开始注释，因此忽略了其余的行
*   `int lineno()`：返回当前行号

可以使用`StreamTokenizer`对象调用以下方法：

*   `void lowerCaseMode(boolean fl)`：表示是否应将令牌单词令牌进行
*   `void ordinaryChar(int ch)`，`void ordinaryChars(int low, int hi)`：表示必须被视为*普通*的特定字符或字符范围（不是注释字符，单词组件，字符串分隔符，空格或数字字符）
*   `void parseNumbers()`：表示必须将具有双重精度浮点数的格式的单词令牌解释为数字而不是单词
*   `void pushBack()`：强制`nextToken()`方法返回`ttype`字段的当前值
*   `void quoteChar(int ch)`：表示提供的字符必须被解释为必须拍摄的字符串值的开头和结尾（作为报价）
*   `void resetSyntax()`：重置此令垂体器的语法表，以便所有字符都是普通的
**   `void slashSlashComments(boolean flag)`：表示必须识别 C ++样式评论*   `void slashStarComments(boolean flag)`：表示必须识别 C 样式评论*   `String toString()`：返回令牌的字符串表示和行号
    `void whitespaceChars(int low, int hi)`：表示必须被解释为空白空间的字符范围*   `void wordChars(int low, int hi)`：表示必须被解释为单词的字符范围*

 *如您所见，使用前面的方法的丰富允许微调文本解释。

# ObjectStreamClass 和 ObjectStreamField.

`ObjectStreamClass`和`ObjectStreamField`类提供对 JVM 中加载的类的序列化数据的访问。 可以使用以下查找方法之一找到/创建`ObjectStreamClass`对象：

*   `static ObjectStreamClass lookup(Class cl)`：查找可序列化类的描述符
*   `static ObjectStreamClass lookupAny(Class cl)`：找到任何类的描述符，无论是序列化还是不序列

在找到`ObjectStreamClass`并找到类是可序列化（实现`Serializable`接口）后，它可用于访问`ObjectStreamField`对象，每个对象包含有关一个序列化字段的信息。 如果类不序列化，则没有与任何字段关联的`ObjectStreamField`对象。

让我们来看看一个例子。 以下是显示从`ObjectStreamClass`和`ObjectStreamField`对象获得的信息的方法：

```
void printInfo(ObjectStreamClass osc) {
    System.out.println(osc.forClass());
    System.out.println("Class name: " + osc.getName());
    System.out.println("SerialVersionUID: " + osc.getSerialVersionUID());
    ObjectStreamField[] fields = osc.getFields();
    System.out.println("Serialized fields:");
    for (ObjectStreamField osf : fields) {
        System.out.println(osf.getName() + ": ");
        System.out.println("\t" + osf.getType());
        System.out.println("\t" + osf.getTypeCode());
        System.out.println("\t" + osf.getTypeString());
    }
}
```

要演示它是如何工作的，我们创建了一个可序列化`Person1`类：

```
package com.packt.learnjava.ch05_stringsIoStreams;
import java.io.Serializable;
public class Person1 implements Serializable {
    private int age;
    private String name;
    public Person1(int age, String name) {
        this.age = age;
        this.name = name;
    }
}
```

我们没有添加方法，因为只有对象状态是序列化的，而不是方法。 现在让我们运行以下代码：

```
ObjectStreamClass osc1 = ObjectStreamClass.lookup(Person1.class);
printInfo(osc1);

```

结果将如下：

![](img/86ca6ffa-a2a4-4e8c-8a62-e93ba17d58e4.png)

如您所见，有关类名和所有字段名称和类型的信息。 还有另外两种方法可以使用`ObjectStreamField`对象来调用：

*   `boolean isPrimitive()`：如果此字段具有原始类型，则返回`true`
*   `boolean isUnshared()`：返回`true`如果不共享此字段（仅私有或仅从同一包访问）

现在让我们创建一个非序列化`Person2`类：

```
package com.packt.learnjava.ch05_stringsIoStreams;
public class Person2 {
    private int age;
    private String name;
    public Person2(int age, String name) {
        this.age = age;
        this.name = name;
    }
}
```

这次，我们将运行仅查找类的代码如下：

```
ObjectStreamClass osc2 = ObjectStreamClass.lookup(Person2.class);
System.out.println("osc2: " + osc2);    //prints: null

```

如预期的那样，使用`lookup()`方法找不到非序列化对象。 为了找到一个非序列化对象，我们需要使用`lookupAny()`方法：

```
ObjectStreamClass osc3 = ObjectStreamClass.lookupAny(Person2.class);
printInfo(osc3);
```

如果我们运行前面的示例，结果将如下：

![](img/7766049f-f24a-44d2-bb2f-9e1aa51c86d1.png)

从非序列化对象中，我们能够提取有关类的信息，但不是关于字段的信息。

# 类 java.util.Scaren.

`java.util.Scanner`类通常用于从键盘读取输入，但可以从实现`Readable`接口的任何对象中读取文本（此接口仅具有`int read(CharBuffer buffer)`方法）。 它通过分隔符（空白空间是默认分隔符）来打破输入值，以使用不同的方法处理的令牌。

例如，我们可以读取从`System.in` -A 标准输入流的输入，这通常表示键盘输入：

```
Scanner sc = new Scanner(System.in);
System.out.print("Enter something: ");
while(sc.hasNext()){
    String line = sc.nextLine();
    if("end".equals(line)){
        System.exit(0);
    }
    System.out.println(line);
}
```

它接受许多线条（按下键*后的每行结束，按下*），直到输入 LINE `*end*`如下所示：

![](img/7f2c2b9e-17e3-40ec-b1ae-228c46092c21.png)

或者，`Scanner`可以从文件中读取行：

```
String filePath = "src/main/resources/tokens.txt";
try(Scanner sc = new Scanner(new File(filePath))){
    while(sc.hasNextLine()){
        System.out.println(sc.nextLine());
    }
} catch (Exception ex){
    ex.printStackTrace();
}
```

如您所见，我们已再次使用`tokens.txt`文件。 结果如下：

![](img/e16dbebb-7087-46f6-9378-dddbcded13e2.png)

要演示`Scanner`通过分隔符来打破输入，让我们运行以下代码：

```
String input = "One two three";
Scanner sc = new Scanner(input);
while(sc.hasNext()){
    System.out.println(sc.next());
}
```

结果如下：

![](img/c2bedcd5-3234-409c-b0cd-d62015d6f9ec.png)

要使用另一个分隔符，可以设置如下：

```
String input = "One,two,three";
Scanner sc = new Scanner(input).useDelimiter(",");
while(sc.hasNext()){
    System.out.println(sc.next());
}
```

结果保持不变：

![](img/c87d32bd-c7ee-47dc-ba10-8d57f6963a9d.png)

还可以使用正则表达式来提取令牌，但此主题超出了本书的范围。

`Scanner`类具有许多其他方法，使其使用适用于各种来源和所需的结果。 `findInLine()`，`findWithinHorizon()`，`skip()`和`findAll()`方法不使用分隔符，他们只是尝试匹配提供的模式。 有关更多信息，请参阅扫描仪文档（ [https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/scanner.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Scanner.html) ）。

# 文件管理

我们已经使用了一些使用 JCL 类查找，创建，读取和编写文件的方法。 我们必须这样做，以支持输入/输出流的演示代码。 在本节中，我们将更详细地使用 JCL 讨论文件管理。

`java.io`包中的`File`类表示底层文件系统。 可以使用以下构造函数之一创建`File`类的对象：

*   `File(String pathname)`：基于提供的路径名创建一个新的`File`实例
*   `File(String parent, String child)`：基于提供的父路径名和子路径名创建一个新的`File`实例
*   `File(File parent, String child)`：基于提供的父对象和子路径名创建一个新的`File`实例
*   `File(URI uri)`：基于表示路径名的提供的`URI`对象创建一个新的`File`实例

我们现在将在谈论创建和删除文件时看到构造函数的使用情况。

# 创建和删除文件和目录

要在文件系统中创建文件或目录，请先使用*文件管理*部分中列出的构造函数之一来构建一个新的`File`对象。 例如，假设文件名为`FileName.txt`，可以创建`File`对象作为`new File("FileName.txt")`。 如果必须在目录中创建文件，则必须在文件名的前面添加路径（当它传递到构造函数时）或必须使用其他三个构造函数中的一个。 例如：

```
String path = "demo1" + File.separator + "demo2" + File.separator;
String fileName = "FileName.txt";
File f = new File(path + fileName);

```

注意`File.separator`的用途而不是斜杠符号（`/`）或（`\`）。 这是因为`File.separator`返回特定于平台的斜杠符号。 这里是另一个`File`构造函数的例子：

```
String path = "demo1" + File.separator + "demo2" + File.separator;
String fileName = "FileName.txt";
File f = new File(path, fileName);
```

另一个构造函数可以如下用：

```
String path = "demo1" + File.separator + "demo2" + File.separator;
String fileName = "FileName.txt";
File f = new File(new File(path), fileName);
```

但是，如果您喜欢或必须使用**通用资源标识符**（ **URI** ），则可以构建如下所示的`File`对象：

```
String path = "demo1" + File.separator + "demo2" + File.separator;
String fileName = "FileName.txt";
URI uri = new File(path + fileName).toURI();
File f = new File(uri);
```

然后，必须在新创建的`File`对象上调用以下方法之一：

*   `boolean createNewFile()`：如果尚不存在此名称的文件，则会创建一个新文件并返回`true`; 否则，返回`false`

*   `static File createTempFile(String prefix, String suffix)`：在临时文件目录中创建文件
*   `static File createTempFile(String prefix, String suffix, File directory)`：创建目录; 提供的前缀和后缀用于生成目录名称

如果要创建的文件必须放在尚未存在的目录中，则首先将首先使用以下方法之一，在`File`对象上表示文件系统的文件系统路径：

*   `boolean mkdir()`：使用提供的名称创建目录
*   `boolean mkdirs()`：使用提供的名称创建目录，包括任何必需但不存在的父目录

并且，在我们查看代码示例之前，我们需要解释`delete()`方法如何工作：

*   `boolean delete()`：删除文件或空目录，这意味着您可以删除文件但不是所有目录，如下所示：

```
String path = "demo1" + File.separator + "demo2" + File.separator;
String fileName = "FileName.txt";
File f = new File(path + fileName);
f.delete();
```

让我们来看看如何在以下示例中克服这个限制：

```
String path = "demo1" + File.separator + "demo2" + File.separator;
String fileName = "FileName.txt";
File f = new File(path + fileName);
try {
    new File(path).mkdirs();
    f.createNewFile();
    f.delete();
    path = StringUtils.substringBeforeLast(path, File.separator);
    while (new File(path).delete()) {
        path = StringUtils.substringBeforeLast(path, File.separator);
    }
} catch (Exception e) {
    e.printStackTrace();
}
```

此示例创建并删除文件和所有相关目录。 请注意我们对`org.apache.commons.lang3.StringUtils`类的用法，我们在*字符串实用程序*部分中讨论。 它允许我们从刚刚删除的目录中删除，然后继续执行此操作，直到删除所有嵌套目录，并删除顶级目录。

# 列出文件和目录

以下方法可用于列出目录和文件中的文件：

*   `String[] list()`：返回目录中的文件和目录的名称
*   `File[] listFiles()`：返回表示目录中文件和目录的`File`对象
*   `static File[] listRoots()`：列出可用文件系统根源

为了演示前面的方法，假设我们已经创建了目录和两个文件，如下所示：

```
String path1 = "demo1" + File.separator;
String path2 = "demo2" + File.separator;
String path = path1 + path2;
File f1 = new File(path + "file1.txt");
File f2 = new File(path + "file2.txt");
File dir1 = new File(path1);
File dir = new File(path);
dir.mkdirs();
f1.createNewFile();
f2.createNewFile();

```

之后，我们应该能够运行以下代码：

```
System.out.print("\ndir1.list(): ");
for(String d: dir1.list()){
    System.out.print(d + " ");
}
System.out.print("\ndir1.listFiles(): ");
for(File f: dir1.listFiles()){
    System.out.print(f + " ");
}
System.out.print("\ndir.list(): ");
for(String d: dir.list()){
    System.out.print(d + " ");
}
System.out.print("\ndir.listFiles(): ");
for(File f: dir.listFiles()){
    System.out.print(f + " ");
}
System.out.print("\nFile.listRoots(): ");
for(File f: File.listRoots()){
    System.out.print(f + " ");
}
```

结果应如下：

![](img/06931621-3ea8-4cb0-bdd3-99984f878bd8.png)

通过向它们添加以下过滤器可以增强展示的方法，因此它们只能列出与过滤器匹配的文件和目录：

*   `String[] list(FilenameFilter filter)`
*   `File[] listFiles(FileFilter filter)`
*   `File[] listFiles(FilenameFilter filter)`

但是，对文件过滤器的讨论超出了本书的范围。

# Apache Commons Utilities fileutils 和 ioutils

JCL 的流行伴侣是 Apache Commons 项目（ [https://commons.apache.org](https://commons.apache.org) ），提供了许多赞美 JCL 功能的库。 `org.apache.commons.io`包的类包含在以下根包和子包中：

*   `org.apache.commons.io`根包包含具有静态方法的实用程序类，即分别在 *fileutils* 和 *ioutils* 中描述的流行`FileUtils`和`IOUtils`类，如*类 *Ioutils* 。*
*   `org.apache.commons.io.input`包包含基于`InputStream`和`Reader`实现的输入的类，如`XmlStreamReader`或`ReversedLinesFileReader`

*   `org.apache.commons.io.output`包包含基于`OutputStream`和`Writer`实现的输出的类，如`XmlStreamWriter`或`StringBuilderWriter`
*   `org.apache.commons.io.filefilter`包包含作为文件过滤器的类，如`DirectoryFileFilter`或`RegexFileFilter`
*   `org.apache.commons.io.comparator`包包含文件的各种实现，如`NameFileComparator`
*   `org.apache.commons.io.serialization`包提供了一种用于控制类的反序列化的框架
*   `org.apache.commons.io.monitor`包允许监视文件系统和检查目录或文件创建，更新或删除; 一个人可以作为线程启动`FileAlterationMonitor`对象，并在指定的时间间隔内创建`FileAlterationObserver`的对象，该对象执行文件系统中的文件中的更改

有关更多详细信息，请参阅 Apache Commons 项目文档（ [https://commons.apache.org](https://commons.apache.org) ）。

# 类文件级别

一个流行的`org.apache.commons.io.FileUtils`类允许做一个与文件的所有可能的操作都需要如下所需的：

*   写成文件
*   读取文件
*   制作包括父目录的目录
*   复制文件和目录
*   删除文件和目录
*   转换为 URL
*   按过滤器和扩展名单文件和目录
*   比较文件内容
*   获取文件最后更改的日期
*   计算校验和

如果您计划以编程方式管理文件和目录，则必须在 Apache Commons 项目网站（ [https://commons.apache.org/proper/commons-io/javadocs/api 上研究此类课程的文档 -2.5 / org / apache / commons / io / fileutils.html](https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/FileUtils.html) ）。

# 班级 Ioutils.

`org.apache.commons.io.IOUtils`是另一个非常有用的实用程序类，提供以下通用 IO 流操作方法：

*   关闭流的`closeQuietly`方法忽略 nulls 和异常
*   `toXxx/read`从流中读取数据的方法
*   `write`将数据写入流的方法
*   `copy`方法将所有数据从一个流复制到另一个流
*   `contentEquals`方法，用于比较两个流的内容的方法

在内部读取流的本类中的所有方法都会缓冲，因此无需使用`BufferedInputStream`或`BufferedReader`类。 `copy`方法所有在现场后面的方法都使用`copyLarge`方法，这显着提高了它们的性能和效率。

此类对于管理 IO 流是必不可少的。 查看有关此类的更多详细信息及其在 Apache Commons 项目网站上的方法（ [https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/ioutils .html](https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/IOUtils.html) ）。

# 概括

在本章中，我们讨论了允许分析字符串，比较和转换它们的`String`类方法。 我们还讨论了 JCL 和 Apache Commons 项目的流行字符串实用程序。 本章的两个大部分专用于 JCL 和 Apache Commons 项目中的输入/输出流和支持类。 还在特定代码示例中讨论并展示了文件管理类及其方法。

在下一章中，我们将介绍 Java Collections 框架及其三个主要接口`List`，`Set`和`Map`，包括泛型的讨论和演示。 我们还将讨论用于管理数组，对象和时间/日期值的实用程序类。

# 测验

1.  以下代码打印是什么？

```
String str = "&8a!L";
System.out.println(str.indexOf("a!L"));
```

2.  以下代码打印是什么？

```
String s1 = "x12";
String s2 = new String("x12");
System.out.println(s1.equals(s2)); 
```

3.  以下代码打印是什么？

```
System.out.println("%wx6".substring(2));

```

4.  以下代码打印是什么？

```
System.out.println("ab"+"42".repeat(2));
```

5.  以下代码打印是什么？

```
String s = "  ";
System.out.println(s.isBlank()+" "+s.isEmpty());

```

6.  选择所有正确的语句：

    1.  流可以表示数据源
    2.  输入流可以写入文件
    3.  流可以表示数据目的地
    4.  输出流可以在屏幕上显示数据
7.  选择关于`java.io`包类的所有正确语句：
    1.  读者延伸`InputStream`
    2.  读者延伸`OutputStream`
    3.  读者延伸`java.lang.Object`
    4.  读者延伸`java.lang.Input`
8.  选择关于`java.io`包类的所有正确语句：
    1.  作者延伸`FilterOutputStream`
    2.  作者延伸`OutputStream`
    3.  作者延伸`java.lang.Output`
    4.  作者延伸`java.lang.Object`
9.  选择关于`java.io`包类的所有正确语句：
    1.  `PrintStream`延伸`FilterOutputStream`
    2.  `PrintStream`延伸`OutputStream`
    3.  `PrintStream`延伸`java.lang.Object`
    4.  `PrintStream`延伸`java.lang.Output`

10.  以下代码是什么？

```
String path = "demo1" + File.separator + "demo2" + File.separator;
String fileName = "FileName.txt";
File f = new File(path, fileName);
try {
    new File(path).mkdir();
    f.createNewFile();
} catch (Exception e) {
    e.printStackTrace();
} 
```*