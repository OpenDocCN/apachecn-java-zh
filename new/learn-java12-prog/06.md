# 数据结构，泛型和流行公用事业

本章介绍了 Java 集合框架及其三个主要接口：`List`，`Set`和`Map`，包括泛型的讨论和演示。 在 Java 集合的上下文中也讨论了`equals()`和`hashCode()`方法。 实用程序用于管理数组，对象和时间/日期值的实用类也具有相应的专用部分。

本章将介绍以下主题：

*   `List`，`Set`和`Map`接口
*   汇集公用事业
*   阵列公用事业
*   对象实用程序
*   `java.time`包

# 列表，设置和映射接口

**Java Collections Framework** 包括实现集合数据结构的类和接口。 集合与阵列类似于这尊重，因为它们可以持有对象的引用，并且可以作为一个组管理。 不同之处在于，阵列需要在使用之前定义其容量，而收集可以根据需要自动增加和减少其尺寸。 一个只需添加或删除对象引用的一个集合，并且集合相应地更改其大小。 另一个不同之处在于，集合不能使其元素成为原始类型，例如`short`，`int`或`double`。 如果您需要存储这样的类型值，则元素必须是相应的包装器类型，例如`Short`，`Integer`或`Double`。

Java CollectionS 支持存储和访问集合元素的各种算法：订购列表，唯一集，Java 中的**映射**的字典，a **堆栈**，a **队列**，还有一些人。 Java Collections 框架的所有类和接口都属于 Java 类库的`java.util`包。 `java.util`包包含以下内容：

*   扩展`Collection`界面的接口：`List`，`Set`，`Queue`为最流行的
*   实现先前列出的接口的类：`ArrayList`，`HashSet`，`Stack`，`LinkedList`，以及其他一些
*   `Map`界面及其子接口：`ConcurrentMap`，`SortedMap`，一个夫妇
*   实现`Map` - 相关接口的类：`HashMap`，`HashTable`，`TreeMap`，命名为最常用的三个

要查看`java.util`包的所有类和接口都需要专用的书籍。 因此，在本节中，我们将简要概述三个主要接口：`List`，`Set`和`Map` - 每个它们的一个实现类 - `ArrayList`，`HashSet`，和 `HashMap`。 我们从`List`和`Set`接口共享的方法开始。 `List`和`Set`之间的主要差异是`Set`不允许重复元素。 另一个区别在于`List`保留元素的顺序，并且还允许它们进行分类。

要识别集合中的元素，使用`equals()`方法。 为了提高性能，实现`Set`界面的类也经常使用`hashCode()`方法。 它允许快速计算整数（称为**散列值**或**散列码**），这是每个元素唯一的大多数时间（但不总是）。 具有相同哈希值的元素位于相同的*桶*中。 虽然建立在集合中已经存在某个值，但它足以检查内部哈希表并查看是否已使用此类值。 如果没有，新元素是唯一的。 如果是，则可以将新元素进行比较（使用`equals()`方法）与具有相同哈希值的每个元素。 这样的过程比将新元素与设置的每个元素进行比较较快。

这就是为什么我们经常看到类的名称具有“哈希”前缀，指示类使用哈希值，因此元素必须实现`hashCode()`方法。 在这样做的同时，您必须确保实现它，以便每次`equals()`方法返回两个对象的`true`，`hashCode()`方法返回的这两个对象的散列值也相等。 否则，刚刚使用哈希值的所有刚才描述的算法都不是工作。

最后，在谈论`java.util`接口之前，关于泛型的几句话。

# 仿制

您可以在此类声明中最常看到它们：

```
List<String> list = new ArrayList<String>();
Set<Integer> set = new HashSet<Integer>();
```

在前面的示例中，**泛型**是由角括号包围的元素类型声明。 如您所见，它们是冗余的，因为它们在分配声明的左侧和右侧重复。 这就是为什么 Java 允许用空括号（`<>`）替换右侧的仿制机（`<>`钻石：

```
List<String> list = new ArrayList<>();
Set<Integer> set = new HashSet<>();
```

泛型通知编译器关于集合元素的预期类型。 这样，编译器可以检查程序员是否尝试添加到声明的集合的元素是兼容类型。 例如：

```
List<String> list = new ArrayList<>();
list.add("abc");
list.add(42);   //compilation error

```

它有助于避免运行时错误。 它还关闭程序员（因为 IDE 在程序员写入时编译代码）关于集合元素的可能操纵。

我们还将看到其他类型的仿制机：

*   `<? extends T>`表示`T` *或* `T`的孩子，其中`T`是用作集合的泛型的类型
*   `<? super T>`表示`T` `T` *或其任何基础（父）类*，其中`T`是用作集合的泛型的类型

因此，让我们从可以创建实现`List`或`Set`接口的类的对象的方式开始，或者，换句话说，可以初始化变量的`List`或`Set`类型。 为了演示这两个接口的方法，我们将使用两类：`ArrayList`（实现`List`）和`HashSet`（实现`Set`）。

# 如何初始化列表和设置

由于 Java 9，`List`或`Set`接口具有静态工厂方法`of()`，可用于初始化集合：

*   `of()`：返回空集合。
*   `of(E... e)`：返回一个包含在呼叫期间传递的元素的集合。 它们可以通过逗号分隔的列表或作为数组传递。

这里有一些例子：

```
//Collection<String> coll = List.of("s1", null); //does not allow null
Collection<String> coll = List.of("s1", "s1", "s2");
//coll.add("s3");                        //does not allow add element
//coll.remove("s1");                     //does not allow remove element
((List<String>) coll).set(1, "s3");      //does not allow modify element
System.out.println(coll);                //prints: [s1, s1, s2]

//coll = Set.of("s3", "s3", "s4");       //does not allow duplicate
//coll = Set.of("s2", "s3", null);       //does not allow null
coll = Set.of("s3", "s4");
System.out.println(coll);                //prints: [s3, s4]

//coll.add("s5");                        //does not allow add element
//coll.remove("s2");                     //does not allow remove

```

可以预期的是，`Set`的工厂方法不允许重复，因此我们已评论出线路（否则，前面的示例将停止在该行处运行）。 什么是较少的预期是，一个人不能拥有`null`元素，并且在使用`of()`方法之一初始化之后，一个人无法添加/删除/修改元素。 这就是为什么我们评论了前面的例子的一些行。 如果初始化集合后需要添加元素，则必须使用构造函数或创建可修改集合的其他实用程序初始化它（我们很快就会看到`Arrays.asList()`的示例）。

接口`Collection`提供了两种方法，用于将元素添加到实现`Collection`的对象（`List`（`List`和`Set`的父界面），这些对象如下所示：

*   `boolean add(E e)`：尝试将提供的元素`e`添加到集合; 在成功的情况下返回`true`，并且在无法完成它的情况下（例如，当`Set`中已经存在这样的元素）

*   `boolean addAll(Collection<? extends E> c)`：尝试将提供的集合中的所有元素添加到集合; 返回`true`如果添加至少一个元素并且在无法将元素添加到集合的情况下（例如，当提供的集合`c`的所有元素已经存在`Set`时）

以下是使用`add()`方法的示例：

```
List<String> list1 = new ArrayList<>();
list1.add("s1");
list1.add("s1");
System.out.println(list1);     //prints: [s1, s1]

Set<String> set1 = new HashSet<>();
set1.add("s1");
set1.add("s1");
System.out.println(set1);      //prints: [s1]

```

这里是使用`addAll()`方法的示例：

```
List<String> list1 = new ArrayList<>();
list1.add("s1");
list1.add("s1");
System.out.println(list1);      //prints: [s1, s1]

List<String> list2 = new ArrayList<>();
list2.addAll(list1);
System.out.println(list2);      //prints: [s1, s1]

Set<String> set = new HashSet<>();
set.addAll(list1);
System.out.println(set);        //prints: [s1]

```

以下是`add()`和`addAll()`方法功能的示例：

```
List<String> list1 = new ArrayList<>();
list1.add("s1");
list1.add("s1");
System.out.println(list1);     //prints: [s1, s1]

List<String> list2 = new ArrayList<>();
list2.addAll(list1);
System.out.println(list2);      //prints: [s1, s1]

Set<String> set = new HashSet<>();
set.addAll(list1);
System.out.println(set);      //prints: [s1]

Set<String> set1 = new HashSet<>();
set1.add("s1");

Set<String> set2 = new HashSet<>();
set2.add("s1");
set2.add("s2");

System.out.println(set1.addAll(set2)); //prints: true
System.out.println(set1);              //prints: [s1, s2]

```

注意，在上述代码片段的最后一个示例中，`set1.addAll(set2)`方法返回`true`，虽然并非添加所有元素。 要查看`add()`和`addAll()`方法返回`false`的情况，请查看以下示例：

```
Set<String> set = new HashSet<>();
System.out.println(set.add("s1"));   //prints: true
System.out.println(set.add("s1"));   //prints: false
System.out.println(set);             //prints: [s1]

Set<String> set1 = new HashSet<>();
set1.add("s1");
set1.add("s2");

Set<String> set2 = new HashSet<>();
set2.add("s1");
set2.add("s2");

System.out.println(set1.addAll(set2)); //prints: false
System.out.println(set1);              //prints: [s1, s2]

```

`ArrayList`和`HashSet`类也有接受集合的构造函数：

```
Collection<String> list1 = List.of("s1", "s1", "s2");
System.out.println(list1);      //prints: [s1, s1, s2]

List<String> list2 = new ArrayList<>(list1);
System.out.println(list2);      //prints: [s1, s1, s2]

Set<String> set = new HashSet<>(list1);
System.out.println(set);        //prints: [s1, s2]

List<String> list3 = new ArrayList<>(set);
System.out.println(list3);      //prints: [s1, s2]
```

现在，在我们学习了如何初始化集合时，我们可以转向接口`List`和`Set`中的其他方法。

# 接口 java.lang.torable.

`Collection`接口扩展了`java.lang.Iterable`接口，这意味着直接与否实现`Collection`接口的类也实现了`java.lang.Iterable`接口。 `Iterable`界面中只有三种方法：

*   `Iterator<T> iterator()`：返回实现接口`java.util.Iterator`的类的对象; 它允许集合用于`FOR`语句，例如：

```
Iterable<String> list = List.of("s1", "s2", "s3");
System.out.println(list);       //prints: [s1, s2, s3]

for(String e: list){
    System.out.print(e + " ");  //prints: s1 s2 s3
}
```

*   `default void forEach (Consumer<? super T> function)`：将`Consumer`类型的提供功能应用于集合的每个元素，直到已处理所有元素或函数抛出异常。 什么功能是，我们将在[第 13 章](13.html)，*功能规划中讨论;* 现在，我们将提供一个例子：

```
Iterable<String> list = List.of("s1", "s2", "s3");
System.out.println(list);                     //prints: [s1, s2, s3]
list.forEach(e -> System.out.print(e + " ")); //prints: s1 s2 s3
```

*   `default Spliterator<T> splititerator()`：返回一个实现`java.util.Spliterator`界面的类的对象; 它主要用于实现允许并行处理并超出本书范围的方法。

# 接口集合

正如我们已经提到的那样，`List`和`Set`接口扩展了`Collection`界面，这意味着`Collection`接口的所有方法由`List`和`Set`继承。 这些方法如下：

*   `boolean add(E e)`：尝试将元素添加到集合
*   `boolean addAll(Collection<? extends E> c)`：尝试在提供的集合中添加所有元素
*   `boolean equals(Object o)`：将集合与提供的对象`o`进行比较; 如果提供的对象不是集合，则此对象返回`false`; 否则，它将收集的组成与所提供的收集的组成进行比较（作为对象`o`）; 在`List`的情况下，它也比较元素的顺序; 让我们用一些例子说明：

```
Collection<String> list1 = List.of("s1", "s2", "s3");
System.out.println(list1);       //prints: [s1, s2, s3]

Collection<String> list2 = List.of("s1", "s2", "s3");
System.out.println(list2);       //prints: [s1, s2, s3]

System.out.println(list1.equals(list2));  //prints: true

Collection<String> list3 = List.of("s2", "s1", "s3");
System.out.println(list3);       //prints: [s2, s1, s3]

System.out.println(list1.equals(list3));  //prints: false

Collection<String> set1 = Set.of("s1", "s2", "s3");
System.out.println(set1);   //prints: [s2, s3, s1] or different order

Collection<String> set2 = Set.of("s2", "s1", "s3");
System.out.println(set2);   //prints: [s2, s1, s3] or different order

System.out.println(set1.equals(set2));  //prints: true

Collection<String> set3 = Set.of("s4", "s1", "s3");
System.out.println(set3);   //prints: [s4, s1, s3] or different order

System.out.println(set1.equals(set3));  //prints: false

```

*   `int hashCode()`：返回集合的哈希值; 在该系列是需要`hashCode()`方法实现的集合的元素时使用
*   `boolean isEmpty()`：返回`true`如果集合没有任何元素
*   `int size()`：返回集合元素的计数; 当`isEmpty()`方法返回`true`时，此方法返回`0`
*   ` void clear()`：从收集中删除所有元素; 调用此方法后，`isEmpty()`方法返回`true`，`size()`方法返回`0`
*   `boolean contains(Object o)`：返回`true`如果集合包含提供的对象`o`; 对于正确的工作方法，集合的每个元素和所提供的对象必须实现`equals()`方法，并且在`Set`的情况下，应该实现`hashCode()`方法
*   `boolean containsAll(Collection<?> c)`：返回`true`如果集合包含提供的集合中的所有元素; 对于该方法来正常工作，集合的每个元素和所提供的集合的每个元素必须实现`equals()`方法，并且在`Set`的情况下，应该实现`hashCode()`方法
*   `boolean remove(Object o)`：尝试从此集合中删除指定的元素，如果存在，则返回`true`; 对于这种方法来正常工作，集合的每个元素和所提供的对象必须实现方法`equals()`，并且在`Set`的情况下，应该实现`hashCode()`方法
*   `boolean removeAll(Collection<?> c)`：尝试从集合中删除所提供的集合的所有元素; 与`addAll()`方法类似，如果删除了至少一个元素，则此方法返回`true`; 否则，它返回`false`; 对于该方法来正常工作，集合的每个元素和所提供的集合的每个元素必须实现`equals()`方法，并且在`Set`的情况下，应该实现`hashCode()`方法
*   `default boolean removeIf(Predicate<? super E> filter)`：尝试从集合中删除所有满足给定谓词的元素; 我们将在[第 13 章](13.html)，*功能编程*中描述的功能; 返回`true`如果删除至少一个元素

*   `boolean retainAll(Collection<?> c)`：尝试保留收集中所包含的元素; 与`addAll()`方法类似，如果保留至少一个元素，则此方法返回`true`; 否则，它返回`false`; 对于该方法来正常工作，集合的每个元素和所提供的集合的每个元素必须实现`equals()`方法，并且在`Set`的情况下，应该实现`hashCode()`方法
*   `Object[] toArray()`，`T[] toArray(T[] a)`：将集合转换为数组
*   `default T[] toArray(IntFunction<T[]> generator)`：使用提供的功能将集合转换为数组; 我们将在[第 13 章](13.html)，*功能编程*中解释功能
*   `default Stream<E> stream()`：返回`Stream`对象（我们在[中谈论 streams 第 14 章](14.html)， *java 标准流*）
*   `default Stream<E> parallelStream()`：返回可能并行`Stream`对象（我们谈论 [](14.html)[](14.html)， *Java 标准流*）中的 Streams。

# 接口列表

`List` interface 具有几种不属于其父接口的其他方法：

*   *中描述的静态工厂`of()`方法如何初始化列表并设置*小节
*   `void add(int index, E element)`：将提供的元素插入列表中的提供位置
*   `static List<E> copyOf(Collection<E> coll)`：返回包含给定`Collection`的元素的未经修复`List`并保留其订单; 以下是演示此方法功能的代码：

```
Collection<String> list = List.of("s1", "s2", "s3");
System.out.println(list);         //prints: [s1, s2, s3]

List<String> list1 = List.copyOf(list);
//list1.add("s4");                //run-time error
//list1.set(1, "s5");             //run-time error
//list1.remove("s1");             //run-time error

Set<String> set = new HashSet<>();
System.out.println(set.add("s1"));
System.out.println(set);          //prints: [s1]

Set<String> set1 = Set.copyOf(set);
//set1.add("s2");                 //run-time error
//set1.remove("s1");              //run-time error

Set<String> set2 = Set.copyOf(list);
System.out.println(set2);         //prints: [s1, s2, s3] 

```

*   `E get(int index)`：返回位于列表中指定位置的元素
*   `List<E> subList(int fromIndex, int toIndex)`：提取`fromIndex`之间的子夹，包容性和`toIndex`，独家
*   `int indexOf(Object o)`：返回列表中指定元素的第一个索引（位置）; 列表中的第一个元素具有索引（位置）`0`
*   `int lastIndexOf(Object o)`：返回列表中指定元素的最后索引（位置）; 列表中的最后一个元素具有等于`list.size() - 1`的索引（位置）
*   `E remove(int index)`：删除位于列表中指定位置的元素; 返回删除的元素
*   `E set(int index, E element)`：替换位于列表中指定位置的元素; 返回替换元素
*   `default void replaceAll(UnaryOperator<E> operator)`：将提供的函数应用于每个元素来转换列表; `UnaryOperator`功能将在 [第 13 章](13.html)，*功能编程*中描述
*   `ListIterator<E> listIterator()`：返回一个`ListIterator`对象，允许向后遍历列表
*   `ListIterator<E> listIterator(int index)`：返回一个`ListIterator`对象，该对象允许横向遍历子钻（从提供的位置开始）; 例如：

```
List<String> list = List.of("s1", "s2", "s3");
ListIterator<String> li = list.listIterator();
while(li.hasNext()){
    System.out.print(li.next() + " ");         //prints: s1 s2 s3
}
while(li.hasPrevious()){
    System.out.print(li.previous() + " ");     //prints: s3 s2 s1
}
ListIterator<String> li1 = list.listIterator(1);
while(li1.hasNext()){
    System.out.print(li1.next() + " ");        //prints: s2 s3
}
ListIterator<String> li2 = list.listIterator(1);
while(li2.hasPrevious()){
    System.out.print(li2.previous() + " ");    //prints: s1
}

```

*   `default void sort(Comparator<? super E> c)`：根据提供的`Comparator`生成的顺序对列表进行排序; 例如：

```
List<String> list = new ArrayList<>();
list.add("S2");
list.add("s3");
list.add("s1");
System.out.println(list);                //prints: [S2, s3, s1]

list.sort(String.CASE_INSENSITIVE_ORDER);
System.out.println(list);                //prints: [s1, S2, s3]

//list.add(null);                 //causes NullPointerException
list.sort(Comparator.naturalOrder());
System.out.println(list);               //prints: [S2, s1, s3]

list.sort(Comparator.reverseOrder());
System.out.println(list);               //prints: [s3, s1, S2]

list.add(null);
list.sort(Comparator.nullsFirst(Comparator.naturalOrder()));
System.out.println(list);              //prints: [null, S2, s1, s3]

list.sort(Comparator.nullsLast(Comparator.naturalOrder()));
System.out.println(list);              //prints: [S2, s1, s3, null]

Comparator<String> comparator = (s1, s2) -> 
 s1 == null ? -1 : s1.compareTo(s2);
list.sort(comparator);
System.out.println(list);              //prints: [null, S2, s1, s3]

```

原则上有两种方式来排序列表：

*   使用`Comparable`界面实现（称为**自然顺序**）
*   使用`Comparator`接口实现

`Comparable`接口仅具有`compareTo()`方法。 在前面的示例中，我们已经实现了`Comparator`界面在`String`类中的`Comparable`接口实现上。 如您所见，此实现提供了与`Comparator.nullsFirst(Comparator.naturalOrder())`相同的排序顺序。 这种实现风格称为**功能编程** *，*，我们将在[第 13 章](13.html)，*功能规划中更详细地讨论。*

# 界面集

`Set` interface 具有以下不属于其父界面中的以下方法：

*   静态`of()`出厂方法*中描述了如何初始化列表并设置*小节
*   `static Set<E> copyOf(Collection<E> coll)`方法：返回包含给定`Collection`的元素的未经修复的`Set`; 它与*接口列表*部分中描述的`static <E> List<E> copyOf(Collection<E> coll)`方法相同的方式工作

# 接口地图

`Map`接口具有与`List`和`Set`的方法类似的方法：

*   `int size()`
*   `void clear()`
*   `int hashCode()`
*   `boolean isEmpty()`
*   `boolean equals(Object o)`
*   `default void forEach(BiConsumer<K,V> action)`
*   静态工厂方法：`of()`，`of(K k, V v)`，`of(K k1, V v1, K k2, V v2)`和许多其他方法

但是，`Map`接口不会扩展`Iterable`，`Collection`或任何其他接口。 它旨在通过它们的**键** *来存储**值**。* 每个密钥是唯一的，而几个等值可以在同一地图中使用不同的键存储。 键和值的组合构成了`Entry`，其是`Map`的内部接口。 值和关键对象都必须实现`equals()`方法。 关键对象还必须实现`hashCode()`方法。

`Map`接口的许多方法具有与接口`List`和`Set`中相同的签名和功能，因此我们不会在此处重复它们。 我们只会走过`Map`的方法：

*   `V get(Object key)`：通过提供的键检索值; 返回`null`如果没有这样的键
*   `Set<K> keySet()`：从地图中检索所有键
*   `Collection<V> values()`：从地图中检索所有值
*   `boolean containsKey(Object key)`：返回`true`如果在地图中存在提供的密钥
*   `boolean containsValue(Object value)`：如果在地图中存在提供的值，则返回`true`
*   `V put(K key, V value)`：将值及其密钥添加到地图; 返回使用相同键存储的先前值
*   `void putAll(Map<K,V> m)`：从提供的地图中拷贝所有键值对
*   `default V putIfAbsent(K key, V value)`：如果地图尚未使用此类密钥，将提供的值存储到提供的键; 返回映射到提供的键的值 - 现有或新的值
*   `V remove(Object key)`：从地图中删除键和值; 返回值或`null`如果没有这样的键或值是`null`
*   `default boolean remove(Object key, Object value)`：如果在地图中存在这样的一对，则从地图中删除键值对
*   `default V replace(K key, V value)`：如果当前映射到提供的值，则替换值。 如果被替换，则返回旧值; 否则，返回`null`
*   `default boolean replace(K key, V oldValue, V newValue)`：如果当前映射到`oldValue`，则替换为提供的`newValue`的值`newValue`; 返回`true`如果被替换`oldValue`; 否则，返回`false`
*   `default void replaceAll(BiFunction<K,V,V> function)`：将提供的函数应用于地图中的每个键值对，并将其替换为结果，或者如果不可能抛出异常
*   `Set<Map.Entry<K,V>> entrySet()`：将一组所有键值对作为`Map.Entry`的对象返回
*   `default V getOrDefault(Object key, V defaultValue)`：如果地图没有提供的键，则返回映射到提供的键或`defaultValue`的值

*   `static Map.Entry<K,V> entry(K key, V value)`：用提供的`key`和`value`返回一个未经修复的`Map.Entry`对象
*   `static Map<K,V> copy(Map<K,V> map):`将提供的`Map`转换为一个不可修改的一个

以下`Map`方法对于本书的范围太复杂，因此我们只是提及它们以获得完整性。 它们允许组合或计算多个值并在`Map`中的单个现有值中聚合它们，或创建新的值：

*   `default V merge(K key, V value, BiFunction<V,V,V> remappingFunction)`：如果提供的键值对存在，并且该值不是`null`，则提供的函数用于计算新值; 如果新计算的值为`null`，则删除键值对; 如果提供的键值对不存在或值为`null`，则提供的非空值取代了当前的非空值; 该方法可用于聚合若干值; 例如，它可以用于连接字符串值：`map.merge(key, value, String::concat)`; 我们将解释[第 13 章](13.html)，*功能编程*中的`String::concat`手段
*   `default V compute(K key, BiFunction<K,V,V> remappingFunction)`：使用提供的功能计算新值
*   `default V computeIfAbsent(K key, Function<K,V> mappingFunction)`：仅当提供的键尚未与值相关联时，才计算使用提供的功能计算新值，或者值为`null`
*   `default V computeIfPresent(K key, BiFunction<K,V,V> remappingFunction)`：仅当提供的键已经与值相关联时，才使用提供的函数计算新值，并且该值不是`null`

最后一组*计算*和*合并合并*方法。 最普遍的是`V put(K key, V value)`和`V get(Object key)`方法，它允许使用 Main `Map`功能存储键值对并使用键检索该值。 `Set<K> keySet()`方法通常用于迭代地图的键值对，尽管`entrySet()`方法似乎是更自然的方式。 这是一个例子：

```
Map<Integer, String> map = Map.of(1, "s1", 2, "s2", 3, "s3");

for(Integer key: map.keySet()){
    System.out.print(key + ", " + map.get(key) + ", ");  
                                   //prints: 3, s3, 2, s2, 1, s1,
}
for(Map.Entry e: map.entrySet()){
    System.out.print(e.getKey() + ", " + e.getValue() + ", "); 
                                   //prints: 2, s2, 3, s3, 1, s1,
}
```

前面代码示例中的`for`循环中的第一个使用更广泛的方式来通过迭代键来访问地图的键对值。 第二个`for`循环迭代这组条目，我们认为是一种更自然的方式。 请注意，打印的值与我们在地图中放置的顺序不相同。 也就是说，由于 Java 9，未经修复的集合（即`of()`工厂方法产生）已添加`Set`元素的顺序随机化。 它更改了不同代码执行之间的元素的顺序。 这样的设计是为了确保程序员不依赖于`Set`元素的一定顺序，这是不保证的。

# 未经修复的收藏品

请注意，从 Java 9 中的`of()`工厂方法产生的收集是由 Java 9 中的**不可变**，并且由于 Java 10.这是因为不可变化意味着一个无法改变任何内容 它们，虽然实际上，如果它们是可修改的对象，则可以更改收集元素。 例如，让我们构建`Person1`类的对象的集合，这些对象看起来如下所示：

```
class Person1 {
    private int age;
    private String name;
    public Person1(int age, String name) {
        this.age = age;
        this.name = name == null ? "" : name;
    }
    public void setName(String name){ this.name = name; }
    @Override
    public String toString() {
        return "Person{age=" + age +
                ", name=" + name + "}";
    }
}
```

为简单起见，我们将仅创建一个包含一个元素的列表，然后尝试修改元素：

```
Person1 p1 = new Person1(45, "Bill");
List<Person1> list = List.of(p1);
//list.add(new Person1(22, "Bob")); //UnsupportedOperationException
System.out.println(list);        //prints: [Person{age=45, name=Bill}]
p1.setName("Kelly");       
System.out.println(list);        //prints: [Person{age=45, name=Kelly}]

```

如您所见，虽然无法将元素添加到由`of()`出厂方法创建的列表中，但如果在列表之外存在对元素的引用，则仍可修改其元素。

# 汇集公用事业

有两种课程，静态方法处理非常受欢迎和有用的集合：

*   `java.util.Collections`
*   `org.apache.commons.collections4.CollectionUtils`

该方法是静态意味着它们不依赖于对象状态，因此它们也称为**无状态方法**或**实用程序方法**。

# class java.util.collections.

`Collections`类中有许多方法，用于管理集合，分析，排序和比较它们。 其中 70 多个，所以我们没有机会谈论所有这些。 相反，我们将期待主流应用开发人员最常使用的：

*   `static copy(List<T> dest, List<T> src)`：将`src`列表的元素复制到`dest`列表，并保留在列表中的元素顺序及其位置; 目的地`dest`列表大小必须相等或大于`src`列表大小，否则会提出运行时异常; 以下是此方法使用的示例：

```
List<String> list1 = Arrays.asList("s1","s2");
List<String> list2 = Arrays.asList("s3", "s4", "s5");
Collections.copy(list2, list1);
System.out.println(list2);    //prints: [s1, s2, s5]

```

*   `static void sort(List<T> list)`：按照每个元素实现的`compareTo(T)`方法按顺序排序列表（称为**自然排序**）; 只接受仅列出了实现`Comparable`接口的元素（需要实现`compareTo(T)`方法）; 在下面的示例中，我们使用`List<String>`，因为类`String`实现`Comparable`：

```
//List<String> list = List.of("a", "X", "10", "20", "1", "2");
List<String> list = Arrays.asList("a", "X", "10", "20", "1", "2");
Collections.sort(list);
System.out.println(list);         //prints: [1, 10, 2, 20, X, a]

```

请注意，我们无法使用`List.of()`方法创建列表，因为列表将是一个不可修改的，并且其顺序无法更改。 另外，请查看结果顺序：数字首先是首先，然后是大写字母，然后是小写字母。 这是因为`String`类中的`compareTo()`方法使用字符的代码点来建立订单。 以下是演示它的代码：

```
List<String> list = Arrays.asList("a", "X", "10", "20", "1", "2");
Collections.sort(list);
System.out.println(list);     //prints: [1, 10, 2, 20, X, a]
list.forEach(s -> {
    for(int i = 0; i < s.length(); i++){
        System.out.print(" " + Character.codePointAt(s, i));
    }
    if(!s.equals("a")) {
        System.out.print(",");   //prints: 49, 49 48, 50, 50 48, 88, 97
    }
});

```

如您所见，订单由组成字符串的字符的代码点的值定义。

*   `static void sort(List<T> list, Comparator<T> comparator)`：根据提供的`Comparator`对象对列表的顺序进行排序列表元素是否实现`Comparable`界面; 作为示例，让我们对由`Person`类的对象组成的列表进行排序：

```
class Person  {
    private int age;
    private String name;
    public Person(int age, String name) {
        this.age = age;
        this.name = name == null ? "" : name;
    }
    public int getAge() { return this.age; }
    public String getName() { return this.name; }
    @Override
    public String toString() {
        return "Person{name=" + name + ", age=" + age + "}";
    }
}
```

以下是一个`Comparator`类，用于对`Person`对象的列表进行排序：

```
class ComparePersons implements Comparator<Person> {
    public int compare(Person p1, Person p2){
        int result = p1.getName().compareTo(p2.getName());
        if (result != 0) { return result; }
        return p1.age - p2.getAge();
    }
}
```

现在我们可以使用`Person`和`ComparePersons`类如下：

```
List<Person> persons = Arrays.asList(new Person(23, "Jack"),
        new Person(30, "Bob"), new Person(15, "Bob"));
Collections.sort(persons, new ComparePersons());
System.out.println(persons);    //prints: [Person{name=Bob, age=15}, 
                                           Person{name=Bob, age=30}, 
                                           Person{name=Jack, age=23}]
```

正如我们已经提到的那样，`Collections`课程中有更多的实用程序，因此我们建议您至少观看其文档至少一次，并查看所有功能。

# Apache 项目的课程 Collectionutils

Apache Commons 项目中的`org.apache.commons.collections4.CollectionUtils`类包含静态无状态方法，该方法补充了`java.util.Collections`类的方法。 它们有助于搜索，处理和比较 Java 集合。

要使用此类，您需要将以下依赖添加到 Maven `pom.xml`配置文件：

```
 <dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-collections4</artifactId>
    <version>4.1</version>
 </dependency>
```

在此类中有许多方法，可能会随着时间的推移增加更多方法。 除了`Collections`方法之外，还创建了这些实用程序，因此它们更复杂，更细致，不适合本书的范围。 要为您提供`CollectionUtils`类中可用的方法的想法，这里有根据其功能分组的方法的简短说明：

*   从集合中检索元素的方法
*   将元素或一组元素添加到集合的方法
*   将`Iterable`元素合并到集合中的方法
*   在有或没有标准的情况下删除或保留元素的方法
*   比较两个集合的方法
*   转换集合的方法
*   从中选择和过滤集合的方法
*   生成联盟，交叉路口或两个集合差异的方法
*   创建不可变空集合的方法
*   检查收集大小和空虚的方法
*   一种反转数组的方法

最后一个方法可能属于处理阵列的实用程序类。 这就是我们现在要讨论的。

# 阵列公用事业

有两种课程，静态方法处理非常受欢迎和有用的集合：

*   `java.util.Arrays`
*   `org.apache.commons.lang3.ArrayUtils`

我们将简要审查它们中的每一个。

# class java.util.arrays.

我们已经多次使用了`java.util.Arrays`课程。 它是阵列管理的主要实用类。 由于`asList(T...a)`方法，此实用程序习惯于非常流行。 这是创建和初始化集合的最紧凑方式：

```
List<String> list = Arrays.asList("s0", "s1");
Set<String> set = new HashSet<>(Arrays.asList("s0", "s1");
```

它仍然是创建可修改列表的流行方式。 我们也用它。 但是，在介绍了`List.of()`工厂方法之后和`Arrays`级普及大幅下降。

尽管如此，如果您需要管理数组，那么`Arrays`课程可能是一个很大的帮助。 它包含超过 160 种方法。 其中大多数都以不同的参数和数组类型超载。 如果通过方法名称对它们进行分组，则将有 21 组。 如果我们通过功能进一步组合它们，只有以下 10 个组将涵盖所有`Arrays`类功能：

*   `asList()`：基于提供的阵列或逗号分隔的参数列表创建`ArrayList`对象
*   `binarySearch()`：搜索数组或仅指定的（索引范围）部分
*   `compare()`，`mismatch()`，`equals()`和`deepEquals()`：比较两个数组或其部件（通过索引的范围）
*   `copyOf()`和`copyOfRange()`：复制所有数组或仅指定的（索引范围）部分
*   `hashcode()`和`deepHashCode()`：基于提供的数组生成散列码值
*   `toString()`和`deepToString()`：创建`String`表示数组的表示
*   `fill()`，`setAll()`，`parallelPrefix()`和`parallelSetAll()`：设置数组的每个元素的设置值（固定或由提供的函数生成）或指令范围指定的那些元素
*   `sort()`和`parallelSort()`：排序数组的元素或仅部分部分（由索引范围指定）
*   `splititerator()`：返回`Splititerator`对象以进行并行处理阵列或其中一部分（由索引的范围指定）
*   `stream()`：生成一条数组元素或其中一些（由索引的范围指定）; 见[第 14 章](14.html)， *java 标准流*

所有这些方法都有用，但我们想引起您的注意`equals(a1, a2)`方法和`deepEquals(a1, a2)`。 它们对数组比较特别有帮助，因为数组对象无法实现`equals()`自定义方法，并使用`Object`类（仅比较引用）。 `equals(a1, a2)`和`deepEquals(a1, a2)`方法允许比较不仅仅是`a1`和`a2`参考，而且使用`equals()`方法并比较元件。 以下是演示这些方法如何工作的代码示例：

```
String[] arr1 = {"s1", "s2"};
String[] arr2 = {"s1", "s2"};
System.out.println(arr1.equals(arr2));             //prints: false
System.out.println(Arrays.equals(arr1, arr2));     //prints: true
System.out.println(Arrays.deepEquals(arr1, arr2)); //prints: true

String[][] arr3 = {{"s1", "s2"}};
String[][] arr4 = {{"s1", "s2"}};
System.out.println(arr3.equals(arr4));             //prints: false
System.out.println(Arrays.equals(arr3, arr4));     //prints: false
System.out.println(Arrays.deepEquals(arr3, arr4)); //prints: true

```

如您所见，`Arrays.deepEquals()`返回`true`，每当一个阵列的每个元素等于相同位置的另一个数组的元素时，每当两个相等的阵列相同时，而`Arrays.equals()`方法执行相同但是一维数组 只要。

# Apache 项目的 Class arrayutils

`org.apache.commons.lang3.ArrayUtils`类通过将新方法添加到阵列管理工具包中的新方法以及在案例中处理`null`的功能，否则，可以抛出`NullPointerException`。 要使用此类，您需要将以下依赖添加到 Maven `pom.xml`配置文件：

```
<dependency>
   <groupId>org.apache.commons</groupId>
   <artifactId>commons-lang3</artifactId>
   <version>3.8.1</version>
</dependency>
```

`ArrayUtils`类有大约 300 个超载方法，可以在以下 12 组中收集：

*   `add()`，`addAll()`和`insert()`：将元素添加到数组中
*   `clone()`：克隆阵列，类似于`Arrays`类的`copyOf()`方法和`arraycopy()`方法`java.lang.System`
*   `getLength()`：返回数组长度或`0`，当阵列本身是`null`
*   `hashCode()`：计算阵列的哈希值，包括嵌套数组
*   `contains()`，`indexOf()`和`lastIndexOf()`：搜索数组
*   `isSorted()`，`isEmpty`和`isNotEmpty()`：检查数组并处理`null`
*   `isSameLength()`和`isSameType()`：比较阵列
*   `nullToEmpty()`：将`null`数组转换为空的
*   `remove()`，`removeAll()`，`removeElement()`，`removeElements()`和`removeAllOccurances()`：删除某些或所有元素
*   `reverse()`，`shift()`，`shuffle()`，`swap()`：改变数组元素的顺序
*   `subarray()`：通过指数的范围提取数组的一部分
*   `toMap()`，`toObject()`，`toPrimitive()`，`toString()`，`toStringArray()`：将数组转换为另一种类型并处理`null`值

# 对象实用程序

本节中描述的两个实用程序是：

*   `java.util.Objects`
*   `org.apache.commons.lang3.ObjectUtils`

在课堂上创建时，它们特别有用，因此我们将主要集中在与此任务相关的方法上。

# class java.util.Objects.

`Objects`类只有 17 种方法都是静态的。 让我们在将它们应用于`Person`类时查看其中一些。 让我们假设这个类是一个集合的一个元素，这意味着它必须实现`equals()`和`hashCode()`方法：

```
class Person {
    private int age;
    private String name;
    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }
    public int getAge(){ return this.age; }
    public String getName(){ return this.name; }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null) return false;
        if(!(o instanceof Person)) return false;
        Person person = (Person)o;
        return age == person.getAge() &&
                Objects.equals(name, person.getName()); 
    }
    @Override
    public int hashCode(){
        return Objects.hash(age, name);
    }
}
```

请注意，我们不会为`null`检查属性`name`，因为当任何参数是`null`时不会破坏`Object.equals()`。 它只是比较对象的工作。 如果其中一个是`null`，它会返回`false`。 如果两者都为 null，则返回`true`。

使用`Object.equals()`是实现`equals()`方法的安全方法。 但是，如果您需要与可能为阵列的对象进行比较，则更好地使用`Objects.deepEquals()`方法，因为它不仅处理`null`作为`Object.equals()`方法，还可以比较所有数组元素的值，即使数组也是如此 是多维的：

```
String[][] x1 = {{"a","b"},{"x","y"}};
String[][] x2 = {{"a","b"},{"x","y"}};
String[][] y =  {{"a","b"},{"y","y"}};

System.out.println(Objects.equals(x1, x2));      //prints: false
System.out.println(Objects.equals(x1, y));       //prints: false
System.out.println(Objects.deepEquals(x1, x2));  //prints: true
System.out.println(Objects.deepEquals(x1, y));   //prints: false

```

`Objects.hash()`方法也掌握空值。 要记住的一个重要措施是`equals()`方法中相比的属性列表必须将传递到`Objects.hash()`的属性列表匹配为参数。 否则，两个相等的`Person`对象将具有不同的哈希值，这使得基于哈希的收集不正确。

值得注意的另一件事是还有另一个哈希相关`Objects.hashCode()`方法，该方法仅接受一个参数。 但它生成的值不等于`Objects.hash()`生成的值，只有一个参数。 例如：

```
System.out.println(Objects.hash(42) == Objects.hashCode(42));  
                                                        //prints: false
System.out.println(Objects.hash("abc") == Objects.hashCode("abc"));  
                                                        //prints: false

```

为避免这种警告，请始终使用`Objects.hash()`。

以下代码证明了另一种潜在的混淆：

```
System.out.println(Objects.hash(null));      //prints: 0
System.out.println(Objects.hashCode(null));  //prints: 0
System.out.println(Objects.hash(0));         //prints: 31
System.out.println(Objects.hashCode(0));     //prints: 0

```

如您所见，`Objects.hashCode()`方法为`null`和`0`生成相同的哈希值，这对于基于散列值的某种算法可能是有问题的。

`static <T> int compare (T a, T b, Comparator<T> c)`是另一个返回`0`的流行方法（如果参数是相等的）或否则`c.compare(a, b)`的结果。 它对于实现`Comparable`界面非常有用（为自定义对象排序建立自然顺序）。 例如：

```
class Person implements Comparable<Person> {
    private int age;
    private String name;
    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }
    public int getAge(){ return this.age; }
    public String getName(){ return this.name; }
    @Override
    public int compareTo(Person p){
        int result = Objects.compare(name, p.getName(),
                                         Comparator.naturalOrder());
        if (result != 0) { 
           return result;
        }
        return Objects.compare(age, p.getAge(),
                                          Comparator.naturalOrder());
    }
}
```

这样，您可以通过设置`Comparator.reverseOrder()`值或添加`Comparator.nullFirst()`或`Comparator.nullLast()`轻松更改排序算法。

此外，我们在上一节中使用的`Comparator`实现可以使用`Objects.compare()`来更灵活：

```
class ComparePersons implements Comparator<Person> {
    public int compare(Person p1, Person p2){
        int result = Objects.compare(p1.getName(), p2.getName(),
                                         Comparator.naturalOrder());
        if (result != 0) { 
           return result;
        }
        return Objects.compare(p1.getAge(), p2.getAge(),
                                          Comparator.naturalOrder());
    }
}
```

最后，我们要讨论的`Objects`类的最后两种方法是生成对象字符串表示的方法。 当您需要在对象上调用`toString()`方法但不确定对象引用是否为`null`时，它们会得到派派。 例如：

```
List<String> list = Arrays.asList("s1", null);
for(String e: list){
    //String s = e.toString();  //NullPointerException
}
```

在前面的示例中，我们知道每个元素的确切值。 但想象一下，列表被传递给方法作为参数。 然后我们被迫写一些如下：

```
void someMethod(List<String> list){
    for(String e: list){
        String s = e == null ? "null" : e.toString();
    }
```

这似乎这不是一个大问题。 但是在写这样的代码后十几次，程序员自然地考虑了一切实用的方法，这是所有这一切，这就是当`Objects`课程的以下两种方法有帮助：

*   `static String toString(Object o)`：返回当不是`null`的参数上调用`toString()`的结果，并在参数值为`null`时返回`null`

*   `static String toString(Object o, String nullDefault)`：返回在第一个参数上呼叫`toString()`的结果，当第一个参数值是`null`时返回第二个参数值`nullDefault`

以下代码演示了这两种方法：

```
List<String> list = Arrays.asList("s1", null);
for(String e: list){
    String s = Objects.toString(e);
    System.out.print(s + " ");          //prints: s1 null
}
for(String e: list){
    String s = Objects.toString(e, "element was null");
    System.out.print(s + " ");          //prints: s1 element was null
}
```

就像这种写作一样，`Objects`类有 17 种方法。 我们建议您熟悉它们，以避免在同一实用程序存在的情况下写自己的实用程序。

# Apache 项目的类 Objectutils

上一节的最后一个语句适用于 Apache Commons 库的`org.apache.commons.lang3.ObjectUtils`类，该库符合上一节中描述的`java.util.Objects`类的方法。 本书的范围和分配的大小不允许详细介绍`ObjectUtils`类的所有方法，因此我们将通过相关功能简要地描述它们。 要使用此类，您需要将以下依赖添加到 Maven `pom.xml`配置文件：

```
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.8.1</version>
</dependency>
```

`ObjectUtils`类的所有方法都可以组织成七组：

*   对象克隆方法
*   支持两个物体比较的方法
*   `notEqual()`方法比较了两个对象的不等式，其中一个或两个对象可以是`null`

*   几个`identityToString()`方法，用于生成所提供的对象的`String`表示，如`toString()`生成，它是`Object`基类的默认方法，并且可选地将其附加到另一个对象
*   `allNotNull()`和`anyNotNull()`方法，用于分析`null`的对象数组
*   `firstNonNull()`和`defaultIfNull()`方法分析对象数组并返回第一个 Not-`null`对象或默认值
*   `max()`，`min()`，`median()`和`mode()`方法分析对象数组并返回与方法名称对应的其中一个

# java.time 包

`java.time`包和其子包中有许多类。 他们被引入处理日期和时间的其他（较旧包）的替代品。 新课程是线程安全的（如此，更适合多线程处理），并且同样重要的是它们更加持续地设计和更容易理解。 此外，新实现遵循**国际标准组织**（ **ISO** ），以便日期和时间格式，但也允许使用任何其他自定义格式。

我们将描述主要五类，并演示如何使用它们：

*   `java.time.LocalDate`
*   `java.time.LocalTime`
*   `java.time.LocalDateTime`
*   `java.time.Period`
*   `java.time.Duration`

所有这些以及其他类`java.time`封装以及其子包的各种功能都丰富，涵盖所有实用案例。 但我们不会讨论所有这些; 我们将介绍基本和最受欢迎的用例。

# 班级派对

类`LocalDate`不携带时间。 它代表 ISO 8601 格式（YYYY-MM-DD）的日期：

```
System.out.println(LocalDate.now()); //prints: 2019-03-04

```

这是当前在这个位置写作的当前日期。 从计算机时钟拾取该值。 同样，您可以使用静态`now(ZoneId zone)`方法在任何其他时区中获取当前日期。 可以使用静态`ZoneId.of(String zoneId)`方法构建`ZoneId`对象，其中`String zoneId`是`ZonId.getAvailableZoneIds()`方法返回的任何字符串值：

```
Set<String> zoneIds = ZoneId.getAvailableZoneIds();
for(String zoneId: zoneIds){
    System.out.println(zoneId);
}
```

前面的代码打印了几乎 600 时区 ID。 这里有几个：

```
Asia/Aden
Etc/GMT+9
Africa/Nairobi
America/Marigot
Pacific/Honolulu
Australia/Hobart
Europe/London
America/Indiana/Petersburg
Asia/Yerevan
Europe/Brussels
GMT
Chile/Continental
Pacific/Yap
CET
Etc/GMT-1
Canada/Yukon
Atlantic/St_Helena
Libya
US/Pacific-New
Cuba
Israel
GB-Eire
GB
Mexico/General
Universal
Zulu
Iran
Navajo
Egypt
Etc/UTC
SystemV/AST4ADT
Asia/Tokyo
```

让我们尝试使用`"Asia/Tokyo"`，例如：

```
ZoneId zoneId = ZoneId.of("Asia/Tokyo");
System.out.println(LocalDate.now(zoneId)); //prints: 2019-03-05

```

`LocalDate`的一个对象可以代表过去的任何日期，或者将来，使用以下方法：

*   `LocalDate parse(CharSequence text)`：从 ISO 8601 格式（YYYY-MM-DD）中的字符串构造一个对象
*   `LocalDate parse(CharSequence text, DateTimeFormatter formatter)`：以`DateTimeFormatter`对象指定的格式构造来自具有丰富模式的格式的字符串以及许多预定义格式的格式; 以下是其中一些：

*   `LocalDate of(int year, int month, int dayOfMonth)`：从一年，月份和一天构建一个物体
*   `LocalDate of(int year, Month month, int dayOfMonth)`：从一年，月（枚举常数）和日期构建一个对象
*   `LocalDate ofYearDay(int year, int dayOfYear)`：从一年和一年的一年中构建目标形式

以下代码演示了列出的前面方法：

```
LocalDate lc1 = LocalDate.parse("2020-02-23");
System.out.println(lc1);                     //prints: 2020-02-23

LocalDate lc2 =  
          LocalDate.parse("20200223", DateTimeFormatter.BASIC_ISO_DATE);
System.out.println(lc2);                     //prints: 2020-02-23

DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
LocalDate lc3 =  LocalDate.parse("23/02/2020", formatter);
System.out.println(lc3);                     //prints: 2020-02-23

LocalDate lc4 =  LocalDate.of(2020, 2, 23);
System.out.println(lc4);                     //prints: 2020-02-23

LocalDate lc5 =  LocalDate.of(2020, Month.FEBRUARY, 23);
System.out.println(lc5);                     //prints: 2020-02-23

LocalDate lc6 = LocalDate.ofYearDay(2020, 54);
System.out.println(lc6);                     //prints: 2020-02-23

```

a `LocalDate`对象可以提供各种值：

```
LocalDate lc = LocalDate.parse("2020-02-23");
System.out.println(lc);                  //prints: 2020-02-23
System.out.println(lc.getYear());        //prints: 2020
System.out.println(lc.getMonth());       //prints: FEBRUARY
System.out.println(lc.getMonthValue());  //prints: 2
System.out.println(lc.getDayOfMonth());  //prints: 23
System.out.println(lc.getDayOfWeek());   //prints: SUNDAY
System.out.println(lc.isLeapYear());     //prints: true
System.out.println(lc.lengthOfMonth());  //prints: 29
System.out.println(lc.lengthOfYear());   //prints: 366

```

`LocalDate`对象可以修改如下：

```
LocalDate lc = LocalDate.parse("2020-02-23");
System.out.println(lc.withYear(2021)); //prints: 2021-02-23
System.out.println(lc.withMonth(5));       //prints: 2020-05-23
System.out.println(lc.withDayOfMonth(5));  //prints: 2020-02-05
System.out.println(lc.withDayOfYear(53));  //prints: 2020-02-22
System.out.println(lc.plusDays(10));       //prints: 2020-03-04
System.out.println(lc.plusMonths(2));      //prints: 2020-04-23
System.out.println(lc.plusYears(2));       //prints: 2022-02-23
System.out.println(lc.minusDays(10));      //prints: 2020-02-13
System.out.println(lc.minusMonths(2));     //prints: 2019-12-23
System.out.println(lc.minusYears(2));      //prints: 2018-02-23

```

`LocalDate`对象可以如下比较：

```
LocalDate lc1 = LocalDate.parse("2020-02-23");
LocalDate lc2 = LocalDate.parse("2020-02-22");
System.out.println(lc1.isAfter(lc2));       //prints: true
System.out.println(lc1.isBefore(lc2));      //prints: false

```

`LocalDate`类中有许多其他有用的方法。 如果您必须使用日期，我们建议您阅读此类和其他类的 API 和其他类别的`java.time`包及其子包。

# 课时课时

`LocalTime`类包含没有约会的时间。 它具有与`LocalDate`类的方法类似的方法。 以下是如何创建`LocalTime`类的对象：

```
System.out.println(LocalTime.now());         //prints: 21:15:46.360904

ZoneId zoneId = ZoneId.of("Asia/Tokyo");
System.out.println(LocalTime.now(zoneId));   //prints: 12:15:46.364378

LocalTime lt1 =  LocalTime.parse("20:23:12");
System.out.println(lt1);                     //prints: 20:23:12

LocalTime lt2 = LocalTime.of(20, 23, 12);
System.out.println(lt2);                     //prints: 20:23:12

```

可以从`LocalTime`对象中提取时间值的每个组件，如下所示：

```
LocalTime lt2 =  LocalTime.of(20, 23, 12);
System.out.println(lt2);                     //prints: 20:23:12

System.out.println(lt2.getHour());           //prints: 20
System.out.println(lt2.getMinute());         //prints: 23
System.out.println(lt2.getSecond());         //prints: 12
System.out.println(lt2.getNano());           //prints: 0
```

可以修改`LocalTime`类的对象：

```
LocalTime lt2 = LocalTime.of(20, 23, 12);
System.out.println(lt2.withHour(3)); //prints: 03:23:12
System.out.println(lt2.withMinute(10)); //prints: 20:10:12
System.out.println(lt2.withSecond(15)); //prints: 20:23:15
System.out.println(lt2.withNano(300)); //prints: 20:23:12.000000300
System.out.println(lt2.plusHours(10));       //prints: 06:23:12
System.out.println(lt2.plusMinutes(2));      //prints: 20:25:12
System.out.println(lt2.plusSeconds(2));      //prints: 20:23:14
System.out.println(lt2.plusNanos(200));      //prints: 20:23:12.000000200
System.out.println(lt2.minusHours(10));      //prints: 10:23:12
System.out.println(lt2.minusMinutes(2));     //prints: 20:21:12
System.out.println(lt2.minusSeconds(2));     //prints: 20:23:10
System.out.println(lt2.minusNanos(200));     //prints: 20:23:11.999999800
```

和`LocalTime`类的两个对象也可以进行比较：

```
LocalTime lt2 =  LocalTime.of(20, 23, 12);
LocalTime lt4 =  LocalTime.parse("20:25:12");
System.out.println(lt2.isAfter(lt4));       //prints: false
System.out.println(lt2.isBefore(lt4));      //prints: true
```

`LocalTime`类中有许多其他有用的方法。 如果您必须使用日期，我们建议您阅读此类和其他类的 API 和其他类别的`java.time`包及其子包。

# 类 localDatetime

`LocalDateTime`类包含日期和时间，并且所有方法都有`LocalDate`和`LocalTime`类，所以我们不会在这里重复它们。 我们只会展示如何创建`LocalDateTime`类的对象：

```
System.out.println(LocalDateTime.now());       
                                   //prints: 2019-03-04T21:59:00.142804
ZoneId zoneId = ZoneId.of("Asia/Tokyo");
System.out.println(LocalDateTime.now(zoneId)); 
                                   //prints: 2019-03-05T12:59:00.146038
LocalDateTime ldt1 = LocalDateTime.parse("2020-02-23T20:23:12");
System.out.println(ldt1);                 //prints: 2020-02-23T20:23:12
DateTimeFormatter formatter =
        DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
LocalDateTime ldt2 =
        LocalDateTime.parse("23/02/2020 20:23:12", formatter);
System.out.println(ldt2);                 //prints: 2020-02-23T20:23:12
LocalDateTime ldt3 = LocalDateTime.of(2020, 2, 23, 20, 23, 12);
System.out.println(ldt3);                 //prints: 2020-02-23T20:23:12
LocalDateTime ldt4 =
        LocalDateTime.of(2020, Month.FEBRUARY, 23, 20, 23, 12);
System.out.println(ldt4);                 //prints: 2020-02-23T20:23:12

LocalDate ld = LocalDate.of(2020, 2, 23);
LocalTime lt = LocalTime.of(20, 23, 12);
LocalDateTime ldt5 = LocalDateTime.of(ld, lt);
System.out.println(ldt5);                 //prints: 2020-02-23T20:23:12

```

`LocalDateTime`类中有许多其他有用的方法。 如果您必须使用日期，我们建议您阅读此类和其他类的 API 和其他类别的`java.time`包及其子包。

# 课程期间和持续时间

`java.time.Period`和`java.time.Duration`类旨在包含一定时间：

*   `Period`对象包含多年，月份和天单位的时间
*   a `Duration`对象包含小时，分钟，秒和纳秒的时间量

以下代码演示了与`LocalDateTime`类的创建和用法，但在`LocalDate`类中存在相同的方法（对于`Period`）和`LocalTime`（for `Duration`）：

```
LocalDateTime ldt1 = LocalDateTime.parse("2020-02-23T20:23:12");
LocalDateTime ldt2 = ldt1.plus(Period.ofYears(2));
System.out.println(ldt2);      //prints: 2022-02-23T20:23:12

```

以下方法的工作方式相同：

```
LocalDateTime ldt = LocalDateTime.parse("2020-02-23T20:23:12");
ldt.minus(Period.ofYears(2));
ldt.plus(Period.ofMonths(2));
ldt.minus(Period.ofMonths(2));
ldt.plus(Period.ofWeeks(2));
ldt.minus(Period.ofWeeks(2));
ldt.plus(Period.ofDays(2));
ldt.minus(Period.ofDays(2));
ldt.plus(Duration.ofHours(2));
ldt.minus(Duration.ofHours(2));
ldt.plus(Duration.ofMinutes(2));
ldt.minus(Duration.ofMinutes(2));
ldt.plus(Duration.ofMillis(2));
ldt.minus(Duration.ofMillis(2));
```

以下代码展示了`Period`的创建和使用对象的其他一些方法：

```
LocalDate ld1 =  LocalDate.parse("2020-02-23");
LocalDate ld2 =  LocalDate.parse("2020-03-25");
Period period = Period.between(ld1, ld2);
System.out.println(period.getDays());       //prints: 2
System.out.println(period.getMonths());     //prints: 1
System.out.println(period.getYears());      //prints: 0
System.out.println(period.toTotalMonths()); //prints: 1
period = Period.between(ld2, ld1);
System.out.println(period.getDays());       //prints: -2

```

`Duration`的对象可以类似地创建和使用：

```
LocalTime lt1 =  LocalTime.parse("10:23:12");
LocalTime lt2 =  LocalTime.parse("20:23:14");
Duration duration = Duration.between(lt1, lt2);
System.out.println(duration.toDays());     //prints: 0
System.out.println(duration.toHours());    //prints: 10
System.out.println(duration.toMinutes());  //prints: 600
System.out.println(duration.toSeconds());  //prints: 36002
System.out.println(duration.getSeconds()); //prints: 36002
System.out.println(duration.toNanos());    //prints: 36002000000000
System.out.println(duration.getNano());    //prints: 0
```

`Period`和`Duration`类中有许多其他有用的方法。 如果您必须使用日期，我们建议您读取此类和其他类的 API 和其他类别的`java.time`包及其子包。

# 概括

本章将读者介绍给 Java Collections 框架及其三个主要接口：`List`，`Set`和`Map`。 讨论了每个接口，并且其方法与其中一个实施类进行说明。 泛型也被解释和展示。 必须实现`equals()`和`hashCode()`方法，以便能够正确地由 Java 集合处理的对象。

实用类`Collections`和`CollectionUtils`具有许多有用的收集处理方法，并在实施例中呈现，以及`Arrays`，`ArrayUtils`，`Objects`和`ObjectUtils`。

`java.time`包的类的方法允许管理时间/日期值，该时间/日期值在特定的实际代码片段中演示。

在下一章中，我们将概述 Java 类库和一些外部库，包括支持测试的外部库。 具体地，我们将探索`org.junit`，`org.mockito`，`org.apache.log4j`，`org.slf4j`和`org.apache.commons`包及其子包。

# 测验

1.  什么是 Java 系列框架？ 选择所有符合条件的：
    1.  框架的集合
    2.  `java.util`包的类和接口
    3.  接口`List`，`Set`和`Map`
    4.  实现集合数据结构的类和接口

2.  什么是集合中的泛型？ 选择所有符合条件的：

3.  收集`of()`工厂方法的局限性是什么？ 选择所有符合条件的：
    1.  不允许`null`元素
    2.  不允许将元素添加到初始化的集合中
    3.  不允许将元素删除到初始化的集合
    4.  不允许将元素修改为初始化的集合

4.  `java.lang.Iterable`界面的实现允许是什么？ 选择所有符合条件的：
    1.  允许一个接一个地访问集合的元素
    2.  允许集合在`FOR`语句中使用
    3.  允许集合在`WHILE`语句中使用
    4.  允许集合在`DO...WHILE`语句中使用

5.  接口`java.util.Collection`允许的是什么？ 选择所有符合条件的：
    1.  添加到集合另一个集合的元素
    2.  从集合中删除另一个集合元素的对象
    3.  仅修改属于另一个集合的集合的元素
    4.  从集合中删除不属于另一个集合的对象

6.  选择关于`List`界面的方法的所有正确语句：

7.  选择关于`Set`界面的方法的所有正确语句：

8.  选择关于`Map`界面的方法的所有正确语句：
    1.  `int size()`：返回存储在地图中的键值对的计数; 当`isEmpty()`方法返回`true`时，此方法返回`0`
    2.  `V remove(Object key)`：从地图中删除键和值; 返回值，或`null`如果没有这样的键或值是`null`
    3.  `default boolean remove(Object key, Object value)`：如果在地图中存在这样的一对，则删除键值对; 如果删除该值，则返回`true`
    4.  `default boolean replace(K key, V oldValue, V newValue)`：如果当前映射到`oldValue`，则替换为提供的`newValue`的值`newValue`; 返回`true`如果被替换`oldValue`; 否则，返回`false`

9.  选择关于`static void sort(List<T> list, Comparator<T> comparator)`类的`static void sort(List<T> list, Comparator<T> comparator)`方法的所有正确陈述：
    1.  如果列表元素实现`Comparable`接口，则会对列表的自然顺序进行排序
    2.  它根据提供的`Comparator`对象对列表的顺序进行排序
    3.  如果列表元素实现`Comparable`接口，则根据提供的`Comparator`对象对列表的顺序进行排序
    4.  它根据提供的`Comparator`对象对列表的顺序进行排序，是列表元素是否实现`Comparable`界面

10.  以下代码执行的结果是什么？

```
List<String> list1 = Arrays.asList("s1","s2", "s3");
List<String> list2 = Arrays.asList("s3", "s4");
Collections.copy(list1, list2);
System.out.println(list1);    
```

11.  `CollectionUtils`类方法的功能是什么？ 选择所有符合条件的：
    1.  匹配`Collections`类方法的功能，但使用处理`null`
    2.  补充`Collections`类方法的功能
    3.  搜索，进程和比较 Java 集合，以便`Collections`类方法不做
    4.  复制`Collections`类方法的功能

12.  以下代码执行的结果是什么？

```
Integer[][] ar1 = {{42}};
Integer[][] ar2 = {{42}};
System.out.print(Arrays.equals(ar1, ar2) + " "); 
System.out.println(Arrays.deepEquals(arr3, arr4)); 
```

13.  以下代码执行的结果是什么？

```
String[] arr1 = { "s1", "s2" };
String[] arr2 = { null };
String[] arr3 = null;
System.out.print(ArrayUtils.getLength(arr1) + " "); 
System.out.print(ArrayUtils.getLength(arr2) + " "); 
System.out.print(ArrayUtils.getLength(arr3) + " "); 
System.out.print(ArrayUtils.isEmpty(arr2) + " "); 
System.out.print(ArrayUtils.isEmpty(arr3));
```

14.  以下代码执行的结果是什么？

```
 String str1 = "";
 String str2 = null;
 System.out.print((Objects.hash(str1) == 
                   Objects.hashCode(str2)) + " ");
 System.out.print(Objects.hash(str1) + " ");
 System.out.println(Objects.hashCode(str2) + " "); 
```

15.  以下代码执行的结果是什么？

```
String[] arr = {"c", "x", "a"};
System.out.print(ObjectUtils.min(arr) + " ");
System.out.print(ObjectUtils.median(arr) + " ");
System.out.println(ObjectUtils.max(arr));
```

16.  以下代码执行的结果是什么？

```
LocalDate lc = LocalDate.parse("1900-02-23");
System.out.println(lc.withYear(21)); 
```

17.  以下代码执行的结果是什么？

```
LocalTime lt2 = LocalTime.of(20, 23, 12);
System.out.println(lt2.withNano(300));      
```

18.  以下代码执行的结果是什么？

```
LocalDate ld = LocalDate.of(2020, 2, 23);
LocalTime lt = LocalTime.of(20, 23, 12);
LocalDateTime ldt = LocalDateTime.of(ld, lt);
System.out.println(ldt);                

```

19.  以下代码执行的结果是什么？

```
LocalDateTime ldt = LocalDateTime.parse("2020-02-23T20:23:12");
System.out.print(ldt.minus(Period.ofYears(2)) + " ");
System.out.print(ldt.plus(Duration.ofMinutes(12)) + " ");
System.out.println(ldt);
```