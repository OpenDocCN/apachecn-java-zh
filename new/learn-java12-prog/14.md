# Java 标准流

在本章中，我们将讨论数据流的处理，这些数据流与我们在[第 5 章](05.html)，*字符串，输入/输出和文件*中进行了审核的 I / O 流不同。 。 我们将定义数据流是什么，如何使用`java.util.stream.Stream`对象的方法（操作）处理它们的元素，以及如何在管道中链式（连接）流操作。 我们还将讨论流的初始化以及如何并行处理流。

本章将介绍以下主题：

*   流作为数据和操作来源
*   流初始化
*   操作（方法）
*   数字流界面
*   并行流

# 流作为数据和操作来源

在上一章中描述和演示的 Lambda 表达式与功能界面一起为 Java 添加了强大的功能编程功能。 它们允许将行为（函数）作为参数作为优化的图书馆，以针对数据处理的性能。 这样，应用程序员可以专注于发达系统的业务方面，将性能方面留给专家 - 图书馆的作者。 这种库的一个示例是包`java.util.stream`，这将是本章的重点。

在 [第 5 章](05.html)， *strings，输入/输出和文件*，我们讨论了 I / O 流作为数据源，但超出了，它们并不多 帮助进一步处理数据。 它们是基于字节或字符的，而不是基于对象的。 只有在编程方式创建和序列化之后，才能创建一个对象流。 I / O 流只是与外部资源的连接，主要是文件，而不是其他的。 但是，有时可以从 I / O 流到`java.util.stream.Stream`进行转换。 例如，`BufferedReader`类具有将基于字符的流转换为`Stream<String>`对象的`lines()`方法。

另一方面，`java.util.stream`封装的流是在处理对象的加工方面。 在[第 6 章](06.html)，*数据结构，泛型和流行的实用程序中，*我们描述了`Collection`界面的两种方法，允许读取集合元素作为流的元素：`default Stream<E> stream()` 和`default Stream<E> parallelStream()`。 我们还提到了`java.util.Arrays`的`stream()`方法。 它具有以下八个重载版本，可将数组或其中的一部分转换为相应数据类型的流：

*   `static DoubleStream stream(double[] array)`
*   `static DoubleStream stream(double[] array, int startInclusive, int endExclusive)`
*   `static IntStream stream(int[] array)`
*   `static IntStream stream(int[] array, int startInclusive, int endExclusive)`
*   `static LongStream stream(long[] array)`
*   `static LongStream stream(long[] array, int startInclusive, int endExclusive)`
*   `static <T> Stream<T> stream(T[] array)`
*   `static <T> Stream<T> stream(T[] array, int startInclusive, int endExclusive)`

现在我们来看看包的溪流`java.util.stream`更近。 理解什么是流的最佳方式是将其与集合进行比较。 后者是存储在存储器中的数据结构。 在添加到集合之前计算每个集合元素。 相比之下，流在源中的其他地方存在的元素在源中存在，并按需计算。 因此，集合可以是流的源。

`Stream`对象是接口`Stream`，`IntStream`，`LongStream`或`DoubleStream`的实现; 最后三个称为**数字流**。 界面`Stream`的方法也可在数字流中使用。 一些数字流具有一些额外的方法，例如`average()`和`sum()`，具体到数值。 在本章中，我们将大多谈论`Stream`界面及其方法，但我们将覆盖的一切都同样适用于数字流。

一旦已处理先前发射的元件，流*生成（*或*发射*）流元素。 它允许可以应用于发射元素的方法（操作）的声明性呈现，同样并行。 如今，当大型数据集处理的机器学习要求正在变得无处不在，这种功能强化了 Java 在一些现代编程语言中的选择。

# 流初始化

有许多方法可以创建和初始化流 - `Stream`或任何数字接口的对象。 我们通过具有`Stream` -CREATING 方法的类和接口分组它们。 我们为读者提供了方便，因此如果需要，读者更容易记住并找到它们。

# 流界面

这组`Stream`工厂由属于`Stream`界面的静态方法组成。

# 空的（）

`Stream<T> empty()`方法创建一个不发出任何元素的空流：

```
Stream.empty().forEach(System.out::println);   //prints nothing
```

`Stream`方法`forEach()`类似于`Collection`方法`forEach()`并将传递的函数应用于每个流元素：

```
new ArrayList().forEach(System.out::println);  //prints nothing
```

结果与从空集合创建流的结果相同：

```
new ArrayList().stream().forEach(System.out::println);  //prints nothing
```

没有任何元素发出，没有任何反应。 我们将在*终端操作*部分中讨论`Stream`方法`forEach()`。

# （t ...值）

`of(T... values)`方法接受 varargs，也可以创建一个空流：

```
Stream.of().forEach(System.out::print);       //prints nothing
```

但它通常用于初始化非空流：

```
Stream.of(1).forEach(System.out::print);           //prints: 1
Stream.of(1,2).forEach(System.out::print);         //prints: 12
Stream.of("1 ","2").forEach(System.out::print);    //prints: 1 2
```

注意用于调用`println()`和`print()`方法的方法参考。

使用`of(T... values)`方法的另一种方法如下：

```
String[] strings = {"1 ", "2"};
Stream.of(strings).forEach(System.out::print);      //prints: 1 2
```

如果没有为`Stream`对象指定的类型，则如果数组包含类型的组合：

```
Stream.of("1 ", 2).forEach(System.out::print);      //prints: 1 2
```

当列出的元素中的至少一个类型中，添加泛型导致预期元素类型的泛型会导致异常：

```
//Stream<String> stringStream = Stream.of("1 ", 2);   //compile error
```

泛型帮助程序员避免许多错误，因此应尽可能添加它们。

`of(T... values)`方法还可用于多个流的串联。 例如，让我们假设我们有以下四条流，我们希望连接成一个：

```
Stream<Integer> stream1 = Stream.of(1, 2);
Stream<Integer> stream2 = Stream.of(2, 3);
Stream<Integer> stream3 = Stream.of(3, 4);
Stream<Integer> stream4 = Stream.of(4, 5);

```

我们希望将它们连接到发出值`1,2,2,3,3,4,4,5`的新流中。 首先，我们尝试以下代码：

```
Stream.of(stream1, stream2, stream3, stream4)
      .forEach(System.out::print);
              //prints: java.util.stream.ReferencePipeline$Head@58ceff1j

```

它不做我们希望的。 它将每个流视为`Stream`接口实现中使用的内部类`java.util.stream.ReferencePipeline`的对象。 因此，我们需要添加`flatMap()`操作以将每个流元素转换为流（我们在*中间操作*部分中描述它）：

```
Stream.of(stream1, stream2, stream3, stream4)
      .flatMap(e -> e).forEach(System.out::print);   //prints: 12233445

```

我们传递给`flatMap()`作为参数（`e -> e`）的函数看起来它没有什么都不做，但这是因为流的每个元素已经是流，所以没有必要转换它。 通过将元素返回作为`flatMap()`操作的结果，我们告诉流水线将返回值视为`Stream`对象。

# 可以（t t）

`ofNullable(T t)`方法如果传递的参数`t`不是`null`，则返回发出单个元素的`Stream<T>`; 否则，它返回一个空`Stream`。 要演示`ofNullable(T t)`方法的使用，我们创建了以下方法：

```
void printList1(List<String> list){
    list.stream().forEach(System.out::print);
}
```

我们已执行此方法两次 - 参数列表等于`null`和`List`对象。 以下是结果：

```
//printList1(null);                          //NullPointerException
List<String> list = List.of("1 ", "2");
printList1(list);                            //prints: 1 2

```

请注意，第一次调用`printList1()`方法如何生成`NullPointerException`。 为避免异常，我们可以实现如下方法：

```
void printList1(List<String> list){ 
     (list == null ? Stream.empty() : list.stream()) 
                           .forEach(System.out::print);
} 
```

通过`ofNullable(T t)`方法可以实现相同的结果：

```
void printList2(List<String> list){
    Stream.ofNullable(list).flatMap(l -> l.stream())
                           .forEach(System.out::print);
}
```

请注意，我们如何添加`flatMap()`，因为，否则，流入`forEach()`的`Stream`元素将是`List`对象。 我们将更多地讨论*中间操作*部分中的`flatMap()`方法。 传递到前面代码中的`flatMap()`操作的功能也可以表示为方法引用：

```
void printList4(List<String> list){
    Stream.ofNullable(list).flatMap(Collection::stream)
                           .forEach(System.out::print);
}
```

# 迭代（对象，undaryOperator）

`Stream`接口的两个静态方法允许使用类似于传统`for`循环的迭代过程生成值流：

*   `Stream<T> iterate(T seed, UnaryOperator<T> func)`：基于第二参数的迭代应用程序，函数`func`，在第一参数`seed`中创建无限顺序流，从而产生值`seed`，`f(seed)`，`f(f(seed))`， 等等
*   `Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)`：基于第三参数的迭代应用程序，函数`next`，为第一参数`seed`创建有限的顺序流，从而产生值`seed`，`f(seed)`，`f(f(seed))`， 等等，只要第三个参数，函数`hasNext`，返回 true

以下代码演示了这些方法的使用：

```
Stream.iterate(1, i -> ++i).limit(9)
      .forEach(System.out::print); //prints: 123456789

Stream.iterate(1, i -> i < 10, i -> ++i)
      .forEach(System.out::print);        //prints: 123456789

```

请注意，我们被迫将中间运算符`limit(int n)`添加到第一个管道，以避免生成无限数量的生成值。 我们将在*中间操作*部分中详细讨论此方法。

# Concat（流 A，Stream B）

`Stream<T> concat(Stream<> a, Stream<T> b)`接口的静态方法基于两个流，`a`和`b`，以作为参数传递的两个流，从而创建值。 新创建的流由第一个参数`a`的所有元素组成，后跟第二个参数的所有元素`b`。 以下代码演示了此方法：

```
Stream<Integer> stream1 = List.of(1, 2).stream();
Stream<Integer> stream2 = List.of(2, 3).stream();
Stream.concat(stream1, stream2)
 .forEach(System.out::print); //prints: 1223

```

请注意，元素`2`在两个原始流中存在，因此由生成的流发射两次。

# 生成（供应商）

接口`Stream`的静态方法`Stream<T> generate(Supplier<T> supplier)`创建无限流，其中每个元素由提供的功能`Supplier<T>`生成。 以下是两个例子：

```
Stream.generate(() -> 1).limit(5)
 .forEach(System.out::print);        //prints: 11111

Stream.generate(() -> new Random().nextDouble()).limit(5)
      .forEach(System.out::println);      //prints: 0.38575117472619247
                                          //        0.5055765386778835
                                          //        0.6528038976983277
                                          //        0.4422354489467244
                                          //        0.06770955839148762

```

如果您运行此代码，则由于生成值的随机（伪随机）性质，您可能会得到不同的结果。

由于创建的流是无限的，因此我们添加了一个`limit(int n)`操作，允许仅允许指定数量的流元素流过。 我们将在*中间操作*部分中详细讨论此方法。

# Stream.Builder 界面

`Stream.Builder<T> builder()`静态方法返回内部（位于接口`Stream`内）接口`Builder`，可用于构造`Stream`对象。 接口`Builder`扩展了`Consumer`界面，并具有以下方法：

*   `default Stream.Builder<T> add(T t)`：调用`accept(T)`方法并返回（`Builder`对象），从而允许在流畅的点连接风格中链接`add(T t)`方法
*   `void accept(T t)`：将元素添加到流中（此方法来自`Consumer`接口）
*   `Stream<T> build()`：将此构建器从构造状态转换为`built`状态; 在调用此方法后，无法将新元素添加到此流中

`add(T t)`方法的用法很简单：

```
Stream.<String>builder().add("cat").add(" dog").add(" bear")
      .build().forEach(System.out::print);       //prints: cat dog bear

```

请注意我们如何在`builder()`方法前面添加泛型`<String>`。 这样，我们告诉建造商，我们正在创建的流将具有`String`类型元素。 否则，它将将元素添加为`Object`类型，不会确保添加的元素是`String`类型的。

当构建器传递为`Consumer<T>`类型的参数时使用`accept(T t)`方法或者当您不需要将添加元素添加的方法链接时。 例如，以下是代码示例：

```
Stream.Builder<String> builder = Stream.builder();
List.of("1", "2", "3").stream().forEach(builder);   
builder.build().forEach(System.out::print);        //prints: 123

```

`forEach(Consumer<T> consumer)`方法接受具有`accept(T t)`方法的`Consumer`功能。 每次流发射元素时，`forEach()`方法会接收并将其传递给`Builder`对象的`accept(T t)`方法。 然后，当在下一行中调用`build()`方法时，创建`Stream`对象并开始发出通过`accept(T t)`方法提前添加的元素。 发射的元素传递给`forEach()`方法，然后将它们一个接一个地打印。

这里是`accept(T t)`方法的显式使用的示例：

```
List<String> values = List.of("cat", " dog", " bear");
Stream.Builder<String> builder = Stream.builder();
for(String s: values){
    if(s.contains("a")){
        builder.accept(s);
    }
}
builder.build().forEach(System.out::print);        //prints: cat bear

```

这次，我们决定不要将所有列表元素添加到流中，而只有那些包含字符`a`的列表元素。 如所预期的那样，创建的流仅包含`cat`和`bear`元素。 此外，请注意我们如何使用`<String>`泛型，以确保所有流元素都是`String`类型。

# 其他类和界面

在 Java 8 中，将两个默认方法添加到`java.util.Collection`界面中：

*   `Stream<E> stream()`：返回此集合的元素流
*   `Stream<E> parallelStream()`：返回（可能）该集合的元素的并行流; *可能是*因为 JVM 尝试将流拆分为几个块并并行处理它们（如果有几个 CPU）或几乎并行（使用 CPU 的时间共享）; 但并不总是可能的并且部分取决于所请求的处理的性质

这意味着所有扩展该接口的集合接口，包括`Set`和`List`都具有这些方法。 例如：

```
List.of("1", "2", "3").stream().forEach(builder);
List.of("1", "2", "3").parallelStream().forEach(builder);
```

我们将讨论*并行处理*部分中的并行流。

在*流的开始作为数据和操作源*部分，我们描述了`java.util.Arrays`类的八个静态过载方法`stream()` `java.util.Arrays`类`stream()`。 以下是使用数组的子集创建流的另一种方式的示例：

```
int[] arr = {1, 2, 3, 4, 5}; 
Arrays.stream(arr, 2, 4).forEach(System.out::print); //prints: 34 
```

`java.util.Random`类允许创建伪随机值的数字流：

*   `DoubleStream doubles()`：在`0`（包含）和`1`之间创建无限的`double`值流（独家）
*   `IntStream ints()`和`LongStream longs()`：创建一个无限制的相应类型值流
*   `DoubleStream doubles(long streamSize)`：在`0`（包含）和`1`之间创建`double`值的流（指定大小）（独家）
*   `IntStream ints(long streamSize)`和`LongStream longs(long streamSize)`：创建指定类型值的指定大小的流
*   `IntStream ints(int randomNumberOrigin, int randomNumberBound)`：在`randomNumberOrigin`（包含）和`randomNumberBound`之间创建无限的`int`值流（独家）
*   `LongStream longs(long randomNumberOrigin, long randomNumberBound)`：在`randomNumberOrigin`（包含）和`randomNumberBound`之间创建无限的`long`值流（独家）
*   `DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)`：在`randomNumberOrigin`（包含）和`randomNumberBound`之间创建`double`值的指定大小的流（独家）

以下是前面方法之一的示例：

```
new Random().ints(5, 8).limit(5) 
            .forEach(System.out::print);    //prints: 56757 
```

`java.nio.file.Files`类有六种静态方法，创建行和路径流：

*   `Stream<String> lines(Path path)`：从提供的路径指定的文件中创建一条行流
*   `Stream<String> lines(Path path, Charset cs)`：从提供的路径指定的文件中创建一条行; 文件中的字节使用提供的 charset 解码为字符
*   `Stream<Path> list(Path dir)`：在指定目录中创建文件流和目录
*   `Stream<Path> walk(Path start, FileVisitOption... options)`：创建一个以`Path start`开头的文件树的文件流和目录
*   `Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options)`：创建文件树的文件和目录，该文件从`Path start`下降到指定深度`maxDepth`
*   `Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes> matcher, FileVisitOption... options)`：创建文件树的文件流和目录（与提供的谓词匹配）以`Path start`向下以`maxDepth`值指定的深度

创建流的其他类和方法包括以下内容：

*   `java.util.BitSet`类具有`IntStream stream()`方法，它创建了一条索引流，其中`BitSet`包含在集合状态中的一位。
*   `java.io.BufferedReader`类具有`Stream<String> lines()`方法，其通常从该文件创建一条线流，该方法从该文件中从文件中创建一条线条。
*   `java.util.jar.JarFile`类具有创建邮政编码条目的流的`Stream<JarEntry> stream()`方法。
*   `java.util.regex.Pattern`类具有`Stream<String> splitAsStream(CharSequence input)`方法，该方法从此模式的匹配周围创建流。
*   `java.lang.CharSequence`界面有两种方法：
    *   `default IntStream chars()`：创建一个`int`零扩展 CHAR 值的流
    *   `default IntStream codePoints()`：从此序列中创建代码点值流

还有一个`java.util.stream.StreamSupport`类，包含库开发人员的静态低级实用程序方法。 但我们不会审查它，因为这在本书的范围之外。

# 操作（方法）

`Stream`接口的许多方法，具有作为参数的功能界面类型的方法，称为**操作**，因为它们不作为传统方法实现。 它们的功能将其作为函数传递给该方法。 操作只是 shell，调用分配为参数方法类型的功能界面的方法。

例如，让我们来看看`Stream<T> filter (Predicate<T> predicate)`方法。 其实现基于对`Predicate<T>`功能的 Boolean `test(T t)`的呼叫。 因此，而不是说，*对象的 w 这允许一些流元素通过并跳过他人*。 它描述了动作（操作）的性质，而不是特定算法，直到方法接收到特定函数直到该特定函数。 `Stream`接口中有两组操作：

*   **中间操作**：返回`Stream`对象的实例方法
*   **终端操作：**返回除`Stream`以外的某些类型的实例方法

流处理通常是使用流畅（DOT 连接）样式的管道。 A `Stream`创建方法或其他流源启动此类管道。 终端操作会产生最终结果或副作用，并结束管道，从而实现名称。 可以将中间操作放置在原始`Stream`对象和终端操作之间。

中间操作处理流元素（在某些情况下）流元素（在某些情况下）并返回修改（或不）`Stream`对象，因此可以应用下一个中间或终端操作。 中间操作的例子如下：

*   `Stream<T> filter(Predicate<T> predicate)`：仅选择符合标准的元素
*   `Stream<R> map(Function<T,R> mapper)`：根据传递的功能转换元素; 请注意，返回的`Stream`对象的类型可能与输入类型完全不同
*   `Stream<T> distinct()`：删除重复
*   `Stream<T> limit(long maxSize)`：将流限制为指定数量的元素
*   `Stream<T> sorted()`：以一定的顺序排列流元素
*   我们将讨论*中间操作*部分中的其他中间操作。

流元素的处理实际上仅在终端操作开始执行时开始。 然后所有中间操作（如果存在）按顺序开始处理。 一旦终端操作完成执行，则流关闭并无法重新打开。

终端操作的示例是`forEach()`，`findFirst()`，`reduce()`，`collect()`，`collect()`，`max()`和不返回`Stream`对象的其他方法。 我们将在*终端操作*部分中讨论它们。

所有`Stream`操作支持并行处理，在多核计算机上处​​理大量数据的情况下特别有用。 我们将在*并行流*部分中讨论它。

# 中间行动

如我们已经提到的那样，中间操作返回发射相同或修改值的`Stream`对象，并且甚至可能与流源不同。

中间操作可以通过它们在执行**滤波**的四个类别中的功能分组，，**映射**，**排序**，或**窥视**。

# 过滤

此组包括删除重复项的操作，跳过一些元素，限制已处理元素的数量，然后选择仅通过某些标准的进一步处理：

*   `Stream<T> distinct()`：使用`method` `Object.equals(Object)`进行流元素并跳过重复项
*   `Stream<T> skip(long n)`：忽略首先发出的流元素的提供数量
*   `Stream<T> limit(long maxSize)`：仅允许要处理的流元素的数量
*   `Stream<T> filter(Predicate<T> predicate)`：仅在由提供的`Predicate`函数处理时，只允许将要处理的元素处理在`true`中
*   `default Stream<T> dropWhile(Predicate<T> predicate)`：在提供的`Predicate`函数处理时跳过导致`true`的第一个元素
*   `default Stream<T> takeWhile(Predicate<T> predicate)`：仅在由提供的`Predicate`函数处理时，只允许在处理`true`中的流的第一个元素

以下是演示操作如何描述工作的代码：

```
Stream.of("3", "2", "3", "4", "2").distinct()
                         .forEach(System.out::print);     //prints: 324

List<String> list = List.of("1", "2", "3", "4", "5");
list.stream().skip(3).forEach(System.out::print);         //prints: 45

list.stream().limit(3).forEach(System.out::print);        //prints: 123

list.stream().filter(s -> Objects.equals(s, "2"))
             .forEach(System.out::print);                 //prints: 2

list.stream().dropWhile(s -> Integer.valueOf(s) < 3)
             .forEach(System.out::print);                 //prints: 345

list.stream().takeWhile(s -> Integer.valueOf(s) < 3)
             .forEach(System.out::print);                 //prints: 12

```

请注意，我们能够重用源`List<String>`对象，但无法重用`Stream`对象。 一旦关闭`Stream`对象，它无法重新打开。

# 映射

该集团可易于使用最重要的中间行动。 它们是修改流元素的唯一中间操作。 它们**映射**（将）原始流元素值映射到一个新的流元素值：

*   `Stream<R> map(Function<T, R> mapper)`：将提供的函数应用于流的类型`T`的每个元素，并生成类型`R`的新元素值
*   `IntStream mapToInt(ToIntFunction<T> mapper)`：将提供的函数应用于流的类型`T`的每个元素，并生成类型`int`的新元素值
*   `LongStream mapToLong(ToLongFunction<T> mapper)`：将提供的函数应用于流的类型`T`的每个元素，并生成类型`long`的新元素值
*   `DoubleStream mapToDouble(ToDoubleFunction<T> mapper)`：将提供的函数应用于流的类型`T`的每个元素，并生成类型`double`的新元素值
*   `Stream<R> flatMap(Function<T, Stream<R>> mapper)`：将提供的函数应用于流的类型的每个元素，并生成一个发出`R`的元素的`Stream<R>`对象
*   `IntStream flatMapToInt(Function<T, IntStream> mapper)`：将提供的函数应用于流的类型的每个元素，并生成一个发出`int`的元素的`IntStream`对象
*   `LongStream flatMapToLong(Function<T, LongStream> mapper)`：将提供的函数应用于流的类型的每个元素，并生成一个发出`long`的元素的`LongStream`对象
*   `DoubleStream flatMapToDouble(Function<T, DoubleStream> mapper)`：将提供的函数应用于流的类型的每个元素，并生成一个发出`double`的元素的`DoubleStream`对象

以下是使用这些操作的示例：

```
List<String> list = List.of("1", "2", "3", "4", "5");
list.stream().map(s -> s + s)
             .forEach(System.out::print);    //prints: 1122334455

list.stream().mapToInt(Integer::valueOf)
             .forEach(System.out::print);    //prints: 12345

list.stream().mapToLong(Long::valueOf)
             .forEach(System.out::print);    //prints: 12345

list.stream().mapToDouble(Double::valueOf)
             .mapToObj(Double::toString)
             .map(s -> s + " ")
             .forEach(System.out::print);  //prints: 1.0 2.0 3.0 4.0 5.0

list.stream().mapToInt(Integer::valueOf)
             .flatMap(n -> IntStream.iterate(1, i -> i < n, i -> ++i))
             .forEach(System.out::print);        //prints: 1121231234

list.stream().map(Integer::valueOf)
             .flatMapToInt(n ->
                  IntStream.iterate(1, i -> i < n, i -> ++i))
             .forEach(System.out::print);        //prints: 1121231234

list.stream().map(Integer::valueOf)
             .flatMapToLong(n ->
                  LongStream.iterate(1, i -> i < n, i -> ++i))
             .forEach(System.out::print);        //prints: 1121231234

list.stream().map(Integer::valueOf)
             .flatMapToDouble(n ->
                  DoubleStream.iterate(1, i -> i < n, i -> ++i))
             .mapToObj(Double::toString)
             .map(s -> s + " ")
             .forEach(System.out::print);
                       //prints: 1.0 1.0 2.0 1.0 2.0 3.0 1.0 2.0 3.0 4.0
```

在最后一个示例中，将流转换为`DoubleStream`，我们将每个数值转换为`String`对象并添加空格，因此可以在数字之间使用空格打印结果。 这些例子非常简单：只需用最小处理转换。 但在现实生活中，每个`map()`或`flatMap()`操作通常接受更复杂的功能，这些功能是更有用的。

# 排序

以下两个中间操作对流元素进行排序：

*   `Stream<T> sorted()`：以自然顺序排序流元素（根据其`Comparable`接口实现）
*   `Stream<T> sorted(Comparator<T> comparator)`：根据提供的`Comparator<T>`对象按顺序排序流元素

当然，在发射所有元素之前，这些操作不能完成，因此这种处理创造了大量的开销，减慢性能，并且必须用于小型流。

这是一个演示代码：

```
List<String> list = List.of("2", "1", "5", "4", "3");
list.stream().sorted().forEach(System.out::print);  //prints: 12345
list.stream().sorted(Comparator.reverseOrder())
             .forEach(System.out::print);           //prints: 54321

```

# 偷看

中间`Stream<T> peek(Consumer<T> action)`操作将提供的`Consumer<T>`函数应用于每个流元素，但不改变流值（函数`Consumer<T>`返回`void`）。 此操作用于调试。 以下代码显示其工作原理：

```
List<String> list = List.of("1", "2", "3", "4", "5");
list.stream()
 .peek(s -> System.out.print("3".equals(s) ? 3 : 0))
 .forEach(System.out::print); //prints: 0102330405
```

# 终端运营

**终端操作**是流管道最重要的操作。 在不使用任何其他操作的情况下，可以在不使用其他操作中完成所有内容。

我们已经使用了`forEach(Consumer<T>)`终端操作来打印每个元素。 它不会返回一个值，因此它用于其副作用。 但`Stream`界面有许多更强大的终端操作，可以返回值。

其中的主要是`collect()`操作，其具有两种形式的`R collect(Collector<T, A, R> collector)`和`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R, R> combiner)`。 它允许实际构思可以应用于流的任何过程。 经典示例如下：

```
List<String> list = Stream.of("1", "2", "3", "4", "5")
                          .collect(ArrayList::new,
                                   ArrayList::add,
                                   ArrayList::addAll);
System.out.println(list);  //prints: [1, 2, 3, 4, 5]

```

在该示例中，它以适合于并行处理的方式使用。 `collect()`操作的第一个参数是一种基于流元素的值的函数。 第二个参数是累积结果的函数。 第三个参数是将累积结果与处理流的所有线程组合的函数。

但只有一个这样的通用终端操作将强制程序员重复地编写相同的功能。 这就是为什么 API 作者添加了类`Collectors`，它会生成许多专业化的`Collector`对象，而无需为每个`collect()`操作创建三个功能。

除此之外，API 作者还添加到界面`Stream`的各种甚至更专业的终端操作，这些终端操作更简单，更易于使用。 在本节中，我们将审查`Stream`界面的所有终端操作，并且在子部分`Collect`中，查看`Collectors`类生成的`Collector`对象的血清。 我们从最简单的终端操作开始，允许一次处理该流的每个元素。

在我们的示例中，我们将使用以下类：`Person`：

```
public class Person {
    private int age;
    private String name;
    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }
    public int getAge() {return this.age; }
    public String getName() { return this.name; }
    @Override
    public String toString() {
        return "Person{" + "name='" + this.name + "'" +
                                       ", age=" + age + "}";
    }
}
```

# 处理每个元素

该组有两个终端操作：

*   `void forEach(Consumer<T> action)`：为此流的每个元素应用提供的操作
*   `void forEachOrdered(Consumer<T> action)`：无论流是顺序还是并行的，如何为此流的每个元素应用此流的每个元素

如果您需要要处理的元素的顺序很重要，并且必须在源处排列订单值，请使用第二种方法，尤其是如果您可以预见到可能的代码将执行您的代码 有几个 CPU 的计算机。 否则，请使用第一个，正如我们在我们所有的例子中所做的那样。

让我们看一下使用`forEach()`操作来从文件中读取逗号分隔值（年龄和名称）并创建`Person`对象。 我们已经放置了以下文件`persons.csv`（ *csv* 在`resources`文件夹中代表*分离值*）：

```
23 , Ji m
    2 5 , Bob
  15 , Jill
17 , Bi ll
```

我们在内部和外部添加了空格，以便借此机会向您展示一些简单但非常有用的提示，用于使用现实生活数据。

首先，我们只需阅读文件并按行显示其内容行，但只有那些包含字母`J`的行：

```
Path path = Paths.get("src/main/resources/persons.csv");
try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
    lines.filter(s -> s.contains("J"))
         .forEach(System.out::println);  //prints: 23 , Ji m
                                         //          15 , Jill
} catch (IOException ex) {
    ex.printStackTrace();
}
```

这是一种使用`forEach()`操作的典型方式：独立地处理每个元素。 此代码还提供了一个实际关闭`BufferedReader`对象的尝试资源构造的示例。

和下面的是一个没有经验的程序员可能如何编写读取从`Stream<String> lines`对象流元素，并创建`Person`对象的列表的代码：

```
List<Person> persons = new ArrayList<>();
lines.filter(s -> s.contains("J")).forEach(s -> {
    String[] arr = s.split(",");
    int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
    persons.add(new Person(age, StringUtils.remove(arr[1], ' ')));
});

```

您可以看到`split()`方法如何使用逗号中断每行，该逗号分隔值以及`org.apache.commons.lang3.StringUtils.remove()`方法如何从每个值中删除空格。 虽然此代码在单核计算机上的小示例中运行良好，但它可能会产生具有长流和并行处理的意外结果。

这就是 Lambda 表达式要求所有变量最终或有效最终的原因，因为可以在不同的上下文中执行相同的功能。

以下是前面代码的正确实现：

```
List<Person> persons = lines.filter(s -> s.contains("J"))
        .map(s -> s.split(","))
        .map(arr -> {
            int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
            return new Person(age, StringUtils.remove(arr[1], ' '));
        }).collect(Collectors.toList());
```

为了提高可读性，我们可以创建一种方法，该方法是映射的作业：

```
private Person createPerson(String[] arr){
    int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
    return new Person(age, StringUtils.remove(arr[1], ' '));
}
```

现在我们可以使用它如下：

```
List<Person> persons = lines.filter(s -> s.contains("J"))
                            .map(s -> s.split(","))
                            .map(this::createPerson)
                            .collect(Collectors.toList());

```

正如您所看到的，我们使用了`collect()`操作员和`Collectors.toList()`方法创建的`Collector`功能。 我们将看到`Collectors`中`Collectors`收集子部分创建的更多功能。

# 计算所有元素

`long count()` interface 的`long count()`终端操作看起来很直接和良性。 它返回此流中的元素数。 习惯使用集合和阵列的人可以使用`count()`操作而不思考两次。 以下代码片段演示了一个警告：

```
long count = Stream.of("1", "2", "3", "4", "5")
                   .peek(System.out::print)
                   .count();
System.out.print(count);          //prints: 5               

```

如果我们运行前面的代码，结果将如下所示：

![](img/46166046-1838-459b-baf4-4e203ac031e5.png)

如您所见，实现`count()`方法的代码能够在不执行所有管道的情况下确定流大小。 `peek()`操作没有打印任何东西，证明了元素未被发出。 因此，如果您期望看到打印的流的值，您可能会困惑，并期望代码有某种缺陷。

另一个警告是，并不总是可以在源处确定流尺寸。 此外，流可能是无限的。 所以，你必须用`count()`小心。

确定流大小的另一种可能方法是使用`collect()`操作：

```
long count = Stream.of("1", "2", "3", "4", "5")
                   .peek(System.out::print)         //prints: 12345
                   .collect(Collectors.counting());
System.out.println(count);                          //prints: 5 
```

以下是屏幕截图，显示前面的代码示例在运行之前发生的情况：

![](img/1f00826d-c8dc-454a-a446-f44452b5fb26.png)

如您所见，`collect()`操作不计算源处的流大小。 这是因为`collect()`操作不像`count()`操作一样。 它只是将传递的收集器应用于流。 并且收集器只需通过`collect()`操作来计算提供给它的元素。

# 匹配所有，任何，没有

有三种看似非常相似的终端操作，允许我们评估是否是所有流元素的一定值：

*   `boolean allMatch(Predicate<T> predicate)`：当用作提供的`Predicate<T>`功能的参数时，返回`true`返回`true`
*   `boolean anyMatch(Predicate<T> predicate)`：当用作提供的`Predicate<T>`函数的参数时，其中一个流元素返回`true`时返回`true`
*   `boolean noneMatch(Predicate<T> predicate)`：返回`true`当否定用作提供的`Predicate<T>`函数的参数时返回`true`

以下是其使用的例子：

```
List<String> list = List.of("1", "2", "3", "4", "5");
boolean found = list.stream()
                    .peek(System.out::print)             //prints: 123
                    .anyMatch(e -> "3".equals(e));
System.out.println(found);                               //prints: true

boolean noneMatches = list.stream()
                          .peek(System.out::print)       //prints: 123
                          .noneMatch(e -> "3".equals(e));
System.out.println(noneMatches);                         //prints: false

boolean allMatch = list.stream()
                       .peek(System.out::print)          //prints: 1
                       .allMatch(e -> "3".equals(e));
System.out.println(allMatch);                            //prints: false
```

请注意，所有这些操作都经过优化，以便如果可以提前确定结果，则不会处理所有流元素。

# 找到任何或第一个

以下终端操作允许腐蚀流的任何或第一个元素：

*   `Optional<T> findAny()`：返回一个`Optional`，使用流的任何元素的值，或者如果流为空，则为空`Optional`
*   `Optional<T> findFirst()`：返回一个`Optional`的流的第一个元素的值，或者如果流为空，则为空`Optional`

以下示例说明了这些操作：

```
List<String> list = List.of("1", "2", "3", "4", "5");
Optional<String> result = list.stream().findAny();
System.out.println(result.isPresent());    //prints: true
System.out.println(result.get());          //prints: 1

result = list.stream()
             .filter(e -> "42".equals(e))
             .findAny();
System.out.println(result.isPresent());    //prints: false
//System.out.println(result.get());        //NoSuchElementException

result = list.stream().findFirst();
System.out.println(result.isPresent());    //prints: true
System.out.println(result.get());          //prints: 1

```

在前面示例的第一和第三，`findAny()`和`findFirst()`操作产生相同的结果：它们都找到流的第一个元素。 但是在并行处理中，结果可能不同。

当流被分成几个部分进行并行处理时，`findFirst()`操作总是返回流的第一元素，而`findAny()`操作仅在一个处理线程中返回第一元件。

现在让我们更详细地讨论`class java.util.Optional`。

# 类可选

`java.util.Optional`的对象用于避免返回`null`（因为它可能导致`NullPointerException`）。 相反，`Optional`对象提供了允许检查存在值并将其替换为预定值的方法，如果返回值为`null`。 例如：

```
List<String> list = List.of("1", "2", "3", "4", "5");
String result = list.stream()
                    .filter(e -> "42".equals(e))
                    .findAny()
                    .or(() -> Optional.of("Not found"))
                    .get();
System.out.println(result);                       //prints: Not found

result = list.stream()
             .filter(e -> "42".equals(e))
             .findAny()
             .orElse("Not found");
System.out.println(result);                      //prints: Not found

Supplier<String> trySomethingElse = () -> {
    //Code that tries something else
    return "43";
};
result = list.stream()
             .filter(e -> "42".equals(e))
             .findAny()
             .orElseGet(trySomethingElse);
System.out.println(result);                      //prints: 43

list.stream()
    .filter(e -> "42".equals(e))
    .findAny()
    .ifPresentOrElse(System.out::println,
        () -> System.out.println("Not found")); //prints: Not found

```

正如您所看到的，如果`Optional`对象为空，则以下内容适用：

*   `Optional`类的`or()`方法允许返回备用`Optional`对象。
*   `orElse()`方法允许返回替代值。
*   `orElseGet()`方法允许提供返回替代值的`Supplier`函数。
*   `ifPresentOrElse()`方法允许提供两个功能：一个消耗`Optional`对象的值，以及在`Optional`对象是空的情况下的另一个。

# 最小和最多

以下终端操作返回流元素的最小值或最大值（如果存在）：

*   `Optional<T> min(Comparator<T> comparator)`：使用提供的`Comparator`对象返回此流的最小元素
*   `Optional<T> max(Comparator<T> comparator)`：使用提供的`Comparator`对象返回此流的最大元素

以下代码演示如下：

```
List<String> list = List.of("a", "b", "c", "c", "a");
String min = list.stream()
                 .min(Comparator.naturalOrder())
                 .orElse("0");
System.out.println(min);     //prints: a

String max = list.stream()
 .max(Comparator.naturalOrder())
                 .orElse("0");
System.out.println(max);     //prints: c

```

如您所见，在非数值的情况下，最小元素是根据所提供的比较器从左侧排序时的第一个元素。 因此，最大值是最后一个元素。 在数字值的情况下，最小和最大值只是：流元素中最小和最大的数字：

```
int mn = Stream.of(42, 77, 33)
               .min(Comparator.naturalOrder())
               .orElse(0);
System.out.println(mn);    //prints: 33

int mx = Stream.of(42, 77, 33)
               .max(Comparator.naturalOrder())
               .orElse(0);
System.out.println(mx);    //prints: 77

```

让我们来看看另一个例子，使用`Person`类。 任务是在下列表中找到最古老的人：

```
List<Person> persons = List.of(new Person(23, "Bob"),
 new Person(33, "Jim"),
 new Person(28, "Jill"),
 new Person(27, "Bill"));

```

为此，我们可以创建以下`Compartor<Person>`，该`Person`仅按年龄比较`Person`对象：

```
Comparator<Person> perComp = (p1, p2) -> p1.getAge() - p2.getAge();
```

然后，使用此比较器，我们可以找到最古老的人：

```
Person theOldest = persons.stream()
                          .max(perComp)
                          .orElse(null);
System.out.println(theOldest);    //prints: Person{name='Jim', age=33}
```

# 到阵列

以下两个终端操作生成包含流元素的数组：

*   `Object[] toArray()`：创建一系列对象; 每个对象都是流的一个元素
*   `A[] toArray(IntFunction<A[]> generator)`：使用提供的功能创建流元素数组

让我们来看看一些例子：

```
List<String> list = List.of("a", "b", "c");
Object[] obj = list.stream().toArray();
Arrays.stream(obj).forEach(System.out::print);    //prints: abc

String[] str = list.stream().toArray(String[]::new);
Arrays.stream(str).forEach(System.out::print);    //prints: abc

```

第一个例子很简单。 它将元素转换为相同类型的数组。 至于第二示例，`IntFunction`的表示为`String[]::new`可能不明显，所以让我们走过它。 `String[]::new`是表示 Lambda 表达式`i -> new String[i]`的方法引用，因为`toArray()`操作从流中接收不是元素，但它们的计数：

```
String[] str = list.stream().toArray(i -> new String[i]);
```

我们可以通过添加`i`值的打印来证明它：

```
String[] str = list.stream()
                   .toArray(i -> {
                          System.out.println(i);    //prints: 3
                          return  new String[i];
                   });

```

`i -> new String[i]`表达式是`IntFunction<String[]>`，根据其文档，接受`int`参数并返回指定类型的结果。 它可以使用匿名类定义，如下所示：

```
IntFunction<String[]> intFunction = new IntFunction<String[]>() { 
         @Override 
         public String[] apply(int i) { 
              return new String[i]; 
         } 
}; 
```

`java.util.Collection`接口具有非常类似的方法，将集合转换为数组：

```
List<String> list = List.of("a", "b", "c");
String[] str = list.toArray(new String[lits.size()]);
Arrays.stream(str).forEach(System.out::print);    //prints: abc

```

唯一的区别是`Stream`接口的`toArray()`接受函数，而`Collection`接口的`toArray()`采用阵列。

# 减少

该终端操作称为`reduce`，因为它处理所有流元素并产生一个值，从而将所有流元素还原为一个值。 但这不是唯一的操作。 `collect`操作也将流元素的所有值减少到一个结果。 并且，在某种程度上，所有终端操作都是还原的。 它们在处理许多元素后产生一个值。

因此，您可以查看`reduce`和`collect`作为帮助将结构和分类添加到`Stream`接口中可用的许多操作的同义词。 此外，可以将`reduce`组中的操作视为`collect`操作的专用版本，因为可以根据`collect()`定制以提供与`reduce()`操作相同的功能。

也就是说，让我们来看看一组`reduce`操作：

*   `Optional<T> reduce(BinaryOperator<T> accumulator)`：使用提供的关联函数缩减元素的带有关联函数来减少流的元素; 如果可用，则返回一个`Optional`的值
*   `T reduce(T identity, BinaryOperator<T> accumulator)`：提供与前一个`reduce()`版本相同的功能，但如果流为空，则使用用作累加器的初始值或默认值的标识参数
*   `U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)`：提供与上一个`reduce()`版本相同的功能，但另外，使用`combiner`功能在将该操作应用于并行流时聚合结果; 如果流不行，则不使用`combiner`功能

要演示`reduce()`操作，我们将使用我们之前使用的`Person`类和`Person`对象的相同列表作为我们的流示例的源：

```
List<Person> persons = List.of(new Person(23, "Bob"),
                               new Person(33, "Jim"),
                               new Person(28, "Jill"),
                               new Person(27, "Bill"));
```

让我们使用`reduce()`操作找到此列表中最古老的人：

```
Person theOldest = list.stream()
              .reduce((p1, p2) -> p1.getAge() > p2.getAge() ? p1 : p2)
              .orElse(null);
System.out.println(theOldest);    //prints: Person{name='Jim', age=33}

```

实施有点令人惊讶，不是吗？ `reduce()`操作需要累加器，但似乎它没有累积任何东西。 相反，它比较了所有流元素。 嗯，累加器会保存比较结果，并将其作为下一个比较的第一个参数（使用下一个元素）提供。 您可以说累加器，在这种情况下，累积了所有先前比较的结​​果。

我们现在明确累积了一些东西。 让我们从一个逗号分隔的列表中从一个人列表中组装所有名称：

```
String allNames = list.stream()
                      .map(p -> p.getName())
                      .reduce((n1, n2) -> n1 + ", " + n2)
                      .orElse(null);
System.out.println(allNames);            //prints: Bob, Jim, Jill, Bill

```

积累的概念，在这种情况下，有点意义，不是吗？

现在让我们使用`identity`值来提供一些初始值：

```
String all = list.stream()
                 .map(p -> p.getName())
                 .reduce("All names: ", (n1, n2) -> n1 + ", " + n2);
System.out.println(all);   //prints: All names: , Bob, Jim, Jill, Bill

```

请注意，此版本的`reduce()`操作返回`value`，而不是`Optional`对象。 也就是说，通过提供初始值，我们保证至少该值将存在于结果中，如果流偏离为空。 但结果的字符串看起来并不像我们希望一样漂亮。 显然，所提供的初始值被视为任何其他流元素，并且在我们创建的累加器之后添加逗号。 要使结果再次看起来很漂亮，我们可以再次使用`reduce()`操作的第一个版本并以这种方式添加初始值：

```
String all = "All names: " + list.stream()
                                 .map(p -> p.getName())
                                 .reduce((n1, n2) -> n1 + ", " + n2)
                                 .orElse(null);
System.out.println(all);     //prints: All names: Bob, Jim, Jill, Bill
```

或者我们可以使用空格作为分隔符而不是逗号：

```
String all = list.stream()
                 .map(p -> p.getName())
                 .reduce("All names:", (n1, n2) -> n1 + " " + n2);
System.out.println(all);     //prints: All names: Bob Jim Jill Bill
```

现在结果看起来更好。 虽然在下一个小节中展示`collect()`操作，我们将显示更好的方法来创建具有前缀的逗号分隔的值列表。

同时，让我们继续查看`reduce()`操作并查看其第三种形式：具有三个参数的第三种形式：`identity`，`accumulator`和`combiner`。 将组合器添加到`reduce()`操作不会改变结果：

```
String all = list.stream()
                 .map(p -> p.getName())
                 .reduce("All names:", (n1, n2) -> n1 + " " + n2,
                                       (n1, n2) -> n1 + " " + n2 );
System.out.println(all);      //prints: All names: Bob Jim Jill Bill

```

这是因为流不是平行的，并且组合器仅使用并行流使用。 如果我们并行进行流，结果会发生变化：

```
String all = list.parallelStream()
                 .map(p -> p.getName())
                 .reduce("All names:", (n1, n2) -> n1 + " " + n2,
                                       (n1, n2) -> n1 + " " + n2 );
System.out.println(all); 
  //prints: All names: Bob All names: Jim All names: Jill All names: Bill
```

显然，对于平行流，元件序列被分解为局部，每个分别处理，它们由组合器聚集它们的结果。 在这样做的同时，组合器将初始值（Identity）添加到每个结果中。 即使我们删除组合器，并行流处理的结果也保持不变，因为提供了默认组合行为：

```
String all = list.parallelStream()
                 .map(p -> p.getName())
                 .reduce("All names:", (n1, n2) -> n1 + " " + n2);
System.out.println(all); 
  //prints: All names: Bob All names: Jim All names: Jill All names: Bill
```

在前两种形式的`reduce()`操作中，累加器使用标识值。 在第三种形式中，组合器使用身份值（注意，`U`类型是组合器类型）。 要在结果中删除重复标识值，我们已决定从组合器中的第二个参数中删除它（和尾部空间）：

```
String all = list.parallelStream().map(p->p.getName())
                 .reduce("All names:", (n1, n2) -> n1 + " " + n2,
       (n1, n2) -> n1 + " " + StringUtils.remove(n2, "All names: "));
System.out.println(all);      //prints: All names: Bob Jim Jill Bill 
```

结果如预期的那样。

到目前为止，在基于字符串的示例中，身份不仅仅是初始值。 它还用作生成的字符串中的标识符（标签）。 但是，当流的元素是数字时，身份看起来更像是初始值。 让我们来看看以下例子：

```
List<Integer> ints = List.of(1, 2, 3);
int sum = ints.stream()
              .reduce((i1, i2) -> i1 + i2)
              .orElse(0);
System.out.println(sum);                          //prints: 6
sum = ints.stream()
          .reduce(Integer::sum)
          .orElse(0);
System.out.println(sum);                          //prints: 6
sum = ints.stream()
          .reduce(10, Integer::sum);
System.out.println(sum);                         //prints: 16
sum = ints.stream()
          .reduce(10, Integer::sum, Integer::sum);
System.out.println(sum);                         //prints: 16

```

除了第二管线使用方法参考之外，前两个管道完全相同。 第三个和第四管道也具有相同的功能。 它们都使用`10`的初始值。 现在第一个参数更有意义与初始值比身份更有意义，不是吗？ 在第四个管道中，我们添加了一个组合器，但没有使用，因为流不是并行的。 让我们并行，看看会发生什么：

```
List<Integer> ints = List.of(1, 2, 3);
int sum = ints.parallelStream()
              .reduce(10, Integer::sum, Integer::sum);
System.out.println(sum);                        //prints: 36
```

结果是`36`，因为`10`的初始值被添加三次，每个部分结果都有三次。 显然，溪流被分为三个子次序。 但情况并非总是如此，因为随后随着流的变化，随着流的增长和计算机上的 CPU 的数量增加，情况并不总是如此。 这就是为什么你不能依赖某个固定数量的子序列，最好不要使用并行流使用非零初始值：

```
List<Integer> ints = List.of(1, 2, 3);
int sum = ints.parallelStream()
              .reduce(0, Integer::sum, Integer::sum);
System.out.println(sum);                             //prints: 6
sum = 10 + ints.parallelStream()
               .reduce(0, Integer::sum, Integer::sum);
System.out.println(sum);                             //prints: 16

```

正如您所看到的，我们已将身份设置为`0`，因此每个子序列都会得到它，但是当组合器组装所有处理线程的结果时，总数不受影响。

# 搜集

`collect()`操作的一些用途非常简单，可以通过任何初学者容易地掌握，而其他情况也可以复杂，即使对于经验丰富的程序员，也不容易理解。 与已经讨论的操作一起，`collect()`使用的最受欢迎的案例我们在本节中呈现的是，对于初学者可能拥有的所有需求，我们都足够了，并将涵盖更有经验的专业人士的大多数需求。 与数字流的操作一起（参见下一节*数字流接口*），它们涵盖了主流程序员将拥有的所有需求。

正如我们已经提到的那样，`collect()`操作非常灵活，并允许我们自定义流处理。 它有两种形式：

*   `R collect(Collector<T, A, R> collector)`：使用提供的`Collector`处理`T`类型的流元素，并通过`A`的中间累积产生`R`的结果
*   `R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R, R> combiner)`：使用提供的功能处理`T`类型的流元素：
    *   `Supplier<R> supplier`：创建一个新的结果容器
    *   `BiConsumer<R, T> accumulator`：一个无状态函数，用于将元素添加到结果容器
    *   `BiConsumer<R, R> combiner`：合并两个部分结果容器的无状态函数：将元素从第二个结果容器添加到第一个结果容器中

让我们先看看`collect()`操作的第二种形式。 它与具有三个参数的`reduce()`操作非常相似我们刚刚演示的三个参数：`supplier`，`accumulator`和`combiner`。 最大的区别是`collect()`操作中的第一个参数不是身份或初始值，而是容器，一个对象，该对象将在函数之间传递，并且维护处理的状态。

让我们通过从`Person`对象列表中选择最古老的人来演示它是如何工作的。 对于以下示例，我们将使用熟悉的`Person`类作为容器，但是添加到它没有参数和两个设置器的构造函数：

```
public Person(){}
public void setAge(int age) { this.age = age;}
public void setName(String name) { this.name = name; }
```

在没有参数和设置的情况下添加构造函数是必要的，因为在没有任何参数的任何时刻，应该可以在任何时刻创建`Person`对象，并且应该能够接收和保留部分结果：最古老的人的名称和年龄 ， 至今。 `collect()`操作将在处理每个元素时使用此容器，并且在处理最后一个元素之后，将包含最旧的名称和年龄。

我们将再次使用相同的人员列表：

```
List<Person> list = List.of(new Person(23, "Bob"),
                            new Person(33, "Jim"),
                            new Person(28, "Jill"),
                            new Person(27, "Bill"));

```

这是`collect()`操作，找到列表中最古老的人：

```
BiConsumer<Person, Person> accumulator = (p1, p2) -> {
    if(p1.getAge() < p2.getAge()){
        p1.setAge(p2.getAge());
        p1.setName(p2.getName());
    }
};
BiConsumer<Person, Person> combiner = (p1, p2) -> {
    System.out.println("Combiner is called!");
    if(p1.getAge() < p2.getAge()){
        p1.setAge(p2.getAge());
        p1.setName(p2.getName());
    }
};
Person theOldest = list.stream()
                       .collect(Person::new, accumulator, combiner);
System.out.println(theOldest);     //prints: Person{name='Jim', age=33}

```

我们试图在操作呼叫中彻底联系，但它看起来很难读取，所以我们决定首先创建功能，然后在`collect()`操作中使用它们。 在处理第一个元素之前仅创建一次`Person`对象的容器。 从这个意义上讲，它类似于`reduce()`操作的初始值。 然后它将它传递给累加器，这将其与第一元素进行比较。 容器中的`age`字段被初始化为零的默认值，因此，将第一元素的`age`和`name`设置为迄今为止最旧的人的参数。 当发射第二流元素（`Person`对象）时，将其`age`值与当前存储在容器中的`age`值进行比较，依此类推，直到处理流的所有元素。 结果显示在先前的评论中。

当流是顺序时，永远不会调用组合器。 但是当我们使其并行（`list.parallelStream()`）时，消息组合器被调用！ 打印三次。 嗯，如在`reduce()`操作的情况下，部分结果的数量可能会有所不同，具体取决于 CPU 的数量和`collect()`操作实现的内部逻辑。 所以，消息组合者被称为！ 可以打印任何次数。

现在让我们看看`collect()`操作的第一种形式。 它需要实现`java.util.stream.Collector<T,A,R>`接口的类的对象，其中`T`是流类型，`A`是容器类型，`R`是结果类型。 您可以使用以下方法之一`of()`（从`Collector`接口）创建必要的`Collector`对象：

```
static Collector<T,R,R> of(Supplier<R> supplier, 
                           BiConsumer<R,T> accumulator, 
                           BinaryOperator<R> combiner, 
                           Collector.Characteristics... characteristics)
```

或者

```
static Collector<T,A,R> of(Supplier<A> supplier, 
                           BiConsumer<A,T> accumulator, 
                           BinaryOperator<A> combiner, 
                           Function<A,R> finisher, 
                           Collector.Characteristics... characteristics).
```

您必须传递给前面方法的功能与我们已经展示的功能类似。 但是我们不会这样做，有两个原因。 首先，它更有涉及，推动我们超越本书的范围，而且在这样做之前，您必须在`java.util.stream.Collectors`类中，提供许多即用的收集器。

正如我们已经提到的那样，与到目前为止所讨论的操作以及我们将在下一节中展示的数字流操作一起，即可使用的收集器在主流编程中涵盖绝大多数处理需求，并且有 您永远不需要创建自定义收集器的好机会。

# 收藏家

`java.util.stream.Collectors`类提供了 40 多种创建`Collector`对象的方法。 我们将仅展示最简单，最流行的：

*   `Collector<T,?,List<T>> toList()`：创建从流元素生成`List`对象的收集器
*   `Collector<T,?,Set<T>> toSet()`：创建从流元素生成`Set`对象的收集器
*   `Collector<T,?,Map<K,U>> toMap (Function<T,K> keyMapper, Function<T,U> valueMapper)`：创建从流元素生成`Map`对象的收集器
*   `Collector<T,?,C> toCollection (Supplier<C> collectionFactory)`：创建一个收集器，它生成`Collection`由`Supplier<C> collectionFactory`提供的类型的对象
*   `Collector<CharSequence,?,String> joining()`：通过连接流元素创建生成`String`对象的收集器
*   `Collector<CharSequence,?,String> joining (CharSequence delimiter)`：创建一个收集器，该收集器从流元素生成分隔符分隔的`String`对象
*   `Collector<CharSequence,?,String> joining (CharSequence delimiter, CharSequence prefix, CharSequence suffix)`：创建一个收集器，从流元素生成分隔符分离的`String`对象，并添加指定的`prefix`和`suffix`
*   `Collector<T,?,Integer> summingInt(ToIntFunction<T>)`：创建收集器，该收集器计算应用于每个元素的提供的功能生成的结果的总和; `long`和`double`类型存在相同的方法
*   `Collector<T,?,IntSummaryStatistics> summarizingInt(ToIntFunction<T>)`：创建一个收集器，计算由所应用的函数生成的结果的总和，min，max，count 和平均值; `long`和`double`类型存在相同的方法
*   `Collector<T,?,Map<Boolean,List<T>>> partitioningBy (Predicate<? super T> predicate)`：创建一个收集器，将元素与提供的`Predicate`函数分开
*   `Collector<T,?,Map<K,List<T>>> groupingBy(Function<T,U>)`：将元素与提供的函数生成的键组成一个收集器，该收集器将元素与`Map`一起组成

以下演示代码显示如何使用列出的方法创建的收集器。 首先，我们证明了`toList()`，`toSet()`，T `oMap()`和`toCollection()`方法的用法：

```
List<String> ls = Stream.of("a", "b", "c")
                        .collect(Collectors.toList());
System.out.println(ls);                //prints: [a, b, c]

Set<String> set = Stream.of("a", "a", "c")
                        .collect(Collectors.toSet());
System.out.println(set);                //prints: [a, c]

List<Person> list = List.of(new Person(23, "Bob"),
                            new Person(33, "Jim"),
                            new Person(28, "Jill"),
                            new Person(27, "Bill"));
Map<String, Person> map = list.stream()
                              .collect(Collectors
                              .toMap(p -> p.getName() + "-" + 
                                          p.getAge(), p -> p));
System.out.println(map); //prints: {Bob-23=Person{name='Bob', age:23},
                         //         Bill-27=Person{name='Bill', age:27},
                         //         Jill-28=Person{name='Jill', age:28},
                         //         Jim-33=Person{name='Jim', age:33}}

Set<Person> personSet = list.stream()
                            .collect(Collectors
                            .toCollection(HashSet::new));
System.out.println(personSet);  //prints: [Person{name='Bill', age=27},
                                //         Person{name='Jim', age=33},
                                //         Person{name='Bob', age=23},
                                //         Person{name='Jill', age=28}]
```

`joining()`方法允许在分隔列表中连接`Character`和`String`值，其中`prefix`和`suffix`：

```
List<String> list1 = List.of("a", "b", "c", "d");
String result = list1.stream()
                     .collect(Collectors.joining());
System.out.println(result);                    //prints: abcd

result = list1.stream()
              .collect(Collectors.joining(", "));
System.out.println(result);                 //prints: a, b, c, d

result = list1.stream()
              .collect(Collectors.joining(", ", "The result: ", ""));
System.out.println(result);           //prints: The result: a, b, c, d

result = list1.stream()
        .collect(Collectors.joining(", ", "The result: ", ". The End."));
System.out.println(result);    //prints: The result: a, b, c, d. The End.
```

现在让我们转向`summingInt()`和`summarizingInt()`方法。 他们创建了计算由应用于每个元素所生产的`int`值的总和和其他统计数据的集合器：

```
List<Person> list2 = List.of(new Person(23, "Bob"),
                             new Person(33, "Jim"),
                             new Person(28, "Jill"),
                             new Person(27, "Bill"));
int sum = list2.stream()
               .collect(Collectors.summingInt(Person::getAge));
System.out.println(sum);                 //prints: 111

IntSummaryStatistics stats = list2.stream()
           .collect(Collectors.summarizingInt(Person::getAge));
System.out.println(stats); //prints: IntSummaryStatistics{count=4,
                           //sum=111, min=23, average=27.750000, max=33}
System.out.println(stats.getCount());    //prints: 4
System.out.println(stats.getSum());      //prints: 111
System.out.println(stats.getMin());      //prints: 23
System.out.println(stats.getAverage());  //prints: 27.750000
System.out.println(stats.getMax());      //prints: 33
```

还有`summingLong()`，`summarizingLong()`，`summingDouble()`和`summarizingDouble()`方法。

`partitioningBy()`方法创建收集器，该收集器通过提供的条件组分组元素，并将`Map`对象中的组（列表）与`boolean`值作为键：

```
Map<Boolean, List<Person>> map2 = list2.stream()
       .collect(Collectors.partitioningBy(p -> p.getAge() > 27));
System.out.println(map2);
     //{false=[Person{name='Bob', age=23}, Person{name='Bill', age=27},
     //  true=[Person{name='Jim', age=33}, Person{name='Jill', age=28}]}

```

正如您所看到的，使用`p.getAge() > 27`标准，我们能够将所有人放入两组：一个人低于或等于`27`的`27`（关键是`false`），另一个是 以上`27`（关键是`true`）。

最后，`groupingBy()`方法允许通过值分组元素，并将其中`Map`对象中的组（列表）放在其中值作为键：

```
List<Person> list3 = List.of(new Person(23, "Bob"),
                             new Person(33, "Jim"),
                             new Person(23, "Jill"),
                             new Person(33, "Bill"));
Map<Integer, List<Person>> map3 = list3.stream()
                       .collect(Collectors.groupingBy(Person::getAge));
System.out.println(map3);  
      // {33=[Person{name='Jim', age=33}, Person{name='Bill', age=33}], 
      //  23=[Person{name='Bob', age=23}, Person{name='Jill', age=23}]} 
```

为了能够演示此方法，我们通过将`age`设置为`23`或`33`来更改`Person`对象列表。 结果是由其`age`订购的两组。

还有过载`toMap()`，`groupingBy()`和`partitioningBy()`方法以及以下内容，通常也过载，方法创建相应的`Collector`对象：

*   `counting()`
*   `reducing()`
*   `filtering()`
*   `toConcurrentMap()`
*   `collectingAndThen()`
*   `maxBy()`，`minBy()`
*   `mapping()`，`flatMapping()`
*   `averagingInt()`，`averagingLong()`，`averagingDouble()`
*   `toUnmodifiableList()`，`toUnmodifiableMap()`，`toUnmodifiableSet()`

如果您无法在本书中讨论的那些中找到所需的操作，请先在构建您自己的`Collector`对象之前先搜索`Collectors` API。

# 数字流界面

正如我们已经提到的那样，所有三个数字接口`IntStream`，`LongStream`和`DoubleStream`都具有与接口`Stream`中的方法类似的方法，包括接口`Stream.Builder`的方法。 这意味着我们到目前为止在本章中讨论的一切都适用于任何数字流接口。 这就是为什么在本节中我们只会谈论`Stream`界面中不存在的方法：

*   接口`range(lower,upper)`和`rangeClosed(lower,upper)`方法`IntStream`和`LongStream`接口允许从指定范围中的值创建流
*   中间操作`boxed()`和`mapToObj()`将数字流转换为``Stream``
*   中间操作`mapToInt()`，`mapToLong()`和`mapToDouble()`将一个类型的数字流转换为另一种类型的数字流
*   中间操作`flatMapToInt()`，`flatMapToLong()`和`flatMapToDouble()`将流转换为数字流
*   终端操作`sum()`和`average()`计算数字流元素的总和和平均值

# 创建流

除了创建流的`Stream`接口的方法外，接口`IntStream`和`LongStream`允许从指定范围中的值创建流。

# RNGE（），RANGECLOSED（）

`range(lower, upper)`方法顺序生成所有值，从`lower`值开始，并以`upper`之前的值结尾：

```
IntStream.range(1, 3).forEach(System.out::print);   //prints: 12
LongStream.range(1, 3).forEach(System.out::print);  //prints: 12

```

`rangeClosed(lower, upper)`方法顺序生成所有值，从`lower`值开始，并以`upper`值结尾：

```
IntStream.rangeClosed(1, 3).forEach(System.out::print); //prints: 123
LongStream.rangeClosed(1, 3).forEach(System.out::print);  //prints: 123

```

# 中间行动

除了`Stream`界面的中间操作之外，接口`IntStream`，`LongStream`和`DoubleStream`还具有数量特定的中间操作：`boxed()`，`mapToObj()`，`mapToInt()`，`mapToLong()` ，`mapToDouble()`，`flatMapToInt()`，`flatMapToLong()`和`flatMapToDouble()`。

# 盒装（），maptoobj（）

中间操作`boxed()`将原始数字类型的（框）转换为相应的包装器类型：

```
    //IntStream.range(1, 3).map(Integer::shortValue) //compile error
    //                  .forEach(System.out::print);

    IntStream.range(1, 3)
             .boxed()
             .map(Integer::shortValue)
             .forEach(System.out::print);            //prints: 12

    //LongStream.range(1, 3).map(Long::shortValue)   //compile error
    //                .forEach(System.out::print);

    LongStream.range(1, 3)
              .boxed()
              .map(Long::shortValue)
              .forEach(System.out::print);           //prints: 12

    //DoubleStream.of(1).map(Double::shortValue)     //compile error
    //              .forEach(System.out::print);

    DoubleStream.of(1)
                .boxed()
                .map(Double::shortValue)
                .forEach(System.out::print);         //prints: 1
```

在前面的代码中，我们已评论出生成编译错误的行，因为`range()`方法生成的元素是原始类型。 `boxed()`操作将原始值转换为相应的包装类型，因此可以将其处理为参考类型。 中间操作`mapToObj()`进行类似的转换，但它不像`boxed()`操作一样，允许使用原始类型的元素生成任何类型的对象：

```
IntStream.range(1, 3)
         .mapToObj(Integer::valueOf)
         .map(Integer::shortValue)
         .forEach(System.out::print);           //prints: 12

IntStream.range(42, 43)
      .mapToObj(i -> new Person(i, "John"))
      .forEach(System.out::print); //prints: Person{name='John', age=42}

LongStream.range(1, 3)
          .mapToObj(Long::valueOf)
          .map(Long::shortValue)
          .forEach(System.out::print);          //prints: 12

DoubleStream.of(1)
            .mapToObj(Double::valueOf)
            .map(Double::shortValue)
            .forEach(System.out::print);        //prints: 1

```

在前面的代码中，我们添加了`map()`操作只是为了证明`mapToObj()`操作执行作业并以预期创建包装类型的对象。 此外，通过添加产生`Person`对象的管道，我们已经演示了如何使用`mapToObj()`操作来创建任何类型的对象。

# maptoint（），maptolong（），maptodouble（）

中间操作`mapToInt()`，`mapToLong()`，`mapToDouble()`允许将一个类型的数字流转换为另一种类型的数字流。 对于演示目的，我们通过将每个`String`值映射到其长度，将`String`值列表转换为不同类型的数字流：

```
List<String> list = List.of("one", "two", "three");
list.stream()
    .mapToInt(String::length)
    .forEach(System.out::print);               //prints: 335

list.stream()
    .mapToLong(String::length)
    .forEach(System.out::print);               //prints: 335

list.stream()
    .mapToDouble(String::length)
    .forEach(d -> System.out.print(d + " "));  //prints: 3.0 3.0 5.0

list.stream()
    .map(String::length)
    .map(Integer::shortValue)
    .forEach(System.out::print);               //prints: 335

```

创建的数字流的元素是基本类型：

```
//list.stream().mapToInt(String::length)
//             .map(Integer::shortValue) //compile error
//             .forEach(System.out::print);
```

而且，正如我们在此主题所示，如果要将元素转换为数字包装类型，则中间`map()`操作是执行方法（而不是`mapToInt()`）：

```
list.stream().map(String::length)
        .map(Integer::shortValue)
        .forEach(System.out::print);      //prints: 335

```

# flatmaptioint（），flatmaptolong（），flatmaptodouble（）

中间操作`flatMapToInt()`，`flatMapToLong()`，`flatMapToDouble()`产生相应类型的数字流：

```
List<Integer> list = List.of(1, 2, 3);
list.stream()
    .flatMapToInt(i -> IntStream.rangeClosed(1, i))
    .forEach(System.out::print);               //prints: 112123

list.stream()
    .flatMapToLong(i -> LongStream.rangeClosed(1, i))
    .forEach(System.out::print);               //prints: 112123

list.stream()
    .flatMapToDouble(DoubleStream::of)
    .forEach(d -> System.out.print(d + " "));  //prints: 1.0 2.0 3.0

```

正如您在前面的代码中看到的那样，我们在原始流中使用了`int`值。 但它可以是任何类型的流：

```
List.of("one", "two", "three")
    .stream()
    .flatMapToInt(s -> IntStream.rangeClosed(1, s.length()))
    .forEach(System.out::print);             //prints: 12312312345

```

# 终端运营

数字特定的终端操作非常简单。 其中两个是：

*   `sum()`：计算数字流元素的总和
*   `average()`：计算数字流元素的平均值

# um（），平均（）

如果需要计算数字流元素的值或平均值，则流的唯一要求是它不应该是无限的。 否则，计算从未完成过。 以下是这些操作的示例：

```
int sum = IntStream.empty()
                   .sum();
System.out.println(sum);            //prints: 0

sum = IntStream.range(1, 3)
               .sum();
System.out.println(sum);            //prints: 3

double av = IntStream.empty()
                     .average()
                     .orElse(0);
System.out.println(av);             //prints: 0.0

av = IntStream.range(1, 3)
              .average()
              .orElse(0);
System.out.println(av);             //prints: 1.5

long suml = LongStream.range(1, 3)
                      .sum();
System.out.println(suml);           //prints: 3

double avl = LongStream.range(1, 3)
                       .average()
                       .orElse(0);
System.out.println(avl);            //prints: 1.5

double sumd = DoubleStream.of(1, 2)
                          .sum();
System.out.println(sumd);           //prints: 3.0

double avd = DoubleStream.of(1, 2)
                         .average()
                         .orElse(0);
System.out.println(avd);            //prints: 1.5

```

如您所见，在空流上使用这些操作不是问题。

# 并行流

我们已经看到，如果代码未写入和测试以处理并行流，则从顺序流从顺序流更改为不正确的结果。 以下是与并行流相关的一些考虑因素。

# 无国籍和有状态的操作

存在**无状态操作**，例如`filter()`，`map()`和`flatMap()`，其不会在从一个流元素到下一个流元素的处理时保持数据（不保持状态）。 并且存在有状态操作，例如`distinct()`，`limit()`，`sorted()`，`reduce()`和`collect()`，其可以将状态从先前处理的元件传递到下一个元素的处理。

无状态操作通常不会在从顺序流切换到平行的时构成问题。 每个元素独立处理，并且可以将流丢弃到任何数量的用于独立处理的子流中。 具有有状态操作，情况不同。 首先，将它们用于无限流可能永远不会完成处理。 此外，在讨论有状态操作`reduce()`和`collect()`的同时，我们已经证明了如果设置初始值（或标识）而不考虑并行处理，则证明了如何切换到并行流可以产生不同的结果。

而且也有绩效考虑因素。 有状态操作通常需要使用缓冲处理多个传递中的所有流元素。 对于大型溪流，它可能会纳税资源并减慢，如果没有完全关闭，应用程序。

这就是为什么程序员不应该轻轻地从顺序切换到并行流。 如果涉及有状态操作，则必须设计和测试代码以便能够执行并行流处理而不会产生负面影响。

# 顺序或并行处理？

正如我们在上一节中所示的那样，并行处理可能或不产生更好的性能。 在决定使用并行流之前，您必须测试每个用例。 并行性可以产生更好的性能，但必须设计和可能优化的代码来进行。 并且每个假设必须在尽可能接近生产的环境中进行测试。

但是，有几个考虑因素，同时决定顺序和并行处理：

*   通常按顺序处理小流（嗯，应通过测试和测量性能来确定对环境的*的*较小的*。***
*   如果无法用无状态操作替换的状态操作，请仔细设计并行处理的代码或只是避免它
*   考虑对需要大量计算的程序的并行处理，但考虑将部分结果集中在一起进行最终结果

# 概括

在本章中，我们讨论了数据流处理，这些处理与处理我们在[第 5 章](05.html)，*字符串，输入/输出和文件*中审阅的 I / O 流不同。 我们定义了数据流是什么，如何使用流操作处理其元素，以及如何在管道中链式（连接）流操作。 我们还讨论了流初始化以及如何并行处理流。

在下一章中，读者将被引入**反应性宣言**，其推力和其实现的例子。 我们将讨论反应性和响应系统之间的差异，以及什么**异步**和**非阻塞**处理。 我们还将讨论**反应流**和 **Rxjava** 。

# 测验

1.  I / O 流和`java.util.stream.Stream`之间有什么区别？ 选择所有符合条件的：
    1.  I / O 流朝向数据传递定向，而`Stream`面向数据处理
    2.  一些 I / O 流可以转换为`Stream`
    3.  可以从文件中读取 I / O 流，而`Stream`不能
    4.  I / O 流可以写入文件，而`Stream`不能

2.  `Stream`方法`empty()`和`of(T... values)`有什么共同之处？
3.  `Stream.ofNullable(Set.of(1,2,3 )`流发出的元素是什么类型？
4.  以下代码打印是什么？

```
Stream.iterate(1, i -> i + 2)
      .limit(3)
      .forEach(System.out::print);
```

5.  以下代码打印是什么？

```
Stream.concat(Set.of(42).stream(), 
             List.of(42).stream()).limit(1)
                                  .forEach(System.out::print);
```

6.  以下代码打印是什么？

```
Stream.generate(() -> 42 / 2)
      .limit(2)
      .forEach(System.out::print);
```

7.  是`Stream.Builder`功能界面？
8.  以下流发出多少元素？

```
new Random().doubles(42).filter(d -> d >= 1)
```

9.  以下代码打印是什么？

```
Stream.of(1,2,3,4)
        .skip(2)
        .takeWhile(i -> i < 4)
        .forEach(System.out::print);
```

10.  以下代码中`d`的值是多少？

```
double d = Stream.of(1, 2)
                 .mapToDouble(Double::valueOf)
                 .map(e -> e / 2)
                 .sum();
```

11.  以下代码中`s`字符串的值是多少？

```
String s = Stream.of("a","X","42").sorted()
 .collect(Collectors.joining(","));
```

12.  以下代码的结果是什么？

```
List.of(1,2,3).stream()
              .peek(i -> i > 2 )
              .forEach(System.out::print);
```

13.  以下代码中的`peek()`操作打印了多少流元素？

```
List.of(1,2,3).stream()
              .peek(System.out::println)
              .noneMatch(e -> e == 2);

```

14.  `or()`方法返回什么时候`Optional`对象为空？
15.  以下代码中`s`字符串的值是多少？

```
String s = Stream.of("a","X","42")
 .max(Comparator.naturalOrder())
 .orElse("12");
```

16.  `IntStream.rangeClosed(42, 42)`流发出多少个元素？
17.  名称两个无状态操作。
18.  名称两个有状态操作。