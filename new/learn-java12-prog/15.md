# 反应规划

在本章中，读者将被引入**反应性宣言**和反应编程世界。 我们从定义和讨论主要相关概念 - 异步，非阻塞和响应。 使用它们，我们然后更详细地定义和讨论反应性编程，主反框架，并讨论 **rxjava** 。

本章将介绍以下主题：

*   异步处理
*   非阻塞 API
*   反应 - 响应，弹性，弹性，信息驱动
*   反应溪流
*   rxjava.

# 异步处理

**异步**意味着请求者立即获得响应，但结果不存在。 相反，请求者等待直到结果发送到它们，或保存在数据库中，或者例如，呈现为允许检查结果是否已准备就绪的对象。 如果后者是这种情况，请求者会定期调用此对象的某些方法，并且当结果准备就绪时，使用同一对象上的另一种方法检索它。 异步处理的优点是请求者在等待时可以做其他事情。

在 [第 8 章](08.html)，，*多线程和并发处理*，我们已经演示了如何创建子线程。 然后，这样的子线程发送非异步（阻塞）请求，并等待其返回无效。 同时，主线程继续执行并定期调用子线程对象以查看结果是否已准备就绪。 这是异步处理实现中最基本的。 事实上，我们已经使用了并行流时使用了它。

创建子线程的场景后面的并行流操作将流分解为段，并将每个段分配给专用线程以进行处理，然后将部分结果与所有段聚合到最终结果。 在上一章中，我们甚至具有汇总作业的书面函数。 作为提醒，该功能称为**组合器**。

让我们使用示例进行比较顺序和并行流的性能。

# 顺序和并行流

为了展示顺序和并行处理之间的差异，让我们想象一个系统从 10 个物理设备（传感器）中收集数据并计算平均值。 以下是从 ID 标识的传感器收集测量的`get()`方法：

```
double get(String id){
    try{
        TimeUnit.MILLISECONDS.sleep(100);
    } catch(InterruptedException ex){
        ex.printStackTrace();
    }
    return id * Math.random();
}
```

我们已经延迟了 100 毫秒，以模仿收集测量从传感器所需的时间。 至于产生的测量值，我们使用`Math.random()`方法。 我们将使用`MeasuringSystem`类的对象调用此`get()`方法，该方法属于该方法。

然后我们将计算平均 - 抵消单个设备的错误和其他特质：

```
void getAverage(Stream<Integer> ids) {
    LocalTime start = LocalTime.now();
    double a = ids.mapToDouble(id -> new MeasuringSystem().get(id))
                  .average()
                  .orElse(0);
    System.out.println((Math.round(a * 100.) / 100.) + " in " +
          Duration.between(start, LocalTime.now()).toMillis() + " ms");
}
```

请注意，我们如何使用`mapToDouble()`操作将 ID 流流转换为`DoubleStream`，因此我们可以应用`average()`操作。 `average()`操作返回一个`Optional<Double>`对象，我们调用其`orElse(0)`方法返回计算值或零（例如，测量系统无法连接到其任何传感器并返回空流 ）。

`getAverage()`方法的最后一行打印结果，计算它所花费的时间。 在实际代码中，我们将返回结果并将其用于其他计算。 但是，对于示范，我们只是打印它。

现在我们可以使用并行处理的性能进行比较顺序流处理的性能：

```
List<Integer> ids = IntStream.range(1, 11)
                             .mapToObj(i -> i)
                             .collect(Collectors.toList());
getAverage(ids.stream());          //prints: 2.99 in 1030 ms
getAverage(ids.parallelStream());  //prints: 2.34 in  214 ms

```

如果您运行此示例，结果可能会有所不同，因为您可以调用，我们将收集的测量值模拟为随机值。

如您所见，并行流的处理比顺序流的处理快五倍。 结果是不同的，因为测量每次产生略有不同的结果。

虽然在幕后，并行流使用异步处理，这不是谈论谈论的异步处理时的程序员。 从应用程序的角度来看，它只是并行（也称为并发）处理。 它比顺序处理更快，但主线程必须等到所有呼叫都进行，并且检索数据。 如果每个呼叫至少需要 100 毫秒（就像在我们的情况下），那么在更少的时间内就无法完成所有呼叫的处理。

当然，我们可以创建一个子线程，让它让所有呼叫等待，直到它们完成，而主线程就会做其他事情。 我们甚至可以创建一个这样的服务，因此应用程序只会判断这项服务必须完成的内容，然后继续做其他事情。 稍后，主线程可以再次调用服务并在某些商定的位置中获取结果或拾取它。

这将是程序员正在谈论的真正异步处理。 但是，在编写这样的代码之前，让我们来看看位于`java.util.concurrent`包中的`CompletableFuture`类。 它确实描述了一切，甚至更多。

# 使用 performablefuture 对象

使用`CompletableFuture`对象，我们可以通过从`CompletableFuture`对象中的结果分开向测量系统发送请求。 这正是我们在解释异步处理的同时描述的场景。 让我们在代码中展示它：

```
List<CompletableFuture<Double>> list = 
     ids.stream()
        .map(id -> CompletableFuture.supplyAsync(() -> 
                                       new MeasuringSystem().get(id)))
        .collect(Collectors.toList());
```

`supplyAsync()`方法不等待对测量系统的调用返回。 相反，它立即创建一个`CompletableFuture`对象并返回它，以便客户端可以随时使用此对象来检索测量系统返回的值：

```
LocalTime start = LocalTime.now();
double a = list.stream()
               .mapToDouble(cf -> cf.join().doubleValue())
               .average()
               .orElse(0);
System.out.println((Math.round(a * 100.) / 100.) + " in " +
     Duration.between(start, LocalTime.now()).toMillis() + " ms"); 
                                               //prints: 2.92 in 6 ms
```

还有方法允许检查是否返回了该值，但这不是本演示的重点，这是为了展示如何使用`CompletableFuture`类来组织异步处理。

提供的`CompletableFuture`对象的创建列表可以存储在任何位置并非常快速地处理（在我们的情况下在 6 毫秒内），只要已经收到了测量。 在创建`CompletableFuture`对象列表之间并处理它们之间，系统不会被阻止，可以做其他事情。

`CompletableFuture`类具有许多其他类和接口的方法和支持。 例如，可以添加固定大小的线程池以限制线程数：

```
ExecutorService pool = Executors.newFixedThreadPool(3);
List<CompletableFuture<Double>> list = ids.stream()
        .map(id -> CompletableFuture.supplyAsync(() -> 
                         new MeasuringSystem().get(id), pool))
        .collect(Collectors.toList());

```

有各种这种游泳池，用于不同的目的和不同的性能。 但所有这些都不会改变整体系统设计，所以我们省略了这些细节。

正如您所看到的，异步处理的力量很大。 还有一个名为**非阻塞 API** 的异步 API 的变化，我们将在下一节中讨论。

# 非阻塞 API

非阻塞 API 的客户端期望快速获取结果，即没有被阻止大量时间。 因此，非阻塞 API 的概念意味着高度响应的应用。 它可以同步或异步地处理请求 - 这对客户端无关紧要。 然而，在实践中，这通常意味着应用程序使用异步处理，这有助于增加吞吐量和改进的性能。

术语**非阻塞**与`java.nio`封装一起使用。 **非阻塞输入/输出**（ **NIO** ）提供了对密集输入/输出操作的支持。 它描述了如何实现应用程序：它不会将执行线程专用于每个请求，但提供了几个轻量级工作线程，该线程异步和同时执行处理。

# java.io 包与 java.nio 包

从外部存储器（例如硬盘驱动器）写入和读取数据是比仅存储器中的过程更慢的操作。 `java.io`封装的已存在的类和接口运行良好，但偶尔成了性能瓶颈。 创建了新的`java.nio`包以提供更有效的 I / O 支持。

`java.io`实现基于 I / O 流处理。 正如我们在上一节中看到的那样，即使在幕后发生某种并发性，它基本上是一个阻塞操作。 为了提高速度，基于读/写入存储器中的缓冲区来引入`java.nio`实现。 这样的设计允许它分离填充/清空缓冲区的缓慢过程，并快速读取/写入它。

在某种程度上，它类似于我们在`CompletableFuture`用法的示例中所做的。 在缓冲器中具有数据的额外优点是可以检查数据，沿缓冲区一起返回，这在从流中顺序读取时不可能。 它在数据处理期间提供了更大的灵活性。 此外，`java.nio`实现引入了另一个称为**信道**的中间人处理，用于批量数据传输到缓冲区。

读取线程正在从频道获取数据，只接收目前可用的数据，或者什么都没有（如果频道没有数据）。 如果数据不可用，则线程，而不是剩余阻止，可以执行其他频道 - 从其他频道读取/写入其他频道，例如，我们的`CompletableFuture`示例中的主线程是可以自由地进行的 在测量系统从传感器读取数据时，请完成。

这样，代替将线程专用于一个 I / O 进程，少数工人线程可以提供许多 I / O 进程。 这种解决方案被称为**非阻塞 I / O** 并稍后被应用于其他过程，最突出的是*事件处理在事件循环中*，也称为 **运行循环**。

# 事件/运行循环

许多非阻塞系统基于**事件**（或**运行**）循环 - 连续执行的线程。 它收到事件（请求，消息），然后将它们调度到相应的事件处理程序（工人）。 事件处理程序没有任何特别的特别之处。 它们只是程序员专用的方法（函数），用于处理特定事件类型。

这种设计称为**反应堆设计模式** *。* 围绕处理并发事件和服务请求构建。 它还向**反应性编程**和**反应系统**将*反应*响应事件并同时处理它们。

基于事件循环的设计广泛用于操作系统和图形用户界面中。 它在 Spring WebFlux 中可在 Spring 5 中获得，并在 JavaScript 中实现及其流行的执行环境 Node.js. 最后使用事件循环作为其处理骨干。 Toolkit Vert.x 也在事件循环周围构建。

在采用事件循环之前，将专用线程分配给每个传入请求 - 非常类似于在流处理的演示中。 每个线程都需要分配一定数量的资源，这些资源不是特定于请求的，因此一些资源 - 主要是内存分配 - 被浪费了。 然后，随着请求的数量，CPU 需要将其上下文从一个线程切换到另一个往往允许所有请求的更多或更少的并发处理。 在负载下，切换上下文的开销很大，以影响应用程序的性能。

实现事件循环已解决这两个问题。 它通过避免创建专用于每个请求的线程来消除资源的浪费，并在处理请求之前保持左右。 使用事件循环到位，每个请求只需要捕获其细节所需的更小的内存分配，这使得可以在存储器中保持更多的请求，以便可以同时处理它们。 由于上下文尺寸减少，CPU 上下文切换的开销也变得更小。

非阻塞 API 是实现请求的处理的方式。 它使系统能够处理更大的负载，同时保持高度响应和弹性​​。

# 反应

术语**反应性**通常用于反应性编程和反应系统的背景下。 反应性编程（也称为 RX 编程）基于异步数据流（也称为**无功流**）。 它被引入 Java 的**反应扩展**（ **RX** ），也称为 **RxJava** （ [http://reactivex.io](http://reactivex.io) ）。 稍后，将 RX 支持添加到`java.util.concurrent`包中的 Java 9 中。 它允许`Publisher`生成数据流，其中`Subscriber`可以异步订阅。

反应流和标准流之间的一个主要差异（也称为**封装中的 **java 8 流**）是反应流的源（发行商）以其自身的速率将元件推动到用户的速率 在标准流中，仅在前一个处理后才会拉动并发出新元素。**

如您所见，即使没有此新 API，我们也能够异步处理数据，使用`CompletableFuture`。 但是在写这样的代码之后几次，你注意到大多数代码只是管道，所以你会感觉到必须更简单，更方便的解决方案。 这就是反应流倡议的方式（ [http://www.revective-streams.org](https://www.reactive-streams.org/) ）出生。 努力的范围定义如下：

*"The scope of Reactive Streams is to find a minimal set of interfaces, methods, and protocols that will describe the necessary operations and entities to achieve the goal – asynchronous streams of data with non-blocking back pressure."*

术语**非阻塞压力**是指异步处理的问题之一：与系统在没有停止（阻塞）的情况下，可以协调进入数据的速度速率的速度 数据输入。 解决方案是通知来源，消费者难以跟上输入。 而且，处理应该以比仅阻塞流程更灵活的方式对进入数据的速率的变化作出反应，因此名称*反应*。

有几个图书馆已经实现了反应流 API：rxjava（ [http://reacectivex.io](http://reactivex.io) ），反应堆（ [https://projectreacrector.io](https://projectreactor.io) ），akka 流（ [https://akka.io/docs](https://akka.io/docs) ）和 vert.x（ [https://vertx.io/](https://vertx.io/) ）是最着名的。 使用 rxjava 或另一个异步流库的编写代码构成*无功编程*。 它实现了反应性宣言（ [https://www.reacectivemanifesto.org](https://www.reactivemanifesto.org) ）作为*响应*，*弹性*， *]弹性*和*消息驱动*。

# 响应

似乎这个术语是不言自明的。 以及时响应的能力是任何系统的主要质量之一。 有很多方法可以实现它。 即使是由足够的服务器和其他基础设施支持的传统阻塞 API 也可以在不断增长的负荷下实现体面的响应性。

无功编程有助于使用较少的硬件。 它具有价格，因为反应代码需要更改我们考虑控制流程的方式。 但经过一段时间，这种新的思维方式变得像任何其他熟悉的技能一样自然。

我们将在以下部分中看到相当多的反应编程示例。

# 有弹性的

失败是不可避免的。 硬件崩溃，软件具有缺陷，收到意外数据，或者取消了未经测试的执行路径 - 任何这些事件或它们的组合都可以随时发生。 *弹性*是系统在意外情况下继续提供预期结果的能力。

它可以使用可部署组件和硬件的冗余来实现，使用系统部件的隔离，使 Domino 效应变得不太可能，使用自动可更换部件设计系统，提高警报，以便例如，合格人员可以干扰。 我们还通过设计作为可弹性系统的一个很好的例子讨论了分布式系统。

分布式架构消除了单点故障。 此外，将系统打破了许多使用消息交换的许多专用组件，允许更好地调整最关键部分的重复，并为其隔离和潜在的故障遏制创造更多机会。

# 松紧带

维持最大可能负载的能力通常与**可伸缩性**相关联。 但是能够在不同负载下保持相同的性能特征，而不是仅在不断增长的负荷下，称为**弹性**。

弹性系统的客户端不应注意空闲周期与峰值负载的周期之间的任何差异。 无阻塞的实施反应风格有助于这种质量。 此外，将程序分解为较小的部分并将其转换为可以独立部署和管理的服务转换为允许的微调资源分配。

这种小型服务称为微服务，其中许多一起包括可伸缩和弹性的反应系统。 我们将在以下部分和下一章中更详细地讨论此类架构。

# 消息驱动

我们已经建立了组件隔离和系统分布是有助于保持系统响应，弹性和弹性的两个方面。 松动和灵活的连接也是支持这些品质的重要条件。 并且反应系统的异步性质根本不会留下设计者其他选择，而是在消息上构建组件之间的通信。

它在每个组件周围创造一个呼吸空间，没有哪些系统将是一个易受各种问题的紧密耦合的巨石，更不用说维护噩梦。

在下一章中，我们将查看可用于构建应用程序作为使用消息进行通信的松散耦合微服务的集合的架构风格。

# 反应溪流

Java 9 中引入的反应流 API 由以下四个接口组成：

```
@FunctionalInterface
public static interface Flow.Publisher<T> {
    public void subscribe(Flow.Subscriber<T> subscriber);
}
public static interface Flow.Subscriber<T> {
    public void onSubscribe(Flow.Subscription subscription);
    public void onNext(T item);
    public void onError(Throwable throwable);
    public void onComplete();
}
public static interface Flow.Subscription {
    public void request(long numberOfItems);
    public void cancel();
}
public static interface Flow.Processor<T,R>
              extends Flow.Subscriber<T>, Flow.Publisher<R> {
}
```

A `Flow.Subscriber`对象可以作为参数传递给`Flow.Publisher<T>`的`subscribe()`方法。 然后，发布者调用订阅者的`onSubscribe()`方法，并将其传递给它作为参数 A `Flow.Subsctiption`对象。 现在，订阅者可以在订阅对象上调用`request(long numberOfItems)`以请求来自发布者的数据。 这就是可以实现**拉模型**的方式，这将其留给订户来决定何时要求其他项目进行处理。 订户可以通过在订阅中调用`cancel()`方法取消订阅发布者服务。

作为返回，Publisher 可以通过调用订户的`onNext()`方法传递给订户的新项目。 当没有更多数据时（发出来自源的所有数据）时，发布者调用订户的`onComplete()`方法。 此外，通过调用订阅者的`onError()`方法，发布者可以告诉订户遇到问题。

`Flow.Processor`界面描述了可以充当订户和发布者的实体。 它允许创建这些处理器的链条（管道），因此订户可以从发布者接收项目，转换它，然后将结果传递给下一个订户或处理器。

在推送模型中，出版商可以调用`onNext()`而不从订户请求。 如果处理速率低于物品出版的速率，则用户可以使用各种策略来缓解压力。 例如，它可以跳过物品或为临时存储器创建缓冲区，希望项目生产将减慢，并且订户将能够赶上。

这是最小的接口集合，该反应流的主动已经定义了支持具有非阻塞压力的异步数据流。 如您所见，它允许订阅者和发布者彼此交谈并协调输入数据的速率，从而实现我们在*反应*部分中讨论的背压问题的各种解决方案。

有很多方法可以实现这些接口。 目前，在 JDK 9 中，只有一个接口的一个实现：`SubmissionPublisher`类实现`Flow.Publisher`。 原因是，应用程序开发人员不应该使用这些接口。 它是一个**服务提供商接口**（ **spi** ），由反应流库的开发人员使用。 如果需要，使用已经提到的已有的已有现有的工具包之一我们已经提到了已提到的 - RxJava，Reactor，Akka Streams，Vert.x 或您喜好的任何其他库。

# rxjava.

我们将使用 **rxjava 2.2.7** （ [http://reactivex.io](http://reactivex.io) ）。 它可以通过以下依赖添加到项目中：

```
<dependency>
    <groupId>io.reactivex.rxjava2</groupId>
    <artifactId>rxjava</artifactId>
    <version>2.2.7</version>
</dependency>
```

让我们首先使用`java.util.stream`包和`io.reactivex`包来比较两个相同功能的实现。 示例程序将非常简单：

*   创建一个整数`1`，`2`，`3`，`4`，`5`流。
*   过滤仅偶数（`2`和`4`）。
*   计算每个过滤器号的平方根。
*   计算所有平方根的总和。

以下是如何使用`java.util.stream`包来实现：

```
double a = IntStream.rangeClosed(1, 5)
                    .filter(i -> i % 2 == 0)
                    .mapToDouble(Double::valueOf)
                    .map(Math::sqrt)
                    .sum();
System.out.println(a);          //prints: 3.414213562373095

```

使用 rxjava 实现的相同功能如下所示：

```
Observable.range(1, 5)
          .filter(i -> i % 2 == 0)
          .map(Math::sqrt)
          .reduce((r, d) -> r + d)
          .subscribe(System.out::println);   //prints: 3.414213562373095

```

rxjava 基于`Observable`对象（播放`Publisher`的角色）和`Observer`向`Observable`订阅并等待要发射的数据。

相比之下，通过`Stream`功能，`Observable`具有显着不同的能力。 例如，一旦关闭，则不能重新打开流，而可以再次使用`Observable`对象。 这是一个例子：

```
Observable<Double> observable = Observable.range(1, 5)
        .filter(i -> i % 2 == 0)
        .doOnNext(System.out::println)    //prints 2 and 4 twice
        .map(Math::sqrt);
observable
        .reduce((r, d) -> r + d)
        .subscribe(System.out::println);  //prints: 3.414213562373095
observable
        .reduce((r, d) -> r + d)
        .map(r -> r / 2)
        .subscribe(System.out::println);  //prints: 1.7071067811865475

```

在前面的示例中，您可以从注释中看到，`doOnNext()`操作被调用两次，这意味着可观察物对象发出的值两次，每次处理管道一次：

![](img/2b3e4ceb-c446-4905-b64c-9a2002794eaf.png)

如果我们不希望`Observable`运行两次，我们可以通过添加`cache()`操作来缓存其数据：

```
Observable<Double> observable = Observable.range(1,5)
        .filter(i -> i % 2 == 0)
        .doOnNext(System.out::println)  //prints 2 and 4 only once
        .map(Math::sqrt)
        .cache();
observable
        .reduce((r, d) -> r + d)
        .subscribe(System.out::println); //prints: 3.414213562373095
observable
        .reduce((r, d) -> r + d)
        .map(r -> r / 2)
        .subscribe(System.out::println);  //prints: 1.7071067811865475

```

如您所见，相同`Observable`的第二个使用率利用了缓存的数据，从而允许更好的性能：

![](img/42bd8994-6da4-4a6a-b67d-cc7283c7abdb.png)

rxjava 提供了如此丰富的功能，无法在本书中详细审核。 相反，我们将尝试涵盖最受欢迎的 API。 API 描述了使用`Observable`对象可用于调用的方法。 这些方法通常也称为**操作**（如同标准 Java 8 流也是如此）或**运算符**（主要用于与反应流有关）。 我们将使用这三个术语，方法，操作和运营商，与同义词相互换换。

# 可观察类型

谈论 rxjava 2 api（注意它与 rxjava 1 完全不同），我们将使用可以在 [http://reactivex.io/rxjava/2.x/javadoc/index.html 上找到的在线文档](http://reactivex.io/RxJava/2.x/javadoc/index.html) 。

观察者订阅从可观察对象接收值，该对象可以表现为以下类型之一：

*   **阻止**：等待直到结果返回
*   **非阻塞**：异步处理发射的元素
*   **cold** ：在观察者的要求下发出元素
*   **hot** ：发射元素是否已订阅或不订阅

可观察对象可以是`io.reactivex `封装的以下类别之一的对象：

*   `Observable<T>`：可以发出无，一个或多个元素; 不支持背压。
*   `Flowable<T>`：可以发出无，一个或多个元素; 支持背压。
*   `Single<T>`：可以发出一个元素或错误; 背压的概念不适用。
*   `Maybe<T>`：代表延迟计算; 可以发出无值，一个值或错误; 背压的概念不适用。
*   `Completable`：表示没有任何值的延迟计算; 表示完成任务或错误; 背压的概念不适用。

这些类中的每一个的对象可以表现为阻塞，非阻塞，冷或热可观察。 它们是不同的，因为可以发出的值数，推迟返回结果的能力，或者仅返回任务完成的标志，并且由于它们处理背压的能力。

# 阻止与非阻塞

要演示此行为，我们创建了一个可观察到的，它从`1`开始发出五个顺序整数：

```
Observable<Integer> obs = Observable.range(1,5);
```

`Observable`的所有阻塞方法（运算符）从“阻塞”开始，因此`blockingLast()`是阻塞运算符之一，它阻止管道，直到排放最后一个元素：

```
Double d2 = obs.filter(i -> i % 2 == 0)
               .doOnNext(System.out::println)  //prints 2 and 4
               .map(Math::sqrt)
               .delay(100, TimeUnit.MILLISECONDS)
               .blockingLast();
System.out.println(d2);                        //prints: 2.0
```

在此示例中，我们仅选择偶数，打印所选元素，然后计算平方根并等待 100 ms（模仿长期计算）。 此示例的结果如下所示：

![](img/ac98bac3-67c0-4610-927e-192d877e2d95.png)

相同功能的非阻塞版本如下：

```
List<Double> list = new ArrayList<>();
obs.filter(i -> i % 2 == 0)
   .doOnNext(System.out::println)  //prints 2 and 4
   .map(Math::sqrt)
   .delay(100, TimeUnit.MILLISECONDS)
   .subscribe(d -> {
        if(list.size() == 1){
            list.remove(0);
        }
        list.add(d);
   });
System.out.println(list);          //prints: []

```

我们使用`List`对象捕获结果，因为如您所知，Lambda 表达式不允许使用非最终变量。

如您所见，生成的列表为空。 这是因为在不阻止（异步）的情况下执行管道计算。 因此，由于延迟 100 毫秒，因此控制同时向下打印列表内容的最后一行，仍然为空。 我们可以在最后一行前设置延迟：

```
try {
    TimeUnit.MILLISECONDS.sleep(200);
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println(list);   //prints: [2.0]
```

延迟必须至少是 200 毫秒，因为管道处理两个元素，每个元素有 100ms 延迟。 现在，正如您所看到的，列表包含`2.0`的预期值。

这基本上是阻塞和非阻塞运算符之间的差异。 代表可观察到的其他类具有类似的阻塞运营商。 以下是阻断`Flowable`，`Single`和`Maybe`的示例：

```
Flowable<Integer> obs = Flowable.range(1,5);
Double d2 = obs.filter(i -> i % 2 == 0)
        .doOnNext(System.out::println)  //prints 2 and 4
        .map(Math::sqrt)
        .delay(100, TimeUnit.MILLISECONDS)
        .blockingLast();
System.out.println(d2);                 //prints: 2.0

Single<Integer> obs2 = Single.just(42);
int i2 = obs2.delay(100, TimeUnit.MILLISECONDS).blockingGet();
System.out.println(i2);                 //prints: 42

Maybe<Integer> obs3 = Maybe.just(42); 
int i3 = obs3.delay(100, TimeUnit.MILLISECONDS).blockingGet(); 
System.out.println(i3);                 //prints: 42 

```

`Completable`类具有阻止允许设置超时的运算符：

```
(1) Completable obs = Completable.fromRunnable(() -> {
            System.out.println("Running...");       //prints: Running...
            try {
                TimeUnit.MILLISECONDS.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
    });                                           
(2) Throwable ex = obs.blockingGet();
(3) System.out.println(ex);                               //prints: null

//(4) ex = obs.blockingGet(15, TimeUnit.MILLISECONDS);
//                                java.util.concurrent.TimeoutException: 
//               The source did not signal an event for 15 milliseconds.

(5) ex = obs.blockingGet(150, TimeUnit.MILLISECONDS);
(6) System.out.println(ex);                               //prints: null

(7) obs.blockingAwait();
(8) obs.blockingAwait(15, TimeUnit.MILLISECONDS);
```

前面代码的结果在以下屏幕截图中呈现：

![](img/e4317b1f-255b-43df-8fd5-c4cdf0986b28.png)

响应于阻塞`blockingGet()`方法的呼叫，第一个运行消息来自第 2 行。 第一个空消息来自第 3 行。第 4 行抛出异常，因为超时设置为 15 ms，而实际处理设置为 100ms 延迟。 响应于`blockingGet()`方法调用，第二次运行消息来自 5 号线。 这次，超时设置为 150 毫秒，它超过 100 毫秒，并且该方法在超时之前能够返回。

最后两行，7 和 8，演示了`blockingAwait()`方法的使用而没有超时。 此方法不会返回值，但允许可观察管道运行其课程。 值得注意的是，即使将超时设置为较小的值，它不会与流水线完成的时间较小的例外，它不会因异常而分解。 显然，它在管道完成处理后启动其等待，除非它稍后将修复的缺陷（此点目不清楚）。

虽然存在阻塞操作（并且我们将在以下部分中的每个可观察类型讨论更多内容），但它们仅在使用非阻塞操作时不可能实现所需功能的情况下 只要。 反应性编程的主要推点是努力以非阻塞式异步处理所有请求。

# 冷与热

我们所看到的所有示例迄今为止只展示了 *Cold* 可观察到的，那些仅在已经处理之前的值后仅在处理流水线的请求时提供下一个值。 这是另一个例子：

```
Observable<Long> cold = Observable.interval(10, TimeUnit.MILLISECONDS);
cold.subscribe(i -> System.out.println("First: " + i));
pauseMs(25);
cold.subscribe(i -> System.out.println("Second: " + i));
pauseMs(55);

```

我们使用该方法`interval()`创建`Observable`对象，表示每个指定的间隔发出的序列号流（在我们的情况下，每 10 毫秒）。 然后我们订阅创建的对象，等待 25 ms，再次订阅，然后等待 55 毫秒。 `pauseMs()`方法如下所示：

```
void pauseMs(long ms){
    try {
        TimeUnit.MILLISECONDS.sleep(ms);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

如果我们运行前面的示例，则输出将如下：

![](img/421f6075-29e9-431d-a237-b23f737c0c48.png)

如您所见，每个管道都处理了寒冷可观察到的每个值。

要转换 *COLD* 可观察到 A *HOT* ，我们使用将可观察到的方法转换为`ConnectableObservable`对象，该方法扩展为`Observable`：

```
ConnectableObservable<Long> hot = 
         Observable.interval(10, TimeUnit.MILLISECONDS).publish();
hot.connect();
hot.subscribe(i -> System.out.println("First: " + i));
pauseMs(25);
hot.subscribe(i -> System.out.println("Second: " + i));
pauseMs(55);

```

正如您所看到的，我们必须调用`connect()`方法，以顺序`ConnectableObservable`对象开始发出值。 输出看起来如下：

![](img/181c6ce4-39f7-4f26-a8af-5239bd2a8872.png)

输出显示第二管线未接收到前三个值，因为它稍后已经订阅了可观察。 因此，可观察到的表示值与观察者处理它们的能力无关。 如果处理落后，并且新的值在前一个未完全处理的同时，`Observable`类将它们放入缓冲区。 如果这种缓冲区足够大，JVM 可以用完内存，因为我们已经提到了，`Observable`类没有背压管理的能力。

对于这种情况，`Flowable`类是可观察到的更好的候选者，因为它确实具有处理背压的能力。 这是一个例子：

```
PublishProcessor<Integer> hot = PublishProcessor.create();
hot.observeOn(Schedulers.io(), true)
   .subscribe(System.out::println, Throwable::printStackTrace);
for (int i = 0; i < 1_000_000; i++) {
    hot.onNext(i);
}
```

`PublishProcessor`类扩展了`Flowable`并具有`onNext(Object o)`方法，该方法强迫它发出传递的对象。 在调用之前，我们使用`Schedulers.io()`螺纹订阅了可观察。 我们将讨论*多线程（调度程序）*部分的调度程序。

`subscribe()`方法具有多个重载版本。 我们决定使用接受两个`Consumer`函数的那个​​：第一个处理传递的值，第二个进程如果它被任何流水线操作抛出（类似于`Catch`块），则为例外。

如果我们运行前述示例，它将打印成功的第一个 127 值，然后将抛出`MissingBackpressureException`，如以下屏幕截图所示：

![](img/075795f4-e2cd-4e7d-aef1-ddf815a51a4d.png)

异常中的消息提供了线索：`Could not emit value due to lack of requests` *。* 显然，​​发光的速率高于消耗它们的速率，内部缓冲器可以保持 128 个元素。 如果我们添加延迟（模拟更长的处理时间），结果将更加差：

```
PublishProcessor<Integer> hot = PublishProcessor.create();
hot.observeOn(Schedulers.io(), true)
   .delay(10, TimeUnit.MILLISECONDS)
   .subscribe(System.out::println, Throwable::printStackTrace);
for (int i = 0; i < 1_000_000; i++) {
    hot.onNext(i);
}
```

即使是前 128 个元素也不会通过，输出只有`MissingBackpressureException`。

要解决此问题，必须设置背压策略。 例如，让我们删除管道无法管理的每个值：

```
PublishProcessor<Integer> hot = PublishProcessor.create();
hot.onBackpressureDrop(v -> System.out.println("Dropped: "+ v))
   .observeOn(Schedulers.io(), true)
   .subscribe(System.out::println, Throwable::printStackTrace);
for (int i = 0; i < 1_000_000; i++) {
    hot.onNext(i);
}
```

请注意，必须在`observeOn()`操作之前设置策略，因此它将被创建的`Schedulers.io()`线程拾取。

输出显示许多发出的值被删除。 以下是输出片段：

![](img/197a7e6c-92a4-4e63-ad5b-add6ec985939.png)

我们将讨论*运算符*部分中的其他背部策略在相应的运营商的概述中。

# 一次性的

请注意，`subscribe()`方法实际上返回一个`Disposable`对象，可以查询以检查管道处理是否已完成（并处理）：

```
Observable<Integer> obs = Observable.range(1,5);
List<Double> list = new ArrayList<>();
Disposable disposable =
     obs.filter(i -> i % 2 == 0)
        .doOnNext(System.out::println)     //prints 2 and 4
        .map(Math::sqrt)
        .delay(100, TimeUnit.MILLISECONDS)
        .subscribe(d -> {
            if(list.size() == 1){
                list.remove(0);
            }
            list.add(d);
        });
System.out.println(list);                    //prints: []
System.out.println(disposable.isDisposed()); //prints: false
try {
    TimeUnit.MILLISECONDS.sleep(200);
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println(disposable.isDisposed());  //prints: true
System.out.println(list);                     //prints: [2.0]
```

还可以执行处理管道，从而有效地取消处理：

```
Observable<Integer> obs = Observable.range(1,5);
List<Double> list = new ArrayList<>();
Disposable disposable =
     obs.filter(i -> i % 2 == 0)
        .doOnNext(System.out::println)       //prints 2 and 4
        .map(Math::sqrt)
        .delay(100, TimeUnit.MILLISECONDS)
        .subscribe(d -> {
            if(list.size() == 1){
                list.remove(0);
            }
            list.add(d);
        });
System.out.println(list);                    //prints: []
System.out.println(disposable.isDisposed()); //prints: false
disposable.dispose();
try {
    TimeUnit.MILLISECONDS.sleep(200);
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println(disposable.isDisposed()); //prints: true
System.out.println(list);                    //prints: []
```

正如您可以看到的，通过将呼叫添加到`disposable.dispose()`，我们已停止处理：列表内容，即使在 200 ms 延迟之后，仍然是空的（前面示例的最后一行）。

这种强制处理方法可用于确保没有遥控线程。 每个创建的`Disposable`对象可以以相同的方式处理资源在`finally`块中释放的资源。 `CompositeDisposable`类有助于以协调的方式处理多个`Disposable`对象。

当`onComplete`或`onError`事件发生时，管道自动处理。

例如，您可以使用`add()`方法并将新创建的`Disposable`对象添加到`CompositeDisposable`对象。 然后，在必要时，可以在`CompositeDisposable`对象上调用`clear()`方法。 它将删除收集的`Disposable`对象并在每个对象上调用`dispose()`方法。

# 创造一个可观察者

您已经看到了一些在我们的例子中创建可观察的方法。 `Observable`，`Flowable`，`Single`，`Maybe`和`Completable`中存在许多其他工厂方法。 并非所有这些接口都可以使用以下所有方法（请参阅注释; *所有*意味着所有列出的接口都有它）：

*   `create()`：通过提供完整的实现（全部）创建`Observable`对象
*   `defer()`：每次新的`Observer`订阅时（全部）创建一个新的`Observable`对象
*   `empty()`：创建一个空的`Observable`对象，在订阅时立即完成（所有，除`Single`之外）
*   `never()`：创建一个没有发出任何物质的`Observable`对象，根本没有任何东西; 甚至没有完成（全部）
*   `error()`：创建一个`Observable`对象，在订阅时立即发出异常（全部）
*   `fromXXX()`：创建一个`Observable`对象，其中 xxx 可以是*可调用*，*未来*（全部）， *erreation* ， *array* ， *发行商*（`Observable`和`Flowable`），*动作*，*可运行的*（`Maybe`和`Completable`）; 这意味着它基于提供的函数或对象创建`Observable`对象
*   `generate()`：创建一个 COLD `Observable`对象，基于提供的功能或对象（`Observable`和`Flowable`生成值）
*   `range(), rangeLong(), interval(), intervalRange()`：创建一个`Observable`对象，其发出顺序`int`或`long`值，这些值由指定的范围和仅由指定的时间间隔（仅限`Observable`和`Flowable`间隔）
*   `just()`：基于提供的对象或一组对象创建`Observable`对象（所有，除`Completable`之外）
*   `timer()`：创建`Observable`对象，在指定时间后，发出`0L`信号（全部），然后为`Observable`和`Flowable`完成

还有许多其他有用的方法，例如`repeat()`，`startWith()`和类似的方法。 我们只是没有足够的空间来列出所有空间。 请参阅在线文档（ [http://reactivex.io/rxjava/2.x/javadoc/index.html](http://reactivex.io/RxJava/2.x/javadoc/index.html) ）。

让我们来看看`create()`方法使用情况。 `create()`的`create()`方法如下所示：

```
public static Observable<T> create(ObservableOnSubscribe<T> source)
```

传递的对象必须是函数界面`ObservableOnSubscribe<T>`的实现，它只有一个抽象方法`subscribe()`：

```
void subscribe(ObservableEmitter<T> emitter)
```

`ObservableEmitter<T>`界面包含以下方法：

*   `boolean isDisposed()`：返回`true`如果处理流水线或终止发射器
*   `ObservableEmitter<T> serialize()`：为位于基类`Emitter`中的呼叫（`onNext()`，`onError()`和`onComplete()`提供的序列化算法
*   `void setCancellable(Cancellable c)`：在此发射器上设置`Cancellable`实现（仅具有一种方法的功能界面，`cancel()`）
*   `void setDisposable(Disposable d)`：在此发射器上设置 A `Disposable`实现（具有两种方法的接口：`isDispose()`和`dispose()`）
*   `boolean tryOnError(Throwable t)`：处理错误条件，尝试发出所提供的异常，如果不允许发射，则返回`false`

要创建可观察到的，可以实现所有前一个接口，如下所示：

```
ObservableOnSubscribe<String> source = emitter -> {
    emitter.onNext("One");
    emitter.onNext("Two");
    emitter.onComplete();
};
Observable.create(source)
          .filter(s -> s.contains("w"))
          .subscribe(v -> System.out.println(v),
                     e -> e.printStackTrace(),
                     () -> System.out.println("Completed"));
pauseMs(100); 
```

让我们来看看前面的示例更近。 我们已经创建了`ObservableOnSubscribe`功能`source`并实现了发射器：我们告诉发射器在第一次调用`onNext()`时发出一个，在第二个调用`onNext()`时发出两个，然后调用`onComplete()`。 我们已将`source`功能传递给`create()`方法，并建立了流水线以处理所有发射值。

为了使其更有趣，我们添加了`filter()`运算符，该操作员允许进一步传播*字符的值。 我们还选择了具有三个参数的`subscribe()`方法版本：功能`Consumer onNext`，`Consumer onError`和`Action onComplete`。 每次达到该方法时，首先被调用，当发出异常时调用第二个，并且当源发出`onComplete()`信号时调用第三个。 创建管道后，我们已暂停 100 毫秒以使异步过程有机会完成。 结果看起来如下：*

![](img/ad0c62da-98d3-409b-8430-1d78e719a219.png)

如果我们从发射器实现中删除了`emitter.onComplete()`，则只会显示两个消息。

这些是如何使用`create()`方法的基础知识。 正如您所看到的，它允许完整的自定义。 在实践中，很少使用，因为有许多更简单的方法来创建可观察。 我们在以下部分中审核它们。

您将看到在本章的其他部分中使用我们的示例中使用的其他工厂方法的示例。

# 运营商

在每个可观察到的接口，`Observable`，`Flowable`，`Maybe`，`Maybe`或`Completable`中，有数百（如果我们计算所有超载版本）的操作员可用的操作员。

在`Observable`和`Flowable`中，方法的数量超出了 500.这就是为什么在本节中我们将只提供概述和一些帮助读者导航可能选择的迷宫的示例。

为了帮助看到大图片，我们将所有运营商分组为十大类：转换，过滤，结合，从 XXX，例外处理，生命周期事件处理，实用程序，条件和布尔，背压和可连接。

请注意，这些不是所有可用的运营商。 您可以在在线文档中查看更多（ [http://reactivex.io/rxjava/2.x/javadoc/index.html](http://reactivex.io/RxJava/2.x/javadoc/index.html) ）。

# 转变

这些运算符将可观察到的值转换：

*   `buffer()`：根据所提供的参数或使用提供的功能将发射的值收集到捆绑包中，并在一次定期发出这些捆绑
*   `flatMap()`：基于当前可观察到的可观察可观察，并将它们插入当前流量，其中一个最流行的运算符之一
*   `groupBy()`：将当前`Observable`划分为可观察组（`GroupedObservables`对象）
*   `map()`：使用提供的功能转换发出的值
*   `scan()`：将提供的函数与作为以前应用于以前值的同一函数的结果相同的值
*   `window()`：发出类似于`buffer()`的值组，而是作为观察到，每个值都会发出来自原始可观察到的值的子集，然后用`onCompleted()`终止

以下代码演示了使用`map()`，`flatMap()`和`groupBy()`：

```
Observable<String> obs = Observable.fromArray("one", "two");

obs.map(s -> s.contains("w") ? 1 : 0)
   .forEach(System.out::print);              //prints: 01

List<String> os = new ArrayList<>();
List<String> noto = new ArrayList<>();
obs.flatMap(s -> Observable.fromArray(s.split("")))
        .groupBy(s -> "o".equals(s) ? "o" : "noto")
        .subscribe(g -> g.subscribe(s -> {
            if (g.getKey().equals("o")) {
                os.add(s);
            } else {
                noto.add(s);
            }
        }));
System.out.println(os);                  //prints: [o, o]
System.out.println(noto);                //prints: [n, e, t, w]
```

# 过滤

以下运算符（及其多载版本）选择哪个值将继续流过管道：

*   `debounce()`：仅在没有可观察到的另一个值的情况下传递指定的时间跨度时发出值
*   `distinct()`：仅选择唯一值
*   `elementAt(long n)`：仅在流中仅发出一个值，其中指定的`n`位置
*   `filter()`：仅发出符合指定标准的值
*   `firstElement()`：仅发出第一个值
*   `ignoreElements()`：不发出值; 只有`onComplete()`信号通过
*   `lastElement()`：仅发出最后一个值
*   `sample()`：发出在指定时间间隔内发出的最新值
*   `skip(long n)`：跳过第一个`n`值
*   `take(long n)`：仅发出第一个`n`值

以下是一些刚列出的运算符的示例：

```
Observable<String> obs = Observable.just("onetwo")
        .flatMap(s -> Observable.fromArray(s.split("")));
// obs emits "onetwo" as characters           
obs.map(s -> {
            if("t".equals(s)){
               NonBlockingOperators.pauseMs(15);
            }
            return s;
        })
        .debounce(10, TimeUnit.MILLISECONDS)
        .forEach(System.out::print);               //prints: eo
obs.distinct().forEach(System.out::print);         //prints: onetw
obs.elementAt(3).subscribe(System.out::println);   //prints: t
obs.filter(s -> s.equals("o"))
   .forEach(System.out::print);                    //prints: oo
obs.firstElement().subscribe(System.out::println); //prints: o
obs.ignoreElements().subscribe(() -> 
       System.out.println("Completed!"));          //prints: Completed!
Observable.interval(5, TimeUnit.MILLISECONDS)
   .sample(10, TimeUnit.MILLISECONDS)
   .subscribe(v -> System.out.print(v + " "));     //prints: 1 3 4 6 8 
pauseMs(50);

```

# 结合

以下运算符（及其多载版本）使用多个源可观察可创建新的可观察到：

*   `concat(src1, src2)`：创建一个发出`src1`的所有值的`Observable`，然后是`src2`的所有值
*   `combineLatest(src1, src2, combiner)`：创建一个`Observable`，它发出两个源中的任一个发射的值，使用所提供的功能组合程序将两个源中的任一个结合使用每个源发出的最新值
*   `join(src2, leftWin, rightWin, combiner)`：根据`combiner`功能，在时间窗口`leftWin`和`rightWin`期间组合两个可观察到的值
*   `merge()`：将多个可观察结果组合成一个; 与`concat()`相比，它可以交织它们，而`concat()`切勿将发出的值与不同的可观察结果进行交错
*   `startWith(T item)`：在从源可观察到的值之前添加指定的值
*   `startWith(Observable<T> other)`：在从源可观察到的值之前，在发射值之前从指定的可观察值添加值
*   `switchOnNext(Observable<Observable> observables)`：创建一个新的`Observable`，发出最近的指定观察值的最近发射值
*   `zip()`：使用提供的功能组合指定的观察值的值

以下代码演示了一些这些运算符的使用：

```
Observable<String> obs1 = Observable.just("one")
                      .flatMap(s -> Observable.fromArray(s.split("")));
Observable<String> obs2 = Observable.just("two")
                      .flatMap(s -> Observable.fromArray(s.split("")));
Observable.concat(obs2, obs1, obs2)
          .subscribe(System.out::print);             //prints: twoonetwo
Observable.combineLatest(obs2, obs1, (x,y) -> "("+x+y+")")
          .subscribe(System.out::print);          //prints: (oo)(on)(oe)
System.out.println();
obs1.join(obs2, i -> Observable.timer(5, TimeUnit.MILLISECONDS),
                i -> Observable.timer(5, TimeUnit.MILLISECONDS),
              (x,y) -> "("+x+y+")").subscribe(System.out::print); 
                          //prints: (ot)(nt)(et)(ow)(nw)(ew)(oo)(no)(eo)
Observable.merge(obs2, obs1, obs2)
          .subscribe(System.out::print);             //prints: twoonetwo
obs1.startWith("42")
    .subscribe(System.out::print); //prints: 42one
Observable.zip(obs1, obs2, obs1,  (x,y,z) -> "("+x+y+z+")")
          .subscribe(System.out::print);       //prints: (oto)(nwn)(eoe) 
```

# 从 XXX 转换

这些运营商非常简单。 以下是`Observable`类的-XXX 运算符的列表：

*   `fromArray(T... items)`：从 varargs 创建`Observable`
*   `fromCallable(Callable<T> supplier)`：从`Callable`函数中创建`Observable`
*   `fromFuture(Future<T> future)`：从`Future`对象中创建`Observable`
*   `fromFuture(Future<T> future, long timeout, TimeUnit unit)`：从`Future`对象中创建`Observable`，其中超时参数应用于`future`
*   `fromFuture(Future<T> future, long timeout, TimeUnit unit, Scheduler scheduler)`：使用应用于`future`的超时参数和调度程序（建议使用`Schedulers.io()`，参见*多线程（调度器）*部分），从`Future`对象中创建`Observable`
*   `fromFuture(Future<T> future, Scheduler scheduler)`：从指定的调度程序上的`Future`对象创建`Observable`对象（建议使用`Schedulers.io()`，参见*多线程（调度程序）*部分）
*   `fromIterable(Iterable<T> source)`：例如，从可迭代的对象（例如`List`创建`Observable`）
*   `fromPublisher(Publisher<T> publisher)`：从`Publisher`对象中创建`Observable`

# 例外处理

`subscribe()`操作员具有超载版本，可接受`Consumer<Throwable>`功能，该函数处理管道中的任何位置举起的任何异常。 它类似于全部拥抱`try-catch`块。 如果您将此功能传递到`subscribe()`运算符中，您可以确定这是唯一一个所有异常最终的位置。

但是，如果您需要在管道中间处理异常，因此在抛出异常的操作员之后，可以通过操作员的其余部分恢复和处理值流，以下运算符（及其多载版本） 可以帮助：

*   `onErrorXXX()`：捕获异常时恢复提供的序列; XXX 表示操作员所做的：`onErrorResumeNext()`，`onErrorReturn()`或`onErrorReturnItem()`
*   `retry()`：创建一个重复从源发出的排放的`Observable`; 重新订阅源`Observable`如果它调用`onError()`

演示代码如下所示：

```
Observable<String> obs = Observable.just("one")
                     .flatMap(s -> Observable.fromArray(s.split("")));
Observable.error(new RuntimeException("MyException"))
          .flatMap(x -> Observable.fromArray("two".split("")))
          .subscribe(System.out::print,
           e -> System.out.println(e.getMessage())//prints: MyException
          );
Observable.error(new RuntimeException("MyException"))
          .flatMap(y -> Observable.fromArray("two".split("")))
          .onErrorResumeNext(obs)
          .subscribe(System.out::print);          //prints: one
Observable.error(new RuntimeException("MyException"))
          .flatMap(z -> Observable.fromArray("two".split("")))
          .onErrorReturnItem("42")
          .subscribe(System.out::print);          //prints: 42

```

# 生命周期事件处理

每个运算符都在在管道中任何位置发生的某个事件上调用。 它们类似地与*例外处理*部分中描述的操作员合作。

这些运算符的格式是`doXXX()`，其中 xxx 是事件的名称：`onComplete`，`onNext`，`onError`和类似。 并非所有这些类都可用，其中一些在`Observable`，`Flowable`，`Single`，`Maybe`或`Completable`中略有不同。 但是，我们没有空间来列出所有这些类的所有变体，并将我们的概述限制为`Observable`类的生命周期事件的少数例子：

*   `doOnSubscribe(Consumer<Disposable> onSubscribe)`：在观察者订阅时执行
*   `doOnNext(Consumer<T> onNext)`：在源可观察调用`onNext`时，适用提供的`Consumer`功能
*   `doAfterNext(Consumer<T> onAfterNext)`：将提供的`Consumer`函数应用于当前值后，在下游之后
*   `doOnEach(Consumer<Notification<T>> onNotification)`：为每个发出的值执行`Consumer`函数
*   `doOnEach(Observer<T> observer)`：向每个发出的值和它发出的终端事件通知`Observer`
*   `doOnComplete(Action onComplete)`：在源可观察到生成`onComplete`事件后，执行提供的`Action`功能
*   `doOnDispose(Action onDispose)`：在管道在下游处理后执行提供的`Action`功能
*   `doOnError(Consumer<Throwable> onError)`：执行`onError`事件时执行
*   `doOnLifecycle(Consumer<Disposable> onSubscribe, Action onDispose)`：调用相应事件的相应`onSubscribe`或`onDispose`函数
*   `doOnTerminate(Action onTerminate)`：当源可观察到生成`onComplete`事件或异常（`onError`事件）时，执行提供的`Action`函数
*   `doAfterTerminate(Action onFinally)`：在源可观察到生成`onComplete`事件或异常（`onError`事件）后执行提供的`Action`函数
*   `doFinally(Action onFinally)`：在源可观察到生成`onComplete`事件或异常（`onError`事件）之后执行提供的`Action`函数是否升高或管道由下游处理

这是一个演示代码：

```
Observable<String> obs = Observable.just("one")
            .flatMap(s -> Observable.fromArray(s.split("")));

obs.doOnComplete(() -> System.out.println("Completed!")) 
        .subscribe(v -> {
            System.out.println("Subscribe onComplete: " + v);
        });        
pauseMs(25);
```

如果我们运行此代码，则输出将如下：

![](img/19b14d2a-6ff5-410c-9a67-515f8943a2e6.png)

您还将在*多线程（调度程序）*部分中查看这些运算符使用的其他示例。

# 公用事业

各种有用的运算符（及其多载版本）可用于控制管道行为：

*   `delay()`：在指定的时间段内延迟发射
*   `materialize()`：创建一个表示发射值的`Observable`和发送的通知
*   `dematerialize()`：反转`materialize()`运算符的结果
*   `observeOn()`：指定`Observer`应观察`Observable`的`Scheduler`（线程）（参见*多线程（调度程序）*部分）
*   `serialize()`：强制发出值和通知的序列化
*   `subscribe()`：从可观察到的排放和通知订购; 各种重载版本接受用于各种事件的回调，包括`onComplete`和`onError`; 只有在调用`subscribe()`之后，才能开始流过管道
*   `subscribeOn()`：使用指定的`Scheduler`异步将`Observer`与`Observable`订阅（参见*多线程（调度程序）*部分）
*   `timeInterval(), timestamp()`：转换发出值的`Observable<T>`将值发出到`Observable<Timed<T>>`中，这反过来又称发射排放或时间戳之间的时间量相应地
*   `timeout()`：重复源的排放`Observable`; 如果在指定的时间段内没有发生排放，则会生成错误
*   `using()`：创建一个与`Observable`自动处理的资源; 与尝试与资源构造类似

以下代码包含在管道中使用的一些操作符的一些示例：

```
Observable<String> obs = Observable.just("one")
                     .flatMap(s -> Observable.fromArray(s.split("")));
obs.delay(5, TimeUnit.MILLISECONDS)
   .subscribe(System.out::print);                          //prints: one
pauseMs(10);
System.out.println(); //used here just to break the line
Observable source = Observable.range(1,5);
Disposable disposable = source.subscribe();
Observable.using(
  () -> disposable,
  x -> source,
  y -> System.out.println("Disposed: " + y) //prints: Disposed: DISPOSED
)
.delay(10, TimeUnit.MILLISECONDS)
.subscribe(System.out::print);                          //prints: 12345
pauseMs(25);
```

如果我们运行所有这些示例，则输出将如下所示：

![](img/aa7ef37f-6ec1-44af-84c3-dffe282f2508.png)

如您所见，管道在完成后，将设置为`using`操作员（第三个参数）的信号发送，因此我们通过第三个参数的`Consumer`功能可以处理管道使用的资源。

# 条件和布尔

以下运算符（及其多个重载版本）允许评估一个或多个可观察到或发射值并相应地更改处理的逻辑：

*   `all(Predicate criteria)`：如果所有发射的值与提供的标准匹配，则返回`Single<Boolean>`值
*   `amb()`：接受两个或多个源可观察到，并仅从开始发出的首先发出值
*   `contains(Object value)`：如果可观察到的值发出提供的值，则返回`Single<Boolean>`
*   `defaultIfEmpty(T value)`：如果源`Observable`不会发出任何东西，请发出提供的值
*   `sequenceEqual()`：如果提供的源发出相同的序列，则用`true`返回`Single<Boolean>`; 超载版本允许提供用于比较的平等功能
*   `skipUntil(Observable other)`：丢弃发射值，直到提供的`Observable other`发出值
*   `skipWhile(Predicate condition)`：只要提供的条件仍然存在`true`，丢弃发射值
*   `takeUntil(Observable other)`：丢弃提供的`Observable other`发出值后的发射值
*   `takeWhile(Predicate condition)`：在提供的条件变为`false`后丢弃发射值

此代码包含一些演示示例：

```
Observable<String> obs = Observable.just("one")
                  .flatMap(s -> Observable.fromArray(s.split("")));
Single<Boolean> cont = obs.contains("n");
System.out.println(cont.blockingGet());             //prints: true
obs.defaultIfEmpty("two")
   .subscribe(System.out::print);                   //prints: one
Observable.empty().defaultIfEmpty("two")
          .subscribe(System.out::print);            //prints: two

Single<Boolean> equal = Observable.sequenceEqual(obs, 
                                 Observable.just("one"));
System.out.println(equal.blockingGet());            //prints: false

equal = Observable.sequenceEqual(Observable.just("one"), 
                                 Observable.just("one"));
System.out.println(equal.blockingGet());           //prints: true

equal = Observable.sequenceEqual(Observable.just("one"), 
                                 Observable.just("two"));
System.out.println(equal.blockingGet());           //prints: false

```

# 背压

我们已经讨论并展示了**背压**效果和可能的液滴策略*冷与热*。 其他策略可能如下：

```
Flowable<Double> obs = Flowable.fromArray(1.,2.,3.);
obs.onBackpressureBuffer().subscribe();
//or
obs.onBackpressureLatest().subscribe();
```

缓冲策略允许定义缓冲区大小并提供如果缓冲区溢出的情况下可以执行的函数。 最新的策略告诉 Value Producer 暂停（当消费者无法按时处理发出的值时）并根据请求发出下一个值。

背压运算符仅在`Flowable`类中可用。

# 可连接

此类别的运营商允许连接可观察到，从而实现更精确的受控订阅动态：

*   `publish()`：将`Observable`对象转换为`ConnectableObservable`对象
*   `replay()`：返回 a `ConnectableObservable`对象，每次新的`Observer`订阅时重复所有发出的值和通知
*   `connect()`：指示`ConnectableObservable`开始向订户发出值
*   `refCount()`：将`ConnectableObservable`转换为`Observable`

我们已经展示了`ConnectableObservable`在*冷与热*部分工作。 `ConnectiableObservable`和`Observable`之间的一个主要差异是`ConnectableObservable`在调用`connect`操作员之前，不会开始发射值。

# 多线程（调度程序）

rxjava 默认是单线程。 这意味着源可观察和其所有运算符通知观察者在调用`subscribe()`操作员的同一线程上。

Тhe 是两个运算符，`observeOn()`和`subscribeOn()`，允许将单个动作的执行移动到不同的线程。 这些方法作为参数 a `Scheduler`对象，嗯，调度要在不同的线程上执行的各个操作。

`subscribeOn()`运算符声明哪个调度程序应发出值。
`observeOn()`运算符声明哪个调度程序应观察和处理值。

`Schedulers`类包含具有不同生命周期和性能配置的工厂方法，可创建`Scheduler`对象和性能配置：

*   `computation()`：基于有界线程池创建调度程序，其中大小最多可用于可用处理器的数量; 它应该用于 CPU 密集的计算; 使用`Runtime.getRuntime().availableProcessors()`避免使用比可用处理器更多的调度仪; 否则，由于线程上下文切换的开销，性能可能会降低
*   `io()`：基于用于 I / O 相关工作的无界线程池创建调度程序，例如当与源的交互阻止的与自然阻塞时，通常使用文件和数据库; 否则避免使用它，因为它可能旋转太多线程并对性能和内存使用产生负面影响
*   `newThread()`：每次创建新线程，不使用任何池; 这是一种昂贵的方式来创建一个线程，所以预计您确切地知道使用它的原因是什么
*   `single()`：基于单个线程创建调度程序，单个线程顺序执行所有任务; 执行事项的序列时有用
*   `trampoline()`：创建一个以先进先出方式执行任务的调度程序; 有用于执行递归算法
*   `from(Executor executor)`：基于所提供的 executor（线程池）创建调度程序，允许控制线程的最大数量及其生命周期。 我们讨论了[第 8 章](08.html)，*多线程和并发处理*中的线程池。 要提醒你，这里是我们讨论过的游泳池：

```
          Executors.newCachedThreadPool();
          Executors.newSingleThreadExecutor();
          Executors.newFixedThreadPool(int nThreads);
          Executors.newScheduledThreadPool(int poolSize);
          Executors.newWorkStealingPool(int parallelism);

```

正如您所看到的，`Schedulers`类的一些其他工厂方法由其中一个线程池备份，并作为线程池声明的更简单和更短的表达式。 要使示例更简单和可比，我们将仅使用 A `computation()`调度程序。 让我们来看看 rxjava 中并行/并发处理的基础知识。

以下代码是将 CPU 密集型计算委托给专用线程的示例：

```
Observable.fromArray("one","two","three")
          .doAfterNext(s -> System.out.println("1: " + 
                 Thread.currentThread().getName() + " => " + s))
          .flatMap(w -> Observable.fromArray(w.split(""))
                           .observeOn(Schedulers.computation())
              //.flatMap(s -> {             
              //      CPU-intensive calculations go here
              // }  
                .doAfterNext(s -> System.out.println("2: " + 
                         Thread.currentThread().getName() + " => " + s))
          )
          .subscribe(s -> System.out.println("3: " + s));
pauseMs(100);

```

在此示例中，我们决定从每个发出的单词创建一个字符的子流，并允许每个单词的专用线程处理字符。 此示例的输出如下所示：

![](img/91fc68b9-2936-479c-bba8-c5df3b812429.png)

如您所见，主线程用于发出单词，并且每个单词的字符由专用线程处理。 请注意，虽然在此示例中，equity 的结果序列对应于序列，但在实际情况下，每个值的计算时间都不相同，所以 无法保证结果与相同的顺序。

如果需要，我们也可以将每个单词发射放在专用的非主线程上，因此主线程可以自由地执行其他可以做的事情。 例如，

```
Observable.fromArray("one","two","three")
        .observeOn(Schedulers.computation())
        .doAfterNext(s -> System.out.println("1: " + 
                         Thread.currentThread().getName() + " => " + s))
        .flatMap(w -> Observable.fromArray(w.split(""))
                .observeOn(Schedulers.computation())
                .doAfterNext(s -> System.out.println("2: " + 
                         Thread.currentThread().getName() + " => " + s))
        )
        .subscribe(s -> System.out.println("3: " + s));
pauseMs(100);
```

此示例的输出如下：

![](img/ee29dc44-8876-479a-91fb-9aaa2baaca47.png)

如您所见，主线程不会再发出单词。

在 rxjava 2.0.5 中，引入了一种新的平行处理方式，类似于标准 Java 8 流中的并行处理。 使用`ParallelFlowable`，可以实现相同的功能，如下所示：

```
ParallelFlowable src = 
                     Flowable.fromArray("one","two","three").parallel();
src.runOn(Schedulers.computation())
   .doAfterNext(s -> System.out.println("1: " + 
                        Thread.currentThread().getName() + " => " + s))
   .flatMap(w -> Flowable.fromArray(((String)w).split("")))
   .runOn(Schedulers.computation())
   .doAfterNext(s -> System.out.println("2: " + 
                        Thread.currentThread().getName() + " => " + s))
   .sequential()
   .subscribe(s -> System.out.println("3: " + s));
pauseMs(100);

```

如您所见，通过将`parallel()`运算符应用于常规`Flowable`来创建`ParallelFlowable`对象。 然后，`runOn()`操作员告诉创建的可观察者使用`computation()`调度器来发射值。 请注意，不再需要设置`flatMap()`运算符中的另一个调度程序（用于处理字符）。 它可以在它外面设置 - 只是在主管线中，这使得代码更简单。 结果如下所示：

![](img/d522525e-60b8-4870-b9c1-49dc85665818.png)

至于`subscribeOn()`操作员，其在管道中的位置不会扮演任何作用。 无论何处放置，它仍然会告诉观察到哪个调度程序应该发出值。 这是一个例子：

```
Observable.just("a", "b", "c")
          .doAfterNext(s -> System.out.println("1: " + 
                         Thread.currentThread().getName() + " => " + s))
          .subscribeOn(Schedulers.computation())
          .subscribe(s -> System.out.println("2: " + 
                        Thread.currentThread().getName() + " => " + s));
pauseMs(100);
```

结果如下所示：

![](img/751bff5d-4e41-4d3b-aff2-d172cd5cd438.png)

即使我们在以下示例中更改`subscribeOn()`运算符的位置，结果也不会改变：

```
Observable.just("a", "b", "c")
          .subscribeOn(Schedulers.computation())
          .doAfterNext(s -> System.out.println("1: " + 
                         Thread.currentThread().getName() + " => " + s))
          .subscribe(s -> System.out.println("2: " + 
                         Thread.currentThread().getName() + " => " + s));
pauseMs(100);
```

最后，这里是两个运算符的示例：

```
Observable.just("a", "b", "c")
          .subscribeOn(Schedulers.computation())
          .doAfterNext(s -> System.out.println("1: " + 
                       Thread.currentThread().getName() + " => " + s))
          .observeOn(Schedulers.computation())
          .subscribe(s -> System.out.println("2: " + 
                      Thread.currentThread().getName() + " => " + s));
pauseMs(100);

```

结果现在显示了使用两个线程：一个用于订阅的线程，另一个用于观察：

![](img/2e17e983-3447-4425-aa9e-96268cadad2c.png)

这结论是我们的简短概述了 Rxjava，这是一个具有很多可能性的大仍然增长的图书馆，其中许多我们只是在本书中没有空间审查。 我们鼓励您尝试学习它，因为似乎反应编程是现代数据处理标题的方式。

# 概括

在本章中，读者已经了解了什么反应性编程以及其主要概念是：异步，非阻塞，响应等。 以简单的术语以及 Rxjava 库引入并解释的反应性流，这是一种支持反应性编程原理的第一实体实现。

在下一章中，我们将讨论微服务作为创建反应系统的基础，并审查另一个成功支持反应编程的库： **vert.x** 。 我们将使用它来演示如何构建各种微服务。

# 测验

1.  选择所有正确的语句：

2.  可以在不使用线程池的情况下使用`CompletableFuture`？
3.  *nio `java.nio`在`java.nio`代表中是什么？*
4.  是一个`event`循环唯一支持非阻塞 API 的设计？
5.  *rxjava 在 rxjava 的 rx* 是什么？
6.  哪个 **java 类库**的 Java 包（ **jcl** ）支持反应流？
7.  从以下列表中选择所有类，可以表示在反应流中可观察到的：
    1.  `Flowable`
    2.  `Probably`
    3.  `CompletableFuture`
    4.  `Single`

8.  您如何知道`Observable`类的特定方法（运算符）是阻塞的？
9.  寒冷和热量可观察到的差异是什么？
10.  `Observable`的`subscribe()`方法返回`Disposable`对象。 在此对象上调用`dispose()`方法时会发生什么？
11.  选择创建`Observable`对象的方法的所有名称：

12.  名称两个转换`Observable`运算符。
13.  名称两个过滤`Observable`运算符。
14.  名称两个背压处理策略。
15.  名称两个`Observable`运算符，允许向流水线处理添加线程。