# Java 11 景观

在本章中，我们将探索 Java 平台的新实现的基于时间的版本控制系统。 我们将调查当前的 Java 景观，具体关注 Java 9,10（18.3）和 11（18.9）引入的更改。 我们的探索将包括 Java 9 的模块化，Java Shell，外部过程控制，垃圾收集， **Java Microbenchmark Markmarks Harness** （ **JMH** ）概述，以及更多。 对于 Java 10，我们将突出显示要包括局部变量类型推断的关键更改， **Java 开发套件**（ **JDK** ）合并，垃圾收集，应用**类 - 数据共享** （ **cds** ），根证书等。 最后，我们将探讨 Java 11 中引入的更改，包括动态类文件常量，垃圾收集，局部变量类型对 Lambdas 等等。

我们将在本章末尾学习的事情包括：

*   了解 Java 平台的新版本化模型
*   了解 Java 9 的重要性
*   受益于 Java 10 引入的更改
*   受益于 Java 11 引入的更改

# 技术要求

本章和后续章节具有 Java 11\. Java 平台的**标准版**（ **SE** ）可以从 Oracle 的官方下载站点下载（ [http://www.oracle .com / technetwork / java / javase / downloads / index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html) ）。

**集成开发环境**（ **IDE** ）软件包就足够了。 来自 JetBrains 的 Intellij Idea 用于与本章相关的所有编码以及随后的章节。 可以从网站下载 Intellij Idea 的社区版本（ [https://www.jetbrains.com/idea/features/](https://www.jetbrains.com/idea/features/) ）。

# 了解 Java 平台的新版本化模型

java 的第一个版本被释放为 1996 年作为 Java 1。从那时起，已经有几个增量版本，每个递增版本遵循一个特征驱动的释放模型。 从 Java 10 开始，Oracle 已经实现了一个新的基于时间的发布模型。 在本节中，我们将查看原始模型，为展示 Java 平台的进化，并查看新版本控制模型以及它为什么要么重要。

# 功能驱动版本

在 1996 年推出 Java 1 之后，后续版本的命名法为 1.1,1.2,1.3 和 1.4。 凭借 1.5 的释放，Java 平台称为 Java 5.频繁更新为 Java 5 释放，直到 Java 6 发布，然后是 Java 7，Java 8 和 Java 9。

下表提供了 Java 发布历史记录的浓缩视图，直到 Java 9：

| **释放名称** | **版本** | **年发布** | **代码名称** |
| Java 1. | 1.0 | 1996 | 橡木 |
| Java 1.1. | 1.1 | 1997 | （阿比盖尔，布鲁斯，切尔西） |
| Java 2. | 1.2 | 1998 | 操场 |
| Java 3. | 1.3 | 2000 | 茶隼 |
| Java 4. | 1.4 | 2002 | 梅林 |
| Java 5. | 1.5 | 2004 | 老虎 |
| Java 6. | 1.6 | 2006 | 野马 |
| Java 7. | 1.7 | 2011 | 海豚 |
| Java 8. | 1.8 | 2014 | 蜘蛛 |
| Java 9. | 9 | 2017 | *代码名称不再使用 |

java 9 的发布是 Java 平台的重大变化以及每个版本的编号方式。 通过后 java 9 发布，Oracle 决定放弃基于功能的模型，选择时间发布的模型。

# 基于时间的释放

Java 9 于 2017 年发布，2018 年预定了两份版本。这些版本是 Java 10 和 Java 11.这些后 Java 9 的版本号跟随 *YY.M* 格式。 因此，与 2018 年 3 月发布的 Java 10，版本号为 18.3。 Java 11，2018 年 9 月发布的 java 11，版本号为 18.9。

基于新的时间的释放模型背后的一般前提是预定可预测和频繁的版本。 以下是详细信息：

*   **功能版本**：每六个月发布一次（每月和九月）
*   **更新版本**：每季度发布
*   **长期支持释放**：每三年发布一次

从开发人员的角度来看，有很大的收益，这个模型。 开发人员不再需要等待释放 java 平台。 更重要的是，没有发布将代表 Java 9 是 java 9 的平台的重大变化。

# 了解 Java 9 的重要性

作为项目拼图的一部分开发的 Java 平台的模块化是与 Java 平台引入的最大变化。最初计划用于 Java 8，但推迟，项目拼图是最终发布的主要原因之一 Java 9 本身就推迟了。 JigSaw 还向 Java 平台推出了一些显着的变化，并且是 Java 9 被认为是主要版本的原因之一。 我们将在后续章节中详细探讨这些功能。

除了与拼图相关的 Java 增强建议之外，还有很长的其他增强功能，它在 Java 9 中制作了它。本节探讨了 Java 9 中引入的最重要的功能，具体而言，

*   打破整体
*   使用 Java shell
*   控制外部过程
*   用 G1 提升性能
*   使用 **Java Microbenchmark MarkMarks** 测量性能（ **JMH** ）
*   为 http 2.0 做好准备
*   包含反应性编程

# 打破整体

多年来，Java 平台的公用事业继续发展和增加，使其成为一个大型雄黄。 为了使平台更适合嵌入式和移动设备，剥离版本的发布，例如 Java **连接的设备配置**（ **CDC** ）和 Java **Micro Edition** （ **me** ）是必要的。 然而，这些并没有证明对于具有不同要求的现代应用，这些应用程序在 JDK 提供的功能方面具有柔和。 在这方面，对模块化系统的需求作为一个重要要求，不仅要解决 Java 实用程序的模块化（总体而言，有超过 5,000 个 Java 类和 1,500 C ++源文件，具有超过 250,000 行代码 Hotspot 运行时），还为开发人员提供了一种使用与 JDK 中使用的相同模块系统创建和管理模块化应用程序的机制。 Java 8 提供了中间机制，使应用程序仅使用整个 JDK 提供的 API 的子集，并且该机制被命名为 **Compact Carfiles** 。 实际上，紧凑的配置文件还为进一步的工作提供了必须进行的基础，以便在 JDK 的各种不同组件之间破坏依赖性。 这种依赖性的这种破坏是必需的，以便在 Java 中实现模块系统。

模块系统本身是在项目拼图的名称下开发的，基于哪个 Java 增强建议和目标 **Java 规范请求**（ **JSR 376** ）。 完成了 JDK 代码库的完全重组，以及 JDK 可分配图像的完整重组。

社区中有相当大的争议，以及是否应作为 JDK 的一部分采用现有和成熟的 Java 模块系统，而不是提供全新的模块系统。 但是，OSGI 定位运行时行为，例如模块依赖性，安装，卸载，启动和停止模块（也以 OSGI 的命名为单位），自定义模块类加载器等。

OSGI 是指 **OSGI 联盟**，正式称为**开放服务网关主动**。 OSGI 是 Java 平台模块化系统的开放标准。

但是，Project jigsaw 定位了一个编译时模块系统，其中依赖于应用程序的分辨率发生时。 此外，作为 JDK 的一部分，安装和卸载模块消除了在编译期间将其视为依赖性的需要。 此外，通过类加载器的现有层次结构（Bootstrap 和扩展和系统 ClassLoaders），可以进行模块类的加载。

Java 模块系统中的其他优势包括增强的安全性和性能。 通过将 JDK 和应用程序模块化为拼图模块，开发人员能够在组件和它们的相应域之间创建良好定义的边界。 这种关注的分离与平台的安全架构对齐，并且是资源利用率更好的推动器。

# 使用 Java shell

长期以来，Java 编程语言没有任何标准的 shell，以试验新的语言功能或库，或用于快速原型设计。 如果您想这样做，您可以使用`main()`方法编写测试应用程序，使用`javac`进行编译，运行它。 这可以在命令行或使用 Java IDE 中完成; 然而，在这两种情况下，这并不像具有用于此目的的交互式炮弹那么方便。

在 JDK 9 中启动交互式 shell 与运行以下命令一样简单（假设`bin` JDK 9 安装在当前路径中）：

```
jshell
```

您可能会发现它有些令人费解的是，互动的 Shell 尚未在 Java 平台中尚未引入，因为许多编程语言，如 Python，Ruby 和其他一些，已经在其最早版本中具有交互式 shell。 但是，这不是在优先级功能列表中，直到 Java 9\. Java shell 使用 JShell API，该 API 提供了能够启用表达式或评估表达式和代码片段的功能。 [第 6 章](06.html)，*尝试使用 Java Shell* ，专用于讨论 Java Shell 的详细信息，以便开发人员可以充分利用它。

# 控制外部过程

最多 9，如果您想创建 Java 进程和处理进程输入/输出，则必须使用以下方法之一：

*   `Runtime.getRuntime.exec()`方法允许我们在单独的 OS 过程中执行命令。 使用这种方法将要求您获得`java.lang.Process`实例，以便提供某些操作以便管理外部过程。
*   新的`java.lang.ProcessBuilder`类，在与外部过程中交互方面具有更多的增强。 您还需要创建`java.lang.Process`实例来表示外部过程。

这两种方法都是不灵活的并且也不容易，因为外部进程执行的一组命令高度依赖于操作系统。 必须施加额外的努力，以便在多个操作系统中进行便携的特定流程操作。 [第 9 章](09.html)，*利用进程 API* ，专用于新的过程 API，为开发人员提供了以更简单的方式创建和管理外部进程的知识。

# 用 G1 提升性能

G1 垃圾收集器已在 JDK 7 中引入，现在在 JDK 9 中默认启用。它是针对具有多个处理核和大量可用内存的系统。 与之前类型的垃圾收集器相比，G1 的好处是什么？ 它如何实现这些改进？ 是否需要手动调整它，以及在哪种情况下？ 关于 G1 的这些和几个问题将在[第 7 章](07.html)，*利用默认 G1 垃圾收集器*中讨论。

# 用 JMH 测量性能

在很多场合，Java 应用程序可能会遭受性能下降。 更加激烈的问题是缺乏性能测试，可以提供至少一组最小的保证，即满足性能要求，而且，某些功能的性能不会随着时间的推移而降低。 测量 Java 应用程序的性能并不琐碎，尤其是由于有许多编译器和运行时优化可能会影响性能统计信息。 因此，必须使用额外的措施，例如热身阶段和其他技巧，以便提供更准确的性能测量。 JMH 是一种包含多种技术的框架，以及可用于此目的的方便 API。 它不是一个新的工具，而是包含在 Java 9 的分发中。如果您尚未将 JMH 添加到工具箱，请阅读[第 8 章](08.html)，*使用 JMH* ，学习 关于 JMH 在 Java 应用程序开发的上下文中使用。

# 为 http 2.0 做好准备

HTTP 2.0 是 HTTP 1.1 协议的继承者，这个新版本的协议解决了前一个的一些限制和缺点。 HTTP 2.0 以多种方式提高性能，并提供单个 TCP 连接中请求/响应多路复用等功能，在服务器推送，流量控制和请求优先级中发送响应等。 Java 提供了可用于建立非正式 HTTP 1.1 连接的`java.net.HttpURLConnection`实用程序。 但是，API 被认为是难以维护的，这是一个问题，它因需要支持 HTTP 2.0 的需要进一步复杂，因此，引入了全新的客户端 API，以便通过 HTTP 2.0 或 Web 套接字协议建立连接。 HTTP 2.0 客户端以及它提供的功能将被介绍在[第 11 章](11.html)，*新工具和工具增强功能中介绍*。

# 包含反应性编程

反应编程是用于描述系统中变化传播的某种模式的范例。 反应不构建在 Java 本身中，但可以使用第三方库（例如 Rxjava 或 Project Reactor）（Spring Framework 的一部分）建立无反应数据流。 JDK 9 还涉及 API，可以通过为此目的提供`java.util.concurrent.Flow`类来帮助开发建立在反应流概念的高度响应应用。 `Flow`类以及 JDK 9 中引入的其他相关更改将被介绍[第 12 章](12.html)，*并发增强*。

# 受益于 Java 10 引入的更改

Java 10 于 2018 年 3 月发布，此处列出了 11 个功能，除了以前涵盖的基于时间的版本控制：

*   局部变量类型推断
*   将 JDK 林的整合到单个存储库中
*   垃圾收集界面
*   G1 的并行全垃圾收集器
*   应用程序类数据共享
*   线程局部握手
*   删除本机标题生成工具（Javah）
*   其他 Unicode 语言标记扩展
*   替代存储器设备上的堆分配
*   基于实验 Java 的 JIT 编译器
*   根证书

本章介绍了这些功能的简要概述，在后续章节中具有更详细的覆盖范围。

# 局部变量类型推断

从 Java 10 开始，已简化局部变量。 开发人员不再需要包含本地变量类型的清单声明。 这是使用新的`var`标识符完成的，如本示例所示：

```
var myList = new ArrayList<String>();
```

使用前述代码，推断出`ArrayList<String>`，因此我们不再需要使用`ArrayList<String> myList = new ArrayList<String>();`。

[第 3 章](03.html)， *Java 11 基础*介绍了局部变量类型推断。

# 将 JDK 林的整合到单个存储库中

在 Java 10 之前，JDK（CORBA，Hotspot，JDK，JAXP，JAX-WS，Langtools，Nashorn 和 Root）有八个存储库。 使用 Java 10，这些存储库已被整合到单个代码库中。 值得注意的是，Java FX 不是这种合并的一部分。 本主题将在 [](03.html) ，*发现 Java 11* 中进一步解释。

# 垃圾收集界面

Java 10 迎来了垃圾收集过程的增强功能。 一个新的垃圾收集器接口导致改进，将在[第 7 章](07.html)，*利用默认 G1 垃圾收集器*中进行改进。

# G1 的并行全垃圾收集器

在 Java 10 中，G1 全垃圾收集器并行。 从 Java 9 开始，G1 是默认的垃圾收集器，因此这种变化具有特殊意义。 此更改将在[第 7 章](07.html)，*利用默认 G1 垃圾收集器*中进行了详细。

# 应用程序类数据共享

**类数据共享**（ **CDS** ）已扩展到支持更快的应用程序启动和较小的占用脚印。 使用 CD，开发人员可以预先解析特定的类文件并存储在可共享存档中。 我们将探讨此更改 [](02.html) ，*发现 Java 11* 。

# 线程局部握手

使用 Java 10 及更大，可以停止单个线程而无需执行全局虚拟机安全点。 我们将完全探索 [](03.html)[](03.html)， *Java 11 基本面*的变化。

# 删除本机标题生成工具（Javah）

承诺从 JDK 中删除 Javah 工具的共同努力。 由于`javac`中提供的功能，保证了此更改。 我们将详细介绍[第 11 章](11.html)，*新工具和工具增强功能*。

# 其他 Unicode 语言标记扩展

Java 平台已经支持了语言标签，因为 Java 7.在 Java 10 中，对`java.util.Local`和相关 API 进行了更改以结合其他 Unicode 语言标记。 详细信息将介绍[第 2 章](02.html)，*发现 Java 11* 。

# 替代存储器设备上的堆分配

java 10 的热点虚拟机支持非 DRAM 存储器设备。 这将在[第 3 章](03.html)， *Java 11 基础*中进行解释。

# 基于实验 Java 的 JIT 编译器

Java 9 向我们介绍了基于 Java 的**即时**（ **JIT** ）编译器。 此 JIT 编译器已启用 Linux / X64 平台。 该实验编译器将在[第 14 章](14.html)，*命令行标志*中进一步探索。

# 根证书

从 java 10 的发布开始，已有默认的**证书颁发机构**（ **ca** ）证书作为 JDK 的一部分。 [第 3 章](03.html)， *Java 11 基本面*将涵盖这种变化及其益处。

# 受益于 Java 11 引入的更改

Java 11，于 2018 年 9 月发布，并在此处列出了四个功能：

*   动态类文件常量
*   epsilon-一个任意低开销的垃圾收集器
*   删除 Java EE 和 CORBA 模块
*   lampda 参数的局部变量语法

本章介绍了这些功能的简要概述，在后续章节中具有更详细的覆盖范围。

# 动态类文件常量

在 Java 11 中，Java 类文件的文件格式扩展为支持`CONSTANT_Dynamic`，委派委托给 Bootstrap 方法。 在[第 3 章](03.html)， *Java 11 基础*中将完全探索此更改。

# epsilon - 任意低开销的垃圾收集器

垃圾收集增强似乎是每个 Java 平台发布的一部分。 Java 11 包括无源垃圾收集器，不会回收内存。 我们将在[第 7 章](07.html)中探讨它，*利用默认 G1 垃圾收集器*。

# 删除 Java EE 和 CORBA 模块

**java 企业版**（ **java** **ee** ）和**常见的对象请求代理架构**（ **corba** ）模块被折旧 在 Java 9 中并已从 Java 平台中删除，java 11.详细信息在[第 3 章](03.html)， *Java 11 基础*中提供。

# lampda 参数的局部变量语法

如本章前面所讨论的，`var`标识符在 Java 10 中引入。使用最新版本，Java 11，`var`可用于隐式键入的 Lambda 表达式。 `var`标识符在 [第 3 章](03.html)，*， *java 11 基本原理*中介绍。*

# 概括

在本章中，我们探索了 Java 平台的新实现了基于时间的版本控制系统。 我们还在高级别学习了 Java 9,10 和 11 中引入的更改（分别称为版本 9,18.3 和 18.9）。 Java 9 最显着的变化是基于项目拼图的模块化，包括额外的更改，专注于 Java Shell，控制外部过程，垃圾收集，JHM 等。 涵盖了 Java 10 的关键功能，包括局部变量类型推断，JDK 合并，垃圾收集，应用程序 CD，根证书等。 Java 11 中引入的更改包括 Lambdas 的动态类文件常量，垃圾收集，局部变量类型推断等。

在下一章中，我们将查看 Java 平台中引入的几个内部更改，包括 Java 9,10 和 11 的更改。

# 问题

1.  第一个 Java 版本是 2019 年的？
2.  新的 Java 时间的释放模型是什么的一个关键优势？
3.  JDK 9 的 Java 平台最重要的变化是什么？
4.  用 Java 11 删除了什么：CORBA，LAMBDA 或 G1？
5.  CD 是否支持更快的启动或更高效的垃圾收集？
6.  什么是 epsilon？
7.  是`var`数据类型，标识符，保留字或关键字？
8.  哪个 Java 发布将根证书引入 Java 平台？
9.  哪个版本包括垃圾收集的增强功能？
10.  Java 中的默认垃圾收集器是什么？

# 进一步阅读

本调查章节为 Java 平台的最近更改采用了广泛的刷子方法。 如果您的任何概念对您不熟悉，请考虑使用以下一个或多个资源刷新您的 Java 知识：

*   *java：面向对象的编程概念[集成课程]* ，可在 [https://www.packtpub.com/application-development/java-object-ontegrate-.course](https://www.packtpub.com/application-development/java-object-oriented-programming-concepts-integrated-course) 。

*   *Java 9 高性能*，可在 [https://www.packtpub.com/application-development/java-9-high-performance](https://www.packtpub.com/application-development/java-9-high-performance) 。