# 新工具和工具增强功能

在上一章中，我们学习了如何使用`StackWalker` API 并检查示例代码片段以加强我们的理解。 我们对 API 的详细审查包括不同的使用情况，选项和信息。 我们探讨了 API 对类使用情况的复杂性和共享细节。 我们介绍了看与`StackWalker` API 相关的性能问题的章节。

在本章中，我们将介绍与现代 Java 平台相关的十几个工具和工具增强功能。 特色更改将涵盖广泛的工具和更新到 API，其旨在通过 Java 更轻松地开发，并增强创建优化的 Java 应用程序的能力。

更具体地，我们将审查以下主题：

*   HTTP 客户端
*   javadoc 和 doclet api
*   mjre 变化
*   JavaScript 解析器
*   多释放 jar 文件
*   Java 级 JVM 编译器界面
*   TIFF 支持
*   平台日志记录
*   XML 目录
*   收藏品
*   特定于平台的桌面功能
*   增强方法处理
*   增强折旧
*   本机标题生成工具（`javah`）

# 技术要求

本章具有 Java 11\. Java 平台的**标准版**（ **SE** ）可以从 Oracle 的官方下载站点下载： [http://www.oracle.com/ technetwork / java / javase / downloads / index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html) 。

IDE 软件包就足够了。 来自 JetBrains 的 Intellij Idea 用于与本章相关的所有编码以及随后的章节。 可以从网站上下载 Intexij Idea 的社区版本（ [https://www.jetbrains.com/idea/features/](https://www.jetbrains.com/idea/features/) ）。

本章的源代码在 URL（ [https://github.com/packtpublthishing/mastering-java-11-chishtition](https://github.com/PacktPublishing/Mastering-Java-11-Second-Edition) ）上提供。

# 使用 HTTP 客户端

在本节中，我们将审核 Java 的**超文本传输​​协议**（ **http** ）客户端，从旧的，前 java 9 客户端开始，然后潜入新的 HTTP 客户端 是当前 Java 平台的一部分。 最后，我们将看一下当前 HTTP 客户端的局限性。 需要这种方法来支持对变化的理解。

# 预 java 9 http 客户端

JDK 版本 1.1 介绍了支持 HTTP 特定功能的`HttpURLConnection` API。 这是一个包含以下字段的强大类：

| 

*   `fixedContentLength`
*   `fixedContentLengthLong`

`HTTP_BAD_METHOD`

*   `HTTP_BAD_REQUEST`
*   `HTTP_CLIENT_TIMEOUT`

*   `HTTP_ENTITY_TOO_LARGE` `HTTP_ENTITY_TOO_LARGE` `HTTP_ENTITY_TOO_LARGE` `HTTP_ENTITY_TOO_LARGE` `HTTP_ENTITY_TOO_LARGE` `HTTP_ENTITY_TOO_LARGE`
*   `HTTP_FORBIDDEN`
*   `HTTP_GONE`
*   `HTTP_INTERNAL_ERROR`

 | 

*   `HTTP_MOVED_PERM`
*   `HTTP_MOVED_TEMP`

`HTTP_NOT_ACCEPTABLE`

*   `HTTP_NOT_AUTHORITATIVE`
*   `HTTP_NOT_FOUND`

*   `HTTP_OK` `HTTP_OK` `HTTP_OK` `HTTP_OK` `HTTP_OK` `HTTP_OK`
*   `HTTP_PARTIAL`
*   `HTTP_PAYMENT_REQUIRED`
*   `HTTP_PRECON_FAILED`

 | 

*   `HTTP_REQ_TOO_LONG`
*   `HTTP_RESET`

`HTTP_UNAUTHORIZED`

*   `HTTP_UNAVAIABLE`
*   `HTTP_UNSUPPORTED_TYPE`

*   `instanceFollowRedirects` `instanceFollowRedirects` `instanceFollowRedirects` `instanceFollowRedirects` `instanceFollowRedirects` `instanceFollowRedirects`
*   `method`
*   `responseCode`
*   `responseMessage`

 |

正如您可以从上述字段列表中看到的，那么对 HTTP 已经很大。 除了构造函数之外，还有一种可用的方法，包括以下内容：

*   `disconnect()`
*   `getErrorStream()`
*   `getFollowRedirects()`
*   `getHeaderField(int n)`
*   `getHeaderFieldDate(String name, long Default)`
*   `getHeaderFieldKey(int n)`
*   `getInstanceFollowRedirects()`
*   `getPermission()`
*   `getRequestMethod()`
*   `getResponseCode()`
*   `getResponseMessage()`
*   `setChunkedStreamingMode(int chunklen)`
*   `setFixedLengthStreamingMode(int contentLength)`
*   `setFixedlengthStreamingMode(long contentLength)`
*   `setFollowRedirects(boolean set)`
*   `setInstanceFollowRedircts(boolean followRedirects)`
*   `setRequestMethod(String method)`
*   `usingProxy()`

提前列出的类方法是从`java.net.URLConnection`类和`java.lang.Object`类继承的方法之外。

原始 HTTP 客户端存在问题，使其成熟以便使用新的 Java 平台更新。 这些问题如下：

*   基础`URLConnection` API 对诸如 Gopher 和 FTP 的废除协议变得越来越多的问题
*   `HttpURLConnection` API 捕获 HTTP 1.1，过于抽象，使其无法使用
*   在记录后，HTTP 客户端令人讨厌，使 API 令人沮丧，难以使用
*   客户一次仅在一个线程上运行
*   由于它在预测 HTTP 1.1 并且缺乏足够的文档，API 非常难以维持

现在我们知道先前的 HTTP 客户端出了什么问题，让我们来看看当前的 HTTP 客户端。

# Java 11 HTTP 客户端

有几种目标与创建现代 Java 平台的新 HTTP 客户端相关联，可用 Java 9,10 和 11.在下表中列出了主要目标。 这些目标在广泛的使用易用性，核心功能，额外功能和性能方面提供：

| 便于使用 | 

*   API 旨在提供高达 90％的 HTTP 相关的应用要求。
*   新 API 可用于最常见的用例，没有不必要的复杂性。
*   包括简单的阻塞模式。
*   API 支持现代 Java 语言功能。 Lambda 表达式，具有 Java 8 发布的主要新介绍，是一个例子。

 |
| 核心能力 | 

*   支持 https / tls
*   支持 HTTP / 2
*   提供与 HTTP 协议请求相关的所有细节的可见性
*   支持标准/常见的身份验证机制
*   提供报头接收的事件通知
*   提供响应主体接收的事件通知
*   提供错误事件通知

 |
| 额外的能力 | 

*   新 API 可用于 WebSocket 握手
*   它与当前网络 API

执行安全检查 |
| 表现 | http / 1.1 的

*   ：
    *   新的 api 必须至少有效地作为上一个 API 执行。
    *   存储器消耗不得超过 Apache Httpclient，NetTy 和 Jetty 的内存消耗，当用作客户端 API 时。

*   对于 http / 2：
    *   性能必须超过 HTTP / 1.1 的性能。
    *   当用作客户端 API 时，新的性能必须匹配或超过 NETTY 和 JETTY 的匹配。 性能下降不应成为新客户端的结果。
    *   当用作客户端 API 时，内存消耗不得超过 Apache Httpclient，NetTy 和 Jetty 的内存消耗。

*   避免了运行定时器线程。

 |

# HTTP 客户端 API 的限制

HTTP 客户端 API 有一些有意的缺点。 虽然这可能会对反向直观，但新的 API 并不旨在完全替换当前的`HttpURLConnection` API。 相反，新 API 旨在最终更换当前的 API。

以下代码段提供了如何实现`HttpURLConnect`类以在 Java 应用程序中读取 URL 的示例：

```
/*
import statements
*/

public class HttpUrlConnectionExample {
  public static void main(String[] args) {
    new HttpUrlConnectionExample();
  }

  public HttpUrlConnectionExample() {
    URL theUrl = null;
    BufferedReader theReader = null;
    StringBuilder theStringBuilder;

    // put the URL into a String
    String theUrl = "https://www.packtpub.com/";

    // here we are creating the connection
    theUrl = new URL(theUrl);
    HttpURLConnection theConnection = (HttpURLConnection)
      theUrl.openConnection();

    theConnection.setRequestedMethod("GET");

    // add a delay
    theConnection.setReadTimeout(30000); // 30 seconds
    theConnection.connect();

    // next, we can read the output
    theReader = new BufferedReader(
      new InputStreamReader(theConnection.getInputStream()));
    theStringBuilder = new StringBuilder();

    // read the output one line at a time
    String theLine = null;
    while ((theLine = theReader.readLine() != null) {
      theStringBUilder.append(line + "\n");
    }

    // echo the output to the screen console
    System.out.println(theStringBuilder.toString());

    // close the reader
    theReader.close();
  }
}
. . .
```

前面的代码不包括简洁的异常处理。

以下是新 API 的一些具体限制：

*   并非所有相关的功能都得到支持。 据估计，API 未公开约 10％的 HTTP 协议。
*   标准/常见的身份验证机制仅限于基本身份验证。
*   新 API 的总体目标是使用的简单性，这意味着可能无法实现性能改进。 当然，将没有表现下降，但它不太可能会有压倒性的改进水平。
*   没有支持对请求进行过滤。
*   没有支持过滤响应。
*   新 API 不包括可插拔连接缓存。
*   缺乏一般升级机制。

# 了解 javadoc 和 doclet api

javadoc 和 doclet api 密切相关。 Javadoc 是一个文档工具，DoCLET API 提供功能，以便我们可以检查嵌入在库和程序的源级别的 Javadoc 评论。 在本节中，我们将审查 DoCLET API（java 9）的早期状态，然后探索在当前 Java 平台中引入的 DOCLET API 的更改。 最后，我们将审查 Javadoc。

# java 前 9 doclet api

java 前 9 doclet api 或`com.sun.javadoc`包，让我们访问位于源代码中的 Javadoc 评论。 通过使用`start`方法来完成调用 DOCCLET。 此方法的签名是`public static boolean start(RootDoc root)`。 我们将使用`RootDoc`实例作为程序结构信息的容器。

为了调用 javadoc，我们需要通过以下方式：

*   包名称
*   源文件名（对于类和接口）
*   访问控制选项 - 以下之一：
*   `package`
*   `private`
*   `protected`
*   `public`

当前面的列出的项目用于调用`javadoc`时，将提供文档集作为过滤列表。 如果我们的目标是获得全面，未经过滤的清单，我们可以使用`allClasses(false)`。

让我们回顾一个示例 Doclet：

```
// Mandatory import statement
import com.sun.javadoc.*;

// We will be looking for all the @throws documentation tags
public class AllThrowsTags extends Doclet {

  // This is used to invoke the Doclet.
  public static boolean start(Rootdoc myRoot) {
    // "ClassDoc[]" here refers to classes and interfaces.
    ClassDoc[] classesAndInterfaces = myRoot.classesAndInterfaces();
    for (int i = 0; i < classesAndInterfaces.length; ++i) {
      ClassDoc tempCD = classesAndInterfaces[i];
      printThrows(tempCD.contructors());
      printThrows(tempCD.methods());
    }
    return true;
  }

  static void printThrows(ExecutableMemberDoc[] theThrows) {
    for (int i = 0; i < theThrows.length; ++i) {
      ThrowsTag[] throws = theThrows[i].throwsTags();
      // Print the "qualified name" which will be 
      // the class or interface name
      System.out.println(theThrows[i].qualifiedName());
      // A loop to print all comments with the 
      // Throws Tag that belongs to the previously
      // printed class or interface name
      for (int j = 0; j < throws.length; ++j) {
        // A println statement that calls three 
        // methods from the ThrowsTag Interface: 
        // exceptionType(), exceptionName(),
        // and exceptionComment().
        System.out.println("--> TYPE: " + 
          throws[j].exceptionType() +
          " | NAME: " + throws[j].exceptionName() +
          " | COMMENT: " + throws[j].exceptionComment());
      }
    }
  }
}
```

正如您所看到的彻底评论代码，对`javadoc`内容的访问相对容易。 在我们的前述示例中，我们将通过使用命令行中的以下代码来调用`AllThrows`类：

```
javadoc -doclet AllThrowsTags -sourcepath <source-location> java.util
```

我们的结果输出将包括以下结构：

```
<class or interface name>
TYPE: <exception type> | NAME: <exception name> | COMMENT: <exception comment>
TYPE: <exception type> | NAME: <exception name> | COMMENT: <exception comment>
TYPE: <exception type> | NAME: <exception name> | COMMENT: <exception comment>
<class or interface name>
TYPE: <exception type> | NAME: <exception name> | COMMENT: <exception comment>
TYPE: <exception type> | NAME: <exception name> | COMMENT: <exception comment>
```

# API 枚举

API 由一个枚举`LanguageVersion`组成，它提供了 Java 编程语言版本。 该枚举的常数是`Java_1_1`和`Java_1_5`。

# API 课程

`Doclet`类提供了如何创建类以启动 DOCLET 的示例。 它包含一个空的`Doclet()`构造函数和以下方法：

*   `languageVersion()`
*   `optionLength(String option)`
*   `start(RootDoc root)`
*   `validOptions(String[][] options, DocErrorReporter reporter)`

# API 界面

doclet api 包含以下列出的接口。 接口名称是不言自明的。 您可以查阅文档以获取其他详细信息：

| 

`AnnotationValue`

*   `ClassDoc`
*   `ConstructorDoc`

 | 

`PackageDoc`

*   `Parameter`
*   `ParameterizedType`

 | 

*   `RootDoc`

*   `SourcePosition`] `Tag`
*   `ThrowsTag`

 |

# 预先存在的 doclet api 问题

推动对新的 DoCLET API 的需求是预先存在的 Doclet API 的几个问题：

*   它不适合测试或并发使用。 这源于其静态方法的实现。
*   API 中使用的语言模型有几个限制，并且每个连续的 Java 升级都变得更加问题。
*   API 效率低下，主要是由于其繁重使用子字符串匹配。
*   关于任何给定评论的具体位置没有参考。 这使得诊断和排除困难。

# Java 9 的 DOCLET API

既然您在 java 9 之前存在的 DOCLET API 上有一个很好的句柄，让我们看看已经使用 Java 9 平台进行了哪些更改和传递。 新的 doclet api 在`jdk.javadoc.doclet`包中。

在高级别，DOCLET API 的更改如下：

*   更新`com.sun.javadoc` doclet api 以利用多个 java se 和 jdk apis
*   更新`com.sun.tools.doclets.standard.Standard` doclet 以使用新的 API
*   支持用于创建自定义`javadoc`标记的更新的 Taglet API

除了上述更改外，新 API 还使用以下两个 API：

*   编译器树 API
*   语言模型 API

让我们在以下部分中探索这些中的每一个。

# 编译树 API.

编译器树 API 位于`com.sun.source.doctree`包中。 它为文档源级评论提供了多个接口。 这些 API 表示为**抽象语法树**（ **AST** ）。

有两个枚举如下：

*   `AttributeTree.ValueKind`，具有以下常量：
*   `DOUBLE`
*   `EMPTY`
*   `SINGLE`
*   `UNQUOTED`

*   `DocTree.Kind`，具有以下常量：
*   `ATTRIBUTE`
*   `AUTHOR`
*   `CODE`
*   `COMMENT`
*   `DEPRECATED`
*   `DOC_COMMENT`
*   `DOC_ROOT`
*   `END_ELEMENT`
*   `ENTITY`
*   `ERRONEOUS`
*   `EXCEPTION`
*   `IDENTIFIER`
*   `INHERIT_DOC`
*   `LINK`
*   `LINK_PLAIN`
*   `LITERAL`
*   `OTHER`
*   `PARAM`
*   `REFERENCE`
*   `RETURN`
*   `SEE`
*   `SERIAL`
*   `SERIAL_DATA`
*   ``SERIAL_FIELD``
*   `SINCE`
*   `START_ELEMENT`
*   `TEXT`
*   `THROWS`
*   `UNKNOWN_BLOCK_TAG`
*   `UNKNOWN_INLINE_TAG`
*   `VALUE`
*   `VERSION`

`com.sun.source.doctree`包包含多个接口。 它们详述了下表：

| **接口名称** | **延伸** | 的树节点 | **非继承方法** |
| `AttributeTree` | `DocTree` | HTML 元素 | `getName()`，`getValue()`，`getValueKind()` |
| `AuthorTree` | `BlockTagTree, DocTree` | `@author`块标签 | `getName()` |
| `BlockTagTree` | `DocTree` | 不同类型的块标记的基类 | `getTagName()` |
| `CommentTree` | `DocTree` | 使用以下 HTML 标签的嵌入式 HTML 评论 - `<!--text-->` | `getBody()` |
| `DeprecatedTree` | `BlockTagTree` | `@deprecated`块标签 | `getBody()` |
| `DocCommentTree` | `DocTree` | 身体块的标签 | `getBlockTags()`，`getBody()`，`getFirstSentence()` |
| `DocRootTree` | `InlineTagTree` | `@docroot`内联标签 | N / A. |
| `DocTree` | N / A. | 所有的共同界面 | `accept(DocTreeVisitor<R,D>visitor,Ddata)`，`getKind()` |
| `DocTreeVisitor<R,P>` | N / A. | `R` =返回类型的访客方法; `P` =附加参数的类型 | `visitAttribute(AttributeTree node, P p)`，`visitAuthor(AuthorTree node, P p)`，`visitComment(CommentTree node, P p)`，`visitDeprecated(DeprecatedTree node, P p)`，`visitDocComment(DocCommentTree node, P p)`，`visitDocRoot(DocRootTree node, P p)`，`visitDocRoot(DocRootTree node, P p)`，`visitEntity(EntityTree node, P p)`，`visitEntity(EntityTree node, P p)`，`visitErroneous(ErroneousTree node, P p)`，`visitErroneous(ErroneousTree node, P p)`，`visitAuthor(AuthorTree node, P p)`，`visitAuthor(AuthorTree node, P p)`，`visitInheritDoc(InheritDocTree node, P p)`，`visitInheritDoc(InheritDocTree node, P p)`，`visitInheritDoc(InheritDocTree node, P p)`，`visitLink(LinkTree node, P p)`，[HTG12 `visitOther(DocTree node, P p)`，`visitParam(ParamTree node, P p)`，`visitReference(ReferenceTree node, P p)`，`visitReturn(ReturnTree node, P p)`，`visitSee(SeeTree node, P p)`，`visitSee(SeeTree node, P p)`，`visitSerial(SerialTree node, P p)`，`visitSerialData(SerialDataTree node, P p)`，`visitInheritDoc(InheritDocTree node, P p)`，`visitSerialField(SerialFieldTree node, P p)`，`visitSince(SinceTree node, P p)`，`visitStartElement(StartElementTree node, P p)`，`visitStartElement(StartElementTree node, P p)`，`visitText(TextTree node, P p)`，`visitThrows(ThrowsTree node, P p)`， `visitUnknownBlockTag(UnknownBlockTagTree node, P p)`，`visitUnknownInlineTag(UnknownInlineTagTree node, P p)`，`visitValue(ValueTree node, P p)`，`visitVersion(VersionTree node, P p) ` |
| `EndElementTree` | `DocTree` | HTML 元素的结尾`</name>` | `getName()` |
| `EntityTree` | `DocTree` | HTML 实体 | `getName()` |
| `ErroneousTree` | `TextTree` | 这是针对畸形文本 | `getDiagnostic()` |
| `IdentifierTree` | `DocTree` | 注释中的标识符 | `getName()` |
| `InheritDocTree` | `InlineTagTree` | `@inheritDoc`内联标签 | N / A. |
| `InlineTagTree` | `DocTree` | 内联标签的通用接口 | `getTagName()` |
| `LinkTree` | `InlineTagTree` | `@link`或`@linkplan`内联标签 | `getLabel(), getReference()` |
| `LiteralTree` | `InlineTagTree` | `@literal`或`@code`内联标签 | `getBody()` |
| `ParamTree` | `BlockTagTree` | `@param`块标签 | `getDescription()`，`getName()`，`isTypeParameter()` |
| `ReferenceTree` | `DocTree` | 用于引用 Java Lang 元素 | `getSignature()` |
| `ReturnTree` | `BlockTagTree` | `@return`块标签 | `getDescription()` |
| `SeeTree` | `BlockTagTree` | `@see`块标签 | `getReference()` |
| `SerialDataTree` | `BlockTagTree` | `@serialData`块标签 | `getDescription()` |
| `SerialFieldTree` | `BlockTagTree` | `@serialData`块标签和`@serialField`字段名称和描述 | `getDescription()`，`getName()`，`getType()` |
| `SerialTree` | `BlockTagTree` | `@serial`块标签 | `getDescription()` |
| `SinceTree` | `BlockTagTree` | `@since`块标签 | `getBody()` |
| `StartElementTree` | `DocTree` | html 元素的开始`< name [attributes] [/] >` | `getAttributes()`，`getName()`，`isSelfClosing()` |
| `TextTree` | `DocTree` | 纯文本 | `getBody()` |
| `ThrowsTree` | `BlockTagTree` | `@exception`或`@throws`块标签 | `getDescription(), getExceptionname()` |
| `UnknownBlockTagTree` | `BlockTagTree` | 无法识别的内联标签 | `getContent()` |
| `UnknownInlineTagTree` | `InlineTagTree` | 无法识别的内联标签 | `getContent()` |
| `ValueTree` | `InlineTagTree` | `@value`内联标签 | `getReference()` |
| `VersionTree` | `BlockTagTree` | `@version`块标签 | `getBody()` |

# 语言模型 API.

语言模型 API 位于`java.lang.model`包中。 它包括用于语言处理和语言建模的包和类。 它由以下组件组成：

*   `AnnotatedConstruct`界面
*   `SourceVersion`枚举
*   `UnknownEntityException`例外

在以下三个部分中进一步探讨了这些语言模型 API 组件中的每一个。

# AnnotatedConstruct 界面

`AnnotatedConstruction`接口为自版本 1.8 自版本为本的 Java 平台的一部分，提供了一个注释的构造。 它适用于构造，它是元素（接口`Element`）或类型（接口`TypeMirror`）。 每个构造的注释不同，如下表所示：

| **构造类型** | **interface** | **注释** |
| `element` | `Element` | 宣言 |
| `type` | `TypeMirror` | 基于类型名称的使用 |

`AnnotatedConstruction`界面有三种方法：

*   `getAnnotation(Class<A> annotationType)`：此方法返回构造注释的类型
*   `getAnnotationMirrors()`：此方法返回构造上的注释列表
*   `getAnnotationsByType(Class<A> annotationType)`：此方法返回构造的相关注释

# SourceVersion 枚举

`SourceVersion`枚举由以下常量组成：

*   `RELEASE_0`
*   `RELEASE_1`
*   `RELEASE_2`
*   `RELEASE_3`
*   `RELEASE_4`
*   `RELEASE_5`
*   `RELEASE_6`
*   `RELEASE_7`
*   `RELEASE_8`
*   `RELEASE_9`

预计`SourceVersion`枚举将被更新为包含`RELEASE_10`和`RELEASE_11`，因为 Java 平台的这些版本是正式发布的。

此枚举还包含几种方法，如下：

**方法名称**：`isIdentifier`：

```
public static boolean isIdentifier(CharSequence name)
```

如果参数字符串是 Java 标识符或关键字，则此方法返回`true`。

**方法名称**：`isKeyword`：

```
public static boolean isKeyword(CharSequence s)
```

如果给定的`CharSequence`是文字或关键字，则此方法返回`true`。

**方法名称**：`isName`：

```
public static boolean isName(CharSequence name)
```

如果`CharSequence`是一个有效名称，则此方法返回`true`。

**方法名称**：`latest`：

```
public static SourceVersion latest()
```

此方法返回用于建模目的的最新源版本。

**方法名称**：`latestSupported`：

```
public static SourceVersion latestSupported()
```

此方法返回可完全支持建模的最新源版本。

**方法名称**：`valueOf`：

```
public static SourceVersion valueOf(String name)
```

此方法基于提供的参数字符串返回枚举常量。

您应该意识到`value(String name)`方法抛出两个例外：`IllegalArgumentException`和`NullPointerException`。

**方法名称**：`values`：

```
public static SourceVersion[] values()
```

此方法返回枚举常量的数组。

# UnknownEntityException 异常

`UnknownEntityException`类扩展了`RuntimeException`，是一个未知异常的超类。 类构造函数如下：

```
protected UnknownEntityException(String message)
```

构造函数将使用作为字符串参数提供的消息创建一个新的`UnknownEntityException`实例。 该方法不采取其他参数。

此类没有自己的方法，但继承来自`java.lang.Throwable`和`class.java.lang.Object`类的方法，如下所示：

`java.lang.Throwable`类方法如下：

*   `addSuppressed()`
*   `fillInStackTrace()`
*   `getCause()`
*   `getLocalizedMessage()`
*   `getMessage()`
*   `getStackTrace()`
*   `getSuppressed()`
*   `initCause()`
*   `printStackTrace()`
*   `setStackTrace()`
*   `toString()`

`java.lang.Object`类方法如下：

*   `clone()`
*   `equals()`
*   `finalize()`
*   `getClass()`
*   `hashCode()`
*   `notify()`
*   `notifyAll()`
*   `wait()`

# 使用 HTML5 javadoc

Javadoc 工具已更新为现代 Java 平台，定义为 Java 9 及更高版本。 除了 HTML 4 之外，它还可以生成 HTML 5 标记输出.Javadoc 工具为 HTML 4 和 HTML 5\. HTML 5 提供支持，如 Java 10，是默认输出标记格式。

以下短 Java 应用程序只需通过`319` -high 帧生成`319` -wide。 在这里显示没有任何 javadoc 标签，我们将在本节后面讨论：

```
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class JavadocExample {

  public static void main(String[] args) {
    drawJFrame();
  }

  public static void drawJFrame() {
    JFrame myFrame = new JFrame("Javadoc Example");
    myFrame.setSize(319,319);
    myFrame.setDefaultCloseOperation(
      WindowConstants.EXIT_ON_CLOSE);
    myFrame.setVisible(true);
  }
}
```

一旦您的包或类完成，您可以使用 Javadoc 工具生成 JavadoC。 您可以从命令行或 IDE 中运行位于 JDK `/bin`目录中的 Javadoc 工具。 每个 IDE 都以不同的方式处理 Javadoc。 例如，在 Eclipse 中，您将从下拉菜单中选择“项目”，然后选择“生成 javadoc”。 在 Intellij Ide IDE 中，您可以选择“工具”下拉菜单，然后选择“生成 Javadoc”。

以下屏幕截图显示了生成 Javadoc 功能的 Intellij Idea 接口。 正如您所看到的，`-html5`命令行参数已包含：

![](img/ee0c059a-46ae-45ba-8171-347dbb1e8a78.png)

生成 javadoc.

单击“确定”按钮时，您将看到一系列状态消息，如以下示例所示：

```
"C:\Program Files\Java\jdk-9\bin\javadoc.exe" -public -splitindex -use -author -version -nodeprecated -html5 @C:\Users\elavi\AppData\Local\Temp\javadoc1304args.txt -d C:\Chapter11\JDOutput
Loading source file C:\Chapter11\src\JavadocExample.java...
Constructing Javadoc information...
Standard Doclet version 9
Building tree for all the packages and classes...
Generating C:\Chapter11\JD-Output\JavadocExample.html...
Generating C:\Chapter11\JD-Output\package-frame.html...
Generating C:\Chapter11\JD-Output\package-summary.html...
Generating C:\Chapter11\JD-Output\package-tree.html...
Generating C:\Chapter11\JD-Output\constant-values.html...
Generating C:\Chapter11\JD-Output\class-use\JavadocExample.html...
Generating C:\Chapter11\JD-Output\package-use.html...
Building index for all the packages and classes...
Generating C:\Chapter11\JD-Output\overview-tree.html...
Generating C:\Chapter11\JD-Output\index-files\index-1.html...
Generating C:\Chapter11\JD-Output\index-files\index-2.html...
Generating C:\Chapter11\JD-Output\index-files\index-3.html...
Building index for all classes...
Generating C:\Chapter11\JD-Output\allclasses-frame.html...
Generating C:\Chapter11\JD-Output\allclasses-frame.html...
Generating C:\Chapter11\JD-Output\allclasses-noframe.html...
Generating C:\Chapter11\JD-Output\allclasses-noframe.html...
Generating C:\Chapter11\JD-Output\index.html...
Generating C:\Chapter11\JD-Output\help-doc.html...
javadoc exited with exit code 0
```

一旦 Javadoc 工具退出，您就可以查看 javadoc。 以下是基于先前提供的代码生成的屏幕截图。 正如您所看到的，它以相同的方式格式化，其中记录了 Oracle 的正式 Java 文档：

![](img/483343ad-839b-43bd-ba78-3da44cde0dea.png)

样本 javadoc.

当我们生成 javadoc 时，创建了多个文档，如以下屏幕截图中提供的目录树所示：

![](img/240fe7f5-0c0a-4a01-b1db-44e042d1b766.png)

javadoc 目录树

您还可以添加 javadoc 工具识别的可选标记。 这些标签在此提供：

*   `@author`
*   `@code`
*   `@deprecated`
*   `@docRoot`
*   `@exception`
*   ``@inheritDoc``
*   `@link`
*   ``@linkplain``
*   `@param`
*   `@return`
*   `@see`
*   `@serial`
*   `@serialData`
*   `@serialField`
*   `@since`
*   `@throws`
*   `@value`
*   `@version`

有关如何为 Javadoc 工具编写文档评论的详细信息，您可以访问 Oracle 的官方指令 http://www.oracle.com/technetwork/articles/articles/java/index-137868.html 。

# javadoc 搜索

在 Java 9 之前，难以导航的标准 Doclet 生成的 API 文档页面。 除非您非常熟悉这些文档页面的布局，否则您可能会使用基于浏览器的查找功能来搜索文本。 这被认为是笨拙和次优。

当前平台包括作为 API 文档的一部分的搜索框。 此搜索框由标准 DOCLET 授予，可用于在文档中搜索文本。 这代表了开发人员的极大方便，并且可能会改变我们对 Doclet 生成的文件的使用。

使用新的 Javadoc 搜索功能，我们有能力搜索以下索引组件：

*   模块名称
*   包名称
*   类型
*   成员
*   使用 New `@index`内联标记索引的术语/短语

# 介绍骆驼案例搜索

Javadoc 搜索功能包括使用骆驼案例搜索的伟大快捷方式。 例如，我们可以搜索`openED`以找到`openExternalDatabase()`方法。

# 更改多个 JRE 功能

以前用于在推出我们的应用程序的情况下指定特定的 JRE 版本或版本范围，以指定特定的 JRE 版本或版本范围，用于指定特定的 JRE 版本或版本范围。 我们将通过命令行选项`-version`或在 JAR 文件的清单中输入此操作。 以下流程图显示了基于我们的选择会发生什么：

![](img/e96e35e9-c105-4eaf-b741-0e69b856ac91.png)

多个 JRE Flow.

使用 JDK 5 引入了此功能，并未在该版本中或在 JDK 9 之前的任何后续版本中完全记录。

使用现代平台引入了以下特定变化：

*   MJRE 功能已被删除。
*   每当使用`-version`命令行选项时，启动器现在将产生错误。 这是该处理中不会继续的终端错误。
*   在 Java 9 中，如果 jar 清单中存在`-version`条目，将产生警告。 警告不会停止执行。
*   在 Java 10 和 11 中，清单文件中的`-version`条目的存在将导致终端错误。

# JavaScript 解析器

最近对 Java 平台的改变是为 Nashorn 的 ECMAScript AST 创建 API。 在本节中，我们将单独查看 Nashorn，EcMascript，然后在 Parser API。

# 犀牛

Oracle Nashorn 是 JavaScript 引擎，用于 JVM，由 Oracle 在 Java 中开发。 它与 Java 8 发布，并创建以提供具有高效和轻量级的 JavaScript 运行时引擎的开发人员。 使用此引擎，开发人员能够在其 Java 应用程序中嵌入 JavaScript 代码。 在 Java 8 之前，开发人员可以访问由 Netscape 创建的 JavaScript 引擎。 1997 年推出的发动机由 Mozilla 维持。

Nashorn 可以用作命令行工具和 Java 应用程序中的嵌入式解释器。 让我们看看两者的例子。

Nashorn 是犀牛的德国词。 从 Mozilla Foundation 从犀牛名为 JavaScript 引擎产生的名称。 据说犀牛起源于 javascript 书籍封面上的动物的照片。 在有趣的事实下归档这个。

# 使用 nashorn 作为命令行工具

nashorn 可执行文件`jjs.exe`驻留在`\bin`文件夹中。 要访问它，可以导航到该文件夹​​，或者如果系统路径适当设置，可以通过在系统上的终端/命令提示符窗口中输入`jjs`命令来启动 shell：

![](img/86f9e555-1bc7-4bbc-bbb5-43b719abda1f.png)

Nashorn 可执行文件的位置

在这里，您可以看到一个开放式终端窗口，首先检查 Java 的版本，然后使用`jjs -version`命令启动 Nashorn Shell。 在此示例中，Java 和 Nashorn 都是 1.8.0.121 版本。 或者，我们可以简单地使用`jjs`命令启动 nashorn，并且 shell 将在没有版本标识的情况下打开：

![](img/c363b799-e305-4757-ac57-55a76dadfaad.png)

使用 JJS 命令启动 Nashorn

接下来，让我们创建一个简短的 JavaScript 并使用 Nashorn 运行它。 考虑以下简单的 JavaScript 代码，其中有三行输出：

```
var addtest = function() {
  print("Simple Test");
  print("This JavaScript program adds the 
    numbers 300 and 19.");
  print("Addition results = " + (300 + 19));
}
addtest();
```

要具有 Java 运行此 JavaScript 应用程序，我们将使用`jjs addtest.js`命令。 以下是输出：

![](img/1763415e-3938-41c6-9775-803bd89973d4.png)

使用 Java 运行 JavaScript

你可以用 nashorn 做很多。 从终端/命令提示符窗口中，我们可以使用`-help`选项执行`jjs`，以查看命令行命令的完整列表：

![](img/c4349d9a-0284-4fcd-a5b5-5ca4a3eec19e.png)

-help 组件

正如您可以看到的，使用`-scripting`选项使我们能够使用 Nashorn 作为文本编辑器创建脚本。 使用 Nashorn 时有几个内置功能：

*   `echo()`：这类似于`System.out.print()` java 方法
*   `exit()`：这出退出了 nashorn
*   `load()`：这加载了给定路径或 URL 的脚本
*   `print()`：这类似于`System.out.print()` java 方法
*   `readFull()`：这读取了文件的内容
*   `readLine()`：这读取了从`stdin`的单行
*   `quit()`：这出退出了 nashorn

# 使用 Nashorn 作为嵌入式翻译

与使用它作为命令行工具相比，NASHORN 更常见的是使用它作为嵌入式解释器。 `javax.script` API 是公共的，可以通过`nashorn`标识符访问。 以下代码演示了我们如何访问 Nashorn 的访问，定义 JavaScript 函数，并从 Java 应用程序中获取结果：

```
// required imports
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;

public class EmbeddedAddTest {

  public static void main(String[] args) 
    throws Throwable {
    // instantiate a new ScriptEngineManager
    ScriptEngineManager myEngineManager =
      new ScriptEngineManager();

    // instantiate a new Nashorn ScriptEngine
    ScriptEngine myEngine = myEngineManager.
      getEngineByName("nashorn");

    // create the JavaScript function
    myEngine.eval("function addTest(x, y) 
      { return x + y; }");

    // generate output including a call to the 
    // addTest function via the engine
    System.out.println("The addition results are:
      " + myEngine.eval("addTest(300, 19);"));
  }
}
```

以下是控制台窗口中提供的输出：

![](img/3a0403b1-19ba-4b4a-bb52-1d4dca98f686.png)

控制台输出

这是一个简单的例子，可以让您了解嵌入式 Nashorn 的可能性。 Oracle 的官方文档中有充足的例子。

# ECMAScript.

1961 年作为信息系统和通信系统的标准组织成立了 **ECMA** （**欧洲计算机制造商协会**）。 今天，ECMA 继续开发标准，并发布技术报告，以帮助标准使用消费电子产品，信息系统和通信技术。 有超过 400 个 ECMA 标准，其中大部分都被采用。

您会注意到 ECMA 并不拼写所有大写字母，因为它不再被视为缩写。 1994 年，**欧洲计算机制造商协会**正式将其名称更改为 **ECMA** 。

ECMAScript，也被称为 es，于 1997 年创建为脚本语言规范。 JavaScript 实现了此规范，其中包括以下内容：

*   互补技术
*   图书馆
*   脚本语言语法
*   语义

# 解析器火灾

Java 平台最近的最新变化之一是为 Nashorn 的 ECMAScript 抽象语法树提供特定支持。 新 API 的目标是提供以下内容：

*   Interfaces 表示 Nashorn Syntax 树节点
*   创建可以使用命令行选项配置的解析器实例的能力
*   用于与 AST 节点接口的访客模式 API
*   测试程序以使用 API

创建了新 API `jdk.nashorn.api.tree`，以允许将来更改对 Nashorn 类。 在新的 Parser API 之前，IDE 使用 Nashorn 的内部 AST 表示进行代码分析。 根据 Oracle 的说法，使用`jdk.nashorn.internal.ir`套件阻止了 Nashorn 的内部类的现代化。

这是一个查看新`jdk.nashorn.api.tree`包的类层次结构：

![](img/9f08b304-b258-4cc9-b27d-9927d409d174.png)

jdk.nashorn.api.tree 类层次结构

以下图形说明了新 API 的复杂性，具有完整的界面层次结构：

![](img/7c9b2874-c046-472e-b5dc-897727491d35.png)

Nashorn 界面层次结构

`jdk.nashorn.api.tree`包的最后一个组件是枚举层次结构，其在此显示：

![](img/b0a47229-1548-4f50-9827-6235a731389d.png)

枚举层次结构

# 多释放 jar 文件

JAR 文件格式已在 Java 平台中扩展，现在允许多个版本的类文件中存在于单个 JAR 文件中。 类版本可以特定于 Java 发布版本。 此增强功能允许开发人员使用单个 jar 文件来容纳其软件的多个版本。

jar 文件增强功能包括以下内容：

*   支持`JarFile` API
*   支持标准类装载机

jar 文件格式的更改导致核心 Java 工具的必要更改，以便它们能够解释新的多版本 jar 文件。 这些核心工具包括以下内容：

*   `javac`
*   `javap`
*   `jdeps`

最后，新的 JAR 文件格式支持模块化，作为现代 Java 平台的关键特性。 jar 文件格式的更改没有导致相关工具或进程的性能降低。

# 识别多版本 jar 文件

多释放 jar 文件将具有新属性`Multi-Release: true`。 此属性将位于 JAR `MANIFEST.MF`主部分中。

目录结构将在标准 jar 文件和多版本 jar 文件之间有所不同。 这是一个看一个典型的 jar 文件结构：

![](img/f2774198-f409-4d54-96d0-365155d95084.png)

javadoc 目录树

下图显示了 Java 8 和 Java 9 的 Java Version-Precess 类文件的新多版 jar 文件结构：

![](img/8739ea3b-444b-443c-a81e-5eae4587f12f.png)

jar 文件结构

# 相关的 JDK 更改

必须对 JDK 进行几种更改以支持新的多版 jar 文件格式。 这些变化包括以下内容：

*   `URLClassLoader`是基于 jar 的，被修改，以便它可以从指定版本读取类文件。
*   写入新的基于模块的类加载器，新的 Java 9，以便它可以从指定版本中读取类文件。
*   修改了`java.util.jar.JarFile`类，以便它从多释放 jar 文件中选择适当的类版本。
*   修改了 JAR URL 方案的协议处理程序，以便它从多释放 jar 文件中选择相应的类版本。
*   java 编译器`javac`是为了读取类文件的识别版本。 这些版本标识是通过使用`-target`和`-release`命令行选项与`JavacFileManager` API 和`ZipFileSystem` API 进行。
*   修改了以下工具以利用`JavacFileManager` API 和`ZipFileSystem` API 的更改：
*   `javah`：这会生成 C 头和源文件
*   `schemagen`：这是 Java 类中名称空间的模式生成器
*   `wsgen`：这是 Web 服务部署的解析器

*   更新`javap`工具以支持新版本控制模式。
*   修改了`jdeps`工具以支持新版本控制模式。
*   jar 包装工具集被相应更新。 此工具集包含`pack200`和`unpack200`。
*   当然，jar 工具得到增强，以便它可以创建多释放 jar 文件。

已更新所有相关文档，以支持建立和支持新的多版 jar 文件格式所涉及的所有更改。

# Java 级 JVM 编译器界面

基于 Java 的 **JVM 编译器接口**（ **JVMCI** ）使 Java 编译器（必须用 java 写入）用作 JVM 的动态编译器。

对 JVMCI 的愿望背后的推理是它将是一个高度优化的编译器，不需要低级语言功能。 一些 JVM 子系统需要低级功能，例如垃圾收集和字节码解释。 因此，JVMCI 用 Java 而不是 C 或 C ++编写。 这提供了一些 Java 最大功能的抵押权益，例如以下内容：

*   异常处理
*   既自由且坚固的 ides
*   内存管理
*   运行时可扩展性
*   同步
*   单元测试支持

正如 JVMCI 被编写的 Java 一样，可以更轻松地维护。

JVMCI API 有三个主要组件：

*   虚拟机数据结构访问
*   使用其元数据安装编译的代码
*   使用 JVM 的编译系统

JVMCI 实际上存在于 Java 8 中.JVMCI API 仅通过用于引导类路径上的代码的类加载器访问。 在 Java 9 中，这改变了。 它仍然在目前的 Java 平台上实验，但更可访问。 要启用 JVMCI，必须使用以下一系列命令行选项：

```
-XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler -Djvmci.Compiler=<name of compiler>
```

Oracle 在 Java 9 中保持 JVMCI 实验，允许进一步测试，并为开发人员提供最大的保护级别。

# BeanInfo 注释

`@beaninfo` javadoc 标签已被更合适的注释替换。 此外，现在在运行时处理这些新注释，以便可以动态生成`BeanInfo`类。 Java 的模块化导致了这种变化。 已经简化了自定义`BeanInfo`类的创建，并且客户端库已模块化。

为了完全掌握这一变化，我们将在进一步进入本 MEP 之前查看`JavaBean`，`BeanProperty`和`SwingContainer`。

# javabean.

a `JavaBean`是 java 类。 与其他 Java 类一样，`JavaBean` S 是可重用的代码。 它们的设计是独一无二的，因为它们将多个对象封装到一个。 有三个惯例`JavaBean`类必须遵循：

*   构造函数不应该采取任何参数
*   它必须是可序列化的
*   它必须包含其属性的突变体和访问器方法

这是一个例子`JavaBean`类：

```
public class MyBean implements java.io.Serializable {

  // instance variables
  private int studentId;
  private String studentName;

  // no-argument constructor
  public MyBean() {
  }

  // mutator/setter
  public void setStudentId(int theID) {
    this.studentId = theID;
  }

  // accessor/getter
  public int getStudentId() {
    return studentId;
  }

  // mutator/setter
  public void setStudentName(String theName) {
    this.studentName = theName;
  }

  // accessor/getter
  public String getStudentName(){
    return studentName;
  }
}
```

访问`JavaBean`类与使用 virator 和访问器方法一样简单。 这可能对您来说不是新的，但是很有可能不知道您创建的那些仔细编码的类被称为`JavaBean`类。

# 豆富人

`BeanProperty`是注释类型。 我们使用此注释来指定属性，以便我们可以自动生成`BeanInfo`类。 这是 Java 的一个相对较新的注释，从 Java 9 开始。

`BeanProperty`注释具有以下可选元素：

*   `boolean bound`
*   `String description`
*   `String[] enumerationValues`
*   `boolean expert`
*   `boolean hidden`
*   `boolean preferred`
*   `boolean required`
*   `boolean visualUpdate`

# SwingContainer.

`SwingContainer`是注释类型。 我们使用该注释来指定与挥杆相关的属性，以便我们可以自动生成`BeanInfo`类。

SwingContainer 注释具有以下可选元素：

*   `String delegate`
*   `boolean value`

现在我们已经审查了`JavaBean`，`BeanProperty`和`SwingContainer`，让我们看看`BeanInfo`类。

# BeanInfo 课程

在大多数情况下，`BeanInfo`类在运行时自动生成。 异常是`Swing`类。 这些类基于`@beaninfo` javadoc 标签生成`BeanInfo`类。 这是在编译时完成的，而不是运行时完成。 从 Java 9 开始，`@beaninfo`标签已被替换为`@interface JavaBean`，`@interface BeanProperty`和`@interface SwingContainer`注释。

这些新的注释用于根据上一节中指出的可选元素设置相应的属性。 作为示例，以下代码段为`SwingContainer`设置了属性：

```
package javax.swing;

public @interface SwingContainer {
  boolean value() default false;
  String delegate() default "";
}
```

这为我们提供了三个好处：

*   在`Bean`类中指定属性将更容易，而不是必须创建单个`BeanInfo`类
*   我们将能够去除自动化的课程
*   通过这种方法，客户端图书馆更容易模块化

# TIFF 支持

为现代 Java 平台扩展了图像输入/输出插件，包括支持 TIFF 图像格式。 `ImageIO`类扩展了`Object`类，是 Java SE 的一部分。 该类包含几种用于编码和解码图像的方法。 以下是静态方法列表：

| **方法** | **返回值** |
| `createImageInputStream(Object input)` | `ImageInputStream` |
| `createImageOutputStream(Object output)` | `ImageOutputStream` |
| `getCacheDirectory()` | `CacheDirectory`的当前值 |
| `getImageReader(ImageWriter writer)` | `ImageReader` |
| `getImageReaders(Object input)` | 当前的迭代器`ImageReaders` |
| `getImageReadersByFormatName(String formatName)` | 具有指定格式名称的当前`ImageReaders`的迭代器 |
| `getImageReadersByMIMEType(String MIMEType)` | 指定 MIME 类型的当前`ImageReaders`的迭代器 |
| `getImageReadersBySuffix(String fileSuffix)` | 当前`ImageReaders`的迭代器与指定的后缀 |
| `getImageTranscoders(ImageReader reader)` | 当前的迭代器`ImageTranscoders` |
| `getImageWriter(ImageReader reader)` | `ImageWriter` |
| `getImageWriters(ImageTypeSpecifier type, String formatName)` | 可以对指定类型进行编码的当前`ImageWriters`的迭代器 |
| `getImageWritersByFormatName(String formatName)` | 具有指定格式名称的当前`ImageWriters`的迭代器 |
| `getImageWritersByMIMEType(String MIMEType)` | 指定 MIME 类型的当前`ImageWriters`的迭代器 |
| `getImageWritersBySuffix(String fileSuffix)` | 当前`ImageWriters`的迭代器与指定的后缀 |
| `getReaderFileSuffixes()` | 字符串数组与文件后缀，由当前读者了解 |
| `getReaderFormatNames()` | 字符串数组，具有当前读者了解的格式名称 |
| `getReaderMIMETypes()` | 字符串数组与当前读者了解的 MIME 类型 |
| `getUseCache()` | `UseCache`值 |
| `getWriterFileSuffixes()` | 字符串文件后缀的数组，由当前作家理解 |
| `getWriterFormatNames()` | 字符串数组，具有当前作家所理解的格式名称 |
| `getWriterMIMETypes()` | 字符串数组与当前编写者了解的 MIME 类型 |
| `read(File input)` | `BufferedImage`与`ImageReader` |
| `read(ImageInputStream stream)` | `BufferedImage`用`ImageInputStream`和`ImageReader` |
| `read(InputStream input)` | `BufferedImage`用`InputStream`和`ImageReader` |
| `read(URL input)` | `BufferedImage`与`ImageReader` |

还有一些静态方法不返回值或返回布尔值：

| **方法** | **描述** |
| `scanForPlugins()` | 执行以下操作：

*   扫描应用程序类路径 for 插件
*   加载插件服务提供商类
*   注册 IIORGISSTRY 中的服务提供商实例

 |
| `setCacheDirectory(File cacheDirectory)` | 这是将存储缓存文件的位置。 |
| `setUseCache(boolean useCache)` | 如果缓存将是基于磁盘的，则此方法会切换。 这适用于`ImageInputStream`和`ImageOutputStream`实例。 |
| `write(RenderedImage im, String formatName, File output)` | 将图像写入指定的文件。 |
| `write(RenderedImage im, String formatName, ImageOutputStream output)` | 将图像写入`ImageOutputStream`。 |
| `write(RenderedImage im, String formatName, OutputStream output)` | 将图像写入`OutputStream`。 |

当您可以从所提供的方法中收集时，图像输入/输出框架为我们提供了一种使用图像编解码器的方便方式。 正如 Java 7 的那样，以下图像格式插件由`javax.imageio`实现：

*   BMP.
*   GIF
*   JPEG.
*   PNG.
*   WBMP.

正如您所看到的，而不是在图像文件格式列表中。 TIFFS 是一种常见的文件格式，2001 年，麦斯科斯队的发布，广泛使用该格式。

当前的 Java 平台包括 TIFFS 的`ImageReader`和`ImageWriter`插件。 这些插件已用 Java 编写，并已在新的`javax.imageio.plugins.tiff`封装中捆绑在一起。

# 平台日志记录

现代 Java 平台包括一个日志记录 API，可使平台类进行日志消息。 它具有用于操纵日志的相称服务。 在我们进入迄今为止关于 Logging API 和 Service 的新内容之前，让我们在 Java 7 中推出的`java.util.logging.api`进行评论。

# java.util.logging 包

`java.util.logging`包包括统称为 Java 的核心日志记录功能的类和接口。 使用以下目标创建此功能：

*   最终用户和系统管理员的问题诊断
*   现场服务工程师的问题诊断
*   开发组织的问题诊断

正如您所看到的，主要目的是启用远程软件的维护。

`java.util.logging`包有两个接口：

*   `public interface Filter`：
*   目的：这提供了对记录数据的微粒控制
*   方法：`isLoggable(LogRecord record)`

*   `public interface LoggingMXBean`：
*   目的：这是伐木工具的管理界面
*   方法：
    *   `getLoggerLevel(String loggerName)`
    *   `getLoggerNames()`
    *   `getparentLoggerName(String loggerName)`
    *   `setLoggerLevel(String loggerName, String levelName)`

下表提供了`java.util.logging`包类，以及关于每个类在日志记录功能和管理方面提供的简要说明：

| **类** | **定义** | **描述** |
| `ConsoleHandler` | `public class ConsoleHandler extends StreamHandler` | 将日志记录发布到`System.err` |
| `ErrorManager` | `public class ErrorManager extends Object` | 用于在日志记录期间处理错误 |
| `FileHandler` | `public class FileHandler extends StreamHandler` | 文件日志记录 |
| `Formatter` | `public abstract class Formatter extends Object` | 格式化`LogRecords` |
| `Handler` | `public abstract class Handler extends Object` | 导出`Logger`消息 |
| `Level` | `public class Level extends Object implements Serializable` | 控制日志记录级别。 按降序，是严重，警告，信息，配置，精细，更精细和最好的级别 |
| `Logger` | `public class Logger extends Object` | 日志消息 |
| `LoggingPermission` | `public final class LoggingPermission extends BasicPermission` | `SecurityManager`检查 |
| `LogManager` | `public class LogManager` | 用于在记录器和日志记录服务之间维护共享状态 |
| `LogRecord` | `public class LogRecord extends Object implements Serializable` | 在处理程序之间传递 |
| `MemoryHandler` | `public class MemoryHandler extends Handler` | 缓冲区请求在内存中 |
| `SimpleFormatter` | `public class SimpleFormatter extends Formatter` | 提供人类可读的`LogRecord`元数据 |
| `SocketHandler` | `public class SocketHandler extends StreamHandler` | 网络日志处理程序 |
| `StreamHandler` | `public class StreamHandler extends Handler` | 基于流的日志处理程序 |
| `XMLFormatter` | `public class XMLFormatter extends Formatter` | 格式化为 XML |

接下来，让我们查看现代 Java 平台中的更改。

# 登录现代 Java 平台

在 Java 9 之前，有多个可用的日志测井模式，包括`java.util.logging`，`SLF4J`和`Log4J`。 后两者是第三方框架，具有单独的外观和实现组件。 这些模式已在当前的 Java 平台中复制。

`java.base`模块已更新以处理日志记录功能，并且不依赖于`java.util.logging` API。 它具有单独的外立面和实现组件。 这意味着，当使用第三方框架时，JDK 只需要提供与请求记录框架合作的实现组件和返回平台记录器。

如下图所示，我们使用`java.util.ServiceLoader` API 加载我们的`LoggerFinder`实现。 如果使用 System Class Loader 时找不到具体实现，则 JDK 使用默认实现：

![](img/46ceb6ca-1454-4b78-83a4-fb32470de09b.png)

ServiceLoader API 的 LoggerFinder 实现

# XML 目录

现代 Java 平台包括标准 XML 目录 API，以支持 OASIS XML 目录标准 V1.1。 新 API 定义目录和目录 - 解析抽象，以便 JAXP 处理器可以使用它们。 在本节中，我们将查看以下内容：

*   OASIS XML 目录标准
*   JAXP 处理器
*   早期的 XML 目录
*   当前的 XML 目录

# OASIS XML 目录标准

**xml** （**可扩展标记语言**）目录是由目录条目组成的 XML 文档。 每个条目对标识符对另一个位置对。 OASIS 是一个非营利性的财团，具有推进公开标准的使命。 他们于 2005 年发布了 XML 目录标准版本 1.1.本标准有两个基本用例：

*   将外部标识符映射到 URI 引用
*   映射 URI 引用另一个 URI 参考

以下是一个示例 XML 目录条目：

```
<public publicId="-//Packt Publishing Limited//Mastering Java 9//EN" uri="https://www.packtpub.com/application-development/mastering-java-9"/>
```

完整的 OASIS XML 目录标准可以在官方网站上找到： [https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html](https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html) 。

# JAXP 处理器

XML 处理的 Java API 称为 JAXP。 据姓名建议，此 API 用于解析 XML 文档。 有四个相关的接口：

*   **dom** ：文档对象模型解析
*   **sax** ：XML 解析的简单 API
*   **stax** ：用于 XML 解析的流式 API
*   **xslt** ：接口转换 XML 文档

# 早期的 XML 目录

Java 平台已有内部目录解析器，因为 JDK 6.没有公共 API，因此外部工具和库用于访问其功能。 进入现代 Java 平台，即第 9,10 和 11，目标是使内部目录解析器是一个标准的 API，用于常用和易于支持。

# 当前的 XML 目录

使用 Java 9 提供的新 XML 目录 API 遵循 OASIS XML 目录标准 V1.1。 以下是功能和功能亮点：

*   实施`EntityResolver`。
*   实施`URIResolver`。
*   通过`CatalogManager`可以创建 XML 目录。
*   `CatalogManager`将用于创建`CatalogResolvers`。
*   OASIS Open Catalog 文件语义将被遵循：
*   将外部标识符映射到 URI 引用
*   映射到另一个 URI 参考的 URI 引用

*   `CatalogResolvers`将实现 JAXP `EntityResolver`接口。
*   `CatalogResolvers`将实现 JAXP `URIResolver`接口。
*   SAX `XMLFilter`将由解析器提供支持。

由于新的 XML 目录 API 是公共，因此已删除了 java 9 内部目录解析器，因为它不再需要。

# 收藏品

Java 编程语言不支持集合文字。 将此功能添加到 Java 平台，于 2013 年提出，并于 2016 年重新审视，但它只获得了作为研究提案的曝光，而不是未来的实施。

Oracle 对集合文字的定义是*一种句法表达式，它评估到聚合类型，例如阵列，列表或映射*（ [http://openjdk.java.net/jeps/186](http://openjdk.java.net/jeps/186) ）。

当然，这是直到 Java 9 被释放。 据报道，在 Java 编程语言中实现集合文字有以下优势：

*   性能改进
*   增加安全
*   减少样板代码

即使在没有研究小组的一部分，我们对 Java 编程语言的了解也将我们带来了额外的福利：

*   写入较短代码的能力
*   编写空间高效代码的能力
*   能够使收集文字不变

让我们在现代 Java 平台之前查看两个案例 - 使用集合，然后在新的 Java 平台中的收集文字的新支持。

# 在现代 Java 平台之前使用集合

以下是我们在现代 Java 平台之前创建自己的集合的示例。 此第一类定义`PlanetCollection`的结构。 它具有以下组件：

*   单个实例变量
*   一个参数构造函数
*   一个突变/塞特方法
*   访问者/ getter 方法
*   打印对象的方法

以下是实现先前列出的构造函数和方法的代码：

```
public class PlanetCollection {

  // Instance Variable
  private String planetName;

  // constructor
  public PlanetCollection(String name) {
    setPlanetName(name);
  }

  // mutator
  public void setPlanetName(String name) {
    this.planetName = name;
  }

  // accessor
  public String getPlanetName() {
    return this.planetName;
  }

  public void print() {
    System.out.println(getPlanetName());
  }
}
```

现在，让我们来看看填充集合的驱动程序类：

```
import java.util.ArrayList;

public class OldSchool {

  private static ArrayList<PlanetCollection> 
    myPlanets = new ArrayList<>();

  public static void main(String[] args) {
    add("Earth");
    add("Jupiter");
    add("Mars");
    add("Venus");
    add("Saturn");
    add("Mercury");
    add("Neptune");
    add("Uranus");
    add("Dagobah");
    add("Kobol");

    for (PlanetCollection orb : myPlanets) {
      orb.print();
    }
  }

  public static void add(String name) {
    PlanetCollection newPlanet = 
      new PlanetCollection(name);
    myPlanets.add(newPlanet);
  }
}
```

以下是此应用程序的输出：

![](img/8d2afd93-4226-4018-a9b1-d009b4bd9362.png)

Oldschool 类输出

不幸的是，这段代码非常详细。 我们在静态初始化程序块中填充了我们的集合，而不是使用字段初始化程序。 还有其他用于填充我们的列表的方法，但它们比他们必须更赘言。 这些其他方法具有额外的问题，例如需要创建额外的类，使用晦涩的代码和隐藏的引用。

现在，让我们来看看这个问题的解决方案，它由现代 Java 平台提供。 我们将查看下一节中的新增功能。

# 使用新的集合文字

为了纠正当前所需的代码在创建集合方面的详细程度中，我们需要库 API 来创建收集实例。 从上一部分查看我们之前的代码片段，然后考虑此可能的重构：

```
PlanetCollection<String> myPlanets = Set.of(
  "Earth",
  "Jupiter",
  "Mars",
  "Venus",
  "Saturn",
  "Mercury",
  "Neptune",
  "Uranus",
  "Dagobah",
  "Kobol");
```

此代码非常人性化可读，而不是冗长。

新实现将在以下接口上包含静态工厂方法：

*   `List`
*   `Map`
*   `Set`

因此，我们现在能够创建`List`集合，`Map`集合和`Set`集合的未经修改的实例。 可以使用以下语法实例化：

*   `List.of(a, b, c, d, e);`
*   `Set.of(a, b, c, d, e);`
*   `Map.of();`

`Map`集合将具有一组固定参数。

# 特定于平台的桌面功能

现代 Java 平台包括一个公共 API，使我们能够编写可以访问特定于平台的桌面功能的应用程序。 这些功能包括与 TaskBars / Docks 进行交互并侦听应用程序和系统事件。

MacOS X `com.apple.eawt`包是内部 API，并且从 Java 9 开始，不再可访问。 为了支持 Java 的嵌入式平台特定的桌面功能，已删除`apple.applescript`类而无需更换即可。 它们不适用于 Java 9,10 或 11。

新 API 已添加到`java.awt.Desktop`类中，并提供以下内容：

*   它创建了一个公共 API 来替换`com.apple.{east,eio}`中的功能。
*   它确保 OS X 开发人员不会丢失功能。 为此，当前的 Java 平台具有以下软件包的替换：
*   `com.apple.eawt`
*   `com.apple.eio`

*   除了 OS X 外，它为平台（即 Windows 和 Linux）提供了具有近乎常见的功能集的开发人员，这些常见功能包括以下内容：
*   具有事件侦听器的登录/注销处理程序
*   屏幕锁定处理程序与活动侦听器
*   任务栏/ Dock 操作包含以下内容：
*   请求用户注意
*   指示任务进度
*   行动捷径

# 增强方法处理

现代 Java 平台包括增强的方法处理作为改进以下列出的类的方法，以便在改进的优化方面更轻松地进行常见用法：

*   `MethodHandle`课程
*   `MethodHandles`课程
*   `MethodHandles.Lookup`课程

前面的类是`java.lang.invoke`包的一部分，它已为现代 Java 平台更新。 通过使用`MethodHandle`组合，`for`循环和`try...finally`块，通过使用查找精细来实现这些改进。

在本节中，我们将关注以下内容：

*   增强的原因
*   查找功能
*   论证处理
*   额外的组合

# 增强的原因

这种增强功能源于开发人员反馈和使`MethodHandle`，`MethodHandles`和`MethodHandles.Lookup`类的愿望更容易使用。 还有呼叫添加额外用例。

这些变化导致以下福利：

*   在使用`MethodHandle` API 的使用中实现了精度
*   减少实例化
*   增加了 JVM 编译器优化

# 查找功能

关于查找功能的更改包括以下内容：

*   `MethodHandles`现在可以在接口中绑定到非抽象方法
*   查找 API 允许来自不同上下文的类查找

`MethodHandles.Lookup.findSpecial(Class<?> refs, String name, MethodType type, Class<?> specialCaller)`类已被修改为允许在接口上定位超可燃的方法。

此外，已添加以下方法`MethodHandles.Lookup`类：

*   `Class<?> findClass(String targetName)`
*   `Class<?> accessClass(Class<?> targetClass)`

# 论证处理

最近的三个更新是为了改善`MethodHandle`参数处理。 这些更改突出显示如下：

*   使用`foldArguments(MethodHandle target, MethodHandle combinator)`折叠以前没有置位参数：
    *   使用`MethodHandle.asCollector(Class<?> arrayType, int arrayLength)`方法的参数集合未先前支持将参数收集到阵列中，除了尾随元素。 这已更改，现在有一个额外的`asCollector`方法来支持该功能。

*   使用`MethodHandle.asSpreader(Class<?> arrayType, int arrayLength)`方法的参数传播以反向方法将尾部阵列的内容传播到多个参数的参数。 参数扩展已被修改为支持方法签名中的任何位置的阵列扩展。

下一节中提供了更新`asCollector`和`asSpreader`方法的新方法定义。

# 额外的组合

已添加以下其他组合来支持`MethodHandle`，`MethodHandles`和`MethodHandles.Lookup`封装的`MethodHandles`和`MethodHandles.Lookup`类的易用性和优化：

*   通用循环抽象：
*   `MethodHandle loop(MethodHandle[] . . . clauses)`
*   `While`循环：
*   `MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body)`
*   `Do...while`循环：
*   `MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred)`
*   计数循环：
*   `MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body)`
*   数据结构迭代：
*   `MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body)`
*   `Try...finally`块：
*   `MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup)`

*   论证处理：
*   参数传播：
    *   `MethodHandle asSpreader(int pos, Class<?> arrayType, int arrayLength)`
*   参数收集：
    *   `MethodHandle asCollector(int pos, Class<?> arrayType, int arrayLength)`
*   参数折叠：
    *   `MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner)`

# 增强折旧

有两个设施表达弃用：

*   `@Deprecated`注释
*   `@deprecated` javadoc 标签

这些设施分别在 Java SE 5 和 JDK 1.1 中引入。 `@Deprecated`注释旨在注释不应使用的程序组件，因为它们被视为危险和/或有更好的选择。 那是预期用途。 实际使用变化，因为警告仅在编译时提供，但几乎没有理由忽略注释代码。

采取了增强的弃用努力，为开发人员提供更清晰的信息，了解了本规范文件中 API 的预期处置。 对此工作也导致一个用于分析程序使用弃用 API 的工具。

要在信息中支持此保真度，请将以下组件添加到`java.lang.Deprecated`注释类型：

*   `forRemoval()`：
*   返回 Boolean `true`如果 API 元素已被播放以供将来删除
*   返回布尔值`false`如果 api 元素尚未被删除，但已被推卸
*   默认为``false``

*   `since()`：
*   返回包含释放或版本号的字符串，此时指定的 API 被标记为已弃用

# @deprecated 注释真的意味着什么

当 API 中的 API 或方法具有/已被标记为`@Deprecated`注释时，通常存在以下一个或多个条件：

*   API 存在错误，没有计划修复它们
*   使用 API​​可能会导致错误
*   API 已被另一个 API 替换
*   API 是实验性的

# 本机标题生成工具（Javah）

使用 Java 8 将 Java 标题工具（`javah`）引入 Java 平台。它为开发人员提供了编写本机标题的能力。 从 Java 10 开始，`javah`工具已被 Java 编译器中包含的功能替换（`javac`）。

开发人员只使用`javac -h`而不是使用`javah`，而不是使用`javah`。

# 概括

在本章中，我们涵盖了有关现代平台的升级。 这些更新涵盖了各种工具和更新到 API，以使 Java 更轻松地开发，具有更大的优化可能性，可为我们的结果进行。 我们的审核包括查看新的 HTTP 客户端，更改为 Javadoc 和 DoCLET API，新的 JavaScript 解析器，JAR 和 JRE 更改，新的 Java 级 JVM 编译器界面，新支持 TIFF 图像，平台记录，XML 目录支持 ，集合和新的平台特定桌面功能。 我们还研究了方法处理和弃用注释的增强功能。

在下一章中，我们将介绍并发增强功能。 我们的主要焦点将是`Flow` API 提供的反应性编程的支持。 我们还将探讨额外的并发增强功能。

# 问题

1.  升级 HTTP 客户端的主要原因是什么？
2.  列出新的 HTTP 客户端 API 的限制。
3.  必须传递三个组件以使用`javadoc`？
4.  名称除构造函数之外的一个或多个方法，即 doclet 类的一部分。
5.  编译器树 API 中的枚举是什么？
6.  javadoc 工具的默认输出是什么？
7.  什么是 nashorn？
8.  什么是 ECMAScript（ES）？
9.  命名两个主要 jar 文件增强功能。
10.  `JavaBean`的三个惯例是什么？

# 进一步阅读

以下是您可以参考的信息列表：

*   *Docker 基础知识[综合课程]* ，可在[https://www.packtpub.com/virtualization-and-cloud/docker-fundamentals- - course](https://www.packtpub.com/virtualization-and-cloud/docker-fundamentals-integrated-course) 。
*   *Java 9：建立强大的模块化应用*，可在 [https://www.packtpub.com/application-development/java-9-building-robust-modulare](https://www.packtpub.com/application-development/java-9-building-robust-modular-applications) 。