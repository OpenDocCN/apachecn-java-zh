+   [Effective Java 中文第三版](docs/effective-java-3e-zh/README.md)
    +   [1. 考虑使用静态工厂方法替代构造方法](docs/effective-java-3e-zh/01.md)
    +   [2. 当构造方法参数过多时使用 builder 模式](docs/effective-java-3e-zh/02.md)
    +   [3. 使用私有构造方法或枚类实现 Singleton 属性](docs/effective-java-3e-zh/03.md)
    +   [4. 使用私有构造器执行非实例化](docs/effective-java-3e-zh/04.md)
    +   [5.  依赖注入优于硬连接资源（hardwiring resources）](docs/effective-java-3e-zh/05.md)
    +   [6. 避免创建不必要的对象](docs/effective-java-3e-zh/06.md)
    +   [7. 消除过期的对象引用](docs/effective-java-3e-zh/07.md)
    +   [8. 避免使用 Finalizer 和 Cleaner 机制](docs/effective-java-3e-zh/08.md)
    +   [9. 使用 try-with-resources 语句替代 try-finally 语句](docs/effective-java-3e-zh/09.md)
    +   [10. 重写 equals 方法时遵守通用约定](docs/effective-java-3e-zh/10.md)
    +   [11. 重写 equals 方法时同时也要重写 hashcode 方法](docs/effective-java-3e-zh/11.md)
    +   [12. 始终重写 toString 方法](docs/effective-java-3e-zh/12.md)
    +   [13. 谨慎地重写 clone 方法](docs/effective-java-3e-zh/13.md)
    +   [14. 考虑实现 Comparable 接口](docs/effective-java-3e-zh/14.md)
    +   [15. 使类和成员的可访问性最小化](docs/effective-java-3e-zh/15.md)
    +   [16. 在公共类中使用访问方法而不是公共属性](docs/effective-java-3e-zh/16.md)
    +   [17. 最小化可变性](docs/effective-java-3e-zh/17.md)
    +   [18. 组合优于继承](docs/effective-java-3e-zh/18.md)
    +   [19.  要么设计继承并提供文档说明，要么禁用继承](docs/effective-java-3e-zh/19.md)
    +   [20. 接口优于抽象类](docs/effective-java-3e-zh/20.md)
    +   [21. 为后代设计接口](docs/effective-java-3e-zh/21.md)
    +   [22. 接口仅用来定义类型](docs/effective-java-3e-zh/22.md)
    +   [23. 类层次结构优于标签类](docs/effective-java-3e-zh/23.md)
    +   [24. 支持使用静态成员类而不是非静态类](docs/effective-java-3e-zh/24.md)
    +   [25. 将源文件限制为单个顶级类](docs/effective-java-3e-zh/25.md)
    +   [26. 不要使用原始类型](docs/effective-java-3e-zh/26.md)
    +   [27. 消除非检查警告](docs/effective-java-3e-zh/27.md)
    +   [28. 列表优于数组](docs/effective-java-3e-zh/28.md)
    +   [29. 优先考虑泛型](docs/effective-java-3e-zh/29.md)
    +   [30. 优先使用泛型方法](docs/effective-java-3e-zh/30.md)
    +   [31. 使用限定通配符来增加 API 的灵活性](docs/effective-java-3e-zh/31.md)
    +   [32. 合理地结合泛型和可变参数](docs/effective-java-3e-zh/32.md)
    +   [33. 优先考虑类型安全的异构容器](docs/effective-java-3e-zh/33.md)
    +   [34. 使用枚举类型替代整型常量](docs/effective-java-3e-zh/34.md)
    +   [35. 使用实例属性替代序数](docs/effective-java-3e-zh/35.md)
    +   [36. 使用 EnumSet 替代位属性](docs/effective-java-3e-zh/36.md)
    +   [37. 使用 EnumMap 替代序数索引](docs/effective-java-3e-zh/37.md)
    +   [38. 使用接口模拟可扩展的枚举](docs/effective-java-3e-zh/38.md)
    +   [39. 注解优于命名模式](docs/effective-java-3e-zh/39.md)
    +   [40. 始终使用 Override 注解](docs/effective-java-3e-zh/40.md)
    +   [41. 使用标记接口定义类型](docs/effective-java-3e-zh/41.md)
    +   [42. lambda 表达式优于匿名类](docs/effective-java-3e-zh/42.md)
    +   [43. 方法引用优于 lambda 表达式](docs/effective-java-3e-zh/43.md)
    +   [44. 优先使用标准的函数式接口](docs/effective-java-3e-zh/44.md)
    +   [45. 明智审慎地使用 Stream](docs/effective-java-3e-zh/45.md)
    +   [46. 优先考虑流中无副作用的函数](docs/effective-java-3e-zh/46.md)
    +   [47. 优先使用 Collection 而不是 Stream 来作为方法的返回类型](docs/effective-java-3e-zh/47.md)
    +   [48. 谨慎使用流并行](docs/effective-java-3e-zh/48.md)
    +   [49. 检查参数有效性](docs/effective-java-3e-zh/49.md)
    +   [50. 必要时进行防御性拷贝](docs/effective-java-3e-zh/50.md)
    +   [51. 仔细设计方法签名](docs/effective-java-3e-zh/51.md)
    +   [52. 明智审慎地使用重载](docs/effective-java-3e-zh/52.md)
    +   [53. 明智审慎地使用可变参数](docs/effective-java-3e-zh/53.md)
    +   [54. 返回空的数组或集合，不要返回 null](docs/effective-java-3e-zh/54.md)
    +   [55. 明智审慎地返回 Optional](docs/effective-java-3e-zh/55.md)
    +   [56. 为所有已公开的 API 元素编写文档注释](docs/effective-java-3e-zh/56.md)
    +   [57. 最小化局部变量的作用域](docs/effective-java-3e-zh/57.md)
    +   [58. for-each 循环优于传统 for 循环](docs/effective-java-3e-zh/58.md)
    +   [59. 了解并使用库](docs/effective-java-3e-zh/59.md)
    +   [60. 若需要精确答案就应避免使用 float 和 double 类型](docs/effective-java-3e-zh/60.md)
    +   [61. 基本数据类型优于包装类](docs/effective-java-3e-zh/61.md)
    +   [62. 当使用其他类型更合适时应避免使用字符串](docs/effective-java-3e-zh/62.md)
    +   [63. 当心字符串连接引起的性能问题](docs/effective-java-3e-zh/63.md)
    +   [64. 通过接口引用对象](docs/effective-java-3e-zh/64.md)
    +   [65. 接口优于反射](docs/effective-java-3e-zh/65.md)
    +   [66. 明智审慎地本地方法](docs/effective-java-3e-zh/66.md)
    +   [67. 明智审慎地进行优化](docs/effective-java-3e-zh/67.md)
    +   [68. 遵守被广泛认可的命名约定](docs/effective-java-3e-zh/68.md)
    +   [69. 只针对异常的情况下才使用异常](docs/effective-java-3e-zh/69.md)
    +   [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常](docs/effective-java-3e-zh/70.md)
    +   [71. 避免不必要的使用受检异常](docs/effective-java-3e-zh/71.md)
    +   [72. 优先使用标准的异常](docs/effective-java-3e-zh/72.md)
    +   [73. 抛出与抽象对应的异常](docs/effective-java-3e-zh/73.md)
    +   [74. 每个方法抛出的异常都需要创建文档](docs/effective-java-3e-zh/74.md)
    +   [75. 在细节消息中包含失败一捕获信息](docs/effective-java-3e-zh/75.md)
    +   [76. 保持失败原子性](docs/effective-java-3e-zh/76.md)
    +   [77. 不要忽略异常](docs/effective-java-3e-zh/77.md)
    +   [78. 同步访问共享的可变数据](docs/effective-java-3e-zh/78.md)
    +   [79. 避免过度同步](docs/effective-java-3e-zh/79.md)
    +   [80. executor 、task 和 stream 优先于线程](docs/effective-java-3e-zh/80.md)
    +   [81. 并发工具优于 wait 和 notify](docs/effective-java-3e-zh/81.md)
    +   [82. 文档应包含线程安全属性](docs/effective-java-3e-zh/82.md)
    +   [83. 明智审慎的使用延迟初始化](docs/effective-java-3e-zh/83.md)
    +   [84. 不要依赖线程调度器](docs/effective-java-3e-zh/84.md)
    +   [85. 优先选择 Java 序列化的替代方案](docs/effective-java-3e-zh/85.md)
    +   [86. 非常谨慎地实现 Serializable](docs/effective-java-3e-zh/86.md)
    +   [87. 考虑使用自定义的序列化形式](docs/effective-java-3e-zh/87.md)
    +   [88. 保护性的编写 readObject 方法](docs/effective-java-3e-zh/88.md)
    +   [89. 对于实例控制，枚举类型优于 readResolve](docs/effective-java-3e-zh/89.md)
    +   [90. 考虑用序列化代理代替序列化实例](docs/effective-java-3e-zh/90.md)
+   [Thinking in Java (Java 编程思想)](docs/thinking-in-java-zh/README.md)
    +   [写在前面的话](docs/thinking-in-java-zh/0.1.md)
    +   [引言](docs/thinking-in-java-zh/0.2.md)
    +   [第1章 对象入门](docs/thinking-in-java-zh/1.md)
        +   [1.1 抽象的进步](docs/thinking-in-java-zh/1.1.md)
        +   [1.2 对象的接口](docs/thinking-in-java-zh/1.2.md)
        +   [1.3 实现方案的隐藏](docs/thinking-in-java-zh/1.3.md)
        +   [1.4 方案的重复使用](docs/thinking-in-java-zh/1.4.md)
        +   [1.5 继承：重新使用接口](docs/thinking-in-java-zh/1.5.md)
        +   [1.6 多态对象的互换使用](docs/thinking-in-java-zh/1.6.md)
        +   [1.7 对象的创建和存在时间](docs/thinking-in-java-zh/1.7.md)
        +   [1.8 异常控制：解决错误](docs/thinking-in-java-zh/1.8.md)
        +   [1.9 多线程](docs/thinking-in-java-zh/1.9.md)
        +   [1.10 永久性](docs/thinking-in-java-zh/1.10.md)
        +   [1.11 Java和因特网](docs/thinking-in-java-zh/1.11.md)
        +   [1.12 分析和设计](docs/thinking-in-java-zh/1.12.md)
        +   [1.13 Java还是C++](docs/thinking-in-java-zh/1.13.md)
    +   [第2章 一切都是对象](docs/thinking-in-java-zh/2.md)
        +   [2.1 用引用操纵对象](docs/thinking-in-java-zh/2.1.md)
        +   [2.2 所有对象都必须创建](docs/thinking-in-java-zh/2.2.md)
        +   [2.3 绝对不要清除对象](docs/thinking-in-java-zh/2.3.md)
        +   [2.4 新建数据类型：类](docs/thinking-in-java-zh/2.4.md)
        +   [2.5 方法、参数和返回值](docs/thinking-in-java-zh/2.5.md)
        +   [2.6 构建Java程序](docs/thinking-in-java-zh/2.6.md)
        +   [2.7 我们的第一个Java程序](docs/thinking-in-java-zh/2.7.md)
        +   [2.8 注释和嵌入文档](docs/thinking-in-java-zh/2.8.md)
        +   [2.9 编码样式](docs/thinking-in-java-zh/2.9.md)
        +   [2.10 总结](docs/thinking-in-java-zh/2.10.md)
        +   [2.11 练习](docs/thinking-in-java-zh/2.11.md)
    +   [第3章 控制程序流程](docs/thinking-in-java-zh/3.md)
        +   [3.1 使用Java运算符](docs/thinking-in-java-zh/3.1.md)
        +   [3.2 执行控制](docs/thinking-in-java-zh/3.2.md)
        +   [3.3 总结](docs/thinking-in-java-zh/3.3.md)
        +   [3.4 练习](docs/thinking-in-java-zh/3.4.md)
    +   [第4章 初始化和清除](docs/thinking-in-java-zh/4.md)
        +   [4.1 用构造器自动初始化](docs/thinking-in-java-zh/4.1.md)
        +   [4.2 方法重载](docs/thinking-in-java-zh/4.2.md)
        +   [4.3 清除：收尾和垃圾收集](docs/thinking-in-java-zh/4.3.md)
        +   [4.4 成员初始化](docs/thinking-in-java-zh/4.4.md)
        +   [4.5 数组初始化](docs/thinking-in-java-zh/4.5.md)
        +   [4.6 总结](docs/thinking-in-java-zh/4.6.md)
        +   [4.7 练习](docs/thinking-in-java-zh/4.7.md)
    +   [第5章 隐藏实现过程](docs/thinking-in-java-zh/5.md)
        +   [5.1 包：库单元](docs/thinking-in-java-zh/5.1.md)
        +   [5.2 Java访问指示符](docs/thinking-in-java-zh/5.2.md)
        +   [5.3 接口与实现](docs/thinking-in-java-zh/5.3.md)
        +   [5.4 类访问](docs/thinking-in-java-zh/5.4.md)
        +   [5.5 总结](docs/thinking-in-java-zh/5.5.md)
        +   [5.6 练习](docs/thinking-in-java-zh/5.6.md)
    +   [第6章 类复用](docs/thinking-in-java-zh/6.md)
        +   [6.1 組合的语法](docs/thinking-in-java-zh/6.1.md)
        +   [6.2 继承的语法](docs/thinking-in-java-zh/6.2.md)
        +   [6.3 组合与继承的结合](docs/thinking-in-java-zh/6.3.md)
        +   [6.4 到底选择组合还是继承](docs/thinking-in-java-zh/6.4.md)
        +   [6.5 `protected`](docs/thinking-in-java-zh/6.5.md)
        +   [6.6 累积开发](docs/thinking-in-java-zh/6.6.md)
        +   [6.7 向上转换](docs/thinking-in-java-zh/6.7.md)
        +   [6.8 `final`关键字](docs/thinking-in-java-zh/6.8.md)
        +   [6.9 初始化和类装载](docs/thinking-in-java-zh/6.9.md)
        +   [6.10 总结](docs/thinking-in-java-zh/6.10.md)
        +   [6.11 练习](docs/thinking-in-java-zh/6.11.md)
    +   [第7章 多态性](docs/thinking-in-java-zh/7.md)
        +   [7.1 向上转换](docs/thinking-in-java-zh/7.1.md)
        +   [7.2 深入理解](docs/thinking-in-java-zh/7.2.md)
        +   [7.3 覆盖与重载](docs/thinking-in-java-zh/7.3.md)
        +   [7.4 抽象类和方法](docs/thinking-in-java-zh/7.4.md)
        +   [7.5 接口](docs/thinking-in-java-zh/7.5.md)
        +   [7.6 内部类](docs/thinking-in-java-zh/7.6.md)
        +   [7.7 构造器和多态性](docs/thinking-in-java-zh/7.7.md)
        +   [7.8 通过继承进行设计](docs/thinking-in-java-zh/7.8.md)
        +   [7.9 总结](docs/thinking-in-java-zh/7.9.md)
        +   [7.10 练习](docs/thinking-in-java-zh/7.10.md)
    +   [第8章 对象的容纳](docs/thinking-in-java-zh/8.md)
        +   [8.1 数组](docs/thinking-in-java-zh/8.1.md)
        +   [8.2 集合](docs/thinking-in-java-zh/8.2.md)
        +   [8.3 枚举器（迭代器）](docs/thinking-in-java-zh/8.3.md)
        +   [8.4 集合的类型](docs/thinking-in-java-zh/8.4.md)
        +   [8.5 排序](docs/thinking-in-java-zh/8.5.md)
        +   [8.6 通用集合库](docs/thinking-in-java-zh/8.6.md)
        +   [8.7 新集合](docs/thinking-in-java-zh/8.7.md)
        +   [8.8 总结](docs/thinking-in-java-zh/8.8.md)
        +   [8.9 练习](docs/thinking-in-java-zh/8.9.md)
    +   [第9章 异常差错控制](docs/thinking-in-java-zh/9.md)
        +   [9.1 基本异常](docs/thinking-in-java-zh/9.1.md)
        +   [9.2 异常的捕获](docs/thinking-in-java-zh/9.2.md)
        +   [9.3 标准Java异常](docs/thinking-in-java-zh/9.3.md)
        +   [9.4 创建自己的异常](docs/thinking-in-java-zh/9.4.md)
        +   [9.5 异常的限制](docs/thinking-in-java-zh/9.5.md)
        +   [9.6 用finally清除](docs/thinking-in-java-zh/9.6.md)
        +   [9.7 构造器](docs/thinking-in-java-zh/9.7.md)
        +   [9.8 异常匹配](docs/thinking-in-java-zh/9.8.md)
        +   [9.9 总结](docs/thinking-in-java-zh/9.9.md)
        +   [9.10 练习](docs/thinking-in-java-zh/9.10.md)
    +   [第10章 Java IO系统](docs/thinking-in-java-zh/10.md)
        +   [10.1 输入和输出](docs/thinking-in-java-zh/10.1.md)
        +   [10.2 增添属性和有用的接口](docs/thinking-in-java-zh/10.2.md)
        +   [10.3 本身的缺陷：`RandomAccessFile`](docs/thinking-in-java-zh/10.3.md)
        +   [10.4 File类](docs/thinking-in-java-zh/10.4.md)
        +   [10.5 IO流的典型应用](docs/thinking-in-java-zh/10.5.md)
        +   [10.6 `StreamTokenizer`](docs/thinking-in-java-zh/10.6.md)
        +   [10.7 Java 1.1的IO流](docs/thinking-in-java-zh/10.7.md)
        +   [10.8 压缩](docs/thinking-in-java-zh/10.8.md)
        +   [10.9 对象序列化](docs/thinking-in-java-zh/10.9.md)
        +   [10.10 总结](docs/thinking-in-java-zh/10.10.md)
        +   [10.11 练习](docs/thinking-in-java-zh/10.11.md)
    +   [第11章 运行期类型识别](docs/thinking-in-java-zh/11.md)
        +   [11.1 对RTTI的需要](docs/thinking-in-java-zh/11.1.md)
        +   [11.2 RTTI语法](docs/thinking-in-java-zh/11.2.md)
        +   [11.3 反射：运行期类信息](docs/thinking-in-java-zh/11.3.md)
        +   [11.4 总结](docs/thinking-in-java-zh/11.4.md)
        +   [11.5 练习](docs/thinking-in-java-zh/11.5.md)
    +   [第12章 传递和返回对象](docs/thinking-in-java-zh/12.md)
        +   [12.1 传递引用](docs/thinking-in-java-zh/12.1.md)
        +   [12.2 制作本地副本](docs/thinking-in-java-zh/12.2.md)
        +   [12.3 克隆的控制](docs/thinking-in-java-zh/12.3.md)
        +   [12.4 只读类](docs/thinking-in-java-zh/12.4.md)
        +   [12.5 总结](docs/thinking-in-java-zh/12.5.md)
        +   [12.6 练习](docs/thinking-in-java-zh/12.6.md)
    +   [第13章 创建窗口和程序片](docs/thinking-in-java-zh/13.md)
        +   [13.1 为何要用AWT？](docs/thinking-in-java-zh/13.1.md)
        +   [13.2 基本程序片](docs/thinking-in-java-zh/13.2.md)
        +   [13.3 制作按钮](docs/thinking-in-java-zh/13.3.md)
        +   [13.4 捕获事件](docs/thinking-in-java-zh/13.4.md)
        +   [13.5 文本字段](docs/thinking-in-java-zh/13.5.md)
        +   [13.6 文本区域](docs/thinking-in-java-zh/13.6.md)
        +   [13.7 标签](docs/thinking-in-java-zh/13.7.md)
        +   [13.8 复选框](docs/thinking-in-java-zh/13.8.md)
        +   [13.9 单选钮](docs/thinking-in-java-zh/13.9.md)
        +   [13.10 下拉列表](docs/thinking-in-java-zh/13.10.md)
        +   [13.11 列表框](docs/thinking-in-java-zh/13.11.md)
        +   [13.12 布局的控制](docs/thinking-in-java-zh/13.12.md)
        +   [13.13 `action`的替代品](docs/thinking-in-java-zh/13.13.md)
        +   [13.14 程序片的局限](docs/thinking-in-java-zh/13.14.md)
        +   [13.15 视窗化应用](docs/thinking-in-java-zh/13.15.md)
        +   [13.16 新型AWT](docs/thinking-in-java-zh/13.16.md)
        +   [13.17 Java 1.1用户接口API](docs/thinking-in-java-zh/13.17.md)
        +   [13.18 可视编程和Beans](docs/thinking-in-java-zh/13.18.md)
        +   [13.19 Swing入门（注释⑦）](docs/thinking-in-java-zh/13.19.md)
        +   [13.20 总结](docs/thinking-in-java-zh/13.20.md)
        +   [13.21 练习](docs/thinking-in-java-zh/13.21.md)
    +   [第14章 多线程](docs/thinking-in-java-zh/14.md)
        +   [14.1 反应灵敏的用户界面](docs/thinking-in-java-zh/14.1.md)
        +   [14.2 共享有限的资源](docs/thinking-in-java-zh/14.2.md)
        +   [14.3 堵塞](docs/thinking-in-java-zh/14.3.md)
        +   [14.4 优先级](docs/thinking-in-java-zh/14.4.md)
        +   [14.5 回顾runnable](docs/thinking-in-java-zh/14.5.md)
        +   [14.6 总结](docs/thinking-in-java-zh/14.6.md)
        +   [14.7 练习](docs/thinking-in-java-zh/14.7.md)
    +   [第15章 网络编程](docs/thinking-in-java-zh/15.md)
        +   [15.1 机器的标识](docs/thinking-in-java-zh/15.1.md)
        +   [15.10 练习](docs/thinking-in-java-zh/15.10.md)
        +   [15.2 套接字](docs/thinking-in-java-zh/15.2.md)
        +   [15.3 服务多个客户](docs/thinking-in-java-zh/15.3.md)
        +   [15.4 数据报](docs/thinking-in-java-zh/15.4.md)
        +   [15.5 一个Web应用](docs/thinking-in-java-zh/15.5.md)
        +   [15.6 Java与CGI的沟通](docs/thinking-in-java-zh/15.6.md)
        +   [15.7 用JDBC连接数据库](docs/thinking-in-java-zh/15.7.md)
        +   [15.8 远程方法](docs/thinking-in-java-zh/15.8.md)
        +   [15.9 总结](docs/thinking-in-java-zh/15.9.md)
    +   [第16章 设计模式](docs/thinking-in-java-zh/16.md)
        +   [16.1 模式的概念](docs/thinking-in-java-zh/16.1.md)
        +   [16.2 观察器模式](docs/thinking-in-java-zh/16.2.md)
        +   [16.3 模拟垃圾回收站](docs/thinking-in-java-zh/16.3.md)
        +   [16.4 改进设计](docs/thinking-in-java-zh/16.4.md)
        +   [16.5 抽象的应用](docs/thinking-in-java-zh/16.5.md)
        +   [16.6 多重分发](docs/thinking-in-java-zh/16.6.md)
        +   [16.7 访问器模式](docs/thinking-in-java-zh/16.7.md)
        +   [16.8 RTTI真的有害吗](docs/thinking-in-java-zh/16.8.md)
        +   [16.9 总结](docs/thinking-in-java-zh/16.9.md)
        +   [16.10 练习](docs/thinking-in-java-zh/16.10.md)
    +   [第17章 项目](docs/thinking-in-java-zh/17.md)
        +   [17.1 文字处理](docs/thinking-in-java-zh/17.1.md)
        +   [17.2 方法查找工具](docs/thinking-in-java-zh/17.2.md)
        +   [17.3 复杂性理论](docs/thinking-in-java-zh/17.3.md)
        +   [17.4 总结](docs/thinking-in-java-zh/17.4.md)
        +   [17.5 练习](docs/thinking-in-java-zh/17.5.md)
    +   [附录A 使用非JAVA代码](docs/thinking-in-java-zh/a.md)
    +   [附录B 对比C++和Java](docs/thinking-in-java-zh/b.md)
    +   [附录C Java编程规则](docs/thinking-in-java-zh/c.md)
    +   [附录D 性能](docs/thinking-in-java-zh/d.md)
    +   [附录E 关于垃圾收集的一些话](docs/thinking-in-java-zh/e.md)
    +   [附录F 推荐读物](docs/thinking-in-java-zh/f.md)
+   [Java 8 简明教程](docs/modern-java-zh/REAMDE.md)
    +   [Java 8 简明教程](docs/modern-java-zh/ch1.md)
    +   [Java 8 数据流教程](docs/modern-java-zh/ch2.md)
    +   [Java 8 Nashorn 教程](docs/modern-java-zh/ch3.md)
    +   [Java 8 并发教程：线程和执行器](docs/modern-java-zh/ch4.md)
    +   [Java 8 并发教程：同步和锁](docs/modern-java-zh/ch5.md)
    +   [Java 8 并发教程：原子变量和 ConcurrentMap](docs/modern-java-zh/ch6.md)
    +   [Java 8 API 示例：字符串、数值、算术和文件](docs/modern-java-zh/ch7.md)
    +   [在 Java 8 中避免 Null 检查](docs/modern-java-zh/ch8.md)
    +   [使用 Intellij IDEA 解决 Java 8 的数据流问题](docs/modern-java-zh/ch9.md)
    +   [在 Nashron 中使用 Backbone.js](docs/modern-java-zh/ch10.md)
+   [Java 设计模式最佳实践](docs/design-pattern-best-prac-java/README.md)
    +   [零、前言](docs/design-pattern-best-prac-java/0.md)
    +   [一、从面向对象到函数式编程](docs/design-pattern-best-prac-java/1.md)
    +   [二、创建型模式](docs/design-pattern-best-prac-java/2.md)
    +   [三、行为模式](docs/design-pattern-best-prac-java/3.md)
    +   [四、结构模式](docs/design-pattern-best-prac-java/4.md)
    +   [五、函数式模式](docs/design-pattern-best-prac-java/5.md)
    +   [六、让我们开始反应式吧](docs/design-pattern-best-prac-java/6.md)
    +   [七、反应式设计模式](docs/design-pattern-best-prac-java/7.md)
    +   [八、应用架构的发展趋势](docs/design-pattern-best-prac-java/8.md)
    +   [九、Java 最佳实践](docs/design-pattern-best-prac-java/9.md)
+   [Java 编程问题](docs/java-coding-prob/README.md)
    +   [零、前言](docs/java-coding-prob/00.md)
    +   [一、字符串、数字和数学](docs/java-coding-prob/01.md)
    +   [二、对象、不变性和`switch`表达式](docs/java-coding-prob/02.md)
    +   [三、使用日期和时间](docs/java-coding-prob/03.md)
    +   [四、类型推断](docs/java-coding-prob/04.md)
    +   [五、数组、集合和数据结构](docs/java-coding-prob/05.md)
    +   [六、Java I/O 路径、文件、缓冲区、扫描和格式化](docs/java-coding-prob/06.md)
    +   [七、Java 反射类、接口、构造器、方法和字段](docs/java-coding-prob/07.md)
    +   [八、函数式编程-基础和设计模式](docs/java-coding-prob/08.md)
    +   [九、函数式编程——深入研究](docs/java-coding-prob/09.md)
    +   [十、并发-线程池、可调用对象和同步器](docs/java-coding-prob/10.md)
    +   [十一、并发-深入探索](docs/java-coding-prob/11.md)
    +   [十二、`Optional`](docs/java-coding-prob/12.md)
    +   [十三、HTTP 客户端和 WebSocket API](docs/java-coding-prob/13.md)
+   [Java 项目大全](docs/java-proj/README.md)
    +   [零、前言](docs/java-proj/0.md)
    +   [一、Java11 入门](docs/java-proj/1.md)
    +   [二、第一个真正的 Java 程序-排序名称](docs/java-proj/2.md)
    +   [三、优化排序代码](docs/java-proj/3.md)
    +   [四、Mastermind-创造游戏](docs/java-proj/4.md)
    +   [五、扩展游戏-跑得并行，跑得更快](docs/java-proj/5.md)
    +   [六、使我们的游戏专业化-将其作为 Web 应用](docs/java-proj/6.md)
    +   [七、使用 REST 构建商业 Web 应用](docs/java-proj/7.md)
    +   [八、扩展我们的电子商务应用](docs/java-proj/8.md)
    +   [九、使用反应式编程构建会计应用](docs/java-proj/9.md)
+   [Java 12 编程学习手册](docs/learn-java12-prog/README.md)
    +   [零、前言](docs/learn-java12-prog/00.md)
    +   [第 1 节：Java 编程概述](docs/learn-java12-prog/sec1.md)
        +   [一、Java12 入门](docs/learn-java12-prog/01.md)
        +   [二、Java 面向对象编程（OOP）](docs/learn-java12-prog/02.md)
        +   [三、Java 基础](docs/learn-java12-prog/03.md)
    +   [第 2 节：Java 的构建块](docs/learn-java12-prog/sec2.md)
        +   [四、异常处理](docs/learn-java12-prog/04.md)
        +   [五、字符串、输入/输出和文件](docs/learn-java12-prog/05.md)
        +   [六、数据结构、泛型和流行工具](docs/learn-java12-prog/06.md)
        +   [七、Java 标准和外部库](docs/learn-java12-prog/07.md)
        +   [八、多线程和并发处理](docs/learn-java12-prog/08.md)
        +   [九、JVM 结构与垃圾收集](docs/learn-java12-prog/09.md)
        +   [十、管理数据库中的数据](docs/learn-java12-prog/10.md)
        +   [十一、网络编程](docs/learn-java12-prog/11.md)
        +   [十二、Java GUI 编程](docs/learn-java12-prog/12.md)
    +   [第 3 节：高级 Java](docs/learn-java12-prog/sec3.md)
        +   [十三、函数式程序设计](docs/learn-java12-prog/13.md)
        +   [十四、Java 标准流](docs/learn-java12-prog/14.md)
        +   [十五、反应式程序设计](docs/learn-java12-prog/15.md)
        +   [十六、微服务](docs/learn-java12-prog/16.md)
        +   [十七、Java 微基准线束](docs/learn-java12-prog/17.md)
        +   [十八、编写高质量代码的最佳实践](docs/learn-java12-prog/18.md)
        +   [十九、Java 新特性](docs/learn-java12-prog/19.md)
    +   [二十、答案](docs/learn-java12-prog/20.md)
+   [精通 Java 11](docs/master-java11/README.md)
    +   [零、前言](docs/master-java11/00.md)
    +   [一、Java11 环境](docs/master-java11/01.md)
    +   [二、探索 Java11](docs/master-java11/02.md)
    +   [三、Java11 基础](docs/master-java11/03.md)
    +   [四、用 Java11 构建模块化应用](docs/master-java11/04.md)
    +   [五、将应用迁移到 Java11](docs/master-java11/05.md)
    +   [六、试用 Java Shell](docs/master-java11/06.md)
    +   [七、利用默认的 G1 垃圾收集器](docs/master-java11/07.md)
    +   [八、JMH 的微基准应用](docs/master-java11/08.md)
    +   [九、利用进程 API](docs/master-java11/09.md)
    +   [十、细粒度栈跟踪](docs/master-java11/10.md)
    +   [十一、新工具和工具增强功能](docs/master-java11/11.md)
    +   [十二、并发性增强](docs/master-java11/12.md)
    +   [十三、安全增强功能](docs/master-java11/13.md)
    +   [十四、命令行标志](docs/master-java11/14.md)
    +   [十五、Java 平台的其他增强功能](docs/master-java11/15.md)
    +   [十六、未来发展方向](docs/master-java11/16.md)
    +   [十七、为 Java 平台做贡献](docs/master-java11/17.md)
    +   [十八、答案](docs/master-java11/18.md)
+   [Java 自动化测试初学者实用指南](docs/handson-auto-test-java-beginners/README.md)
    +   [零、前言](docs/handson-auto-test-java-beginners/00.md)
    +   [一、Java 中的第一个编程步骤](docs/handson-auto-test-java-beginners/01.md)
    +   [二、了解 Java 中的类、对象及其用法](docs/handson-auto-test-java-beginners/02.md)
    +   [三、在 Java 中处理字符串及其函数](docs/handson-auto-test-java-beginners/03.md)
    +   [四、Java 程序–循环和条件的构建块](docs/handson-auto-test-java-beginners/04.md)
    +   [五、您需要了解的关于接口和继承的所有信息](docs/handson-auto-test-java-beginners/05.md)
    +   [六、了解有关数组的所有信息](docs/handson-auto-test-java-beginners/06.md)
    +   [七、了解 Java11 中的日期类和构造器](docs/handson-auto-test-java-beginners/07.md)
    +   [八、`super`和`this`关键字和异常在 Java 中的重要性](docs/handson-auto-test-java-beginners/08.md)
    +   [九、理解集合框架](docs/handson-auto-test-java-beginners/09.md)
    +   [十、`final`关键字、包和修饰符的重要性](docs/handson-auto-test-java-beginners/10.md)
+   [Java9 高性能应用](docs/high-perform-app-java9/README.md)
    +   [零、序言](docs/high-perform-app-java9/0.md)
    +   [一、学习 Java 9 底层性能改进](docs/high-perform-app-java9/1.md)
    +   [二、提高生产率和加速应用的工具](docs/high-perform-app-java9/2.md)
    +   [三、多线程和反应式编程](docs/high-perform-app-java9/3.md)
    +   [四、微服务](docs/high-perform-app-java9/4.md)
    +   [五、利用新 API 改进代码](docs/high-perform-app-java9/5.md)
    +   [六、测验答案](docs/high-perform-app-java9/6.md)
+   [Java11 秘籍](docs/java11-cb/README.md)
    +   [零、序言](docs/java11-cb/00.md)
    +   [一、安装和对 Java11 的窥探](docs/java11-cb/01.md)
    +   [二、面向对象编程的快速通道-类和接口](docs/java11-cb/02.md)
    +   [三、模块化编程](docs/java11-cb/03.md)
    +   [四、走向函数式](docs/java11-cb/04.md)
    +   [五、流和管道](docs/java11-cb/05.md)
    +   [六、数据库编程](docs/java11-cb/06.md)
    +   [七、并发和多线程编程](docs/java11-cb/07.md)
    +   [八、更好地管理操作系统进程](docs/java11-cb/08.md)
    +   [九、使用 springboot 的 restfulWeb 服务](docs/java11-cb/09.md)
    +   [十、网络](docs/java11-cb/10.md)
    +   [十一、内存管理和调试](docs/java11-cb/11.md)
    +   [十二、使用 JShell 的读取求值打印循环（REPL）](docs/java11-cb/12.md)
    +   [十三、使用新的日期和时间 API](docs/java11-cb/13.md)
    +   [十四、测试](docs/java11-cb/14.md)
    +   [十五、Java10 和 Java11 的编程新方法](docs/java11-cb/15.md)
    +   [十六、将 JavaFX 用于 GUI 编程](docs/java11-cb/16.md)
+   [精通 JUnit5 软件测试](docs/master-soft-test-junit5/README.md)
    +   [零、序言](docs/master-soft-test-junit5/0.md)
    +   [一、软件质量与 Java 测试回顾](docs/master-soft-test-junit5/1.md)
    +   [二、JUnit5 有什么新功能](docs/master-soft-test-junit5/2.md)
    +   [三、JUnit5 标准测试](docs/master-soft-test-junit5/3.md)
    +   [四、使用高级 JUnit 特性简化测试](docs/master-soft-test-junit5/4.md)
    +   [五、JUnit5 与外部框架的集成](docs/master-soft-test-junit5/5.md)
    +   [六、从需求到测试用例](docs/master-soft-test-junit5/6.md)
    +   [七、测试管理](docs/master-soft-test-junit5/7.md)
+   [Java 测试驱动开发](docs/test-driven-java-dev/README.md)
    +   [零、前言](docs/test-driven-java-dev/00.md)
    +   [一、为什么我应该关心测试驱动的开发？](docs/test-driven-java-dev/01.md)
    +   [二、工具、框架和环境](docs/test-driven-java-dev/02.md)
    +   [三、红绿重构——从失败到成功，直到完美](docs/test-driven-java-dev/03.md)
    +   [四、单元测试——关注你做了什么，而不是已经做了什么](docs/test-driven-java-dev/04.md)
    +   [五、设计——如果它不可测试，那么它就设计得不好](docs/test-driven-java-dev/05.md)
    +   [六、模拟——删除外部依赖项](docs/test-driven-java-dev/06.md)
    +   [七、TDD 和函数式编程——完美匹配](docs/test-driven-java-dev/07.md)
    +   [八、BDD——与整个团队合作](docs/test-driven-java-dev/08.md)
    +   [九、重构遗留代码——使其再次年轻](docs/test-driven-java-dev/09.md)
    +   [十、功能切换——将部分完成的功能部署到生产环境](docs/test-driven-java-dev/10.md)
    +   [十一、把它们放在一起](docs/test-driven-java-dev/11.md)
    +   [十二、通过实现连续交付利用 TDD](docs/test-driven-java-dev/12.md)
+   [Java 云原生应用](docs/cloud-native-app-java/README.md)
	+   [零、前言](docs/cloud-native-app-java/00.md)
	+   [一、云原生简介](docs/cloud-native-app-java/01.md)
	+   [二、编写第一个云原生应用](docs/cloud-native-app-java/02.md)
	+   [三、设计您的云原生应用](docs/cloud-native-app-java/03.md)
	+   [四、扩展云原生应用](docs/cloud-native-app-java/04.md)
	+   [五、测试云原生应用](docs/cloud-native-app-java/05.md)
	+   [六、云原生应用部署](docs/cloud-native-app-java/06.md)
	+   [七、云原生应用运行时](docs/cloud-native-app-java/07.md)
	+   [八、平台部署——AWS](docs/cloud-native-app-java/08.md)
	+   [九、平台部署——Azure](docs/cloud-native-app-java/09.md)
	+   [十、集成为服务](docs/cloud-native-app-java/10.md)
	+   [十一、API 设计最佳实践](docs/cloud-native-app-java/11.md)
	+   [十二、数字转型](docs/cloud-native-app-java/12.md)
+   [Java 代码面试完全指南](docs/comp-code-interview-guide-java/README.md)
	+   [零、序言](docs/comp-code-interview-guide-java/00.md)
	+   [第一节：面试的非技术部分](docs/comp-code-interview-guide-java/sec1.md)
		+   [一、从何处开始以及如何准备面试](docs/comp-code-interview-guide-java/01.md)
		+   [二、大公司的面试是什么样的](docs/comp-code-interview-guide-java/02.md)
		+   [三、常见非技术性问题及解答](docs/comp-code-interview-guide-java/03.md)
		+   [四、如何处理失败](docs/comp-code-interview-guide-java/04.md)
		+   [五、如何应对编码挑战](docs/comp-code-interview-guide-java/05.md)
	+   [第二节：概念](docs/comp-code-interview-guide-java/sec2.md)
		+   [六、面向对象编程](docs/comp-code-interview-guide-java/06.md)
		+   [七、算法的大 O 分析](docs/comp-code-interview-guide-java/07.md)
		+   [八、递归与动态规划](docs/comp-code-interview-guide-java/08.md)
		+   [九、位操作](docs/comp-code-interview-guide-java/09.md)
	+   [第三节：算法和数据结构](docs/comp-code-interview-guide-java/sec3.md)
		+   [十、数组和字符串](docs/comp-code-interview-guide-java/10.md)
		+   [十一、链表和地图](docs/comp-code-interview-guide-java/11.md)
		+   [十二、栈和队列](docs/comp-code-interview-guide-java/12.md)
		+   [十三、树与图](docs/comp-code-interview-guide-java/13.md)
		+   [十四、排序](docs/comp-code-interview-guide-java/14.md)
		+   [十五、数学与谜题](docs/comp-code-interview-guide-java/15.md)
	+   [第四节：奖励——并发和函数式编程](docs/comp-code-interview-guide-java/sec4.md)
		+   [十六、并发](docs/comp-code-interview-guide-java/16.md)
		+   [十七、函数式编程](docs/comp-code-interview-guide-java/17.md)
		+   [十八、单元测试](docs/comp-code-interview-guide-java/18.md)
		+   [十九、系统可扩展性](docs/comp-code-interview-guide-java/19.md)
+   [Java 基础知识](docs/java-fund/README.md)
	+   [零、序言](docs/java-fund/00.md)
	+   [一、Java 简介](docs/java-fund/01.md)
	+   [二、变量、数据类型和运算符](docs/java-fund/02.md)
	+   [三、控制流程](docs/java-fund/03.md)
	+   [四、面向对象编程](docs/java-fund/04.md)
	+   [五、深入 OOP](docs/java-fund/05.md)
	+   [六、数据结构、数组和字符串](docs/java-fund/06.md)
	+   [七、Java 集合框架和泛型](docs/java-fund/07.md)
	+   [八、Java 高级数据结构](docs/java-fund/08.md)
	+   [九、异常处理](docs/java-fund/09.md)
	+   [十、附录](docs/java-fund/10.md)
+   [JavaFX 基础知识](docs/javafx-essential/README.md)
	+   [零、序言](docs/javafx-essential/0.md)
	+   [一、JavaFX 8 入门](docs/javafx-essential/1.md)
	+   [二、JavaFX 8 基础和创建自定义 UI](docs/javafx-essential/2.md)
	+   [三、开发 JavaFX 桌面和 Web 应用](docs/javafx-essential/3.md)
	+   [四、为 Android 开发 JavaFX 应用](docs/javafx-essential/4.md)
	+   [五、为 iOS 开发 JavaFX 应用](docs/javafx-essential/5.md)
	+   [六、在 Raspberry Pi 上运行 JavaFX 应用](docs/javafx-essential/6.md)
	+   [七、使用 JavaFX 监控 Arduino](docs/javafx-essential/7.md)
	+   [八、使用 JavaFX 的交互式 Leap Motion 应用](docs/javafx-essential/8.md)
	+   [九、成为 JavaFX 大师](docs/javafx-essential/9.md)
+   [Java 编程入门](docs/intro-prog-java/README.md)
	+   [零、前言](docs/intro-prog-java/00.md)
	+   [一、计算机上的 Java 虚拟机（JVM）](docs/intro-prog-java/01.md)
	+   [二、Java 语言基础](docs/intro-prog-java/02.md)
	+   [三、您的开发环境设置](docs/intro-prog-java/03.md)
	+   [四、您的第一个 Java 项目](docs/intro-prog-java/04.md)
	+   [五、Java 语言元素和类型](docs/intro-prog-java/05.md)
	+   [六、接口、类和对象构造](docs/intro-prog-java/06.md)
	+   [七、包和可访问性（可见性）](docs/intro-prog-java/07.md)
	+   [八、面向对象设计（OOD）原则](docs/intro-prog-java/08.md)
	+   [九、运算符、表达式和语句](docs/intro-prog-java/09.md)
	+   [十、控制流语句](docs/intro-prog-java/10.md)
	+   [十一、JVM 进程和垃圾收集](docs/intro-prog-java/11.md)
	+   [十二、Java 标准和外部库](docs/intro-prog-java/12.md)
	+   [十三、Java 集合](docs/intro-prog-java/13.md)
	+   [十四、管理集合和数组](docs/intro-prog-java/14.md)
	+   [十五、管理对象、字符串、时间和随机数](docs/intro-prog-java/15.md)
	+   [十六、数据库编程](docs/intro-prog-java/16.md)
	+   [十七、Lambda 表达式与函数式编程](docs/intro-prog-java/17.md)
	+   [十八、流和管道](docs/intro-prog-java/18.md)
	+   [十六、反应式系统](docs/intro-prog-java/19.md)
+   [Java7 并发秘籍](docs/java7-concur-cb/README.md)
	+   [零、序言](docs/java7-concur-cb/0.md)
	+   [一、线程管理](docs/java7-concur-cb/1.md)
	+   [二、线程基本同步](docs/java7-concur-cb/2.md)
	+   [三、线程同步工具](docs/java7-concur-cb/3.md)
	+   [四、线程执行器](docs/java7-concur-cb/4.md)
	+   [五、Fork/Join 框架](docs/java7-concur-cb/5.md)
	+   [六、并发](docs/java7-concur-cb/6.md)
	+   [七、自定义并发类](docs/java7-concur-cb/7.md)
	+   [八、测试并发应用](docs/java7-concur-cb/8.md)
+   [Java9 和 JShell](docs/java9-jshell/README.md)
	+   [零、序言](docs/java9-jshell/00.md)
	+   [一、JShell——Java 9 的读取-求值-打印循环](docs/java9-jshell/01.md)
	+   [二、通过 Java 9 JShell 将现实世界的对象转换为 UML 图](docs/java9-jshell/02.md)
	+   [三、类与实例](docs/java9-jshell/03.md)
	+   [四、数据封装](docs/java9-jshell/04.md)
	+   [五、可变类和不可变类](docs/java9-jshell/05.md)
	+   [六、继承、抽象、扩展和特化](docs/java9-jshell/06.md)
	+   [七、成员继承与多态性](docs/java9-jshell/07.md)
	+   [八、使用接口的契约式编程](docs/java9-jshell/08.md)
	+   [九、使用接口的高级契约式编程](docs/java9-jshell/09.md)
	+   [十、使用泛型实现代码重用的最大化](docs/java9-jshell/10.md)
	+   [十一、高级多态](docs/java9-jshell/11.md)
	+   [十二、面向对象、函数式编程和 Lambda 表达式](docs/java9-jshell/12.md)
	+   [十三、Java 9 中的模块化](docs/java9-jshell/13.md)
	+   [十四、练习答案](docs/java9-jshell/14.md)
+   [面向初学者的 Java 编程](docs/java-prog-beginner/README.md)
	+   [零、前言](docs/java-prog-beginner/00.md)
	+   [一、Java 入门](docs/java-prog-beginner/01.md)
	+   [二、理解类型化变量](docs/java-prog-beginner/02.md)
	+   [三、分支](docs/java-prog-beginner/03.md)
	+   [四、数据结构](docs/java-prog-beginner/04.md)
	+   [五、函数](docs/java-prog-beginner/05.md)
	+   [六、Java 面向对象建模](docs/java-prog-beginner/06.md)
	+   [七、更加面向对象的 Java](docs/java-prog-beginner/07.md)
	+   [八、有用的 Java 类](docs/java-prog-beginner/08.md)
	+   [九、文件输入和输出](docs/java-prog-beginner/09.md)
	+   [十、基本图形用户界面开发](docs/java-prog-beginner/10.md)
	+   [十一、XML](docs/java-prog-beginner/11.md)
+   [精通 Java8 并发编程](docs/master-concur-prog-java8/README.md)
	+   [零、序言](docs/master-concur-prog-java8/00.md)
	+   [一、第一步——并发设计原则](docs/master-concur-prog-java8/01.md)
	+   [二、管理大量线程——执行器](docs/master-concur-prog-java8/02.md)
	+   [三、最大程度利用执行器](docs/master-concur-prog-java8/03.md)
	+   [四、从任务获取数据——`Runnable`接口和`Future`接口](docs/master-concur-prog-java8/04.md)
	+   [四、分阶段运行任务——相位器类](docs/master-concur-prog-java8/05.md)
	+   [六、优化分治的解决方案——Fork/Join 框架](docs/master-concur-prog-java8/06.md)
	+   [七、用并行流处理海量数据集——映射和归约模型](docs/master-concur-prog-java8/07.md)
	+   [八、用并行流处理海量数据集——映射和收集模型](docs/master-concur-prog-java8/08.md)
	+   [九、深入研究并发数据结构和同步工具](docs/master-concur-prog-java8/09.md)
	+   [十、片段整合和备选方案实现](docs/master-concur-prog-java8/10.md)
	+   [十一、测试和监控并发应用](docs/master-concur-prog-java8/11.md)
